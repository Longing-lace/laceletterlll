<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

<meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://files.catbox.moe/g2x30e.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>Phone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Noto+Sans+SC:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
    <script>
  
</script>
    <script>
    // 禁止移动端主界面的上下滚动
    (function() {
        // 检测是否为触摸设备
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        if (isTouchDevice) {
            let homeScreen;

            // 页面加载完成后获取主界面元素
            document.addEventListener('DOMContentLoaded', function() {
                homeScreen = document.getElementById('home-screen');
            });

            // 禁止主界面的touchmove事件
            document.addEventListener('touchmove', function(e) {
                // 检查当前是否在主界面
                if (homeScreen && homeScreen.classList.contains('active')) {
                    // 检查触摸点是否在主界面内
                    let target = e.target;
                    let isInHomeScreen = false;

                    while (target && target !== document.body) {
                        if (target === homeScreen) {
                            isInHomeScreen = true;
                            break;
                        }
                        target = target.parentElement;
                    }

                    // 如果在主界面内,阻止默认滚动行为
                    if (isInHomeScreen) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            console.log('程煜：移动端主界面滚动已禁止。');
        }
    })();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mammoth/mammoth.browser.min.js"></script>
    <style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { 
            --screen-width: 350px; 
            --screen-height: 650px; 
            --secondary-bg: #ffffff;
            --border-color: #e0e0e0; 
            --text-primary: #1E1E1E; 
            --text-secondary: #6B6B6B; 
            --accent-color: #1E1E1E;
            --world-book-bg: #F7F7F7;
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(255, 255, 255, 0.4);
        }
        html {
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
            /* 全局禁止水平滚动 */
            overflow-x: hidden;
        }

/* ▼▼▼ 请用下面这【一整块】全新的代码，替换掉所有旧的 body, phone-frame, phone-screen 等样式 ▼▼▼ */

      /*ios底部兼容*/
         body.ios{
             padding-bottom: 0;
         }
        body.ios #chat-list-bottom-nav{
             padding-bottom: 20px;
         }

/* 1. 重置 body，使其成为一个干净的画布 */
body {
    height: 100vh;
    height: calc(var(--vh, 1vh) * 100);
    overflow: hidden;
    margin: 0;
    padding: 0;
    font-family: 'Inter', 'Noto Sans SC', 'bulangni', -apple-system, BlinkMacSystemFont, "Segue UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #F7F7F7;
    /* 防止水平滚动和拖拽 */
    overflow-x: hidden;
    max-width: 100vw;
    box-sizing: border-box;
}

/* 2. 让 #phone-screen 成为新的“根”容器，撑满整个浏览器窗口 */
#phone-screen {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #F7F7F7; /* 改成跟主屏幕一样的浅灰色 */
    /* 防止水平滚动 */
    overflow-x: hidden;
    max-width: 100vw;
    box-sizing: border-box;
}

/* 4. 【核心】让所有页面的头部自动适应iPhone的“刘海”安全区 */
.header, .qzone-header {
    /* 使用 env(safe-area-inset-top) 自动获取顶部安全距离 */
    padding-top: calc(0px + env(safe-area-inset-top));
}

/* 5. 【核心】让聊天输入框和底部导航栏自动适应iPhone底部的“小黑条”安全区 */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 20px 20px; padding-top: calc(20px + env(safe-area-inset-top)); background-color: #F7F7F7; border-bottom: 1px solid #E0E0E0; display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; color: var(--text-primary); min-height: 20px; }
        
        #world-book-screen .header { box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        .header .header-actions { display: flex; align-items: center; gap: 5px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; position: relative; }
        /* 圆形SVG按钮样式 */
        .circle-btn { width: 30px; height: 30px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: opacity 0.2s; font-size: 0; }
        .circle-btn:hover { opacity: 0.8; }
        .circle-btn svg { width: 16px; height: 16px; fill: none; stroke: white; }
        .circle-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .circle-btn:disabled:hover { opacity: 0.4; }

        #world-book-screen .header .back-btn { color: var(--text-primary); }

.header .action-btn {
    font-size: 30px; /* 专门为"上传"、"+"等文字按钮缩小字号 */
    font-weight: 100; /* 可以加粗一点让它更清晰 */
}
.header .action-btn svg {
    width: 10px;
    height: 10px;
}

#world-book-screen .header .action-btn {
    color: var(--text-secondary);
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        /* 完成按钮的圆形样式 */
.save-btn.circle-btn { width: 30px; height: 30px; }
            /* 修改1: 为底部的悬浮Dock留出空间 */
            #home-screen {
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                padding: 0;
                box-sizing: border-box;
                background-size: cover;
                background-position: center;
                background-color: #F7F7F7;
            }

            /* 翻页容器 - 占据除了Dock以外的所有空间 */
            #home-pages-container {
                flex: 1;
                width: 100%;
                overflow: hidden;
                position: relative;
            }

            /* 翻页包装器 - 横向排列所有页面 */
            .home-pages-wrapper {
                display: flex;
                width: 100%;
                height: 100%;
                transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                will-change: transform;
            }

            /* 单个页面 */
            .home-page {
                min-width: 100%;
                width: 100%;
                height: 100%;
                flex-shrink: 0;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                padding: 20px;
                padding-top: 80px;
                padding-bottom: 135px;
                box-sizing: border-box;
                background-size: cover;
                background-position: center;
                background-color: #F7F7F7;
                overflow-y: auto;
                overflow-x: hidden;
            }

            /* 分页指示器 - 固定在Dock上方10px */
            #home-page-indicator {
                position: fixed;
                bottom: calc(145px + env(safe-area-inset-bottom));
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 8px;
                z-index: 101;
                pointer-events: none;
            }

            .page-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background-color: rgba(255, 255, 255, 0.4);
                transition: all 0.3s ease;
            }

            .page-dot.active {
                background-color: rgba(255, 255, 255, 0.9);
                transform: scale(1.2);
            }

            /* 音乐播放器装饰组件样式 */
            #music-widget {
                width: 100%;
                display: flex;
                justify-content: center;
                padding: 20px;
                margin-top: -8px;
            }

            .music-widget-container {
                width: 320px;
                max-width: 320px;
                background: rgba(255, 255, 255, 0.85);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border-radius: 28px;
                padding: 25px 25px 12px 25px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                display: flex;
                flex-direction: column;
                align-items: center;
                position: relative;
            }

            /* 装饰螺丝钉 */
            .music-widget-container::before,
            .music-widget-container::after {
                content: '';
                position: absolute;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: linear-gradient(135deg, #d0d0d0 0%, #f0f0f0 50%, #d0d0d0 100%);
                box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
            }

            .music-widget-container::before {
                top: 15px;
                left: 15px;
            }

            .music-widget-container::after {
                top: 15px;
                right: 15px;
            }

            .music-cover {
                width: 220px;
                height: 220px;
                border-radius: 50%;
                object-fit: cover;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
                cursor: pointer;
                transition: transform 0.2s ease;
                border: 8px solid rgba(255, 255, 255, 0.5);
            }

            .music-cover:hover {
                transform: scale(1.02);
            }

            .music-title {
                margin: 15px 0 10px 0;
                font-size: 16px;
                font-weight: 600;
                color: #333;
                text-align: center;
                cursor: pointer;
                font-family: 'Georgia', serif;
                letter-spacing: 0.5px;
            }

            .music-title:hover {
                color: #000;
            }

            .music-progress-container {
                width: 100%;
                display: flex;
                align-items: center;
                gap: 10px;
                margin: 10px 0;
            }

            .music-time {
                font-size: 12px;
                color: #666;
                font-weight: 500;
                min-width: 35px;
            }

            .music-progress-bar {
                flex: 1;
                height: 4px;
                background: rgba(0, 0, 0, 0.1);
                border-radius: 2px;
                position: relative;
                overflow: hidden;
            }

            .music-progress-fill {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                width: 55%;
                background: #333;
                border-radius: 2px;
            }

            .music-controls {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 20px;
                margin: 0;
            }

            .music-btn {
                background: none;
                border: none;
                color: #333;
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .music-btn:hover {
                background: rgba(0, 0, 0, 0.05);
                transform: scale(1.1);
            }

            .music-btn:active {
                transform: scale(0.95);
            }

            .music-btn-large {
                background: white;
                border: 2px solid #333;
                padding: 8px;
            }

            .music-btn-large:hover {
                background: #f5f5f5;
            }

            .music-widget-label {
                margin-top: -15px;
                font-size: 14px;
                color: #666;
                font-weight: 500;
            }

            /* 小卡片组件样式 */
            #mini-card-widget {
                width: 160px;
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 8px;
                margin-left: -213px;
            }

            .mini-card-image {
                width: 160px;
                height: 160px;
                border-radius: 18px;
                object-fit: cover;
                cursor: pointer;
                transition: transform 0.2s ease;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            .mini-card-image:hover {
                transform: scale(1.02);
            }

            .mini-card-text {
                margin: 12px 0 0 0;
                font-size: 13px;
                font-weight: 500;
                color: #1f1f1f;
               
                cursor: pointer;
                text-align: center;
            }

            
            #clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-bottom: 20px; flex-shrink: 0; }
                   /* 修改2: app-grid (2x2网格) 的样式 */
        #app-grid {
            display: flex;
            flex-direction: column;
            gap: 35px; /* 修改：固定垂直间距为 35px */
            flex: 1;
            padding: 0;
        }
        /* 修改3: app-row (网格内的行) 的样式 */
        .app-row { 
            display: flex; 
            justify-content: center; /* 保持默认居中，因为我们将修改特定行 */
            gap: 25px; 
            width: 100%; 
        }
        /* 新增: 专门为2x2网格内的行(app-grid 里的 .app-row)设置样式 */
        #app-grid .app-row {
            justify-content: flex-end; /* 让图标靠右 */
            gap: 35px; /* 缩小水平间距 */
            width: auto; /* 让行宽度自适应内容, 配合 app-grid 的 align-items: flex-end */
        }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; padding-bottom: calc(20px + env(safe-area-inset-bottom)); overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column;background-color: #F7F7F7; }
        .form-group { margin-bottom: 20px; }
        
        /* 【新增】群聊互通记忆开关样式 */
        .memory-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }
        
        .memory-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .memory-switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #DCDCDC;
            border-radius: 24px;
            transition: background-color 0.2s ease-in-out;
        }
        
        .memory-switch-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: #FFFFFF;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease-in-out;
        }
        
        .memory-switch input:checked + .memory-switch-slider {
            background-color: #1E1E1E;
        }
        
        .memory-switch input:checked + .memory-switch-slider::before {
            transform: translateX(20px);
        }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }

        /* 备份成功状态标签样式 */
        .backup-success-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .backup-success-badge .checkmark-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #C8E6C9;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 12px;
            color: white;
            font-weight: bold;
        }
        .backup-success-badge .checkmark-circle::before {
            content: "✓";
        }

        /* 预设条目样式 */
        .preset-item {
            background: #FFFFFF;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 15px;
            margin-bottom: 10px;
        }
        .preset-item-divider {
            height: 1px;
            background: linear-gradient(to right, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.1));
            margin: 20px 0 15px 0;
            position: relative;
        }
        .preset-item-divider-label {
            position: absolute;
            left: 50%;
            top: -10px;
            transform: translateX(-50%);
            background: #F5F5F5;
            padding: 0 12px;
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        .preset-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .preset-item-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .preset-item-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .preset-item-move-btn {
            background-color: rgba(0, 122, 255, 0.1);
            color: #007AFF;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .preset-item-move-btn:hover {
            background-color: rgba(0, 122, 255, 0.2);
        }
        .preset-item-move-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        .preset-item-delete-btn {
            background-color: rgba(255, 59, 48, 0.1);
            color: #AB4D3F;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        .preset-item-delete-btn:hover {
            background-color: rgba(255, 59, 48, 0.2);
        }
        .preset-item-edit-btn {
            background-color: rgba(100, 100, 100, 0.1);
            color: #666666;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .preset-item-edit-btn:hover {
            background-color: rgba(100, 100, 100, 0.2);
        }
        .preset-item-edit-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        .preset-list-item {
            background: #FFFFFF;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .preset-list-item:hover {
            background-color: #f8f8f8;
        }
        .preset-list-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .preset-list-item-name {
            font-weight: 500;
            font-size: 16px;
            color: var(--text-primary);
        }
        .preset-list-item-info {
            font-size: 14px;
            color: var(--text-secondary);
            margin-top: 8px;
        }
        .preset-list-item-delete {
            background-color: rgba(255, 59, 48, 0.1);
            color: #AB4D3F;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }
        .preset-list-item-delete:hover {
            background-color: rgba(255, 59, 48, 0.2);
        }

        /* 复制预设按钮样式 */
        .preset-list-item-copy {
            background-color: rgba(0, 122, 255, 0.1);
            color: #007AFF;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
        }
        .preset-list-item-copy:hover {
            background-color: rgba(0, 122, 255, 0.2);
        }
        .preset-list-item-copy svg {
            width: 16px;
            height: 16px;
        }

        /* 【新增】预设条目part选择模式样式 */
        #preset-items-container.preset-selection-mode .preset-item.selectable {
            transition: opacity 0.2s ease, background-color 0.2s ease;
            border: 2px solid #E0E0E0;
        }

        #preset-items-container.preset-selection-mode .preset-item.selected {
    background-color: #f0f0f0; /* 修改点：更换为淡灰色背景 */
    border: 2px solid #dcdcdc; /* 修改点：更换为淡灰色边框 */
    box-shadow: none;          /* 修改点：移除阴影，让风格更统一 */
}

        #wallpaper-screen .form-container { align-items: flex-start; }
        
        /* 新增：预览界面容器样式 */
        .preview-container {
            display: flex;
            gap: 20px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .preview-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* 预览区域按钮样式 */
        .preview-section .form-button {
            width: 180px;
            margin-top: 0;
        }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #F7F7F7; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
        
        /* 聊天背景预览样式 */
        #chat-background-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #F7F7F7; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #chat-background-upload-input { display: none; }
/* world-book相关页面背景样式 */
#world-book-screen,
#world-book-editor-screen {
    background-color: var(--world-book-bg);
}

/* 修改后的 #world-book-list 样式 */
#world-book-list {
    flex-grow: 1;
    overflow-y: auto;
    background-color: transparent;
    padding: 20px;
    padding-top: 20px;
}

/* 毛玻璃容器核心样式 */
.glass-container {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    margin-bottom: 16px;
    overflow: hidden !important;
    transition: all 0.3s ease;
    /* 解决边缘锯齿问题 */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* 强制硬件加速 */
    will-change: transform;
    /* 确保圆角边界完全生效 */
    -webkit-mask-image: -webkit-radial-gradient(white, black);
    mask-image: radial-gradient(white, black);
}

/* 分类标题的毛玻璃容器 */
.glass-container.category-header {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    margin-bottom: 8px;
    overflow: hidden;
    /* 解决边缘锯齿问题 */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* 强制硬件加速 */
    will-change: transform;
}

/* 内容列表的毛玻璃容器 */
.glass-container.content-list {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    margin-bottom: 16px;
    overflow: hidden;
    /* 解决边缘锯齿问题 */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* 强制硬件加速 */
    will-change: transform;
}

.glass-container.empty-state {
    margin-top: 40px;
}

.glass-content {
    padding: 0;
    background: transparent;
}

/* 列表项样式优化 */
.glass-container .list-item {
    border-bottom: 1px solid rgba(255, 255, 255, 0.15);
    margin: 0;
    background: transparent;
    position: relative;
    padding: 16px 20px;
    transition: background-color 0.2s ease;
}

.glass-container .list-item:first-child {
    border-top: none;
}

.glass-container .list-item:last-child {
    border-bottom: none;
}

.glass-container .list-item:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

.glass-container .list-item .item-title {
    font-weight: 500;
    font-size: 16px;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.glass-container .list-item .item-content {
    font-size: 14px;
    color: var(--text-secondary);
    line-height: 1.4;
}

/* 分组标题样式优化 */
.glass-container .world-book-group-header {
    background: transparent;
    margin: 0;
    padding: 12px 20px;
}

/* 移除hover悬浮效果 */

/* ▼▼▼ 晴空设计方案样式 ▼▼▼ */

/* 输入框样式 */
.input-field, 
#world-book-unified-modal input[type="text"],
#world-book-unified-modal textarea,
#world-book-unified-modal select,
.form-group input,
.form-group textarea,
.form-group select {
    background-color: #FFFFFF !important;
    color: #1E1E1E !important;
    border: 1px solid #DCDCDC !important;
    border-radius: 8px !important;
    padding: 12px 16px !important;
    font-size: 16px !important;
    transition: all 0.2s ease-in-out !important;
    box-sizing: border-box !important;
}

.input-field::placeholder,
#world-book-unified-modal input[type="text"]::placeholder,
#world-book-unified-modal textarea::placeholder {
    color: #A0A0A0 !important;
}

.input-field:focus,
#world-book-unified-modal input[type="text"]:focus,
#world-book-unified-modal textarea:focus,
#world-book-unified-modal select:focus,
.form-group input:focus,
.form-group textarea:focus,
.form-group select:focus {
    outline: none !important;
    border-color: #1E1E1E !important;
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important;
}

/* 世界书搜索框样式 */
.wb-search-container {
    position: relative;
    width: 100%;
}

.wb-search-btn {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background-color: #1E1E1E;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.wb-search-btn:hover {
    opacity: 0.8;
}

.wb-search-btn svg {
    width: 16px;
    height: 16px;
    fill: white;
}

.wb-search-clear-btn {
    position: absolute;
    right: 45px;
    top: 50%;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    color: #6B6B6B;
    font-size: 16px;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.wb-search-clear-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: #1E1E1E;
}

/* textarea高亮样式 */
#unified-book-content.wb-highlight {
    background: linear-gradient(to bottom,
        rgba(220, 220, 220, 0.3) 0%,
        rgba(220, 220, 220, 0.3) 100%);
}

/* 主按钮样式 */
.primary-button,
#save-world-book-btn,
#add-new-category-btn,
#close-category-manager-btn,
.form-button,
.save {
    background-color: #1E1E1E !important;
    color: #FFFFFF !important;
    border: none !important;
    border-radius: 8px !important;
    padding: 10px 20px !important;

    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

.primary-button:hover,
#save-world-book-btn:hover,
#add-new-category-btn:hover,
#close-category-manager-btn:hover,
.form-button:hover,
.save:hover {
    background-color: #000000 !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 分类条目样式 */
.category-item,
#existing-categories-list .category-item-row {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    padding: 20px !important;
    overflow: hidden !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
    margin-bottom: 12px !important;
}

.category-item:hover,
#existing-categories-list .category-item-row:hover {
    transform: translateY(-4px) scale(1.02) !important;
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}


/* 下拉框样式 */
.select-trigger,
#world-book-category-select,
.form-group select {
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%236B6B6B" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>') !important;
    background-repeat: no-repeat !important;
    background-position: right 16px center !important;
    background-size: 12px !important;
    cursor: pointer !important;
}

/* 标签样式 */
#world-book-unified-modal .form-group label {
    display: none !important;
}

/* 分类项内容样式 */
.category-item-row {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
}

.category-item-row .group-name {
    color: var(--text-primary) !important;
    font-weight: 500 !important;
    font-size: 16px !important;
    flex: 1 !important;
}

.category-item-row .delete-group-btn {
    background-color: rgba(255, 59, 48, 0.1) !important;
    color: #AB4D3F !important;
    border: none !important;
    border-radius: 50% !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    font-size: 18px !important;
    font-weight: bold !important;
    transition: all 0.2s ease !important;
}

.category-item-row .delete-group-btn:hover {
    background-color: rgba(255, 59, 48, 0.2) !important;
    transform: scale(1.1) !important;
}

/* 表单组间距优化 */
#world-book-unified-modal .form-group {
    display: flex !important;
    flex-direction: column !important;
    margin-bottom: 0 !important;
    min-height: 0 !important;
}

#world-book-unified-modal .form-group[style*="flex-grow"] {
    flex-grow: 1 !important;
    min-height: 0 !important;
}

/* textarea世界书输入框高度修改特殊样式 */
#world-book-unified-modal textarea {
    /* 固定高度500px，仅此部分可独立滑动 */
    height: 520px !important;
    min-height: 520px !important;
    max-height: 520px !important;
    overflow-y: auto !important;
    resize: none !important;
    font-family: inherit !important;
    flex-grow: 0 !important;
    flex-shrink: 0 !important;
    margin-top: 0px !important;
}

/* ▼▼▼ 统一模态框样式 ▼▼▼ */

/* 统一模态框基础样式 */
#world-book-unified-modal .modal-content {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    overflow: hidden !important;
    display: flex !important;
    flex-direction: column !important;
}

/* 统一视图切换 */
.unified-view {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px;
    min-height: 0 !important;
    flex: 1 !important;
}

/* 主菜单项样式 */
.unified-menu-item {
    background: rgba(255, 255, 255, 0.5) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    border-radius: 12px !important;
    padding: 20px !important;
    margin-bottom: 12px !important;
    display: flex !important;
    align-items: center !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

.unified-menu-item:hover {
    background: rgba(255, 255, 255, 0.7) !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.1) !important;
}

.unified-menu-item .menu-icon {
    font-size: 32px;
    margin-right: 16px;
    flex-shrink: 0;
}

.unified-menu-item .menu-text {
    flex-grow: 1;
}

.unified-menu-item .menu-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.unified-menu-item .menu-desc {
    font-size: 14px;
    color: var(--text-secondary);
}

.unified-menu-item .menu-arrow {
    font-size: 20px;
    color: var(--text-secondary);
    flex-shrink: 0;
}

/* 返回按钮样式 */
.unified-back-btn {
    display: inline-flex !important;
    align-items: center !important;
    color: var(--accent-color) !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    margin-bottom: 20px !important;
    padding: 8px 0 !important;
    transition: color 0.2s ease !important;
}

.unified-back-btn:hover {
    color: var(--text-primary) !important;
}

/* 统一动作按钮区域 */
.unified-actions {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}

/* 模态框头部样式优化 */
#world-book-unified-modal .modal-header {
    background: transparent !important;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
    padding: 20px 20px 16px 20px !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    flex-shrink: 0 !important;
}

#world-book-unified-modal .modal-body {
    padding: 20px !important;
    overflow-x: hidden !important;
    overflow-y: hidden !important;
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
}

#unified-manage-categories {
    overflow-y: auto !important;
}

#world-book-unified-modal .modal-footer {
    background: transparent !important;
    border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
    padding: 16px 20px 20px 20px !important;
    flex-shrink: 0 !important;
}

/* ▲▲▲ 统一模态框样式结束 ▲▲▲ */

/* ▲▲▲ 晴空设计方案样式结束 ▲▲▲ */

/* 修改后的 #chat-list 样式，去掉了 padding 和 margin */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    /* padding-top: 72px; */ /* 像这样注释掉也可以 */
    padding-bottom: 70px; /* 为底部导航栏留出空间 */
    box-sizing: border-box;
}

        .list-item { display: flex; flex-direction: column; cursor: pointer; }
        
        /* 非毛玻璃容器中的列表项样式 */
        .list-item:not(.glass-container .list-item) {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        /* 非毛玻璃容器中的列表项hover效果 */
        .list-item:not(.glass-container .list-item):hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
@media (hover: hover) {
    .chat-list-item:hover {
        background-color: #f5f5f5;
    }
}
.chat-list-item .avatar { width: 45px; height: 45px; border-radius: 20%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
.chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #F7F7F7; padding: 2px 6px; border-radius: 8px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn.circle-btn { margin-right: 10px; }
        #selection-delete-btn.circle-btn { background-color: #AB4D3F !important; }

/* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden;
    transition: margin-bottom 0.3s ease-in-out, padding-bottom 0.3s ease-in-out;
    margin-bottom: 0;
    padding: 10px 15px;
    /* 核心修改：增加了顶部的内边距，为浮动的Header留出空间 */
    /* 这个值可以根据你的Header实际高度微调，100px是一个比较安全的值 */
    padding-top: 150px; 
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px; /* 稍微调整，与头像对齐 */
    margin-bottom: 3px;
    position: absolute; /* 让它脱离流，避免影响气泡对齐 */
    top: -16px;       /* 定位到气泡上方 */
    left: 0;
}

/* === 【全新】消息布局与时间戳样式 === */

/* 1. 消息单元的总容器 (重构) */
.message-wrapper {
    display: flex;          /* 使用Flex布局 */
    gap: 8px;               /* 气泡和时间戳之间的间距 */
    align-items: flex-end;  /* 核心：让气泡和时间戳底部对齐 */
    position: relative;
    max-width: 90%;         /* 可以稍微放宽一点，因为时间戳现在在外面了 */
/* ▼▼▼ 【核心新增代码】在这里 ▼▼▼ */
    -webkit-user-select: none; /* 兼容 Safari/Chrome */
    user-select: none;         /* 标准语法 */
    /* ▲▲▲ 新增代码结束 ▲▲▲ */
}

/* 2. AI消息单元靠左 */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
}

/* 3. 用户消息单元靠右 */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
}

/* 4. 气泡和头像的直接容器 (保持不变) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    /* 移除旧的 position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* 防止时间换行 */
    margin-bottom: 0.2px;  /* 从 5px 减小到 2px，使其位置更低 */
    flex-shrink: 0;      /* 防止被压缩 */
}

/* 新增：为AI和用户的时间戳分别添加水平微调 */
.message-wrapper.ai .timestamp {
    margin-left: -4px; /* 负值会把它向左拉，靠近AI气泡 */
}
.message-wrapper.user .timestamp {
    margin-right: -4px; /* 负值会把它向右拉，靠近用户气泡 */
}

/* 【新增】模拟时间戳的特殊样式 */
.timestamp.simulated-timestamp {
    /* ▼▼▼ 在这里修改 ▼▼▼ */
    background: rgba(0, 0, 0, 0.2);      /* 1. 背景色：改为透明度更高的淡黑色 */
    color: var(--text-secondary);        /* 2. 文字颜色：改为深灰色以保证清晰 */
    padding: 2px 4px;                   /* 3. 内边距(大小)：增加左右边距，让气泡更舒展 */
    border-radius: 16px;                 /* 4. 圆角：可以稍微减小，看起来更精致 */
    font-size: 10px;                     /* (大小)：字体大小，您可以按需修改 */
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); /* 5. 阴影：改为更柔和的淡阴影 */
    top: 1px; 
    /* --- 以下为保持不变的基础样式 --- */
    font-weight: 500;
    text-shadow: none;
    position: relative;
    display: inline-block;
    z-index: 10;
    margin-bottom: 3px;
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        #chat-input-area {
            flex-shrink: 0;
            padding: 8px;
            padding-bottom: 28px; /* 保持原有的底部安全距离 */
            background-color: rgba(247, 247, 247, 0.8); /* 1. 背景色改为半透明 */
            backdrop-filter: blur(15px);                /* 2. 增强模糊效果 */
            -webkit-backdrop-filter: blur(15px);        /* 3. 兼容Safari */
            border-top: 1px solid rgba(0, 0, 0, 0.1);    /* 4. 边框改为更柔和的半透明色 */
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 7px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; overflow: hidden; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column;position: relative; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; padding-bottom: calc(15px + env(safe-area-inset-bottom)); overflow-y: auto; flex: 1; }
        .modal-footer { padding: 15px; padding-bottom: calc(15px + env(safe-area-inset-bottom)); border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
#notification-bar {
    position: absolute;
    /* 核心修改：使用 env(safe-area-inset-top) 来自动避开顶部的“刘海”或“灵动岛” */
    top: calc(0px + env(safe-area-inset-top));
    left: 50%;
    width: 90%;
    z-index: 500;
    background-color: rgba(250, 250, 250, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    transform: translateX(-50%) translateY(-150%);
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
.message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0 !important; background-color: transparent !important; box-shadow: none !important; border: none !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important; }        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        /* NAI Gallery Panel Styles */
        #nai-gallery-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 65%; background-color: #ffffff; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid #e0e0e0; border-radius: 0px 0px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #nai-gallery-panel.visible { transform: translateY(0); visibility: visible; }
        #nai-gallery-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid #e0e0e0; }
        #nai-gallery-panel-header .title { font-weight: 600; color: #1e1e1e; font-size: 16px; }
        .nai-header-btn { width: 40px; height: 40px; border-radius: 50%; background-color: #1e1e1e; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: opacity 0.2s, transform 0.1s; }
        .nai-header-btn:hover { opacity: 0.8; }
        .nai-header-btn:active { transform: scale(0.95); }
        .nai-header-btn svg { color: #ffffff; width: 20px; height: 20px; stroke-width: 2; }
        #nai-gallery-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: min-content; row-gap: 15px; column-gap: 15px; background-color: #ffffff; align-items: start; }
        .nai-gallery-item { position: relative; width: 100%; aspect-ratio: 1/1; cursor: pointer; display: block; margin: 0; padding: 0; line-height: 0; overflow: hidden; }
        .nai-image-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f5f5f5; border-radius: 8px; background-size: contain; background-repeat: no-repeat; background-position: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow: hidden; border: 1px solid #e0e0e0; box-sizing: border-box; }
        .nai-gallery-name { font-size: 12px; color: #666; width: 100%; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: none; }
        .nai-image-container .nai-gallery-controls { position: absolute; bottom: 0; left: 0; width: 100%; padding: 4px; background: rgba(0,0,0,0.4); display: none; justify-content: space-around; align-items: center; }
        .nai-gallery-controls button { background: none; border: none; color: white; cursor: pointer; padding: 2px; }
        .nai-gallery-controls svg { width: 16px; height: 16px; }
        #nai-gallery-grid.management-mode .nai-gallery-controls { display: flex; }
        #nai-gallery-grid.management-mode .nai-image-container::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 3px solid transparent; border-radius: 8px; box-sizing: border-box; transition: border-color 0.2s; pointer-events: none; }
        #nai-gallery-grid.management-mode .nai-gallery-item.selected .nai-image-container::after { border-color: #1e1e1e; }
        #nai-gallery-action-bar { display: none; flex-shrink: 0; padding: 12px 15px; padding-bottom: calc(12px + env(safe-area-inset-bottom)); background-color: #ffffff; border-top: 1px solid #e0e0e0; justify-content: space-between; align-items: center; gap: 10px; }
        #nai-gallery-action-bar.visible { display: flex; }
        .select-all-label { font-size: 14px; color: #1e1e1e; cursor: pointer; flex-grow: 1; display: flex; align-items: center; gap: 8px; }
        .select-all-label input {
            cursor: pointer;
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid #1e1e1e;
            border-radius: 50%;
            background-color: #ffffff;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .select-all-label input:checked {
            background-color: #1e1e1e;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .select-all-label input:hover {
            border-color: #1e1e1e;
        }
        .action-bar-btn { width: 40px; height: 40px; border-radius: 50%; border: none; cursor: pointer; background-color: #1e1e1e; flex-shrink: 0; transition: opacity 0.2s, transform 0.1s; display: flex; align-items: center; justify-content: center; }
        .action-bar-btn:hover { opacity: 0.8; }
        .action-bar-btn:active { transform: scale(0.95); }
        .action-bar-btn svg { color: #ffffff; width: 20px; height: 20px; stroke-width: 2; }

        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: #F7F7F7; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 0px 0px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden;
            /* 禁止用户选择文本 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 禁止触摸滚动和橡皮筋效果 */
            -webkit-overflow-scrolling: auto;
            overscroll-behavior-x: contain;
            /* 禁止拖拽 */
            -webkit-touch-callout: none;
            /* 只限制水平方向，允许垂直内容正常显示 */
            max-width: 100vw;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color);
            /* 禁止用户选择文本 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 禁止拖拽 */
            -webkit-touch-callout: none;
            /* 限制宽度，但允许高度自适应 */
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        .svg-btn { width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: opacity 0.2s, transform 0.1s;
            /* 禁止用户选择文本 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 禁止拖拽和右键菜单 */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        .svg-btn:hover { opacity: 0.8; }
        .svg-btn:active { transform: scale(0.95); }
        .svg-btn svg { color: white; }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px;
            /* 禁止用户选择文本 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 优化触摸滚动 */
            -webkit-overflow-scrolling: touch;
            overscroll-behavior-x: contain;
            /* 禁止拖拽 */
            -webkit-touch-callout: none;
            /* 只限制水平宽度，保持垂直滚动 */
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            box-sizing: border-box;
            /* 确保网格项目正确布局 */
            min-width: 0;
            /* 确保grid能正常撑开高度 */
            min-height: 0;
            height: auto;
        }
/* ▼▼▼ 【核心结构修正】分离外框与内胆样式 ▼▼▼ */
        .sticker-item {
            position: relative;
            aspect-ratio: 1 / 1;
            cursor: pointer;
            padding: 2px; /* 给边框留出空间 */
            border-radius: 6px; /* 给外框一个圆角 */
            border: 3px solid transparent; /* 【关键】用透明边框占位，防止选中时布局跳动 */
            box-sizing: border-box;
            transition: all 0.2s ease;
            /* 禁止用户选择文本 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 禁止拖拽和右键菜单 */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            /* 确保项目不会超出网格宽度，但允许正常高度 */
            width: 100%;
            max-width: 100%;
            min-width: 0;
            /* 移除overflow: hidden，让内容正常显示 */
        }
        .sticker-image-inner { /* 【全新】这是内胆的样式，所有背景相关属性都在这里 */
            width: 100%;
            height: 100%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* 禁止拖拽图片 */
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
            /* 禁止选择 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 禁止右键菜单 */
            -webkit-touch-callout: none;
        }
        /* ▲▲▲ 修正结束 ▲▲▲ */        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #AB4D3F; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
#wait-reply-btn {
    position: static;
    bottom: auto;
    right: auto;
    width: 40px;
    height: 40px;
    padding: 0;
    border-radius: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: transparent; /* 1. 将背景色设为透明 */
    backdrop-filter: none;         /* 2. 移除模糊效果 */
    -webkit-backdrop-filter: none; /* 3. 移除模糊效果 (兼容) */
    border: none;                  /* 4. 移除边框 */
    box-shadow: none;              /* 5. 移除阴影 */
    transition: opacity 0.2s, transform 0.1s;
    cursor: pointer;
}        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
/* ▼▼▼ 用这块代码替换旧的 #wait-reply-btn img 样式 ▼▼▼ */
#wait-reply-btn img {
    height: 35px; /* 您可以按需调整这个数值，比如 28px 或 32px */
}        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 9999; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer {  display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #AB4D3F; }
#preset-actions-modal .custom-modal-footer {
    flex-direction: column; /* 保持垂直排列 */
    align-items: center; /* 【核心修改1】让按钮在水平方向上居中 */
    padding: 16px; /* 在容器四周增加一些留白 */
    gap: 12px; /* 统一设置按钮之间的垂直间距 */
}

#preset-actions-modal .custom-modal-footer button {
    width: 90%; /* 【核心修改2】设置一个稍短的宽度，而不是占满 */
    border: none; /* 移除旧的边框和下划线 */
    border-radius: 14px; /* 【外观优化】添加圆角，使其看起来更像按钮 */
    padding: 14px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    background-color: #f9f9f9; /* 统一设置一个浅灰色背景 */
    color: #1E1E1E;
    transition: background-color 0.2s;
}

#preset-actions-modal .custom-modal-footer button:hover {
    background-color: #f0f0f0;
}

#preset-actions-modal .custom-modal-footer button.btn-danger {
    color: #d9534f; /* 删除按钮使用红色文字 */
    background-color: #f9f9f9;
}

#preset-actions-modal .custom-modal-footer button#preset-action-cancel {
    margin-top: 8px; /* 为取消按钮增加一点额外的顶部间距，将其与操作组分开 */
    background-color: #f0f0f0;
    font-weight: 600;
}        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
         .select-box .selected-options-text {
    flex-grow: 1;
    white-space: normal; /* 允许正常换行 */
    word-break: break-all; /* 对长单词或URL等强制换行 */
    color: var(--text-primary);
    line-height: 1.4; /* 增加行高，让多行文本更易读 */
}
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

        /* ▼▼▼ NPC管理Modal样式 ▼▼▼ */
        #npc-manager-modal {
            display: none !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 2000 !important;
            visibility: hidden !important;
            opacity: 0 !important;
            transition: opacity 0.3s ease, visibility 0.3s ease !important;
        }

        #npc-manager-modal.visible {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .npc-tab-btn { transition: all 0.2s ease; }
        .npc-tab-btn:hover { background-color: #f5f5f5 !important; }
        .npc-tab-btn.npc-tab-active { border-bottom-color: #1E1E1E !important; color: #1E1E1E !important; }

        .npc-list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #fafafa;
        }

        .npc-list-item-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .npc-list-item-info {
            flex: 1;
            min-width: 0;
        }

        .npc-list-item-name {
            font-weight: 500;
            font-size: 14px;
            color: #1E1E1E;
            margin-bottom: 2px;
        }

        .npc-list-item-chars {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .npc-list-item-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .npc-list-item-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #fff;
            cursor: pointer;
            font-size: 12px;
            color: #1E1E1E;
            transition: all 0.2s;
        }

        .npc-list-item-btn:hover {
            background-color: #f0f0f0;
        }

        .npc-list-item-btn.delete {
            border-color: #AB4D3F;
            color: #AB4D3F;
        }

        .npc-list-item-btn.delete:hover {
            background-color: rgba(171, 77, 63, 0.1);
        }

        .npc-character-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            cursor: pointer;
            user-select: none;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .npc-character-checkbox:hover {
            background-color: #f0f0f0;
        }

        .npc-character-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .npc-character-checkbox-label {
            font-size: 13px;
            color: #1E1E1E;
            cursor: pointer;
        }

        /* ▲▲▲ NPC管理Modal样式结束 ▲▲▲ */

.checkboxes-container {
    display: none;
    position: absolute;
    /* 核心修改：不再使用 top，而是用 margin-top 来创造间距，更稳定 */
    top: 100%; 
    margin-top: 5px; /* <-- 新增：向下推开5像素的距离 */
    left: 0;
    right: 0;
    max-height: 350px;
    overflow-y: auto;
    overflow-x: hidden;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

        .checkboxes-container.visible { display: block; }

.checkboxes-container label {
    display: flex;
    align-items: center;
    padding: 8px 12px; /* 减少内边距，实现紧凑排布 */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px;
    gap: 8px; /* 元素间距离 */
    flex-wrap: nowrap; /* 防止换行 */
}

/* 书籍项目不需要gap */
.wb-book-container label {
    gap: 0 !important;
}

        /* 隐藏默认勾选框 */
        .checkboxes-container input[type="checkbox"] {
            display: none !important;
        }

        /* 只隐藏书籍项目（label）中的checkbox，不隐藏分类标题的checkbox */
        .wb-book-container label input[type="checkbox"] {
            display: none !important;
        }

        /* 只隐藏书籍项目（label）中的自定义勾选框，不隐藏分类标题的复选框 */
        .wb-book-container label .custom-checkbox {
            display: none !important;
        }

        /* 显示分类标题中的复选框（覆盖上面的隐藏规则） */
        .wb-category-header .custom-checkbox {
            display: inline-block !important;
        }
        
        /* SVG圆形勾选框样式 */
        .custom-checkbox {
            width: 16px;
            height: 16px;
            min-width: 16px; /* 确保最小宽度 */
            min-height: 16px; /* 确保最小高度 */
            cursor: pointer;
            flex-shrink: 0; /* 不允许收缩 */
        }
        
        .custom-checkbox-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #1E1E1E;
            background-color: transparent;
            transition: all 0.2s ease;
        }
        
        .custom-checkbox.checked .custom-checkbox-circle {
            background-color: #1E1E1E;
            border-color: #1E1E1E;
        }

        /* 分类头部样式 */
        .wb-category-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 15px;
            gap: 8px;
            background-color: #ffffff;
            border-bottom: 1px solid #e9ecef;
            flex-wrap: nowrap; /* 防止换行 */
            white-space: nowrap; /* 防止文本换行 */
        }
        
        .wb-category-header .arrow {
            color: #1E1E1E !important; /* 强制黑色箭头 */
            font-size: 12px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }
        
        .wb-category-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
#remove-bg-btn {
    /* ▼▼▼ 从旁边的按钮复制的核心样式 ▼▼▼ */
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.4);
    border-radius: 16px;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    
    /* ▼▼▼ 统一其他基础样式 ▼▼▼ */
    color: var(--text-primary); /* 与“上传”按钮文字颜色统一 */
    padding: 8px 12px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    display: none; /* 保持默认隐藏的行为 */
}

#remove-bg-btn:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12);
}        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .message-bubble.is-naiimag { padding: 0; }
        .message-bubble.is-naiimag .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        /* 【新增】naiimag 图片容器和重新生成按钮样式 */
        .naiimag-container { position: relative; display: inline-block; }
        .naiimag-container:hover .naiimag-retry-btn { display: flex !important; }
        .naiimag-retry-btn:hover { background-color: rgba(30, 30, 30, 0.95) !important; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 4px 8px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1E1E1E; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
        /* ▼▼▼ 【Minimax TTS】播放时的动画 ▼▼▼ */
        .message-bubble.is-voice-message.playing .voice-waveform div {
            animation: wave-playing 0.8s ease-in-out infinite;
        }
        @keyframes wave-playing { 0%, 100% { height: 3px; } 50% { height: 16px; } }
        .message-bubble.is-voice-message.playing .voice-waveform div:nth-child(2) { animation-delay: 0.1s; }
        .message-bubble.is-voice-message.playing .voice-waveform div:nth-child(3) { animation-delay: 0.2s; }
        .message-bubble.is-voice-message.playing .voice-waveform div:nth-child(4) { animation-delay: 0.3s; }
        .message-bubble.is-voice-message.playing .voice-waveform div:nth-child(5) { animation-delay: 0.4s; }
        /* ▲▲▲ 【Minimax TTS】播放时的动画 ▲▲▲ */
.voice-duration {
    /* --- 核心修正 --- */
    font-size: var(--chat-font-size, 13px);
    /* --- 修正结束 --- */
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #1E1E1E; }

/* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
/* 通用内容区样式，为时间戳和字体大小做准备 */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
    text-align: justify; /* <<<--- 新增这一行代码 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

        /* === 气泡主题样式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #f9f9f9; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(238, 238, 243, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #1E1E1E; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #1E1E1E; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #f4f2f3; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #1E1E1E; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #fcfafb; color: #1E1E1E; }
        #transfer-confirm-btn { background-color: #1E1E1E; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #fcc97d, #fcc97d); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #fcc97d, #fcc97d); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(213, 99, 99, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(131, 176, 225, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #d46b66; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* 圆形SVG按钮样式 */
        .circular-svg-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 36px;
            height: 36px;
            min-width: 36px;
            min-height: 36px;
            max-width: 36px;
            max-height: 36px;
            border-radius: 50%;
            background-color: #1E1E1E;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 1;
            flex-shrink: 0;
            box-sizing: border-box;
            aspect-ratio: 1/1;
        }
        
        .circular-svg-button:hover {
            background-color: #333;
            transform: scale(1.05);
        }
        
        .circular-svg-button svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        #search-ai-sticker-btn {
            left: 15px;
        }

        #import-txt-ai-sticker-btn {
            right: 105px;
        }

        #manage-ai-sticker-library-btn {
            left: 65px;
        }

        #batch-add-ai-sticker-btn {
            right: 60px;
        }

        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* 这是你要添加的新样式 */
#font-preview {
    transition: font-family 0.3s ease;}

/* === 线下模式样式 === */
/* 线下模式消息容器 */
.reality-message-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: -2px 0 -10px 0;
    position: relative;
    width: 100%;
}

/* 线下模式消息气泡 - 毛玻璃效果 */
.reality-message-bubble {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    padding: 8px 12px 8px 12px;  /* 上右下左：左右相等 */
    max-width: 90%;
    position: relative;
    text-align: left;
    word-break: break-word;
    line-height: 1.5;
    /* 使用和线上模式相同的字体样式 */
    font-size: var(--chat-font-size, 16px);
    margin: 5px auto;
    /* 恢复原来的布局 */
    display: inline-block;
}

/* 线下模式用户气泡的特殊padding */
.reality-message-bubble.user {
    padding: 5px 10px 5px 10px;  /* 用户消息：左右相等 */
}

/* 线下模式斜体文字样式 */
.reality-italic {
    font-style: italic;
}

/* 线下模式时间戳 - 在气泡外部上方居中 */
.reality-timestamp {
    font-size: 11px;
    color: #666;
    text-align: center;
    margin-bottom: 5px;
    background: rgba(255, 255, 255, 0.6);
    padding: 3px 8px;
    border-radius: 15px;
    display: inline-block;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

/* 线下模式系统提示容器 - 真正的居中 */
.message-wrapper.system-mode-switch {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0px auto -5px auto;
    width: 100%;
    text-align: center;
    
}
/* 或者使用更精确的选择器 */
  #chat-messages .reality-message-wrapper:nth-last-child(2) {
      margin-bottom: 7px !important;
  }

  #chat-messages .message-wrapper.system-mode-switch:nth-last-child(2) {
      margin-bottom: 7px !important;
  }
  
/* 线下模式系统提示 - 居中的黑色气泡 */
.reality-system-message {
    text-align: center;
    padding: 5px 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 10px;
    font-size: 12px;
    font-weight: 500;
    max-width: 200px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    margin: 0 auto;
    display: inline-block;
}

/* === 聊天列表界面新增样式 (这是新添加的) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* 底部导航栏样式 */
#chat-list-bottom-nav {
    position: absolute; /* 让它固定在底部 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* 确保它在视图之上 */
    display: flex;
    border-top: 1px solid #E0E0E0;
    background-color: #F7F7F7;
    
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 10px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
    position: relative;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* 【新增】底部导航中的未读指示器定位 */
.nav-item .unread-indicator {
    position: absolute;
    top: 0;
    right: 5px;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #AB4D3F;
    color: white;
    font-size: 11px;
    font-weight: bold;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    z-index: 1;
    display: none;
}

/* 显示时使用flex居中 */
.nav-item .unread-indicator[style*="display: inline-flex"],
.nav-item .unread-indicator:not([style*="display: none"]) {
    display: flex;
    align-items: center;
    justify-content: center;
}

/* === 动态界面 (QZone) 样式 (这是新添加的) === */
#qzone-screen {
    background-color: #F7F7F7;
}

.qzone-header {
    /* position: absolute;  <-- 把这个改成 relative */
    position: relative;
    z-index: 10; /* z-index 保持，或者可以更高 */
    flex-shrink: 0; /* 防止被压缩 */
    padding: 10px 20px;
    padding-top: calc(10px + env(safe-area-inset-top));
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
    min-height: 30px;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { /* "好友动态"文字 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-header .header-actions {
    display: flex;
    align-items: center;
    gap: 5px;
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #F7F7F7;
    /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 背景板高度 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
    left: 20px;
    display: flex;
    align-items: flex-end; /* 让昵称和头像底部对齐 */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 微调位置 */
}

/* 编辑按钮的通用样式 */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* 与昵称的间距 */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* 脱离flex布局的对齐 */
    bottom: 5px; /* 微调垂直位置 */
}

/* === 让编辑功能更“隐形” === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
}
/* 隐藏掉旧的、独立的编辑按钮 */
.qzone-edit-btn {
    display: none;
}

/* === 控制 Header 和 Bottom Nav 的显隐 === */
/* 默认隐藏动态界面的 Header */
#qzone-screen .qzone-header {
    display: none;
}
/* 当动态视图激活时，显示它的Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* 当进入动态视图时，隐藏主Header和底部导航栏 */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-list-item:first-child,
.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ 新样式替换结束 ▲▲▲ */

/* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 动态功能栏样式 === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* 用伪元素创建分隔线 */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === 动态帖子列表样式 === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
    display: flex;
    flex-direction: column;
    gap: 20px; /* 帖子之间的间距 */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* 让换行符生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

/* === 发布动态模态框样式 === */
#post-public-text {
    min-height: 80px; /* 确保文本域有足够的高度 */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
    background-color: #F7F7F7;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* 上传后显示 */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #AB4D3F;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式 ▼▼▼ */

/* === 发布动态模态框 - 模式切换样式 === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #333333; /* 修改点：容器背景改为深灰色 */
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: #ababab; /* 修改点：未选中时文字颜色改为浅灰色 */
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: #1E1E1E; /* 修改点：背景色改为 #1E1E1E */
    color: #FFFFFF; /* 修改点：文字颜色改为纯白色 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* 默认都隐藏 */
}

.post-mode-content.active {
    display: block; /* 激活的才显示 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* === 相册页面背景色 === */
#album-screen {
    background-color: #F7F7F7; /* 使用一个柔和的浅灰色，比纯白更护眼 */
}

/* === 相册页面网格布局 === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
    gap: 15px;
}

/* === 相册项目样式 (美化) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* 给整个项目也加个圆角 */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* 保持封面为正方形 */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #F7F7F7; /* 封面加载前的占位颜色 */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 防止长名字换行 */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 相册照片详情页 === */
#album-photos-screen {
    background-color: #F7F7F7;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    /* 每行显示3张照片，并保持间距 */
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; /* 为了定位删除按钮 */
    aspect-ratio: 1 / 1; /* 保持照片为正方形 */
    border-radius: 6px;
    overflow: hidden; /* 防止图片溢出圆角 */
    background-color: #e9ecef; /* 图片加载前的占位符颜色 */
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满容器且不变形 */
    cursor: pointer;
}

/* 删除按钮的样式 */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease;
}

/* 鼠标悬停在照片上时显示删除按钮 */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 图片查看器模态框样式 === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* 图片最大宽度为视口的90% */
    max-height: 85vh; /* 图片最大高度为视口的85% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* 为图片的切换添加一点平滑的淡入淡出效果 */
    transition: opacity 0.2s ease-in-out;
}

/* 关闭按钮 */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* 左右导航箭头 */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* 现在我们用绝对定位来控制箭头 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* 调整内边距 */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* 确保箭头在最上层 */
}

#photo-viewer-prev-btn {
    left: 5px; /* 定位左箭头 */
}

#photo-viewer-next-btn {
    right: 5px; /* 定位右箭头 */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* 当箭头被禁用时（比如第一张或最后一张） */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

/* === 帖子内容区 - 相对定位容器 === */
/* === 帖子内容区 === */
.post-main-content {
    /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
}

/* === 帖子互动图标区 (新样式) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* 让图标靠右对齐 */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* 默认灰色 */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* 图标激活(点赞/收藏后)的样式 */
.action-icon.active {
    color: #ff5252; /* 激活后变红色 */
    transform: scale(1.1); /* 轻微放大 */
}

.action-icon.active.favorite {
    color: #ffc107; /* 收藏用黄色 */
}

.action-icon.active svg {
    fill: currentColor; /* 激活后填充颜色 */
}

/* 点击时的动画效果 */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === 帖子底部评论区样式 (现在是独立部分) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
    display: flex;
    align-items: center;
    gap: 8px; /* 调整整体间距 */
}

/* 评论区容器 */
.comment-section {
    flex-grow: 1; /* 占据大部分空间 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #F7F7F7;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* 新增的发送按钮样式 */
.comment-send-btn {
    flex-shrink: 0; /* 防止被压缩 */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息小红点通用样式 === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #AB4D3F;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* 放到返回箭头右上角 */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 评论列表容器 === */
.post-comments-container {
    padding: 10px 0; /* 上下留白 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 评论之间的间距 */
    font-size: 13px; /* 统一评论区字体大小 */
}

/* 每一条评论 */
.comment-item {
    line-height: 1.5;
}

/* 评论者的名字，加粗并使用主题色 */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* 和评论内容之间留点空隙 */
}

/* 评论内容 */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}

/* 【新增】二级评论（回复）缩进样式 */
.comment-item-reply {
    margin-left: 24px !important;  /* 缩进24px */
    padding-left: 12px !important;  /* 左边距 */
    border-left: 2px solid var(--accent-color, #4a90e2);  /* 左边框，显示层级 */
    opacity: 0.95;  /* 略微降低透明度，区分二级 */
}

.comment-item-reply .commenter-name {
    color: var(--accent-color);
}

/* 【新增】新评论的红点标记 */
.comment-item.has-new-mark .commenter-name::before {
    content: '';
    display: inline-block;
    width: 6px;
    height: 6px;
    background-color: #AB4D3F;
    border-radius: 50%;
    margin-right: 4px;
    vertical-align: super;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 帖子点赞区域样式 === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    padding: 8px 10px; /* 内边距 */
    font-size: 13px;
    color: var(--accent-color); /* 使用主题蓝色 */
    background-color: #f0f5fa; /* 给一个淡淡的背景色 */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* 和上方的图标保持一点距离 */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* 让SVG图标继承父元素的颜色 */
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === @提及 弹出菜单样式 === */
.at-mention-popup {
    position: absolute; /* 相对于父元素定位 */
    bottom: 100%; /* 显示在输入框的上方 */
    left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
    width: calc(100% - 40px); /* 宽度和输入框差不多 */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* 默认隐藏 */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

            /* 让收藏视图成为一个flex容器, 从上到下排列 */
            #favorites-view {
                display: flex;
                flex-direction: column;
            }

            /* 确保收藏页的header高度固定，不被压缩 */
            #favorites-view > .header {
                flex-shrink: 0;
                /* 修改：将padding-top单独分离出来，以合并安全区 */
                padding: 10px 20px !important;
                padding-top: calc(10px + env(safe-area-inset-top)) !important;
            }

            /* === 收藏列表样式 (修正后) === */
            #favorites-list {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
    padding: 8px 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* 为了定位删除按钮 */
}

/* 卡片头部，包含头像、名字和来源 */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片内容 */
.fav-card-content {
    font-size: 14px;
    line-height: 1;
    color: #333;
    white-space: normal;
    word-break: break-word;
    overflow: hidden;
    max-width: 100%;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* 图片和文字的间距 */
}

/* HTML模块在收藏卡片中的样式 */
.fav-card-content orange {
    display: block;
    width: 100% !important;
    max-width: 100% !important;
    max-height: 500px !important; /* 限制最大高度，避免卡片过长 */
    overflow-y: auto !important; /* 允许垂直滚动 */
    overflow-x: hidden !important; /* 禁止水平滚动 */
    box-sizing: border-box;
}

/* 删除按钮 */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #F7F7F7;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #AB4D3F;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 角色选择器样式 === */
.character-selector {
    padding: 8px 10px;
    background-color: #f9f9f9;
    flex-shrink: 0;
    display: flex;
    gap: 6px;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-behavior: smooth;
}

.character-selector::-webkit-scrollbar {
    height: 3px;
}

.character-selector::-webkit-scrollbar-track {
    background: #f0f0f0;
}

.character-selector::-webkit-scrollbar-thumb {
    background: #ccc;
    border-radius: 3px;
}

.character-selector::-webkit-scrollbar-thumb:hover {
    background: #999;
}

.char-btn {
    padding: 6px 14px;
    background-color: #e8e8e8;
    border: none;
    border-radius: 16px;
    font-size: 12px;
    white-space: nowrap;
    cursor: pointer;
    color: #666;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.char-btn:hover {
    background-color: #ddd;
}

.char-btn-active {
    background-color: #1e1e1e;
    color: white;
}

/* === 搜索栏样式 === */
.search-bar-container {
    padding: 8px 10px;
    background-color: #f9f9f9; /* 和列表背景色保持一致 */
    position: relative; /* 为了定位清除按钮 */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圆角矩形，更现代化 */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 聊天界面多选操作栏优化 === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    align-items: center;
    width: 100%;
    position: relative;
}
/* 左侧取消按钮 */
#chat-interface-screen .selection-controls #selection-cancel-btn {
    position: absolute;
    left: 0;
}
/* 右侧操作按钮组 */
#chat-interface-screen .selection-controls .header-actions {
    position: absolute;
    right: 0;
    display: flex;
    gap: 5px;
}
#chat-interface-screen .selection-controls .action-btn.circle-btn {
    width: 30px !important;
    height: 30px !important;
    min-width: 30px !important;
    flex-shrink: 0 !important;
    border-radius: 50% !important;
}
/* 确保选择计数文本居中 */
#chat-interface-screen .selection-controls #selection-count {
    width: 100%;
    text-align: center;
    font-size: 16px;
    font-weight: 600;
}

/* === 收藏页面多选模式样式 === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 选择框的样式 */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* 把它放在卡片左边外面 */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 进入选择模式时，卡片向右移动，露出选择框 */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* 选中后的样式 */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 底部操作栏 (终极修正版) */
#favorites-action-bar {
    position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
    width: auto;        /* ★ 改为 auto，让 left/right 决定宽度 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width 已经不需要了，因为父元素已经限制了宽度 */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #AB4D3F;
    color: white;
}

/* === 【修正】聊天界面头部控件切换逻辑 === */

/* 默认状态：隐藏多选控件 */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* 默认状态：显示默认控件，并让它撑满整个头部 */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* 当进入多选模式时：隐藏默认控件 */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：放大所有主要的“+”号按钮 === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
    font-weight: 300;  /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
    position: relative;/* 允许进行位置微调 */
    top: -1px;         /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 预览区容器样式 */
#settings-preview-area {
    width: 100%;
    height: 180px; /* 给一个固定的高度 */
    background-color: #F7F7F7;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* 防止内容溢出 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* 预览气泡之间的间距 */
    border: 1px solid var(--border-color);
    position: relative; /* 为了定位背景 */
}

/* 预览区的背景，可以和真实聊天界面同步 */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* 让预览气泡在背景之上 */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* 预览区内使用的头像要小一点 */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}

#settings-preview-area .message-bubble .timestamp {
    display: none; /* 预览区不需要显示时间戳 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #AB4D3F;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}

.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 格式助手按钮的容器 */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* 与下方的文本框拉开距离 */
    flex-wrap: wrap; /* 如果按钮太多可以换行 */
}

/* 单个格式助手按钮的样式 */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* 胶囊形状，更友好 */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* “…”按钮的样式 */
.post-actions-btn {
    margin-left: auto; /* 关键：让它自动靠到最右边 */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 统一重置转账卡片内所有文字的特效和颜色 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
    color: white !important;      /* 强制锁定文字颜色为白色 */
}

/* 分别锁定各自的字体大小和字重，防止被篡改 */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
.header > span:nth-child(2),
#chat-header-title {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* 在-50%的基础上，再向左推2像素 */
    
    /* (可选但推荐) 防止长标题与两边按钮重叠 */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* 覆盖默认的 margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #AB4D3F;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
#member-management-list {
    padding: 0; /* 移除默认padding，让列表项撑满 */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #AB4D3F;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #657f49; /* 新建用绿色，以示区分 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; /* 橙黄色背景 */
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

/* === 同意支付后的样式 === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* 绿色边框 */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我已为您买单，请尽情享用吧～" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* 隐藏支付详情 */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === 拒绝支付后的样式 === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* 红色边框 */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我拒绝了您的代付请求" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* 隐藏支付详情 */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 强制重写 request-title 内容的技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* 隐藏原始文本 */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* 让伪元素显示新文本 */
}
.message-bubble.status-paid .request-title::after {
    content: "我已为您买单，请尽情享用吧～";
}
.message-bubble.status-rejected .request-title::after {
    content: "我拒绝了您的代付请求";
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【新增】统一设置页面的背景色 (已修正) === */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#memories-view,
#contact-picker-screen,
#member-management-screen,
#world-book-editor-screen {  
    background-color: #F7F7F7;
}

/* 确保这些页面的内容区能正确滚动 */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    background-color: #F7F7F7;
}

/* 壁纸设置页面的预览区比较特殊，需要额外调整 */
#wallpaper-screen .form-container {
    align-items: center; /* 保持内容居中 */
}

/* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

/* --- 来电请求模态框 --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #AB4D3F;
    /* 【核心修改】将图标的SVG代码换成一个简单的“X” */
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
}

.call-action-btn.accept {
    background-color: #657f49;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* --- 视频通话界面 --- */
/* ▼▼▼ 请用这一整块【最终修正版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

/* 1. 通话屏幕总容器 (保持不变) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 2. 顶部栏和底部控制栏 (保持不变) */
.video-call-top-bar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    padding: 15px 20px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    text-align: center;
    box-sizing: border-box;
    pointer-events: none;
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}
.video-call-controls {
    position: absolute;
    bottom: 0; left: 0; width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    box-sizing: border-box;
}

/* 3. 参与者头像显示区 (保持不变) */
.video-call-avatar-area {
    flex-shrink: 0; 
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: 80px; /* 确保顶部有足够空间 */
    box-sizing: border-box;
    overflow-y: auto; /* ★ 新增：如果头像太多，允许此区域滚动 */
}

/* 4. 头像网格容器 (保持不变) */
#participant-avatars-grid {
    display: flex;
    flex-wrap: wrap; 
    justify-content: center;
    align-items: center;
    gap: 15px; /* ★ 稍微减小头像间距 */
    max-width: 100%;
}

/* 5. 单个参与者的头像容器 (头像缩小) */
.participant-avatar-wrapper {
    position: relative;
    text-align: center;
    flex-shrink: 0;
}
.participant-avatar {
    width: 70px;   /* ★ 从 80px 缩小到 70px */
    height: 70px;  /* ★ 从 80px 缩小到 70px */
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 12px;
    color: #ccc;
}

/* 6. 发言者头像高亮效果 (保持不变) */
.participant-avatar.speaking {
    border-color: #657f49;
    box-shadow: 0 0 20px #657f49;
    transform: scale(1.05);
}

/* 7. 【最终版】对话框区域 */
#video-call-main {
    flex-grow: 1; 
    min-height: 40%; 
    margin: 0 15px 130px 15px; 
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    /* ▼▼▼ 修改2：新增这一行 ▼▼▼ */
    align-items: flex-start; /* 让气泡宽度自适应，不再强制拉伸 */
    /* ▲▲▲ 修改结束 ▲▲▲ */
    gap: 15px;
    box-sizing: border-box;
    
}

/* 8. 控制按钮样式 (保持不变) */
.control-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, background-color 0.2s;
}
.control-btn:active {
    transform: scale(0.9);
}
.control-btn.speak-btn {
    background-color: rgba(255,255,255,0.2);
    background-size: 55%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><path d="M12 19v4"></path><path d="M8 23h8"></path></svg>');
}
.control-btn.hangup-btn {
    background-color: #AB4D3F;
    background-size: 50%;
    /* 【核心修改】将图标的SVG代码换成一个简单的“X” */
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
}
.control-btn.join-btn {
    background-color: #1E1E1E;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
}

/* ▲▲▲ 新CSS替换结束 ▲▲▲ */

/* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
    /* ▼▼▼ 修改1：为所有气泡增加下方间距 ▼▼▼ */
    margin-bottom: 10px; 
    /* ▲▲▲ 修改结束 ▲▲▲ */
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; /* AI发言靠左 */
    position: relative; /* 为重roll按钮定位 */
    cursor: pointer; /* 显示可点击 */
}

/* 重roll按钮样式 */
.reroll-btn {
    position: absolute;
    right: -40px;
    top: 50%;
    transform: translateY(-50%);
    width: 28px;
    height: 28px;
    background-color: rgba(255, 255, 255, 0.9);
    border: none;
    border-radius: 50%;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 100;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
}

.reroll-btn:hover {
    background-color: rgba(255, 255, 255, 1);
    transform: translateY(-50%) scale(1.1);
}

.reroll-btn svg {
    width: 16px;
    height: 16px;
    fill: #666;
}

.call-message-bubble.user-speech {
    background-color: #5f9668; /* 用户发言用绿色，类似微信 */
    align-self: flex-end;   /* 用户发言靠右 */
    text-align: left; /* 确保用户气泡内的文字是左对齐的 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【新增】语音通话界面CSS ▼▼▼ */
#voice-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.voice-call-top-bar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    padding: 15px 20px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    text-align: center;
    box-sizing: border-box;
    pointer-events: none;
}

#voice-call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}

.voice-call-controls {
    position: absolute;
    bottom: 0; left: 0; width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    box-sizing: border-box;
}

.voice-call-avatar-area {
    flex-shrink: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: 80px;
    box-sizing: border-box;
    overflow-y: auto;
}

#voice-participant-avatars-grid {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 15px;
    max-width: 100%;
}

.voice-call-main {
    flex-grow: 1;
    min-height: 40%;
    margin: 0 15px 130px 15px;
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 15px;
    box-sizing: border-box;
}

.control-btn.voice-speak-btn {
    background-color: rgba(255,255,255,0.2);
    background-size: 55%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>');
}

.control-btn.voice-hangup-btn {
    background-color: #AB4D3F;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
}

.control-btn.voice-join-btn {
    background-color: #1E1E1E;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
}

.voice-call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
    margin-bottom: 10px;
}

.voice-call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start;
    position: relative;
    cursor: pointer;
}

.voice-call-message-bubble.user-speech {
    background-color: #5f9668;
    align-self: flex-end;
    text-align: left;
}
/* ▲▲▲ 语音通话界面CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* 垂直居中 */
    align-items: center;   /* 水平居中 */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* 和上方文字拉开距离 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
.qzone-post-container {
    position: relative; /* 让内部的删除按钮可以相对于它定位 */
    overflow: hidden;   /* 隐藏掉超出部分的删除按钮 */
    border-radius: 12px;/* 和内部卡片保持一致的圆角 */
}

/* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* 确保它有背景色，能盖住下面的删除按钮 */
    position: relative; /* 确保它在最上层 */
    z-index: 2;
}

/* 3. 【核心】这就是那个“删除”按钮的样式！*/
.qzone-post-delete-action {
    position: absolute; /* 绝对定位，脱离文档流 */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* 删除按钮的宽度 */
    background-color: #AB4D3F; /* 您想要的红色背景 */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* 确保它在卡片下面 */
}

/* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. “拍一拍”的屏幕震动动画 */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. “拍一拍”系统提示消息的样式 */
.system-message {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* 让“拍一拍”类型的 wrapper 居中 */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* “拍一-拍”消息气泡的样式 */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：让顶部操作栏可以横向滚动 === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- 核心代码开始 --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天界面头部状态栏样式 === */

/* 1. 标题和状态的总容器，使用flex布局让它们垂直排列 */
#chat-header-title-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; /* 水平居中 */
    gap: 2px; /* 标题和状态之间的微小间距 */
    
    /* 为了让它能在flex布局中正确居中 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    max-width: 60%;
}

/* 2. 主标题的样式微调 */
#chat-header-title {
    font-size: 16px; /* 可以稍微缩小一点，给状态栏留出空间 */
    font-weight: 600;
    position: static; /* 覆盖掉旧的absolute定位 */
    transform: none;  /* 覆盖掉旧的transform */
    /* 保证长标题也能正确显示省略号 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

/* 3. 状态栏容器 */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. 状态小圆点 */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #657f49; /* 默认绿色，代表在线 */
    transition: background-color 0.3s ease;
    flex-shrink: 0; /* 新增此行，防止被压缩 */
}

/* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. 状态文本 */
.status-text {
    font-weight: 500;
}

/* ★★★★★【全新美化】状态更新加载动画气泡★★★★★ */
.status-updating-bubble {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 0px;
    
    padding: 1px 6px;
    border-radius: 20px;
    
    /* 毛玻璃背景效果 */
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    
    /* 浅灰色边框 */
    border: 1px solid rgba(200, 200, 200, 0.6);
    
    /* 阴影效果 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    
    font-size: 10px;
    font-weight: 500;
    color: var(--text-secondary);
    
    /* 动画效果 */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    
    white-space: nowrap;
    z-index: 10;
}

.status-updating-bubble.visible {
    opacity: 1;
}

.status-updating-bubble::after {
    content: '更新中';
    animation: status-loading-dots 1.5s infinite;
}

@keyframes status-loading-dots {
    0%, 20% { content: '更新中.'; }
    25%, 45% { content: '更新中..'; }
    50%, 70% { content: '更新中...'; }
    75%, 95% { content: '更新中'; }
    100% { content: '更新中.'; }
}

/* 确保状态栏容器有相对定位，以便气泡正确定位 */
#chat-header-status {
    position: relative;
}
/* ★★★★★【状态更新动画结束】★★★★★ */

/* === 【全新美化版】回忆卡片样式 === */

/* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
.memory-card {
    background-color: #FFFFFF;
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 修改点：更换为更清晰柔和的阴影 */
    border: 1px solid #EAEAEA; /* 修改点：替换掉border-left，改为完整的细灰色边框 */
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 2. 头部容器：现在只负责布局和分割线 */
.memory-card .header {
    background-color: #FFFFFF;
    border-bottom: 1px solid rgba(109, 110, 131, 0.15); /* 分割线颜色可以稍微加深一点 */
    padding-bottom: 8px; 
}

/* 3. 日期样式 (保持不变) */
.memory-card .header .date {
    font-size: 11px;
    color: #1E1E1E;
    margin-bottom: 4px; 
}

/* 4. 作者样式 (保持不变) */
.memory-card .header .author {
    font-weight: 600;
    color: #1E1E1E;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 内容区样式 (保持不变) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #1E1E1E;
    white-space: pre-wrap;
}

/* === 【全新】约定/倒计时卡片样式 === */
.countdown-card {
    background: linear-gradient(135deg, #1E1E1E, #1E1E1E);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(104, 97, 111, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【全新】聊天锁定遮罩层样式 === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #F7F7F7;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 100; /* 比输入框高，比贴纸面板低 */
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    padding: 10px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: flex-end;
    
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 5px;
    align-items: center;
    text-align: center;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 8px 15px;
    border-radius: 14px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}
/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
.lock-actions-row {
    display: flex;
    gap: 10px; /* 按钮之间的间距 */
    align-items: center; /* 垂直居中对齐 */
    width: 100%;
}
#toggle-dev-panel-btn {
    width: 32px;
    height: 32px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    /* ▼▼▼ 全新添加的样式 ▼▼▼ */
    background-color: #1E1E1E !important; /* 主色调背景 */
    border-radius: 50%; /* 变为圆形 */
    border: none; /* 移除边框 */
    cursor: pointer;
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* 金色文字 */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

/* 投票卡片在消息气泡中的样式 */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 投票卡片主体 */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* 结束后变灰 */
}

/* 投票问题 */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* 投票选项列表 */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 单个投票选项 */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* 用户已投票的选项样式 */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* 投票进度条 */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* 选项内容（文字和票数），确保在进度条之上 */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* 投票卡片底部 */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* 创建投票模态框的选项输入 */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #AB4D3F;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天头部“正在输入”状态样式 === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

/* === 【新增】后台活动头像呼吸光圈效果 === */
.chat-list-item.background-active img,
.chat-list-item.background-active .app-icon {
    animation: background-activity-glow 2s ease-in-out infinite;
}

@keyframes background-activity-glow {
    0%, 100% {
        box-shadow: 0 0 0 0 rgba(158, 158, 158, 0.4);
    }
    50% {
        box-shadow: 0 0 0 8px rgba(158, 158, 158, 0);
    }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}





/* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 12px; /* 稍微增加左右间距，让文字更舒展 */
    font-size: 12px;
    border: none; /* 修改点：移除了边框 */
    background-color: #1E1E1E; /* 修改点：更换为您想要的背景色，例如主题黑色 */
    color: #FFFFFF; /* 新增：文字颜色改为白色以保证清晰 */
    border-radius: 20px; /* 修改点：将圆角改大，使其更圆润 */
    cursor: pointer;
    transition: background-color 0.2s; /* 新增：添加一个简单的悬浮过渡效果 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */

/* 1. 修正滚动问题 */
#wallpaper-screen .form-container {
    /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
    min-height: 0; 
}

/* 2. 修正壁纸预览被压扁的问题 */
#wallpaper-preview {
    /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
    flex-shrink: 0; 
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */

/* 1. 浏览器界面背景色和内容区样式 (保持不变) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. 聊天气泡中的链接卡片样式 (无图版) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 210px; 
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* 让图标和文字水平对齐 */
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* 和上面的描述拉开一点距离 */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位 */
.comment-item {
    position: relative;
    padding-right: 25px; /* 在右侧留出删除按钮的空间 */
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在评论上时，显示删除按钮 */
.comment-item:hover .comment-delete-btn {
    opacity: 1;
}

.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #AB4D3F;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】夜间模式样式 === */

/* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */

/* 1. 全局背景和文本颜色 */
#phone-screen.dark-mode {
    --secondary-bg: #1c1c1e; /* 主要卡片背景色 */
    --border-color: #38383a;  /* 边框颜色 */
    --text-primary: #ffffff;   /* 主要文字颜色 */
    --text-secondary: #8d8d92; /* 次要文字/图标颜色 */
}

/* 2. 各个页面的主背景色 */
#phone-screen.dark-mode #chat-list-screen,
#phone-screen.dark-mode #qzone-screen .qzone-content,
#phone-screen.dark-mode #memories-view {
    background-color: #000000;
}

/* 3. 聊天列表 */
#phone-screen.dark-mode #chat-list {
    background-color: #000000;
}
#phone-screen.dark-mode .chat-list-item {
    border-bottom-color: rgba(255, 255, 255, 0.15);
}
#phone-screen.dark-mode .chat-group-header {
    background-color: #1c1c1e; /* 从白色改为深灰色 */
    border-bottom: 1px solid #38383a; /* 给它一个细微的下边框 */
}
#phone-screen.dark-mode .chat-list-item .name,
#phone-screen.dark-mode .chat-group-header .group-name {
    color: #ffffff;
}
#phone-screen.dark-mode .chat-list-item:hover {
    background-color: #1c1c1e;
}

/* 4. 顶部/底部导航栏 */
#phone-screen.dark-mode .header,
#phone-screen.dark-mode .qzone-header {
    background-color: #191919;
    
    border-bottom-color: rgba(255, 255, 255, 0.15);
    color: #ffffff;
}
#phone-screen.dark-mode .header .back-btn,
#phone-screen.dark-mode .header .action-btn,
#phone-screen.dark-mode .header .save-btn {
    color: #ffffff;
}
#phone-screen.dark-mode #chat-list-bottom-nav {
    background-color: rgba(25, 25, 25, 0.9);
    border-top-color: rgba(255, 255, 255, 0.15);
}
#phone-screen.dark-mode .nav-item.active {
    color: #ffffff;
}

/* 5. 聊天界面 */
#phone-screen.dark-mode #chat-input-area {
    background-color: #191919;
    border-top: none;
    padding-bottom: 28px; /* 与普通模式保持一致：原8px + 新增10px = 18px */
}
#phone-screen.dark-mode #chat-input {
    background-color: #1E1E1E;
    color: #ffffff;
}
#phone-screen.dark-mode #chat-input::placeholder {
    color: #8d8d92;
}
#phone-screen.dark-mode .chat-action-icon-btn {
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.1);
    border: none;
}
#phone-screen.dark-mode #send-btn {
    background-color: var(--accent-color);
}

/* 6. 动态 (QZone) 界面 */
#phone-screen.dark-mode .qzone-actions-bar,
#phone-screen.dark-mode .qzone-post-item {
    background-color: #1c1c1e;
    border: 1px solid #333;
    box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
}
#phone-screen.dark-mode .action-item:not(:last-child)::after {
    background-color: #333;
}
#phone-screen.dark-mode .post-footer,
#phone-screen.dark-mode .post-likes-section {
    border-top-color: #333;
}
#phone-screen.dark-mode .post-likes-section {
    background-color: rgba(0, 123, 255, 0.1);
}
#phone-screen.dark-mode .comment-input {
    background-color: #333;
    color: #ffffff;
}
#phone-screen.dark-mode .comment-input::placeholder {
    color: #8d8d92;
}
#phone-screen.dark-mode .post-actions-btn:hover {
    background-color: #333;
}
#phone-screen.dark-mode .at-mention-popup {
    background-color: #1c1c1e;
    border-color: #333;
}
#phone-screen.dark-mode .at-mention-item {
    border-bottom-color: #333;
}
#phone-screen.dark-mode .at-mention-item:hover {
    background-color: #333;
}

/* 7. 回忆录界面 */
#phone-screen.dark-mode .memory-card {
    background-color: #1c1c1e;
    border-left-color: #e6a753;
    box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
}
#phone-screen.dark-mode .memory-card .header {
    background-color: #2c2c2e;
    border-bottom-color: #38383a;
    margin: -15px -15px 8px -15px;
    padding: 12px 15px;
    border-radius: 12px 12px 0 0;
}
#phone-screen.dark-mode .memory-card .header .date,
#phone-screen.dark-mode .memory-card .header .author,
#phone-screen.dark-mode .memory-card .content {
    color: #e0e0e0;
}

/* 8. 其他设置和列表页 */
#phone-screen.dark-mode #api-settings-screen,
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #wallpaper-screen,
#phone-screen.dark-mode #contact-picker-screen,
#phone-screen.dark-mode #member-management-screen,
#phone-screen.dark-mode #world-book-editor-screen,
#phone-screen.dark-mode #world-book-list,
#phone-screen.dark-mode .list-item:hover,
#phone-screen.dark-mode .list-container,
#phone-screen.dark-mode .form-container {
    background-color: #000000;
}
#phone-screen.dark-mode .form-group input, 
#phone-screen.dark-mode .form-group select, 
#phone-screen.dark-mode .form-group textarea {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
#phone-screen.dark-mode .form-button-secondary {
    background-color: #333;
    border-color: #555;
    color: #fff;
}
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e;
    border-color: #38383a;
}
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块【全新的修正CSS】，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】夜间模式视觉修正 === */

/* 1. 修正动态卡片内的文字颜色 */
#phone-screen.dark-mode .qzone-post-item .post-nickname,
#phone-screen.dark-mode .qzone-post-item .post-content {
    color: #f0f0f0; /* 从深灰色改为明亮的浅灰色 */
}

/* 2. 修正收藏卡片内的文字颜色 */
#phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
#phone-screen.dark-mode .favorite-item-card .fav-card-content {
    color: #f0f0f0; /* 同样改为浅灰色 */
}
#phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
    color: #8d8d92; /* 来源文字用次要灰色 */
}

/* 3. 修正收藏页的搜索栏背景和输入框样式 */
#phone-screen.dark-mode .search-bar-container {
    background-color: #000000; /* 容器背景变为纯黑 */
}
#phone-screen.dark-mode #favorites-search-input {
    background-color: #1c1c1e; /* 输入框背景变为深灰 */
    border-color: #38383a;     /* 边框颜色变暗 */
    color: #ffffff;            /* 输入文字变为白色 */
}
#phone-screen.dark-mode #favorites-search-input::placeholder {
    color: #8d8d92; /* 占位符文字颜色变暗 */
}

/* ▲▲▲ 修正CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】iOS风格的Toggle Switch开关样式 === */

/* 1. 开关的容器 */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 51px;
    height: 31px;
}

/* 2. 隐藏掉原始的 checkbox 输入框 */
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* 3. 开关的背景（那个椭圆） */
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e9e9eb; /* 关闭时的背景色 */
    transition: .4s;
    border-radius: 34px;
}

/* 4. 开关上的圆点 */
.slider:before {
    position: absolute;
    content: "";
    height: 27px;
    width: 27px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* 5. 【核心】当 checkbox 被选中时（即开启状态） */
input:checked + .slider {
    background-color: #34c759; /* 开启时的背景色（iOS绿色）*/
}

input:checked + .slider:before {
    transform: translateX(20px); /* 让圆点滑动到右边 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */

/* === 【全新美化版】回复预览栏样式 === */
#reply-preview-bar {
    display: none; /* 默认隐藏 */
    position: relative;

    /* 毛玻璃气泡核心样式 */
    background: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);

    /* 修改点1：调整边距和圆角，使其成为一个独立的气泡 */
    margin: 0 8px 10px 8px;
    padding: 8px 30px 8px 12px; /* 右侧留出关闭按钮的位置 */
    border-radius: 12px;

    /* 修改点2：移除了旧的 border-left */
    border-left: none;
}

/* 夜间模式适配 */
#phone-screen.dark-mode #reply-preview-bar {
    background: rgba(28, 28, 30, 0.7);
    border-color: rgba(255, 255, 255, 0.2);
}

/* 美化内部文字颜色 */
.reply-preview-content .sender {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 13px;
}

.reply-preview-content .text {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block;
    max-width: 100%;
}

/* 美化关闭按钮 */
#cancel-reply-btn {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.1);
    cursor: pointer;
    font-size: 16px;
    font-weight: 300;
    color: var(--text-secondary);
    transition: background-color 0.2s;
}

#cancel-reply-btn:hover {
    background-color: rgba(0, 0, 0, 0.2);
}

#phone-screen.dark-mode #cancel-reply-btn {
    background-color: rgba(255, 255, 255, 0.15);
    color: var(--text-secondary);
}


/* === 【全新美化版】引用消息气泡样式 (已支持换行) === */
.quoted-message {
    padding: 6px 12px;
    margin-bottom: 8px;
    background-color: rgba(0, 0, 0, 0.04);
    border-left: none;
    border-radius: 10px;
    font-size: 13px;
    color: inherit; /* ★ 核心修改：从固定颜色改为继承父元素颜色 */
    opacity: 0.8;   /* (推荐) 增加一点透明度，让引用文字和主消息有区分度 */

    /* ▼▼▼ 其他样式保持不变 ▼▼▼ */
    white-space: pre-wrap;
    overflow: visible;
    text-overflow: clip;
    word-break: break-word;
    display: block;
}

/* 夜间模式适配 */
#phone-screen.dark-mode .quoted-message {
    background-color: rgba(255, 255, 255, 0.08); /* 夜间模式下更亮的背景 */
    border-left: none; /* 同样移除竖线 */
}

/* 引用消息中的发送者名字加粗 */
.quoted-message .quoted-sender-name {
    font-weight: 500;
}

/* === 字体预览框样式 (修正后) === */

/* 默认（日间模式）的样式 */
#font-preview {
    padding: 20px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f9f9f9; /* 日间模式的浅灰色背景 */
    transition: background-color 0.3s, border-color 0.3s;
}

/* 预览框里的文字颜色，默认是黑色 */
#font-preview p {
    color: var(--text-primary);
}

/* 夜间模式下的修正样式 */
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e; /* 深灰色背景 */
    border-color: #38383a;     /* 暗色边框 */
}

/* 夜间模式下，预览框里的文字变为白色 */
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
.transfer-actions-content {
    background-color: #ffffff; /* 粉嫩的背景色 */
    border-radius: 20px;
    width: 290px;
    padding: 20px;
    box-shadow: 0 5px 25px rgba(68, 73, 92, 0.3); /* 粉色阴影 */
    text-align: center;
    position: relative;
    border: 1px solid #fafafa;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.transfer-actions-header {
    font-size: 20px;
    font-weight: bold;
    color: #1E1E1E; /* 深粉色标题 */
    margin-bottom: 15px;
}

.transfer-actions-body p {
    font-size: 15px;
    color: #555;
    margin: 0 0 25px 0;
    line-height: 1.5;
}

.transfer-actions-footer {
    display: flex;
    justify-content: space-between;
    gap: 15px;
}

.transfer-actions-footer .action-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    color: white;
}

.transfer-actions-footer .action-btn:active {
    transform: scale(0.95);
}

.transfer-actions-footer .action-btn.accept {
    background: linear-gradient(135deg, #1E1E1E, #1E1E1E);
    box-shadow: 0 4px 10px #F7F7F7;
}

.transfer-actions-footer .action-btn.decline {
    background: #F7F7F7;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.transfer-actions-content .cancel-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: #1E1E1E;
    font-size: 20px;
    line-height: 28px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息红点样式 === */
.unread-count-wrapper {
    flex-shrink: 0;
    width: 40px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px; /* 让红点和名字差不多高 */
}

.unread-count {
        position: relative; /* 新增：开启相对定位，为移动做准备 */
        left: 4px; /* 新增：向右移动5px */
        min-width: 20px;
        height: 20px;
        padding: 0 6px;
        background-color: #AB4D3F; /* iOS 风格的红色 */
        color: white;
        font-size: 13px;
        font-weight: 500;
        line-height: 20px;
        text-align: center;
        border-radius: 10px; /* 圆角矩形 */
        box-shadow: 0 1px 2px rgba(0,0,0,0.15);
        display: none; /* 默认隐藏 */
        justify-content: center;
        align-items: center;
    }
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */

/* 确保页面背景色统一 */
#call-history-screen {
    background-color: #F7F7F7;
}

/* 通话记录卡片样式 */
.call-record-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
   
}
.call-record-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 卡片头部：包含日期和时长 */
.call-record-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.call-record-card .card-header .duration {
    font-weight: 500;
    color: var(--text-primary);
}

/* 卡片主体：参与者头像 */
.call-record-card .card-body {
    display: flex;
    align-items: center;
}
.call-record-card .participants-avatars {
    display: flex;
    align-items: center;
}
.call-record-card .participant-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* 让头像有一个漂亮的堆叠效果 */
.call-record-card .participant-avatar:not(:first-child) {
    margin-left: -12px;
}
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
}

/* --- 通话详情弹窗样式 --- */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 15px;
}
.transcript-entry {
    padding: 8px 12px;
    border-radius: 10px;
    max-width: 85%;
    line-height: 1.5;
    word-break: break-word;
}
.transcript-entry.user {
    background-color: #dcf8c6; /* 类似微信的绿色 */
    align-self: flex-end;
}
.transcript-entry.assistant {
    background-color: #ffffff;
    align-self: flex-start;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

#chat-list-title {
    cursor: pointer;
}

/* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */

.call-record-card .card-body {
    /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 标题和参与者信息之间的间距 */
}

.call-record-card .custom-title {
    font-size: 16px;
    font-weight: 600; /* 加粗，让它像个标题 */
    color: var(--text-primary);
    padding-bottom: 8px; /* 标题下的留白 */
    border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
    margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
}

.call-record-card .participants-info {
    /* 这个新容器让头像和“与xx”能水平对齐 */
    display: flex;
    align-items: center;
}

/* 参与者名字的样式微调，让它不那么突出 */
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 500; /* 不再加粗 */
    font-size: 14px; /* 稍微小一点 */
    color: var(--text-secondary); /* 使用次要文字颜色 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */

/* 1. 语音文字内容的样式 (已修复移动端显示BUG) */
.voice-transcript ,
.translation-text {
    /* ▼▼▼ 核心修改：移除绝对定位，让其回归文档流 ▼▼▼ */
    /* position: absolute;  <-- 已删除 */
    /* top: 100%;           <-- 已删除 */
    /* left: 0;             <-- 已删除 */
    /* ▲▲▲ 修改结束 ▲▲▲ */
    width: 100%; /* 新增：让其宽度与父容器对齐 */
    max-width: 260px;
    box-sizing: border-box;

    font-size: 14px;
    line-height: 1.6;
    color: var(--text-secondary);
    padding: 5px 8px;
    margin-top: 6px;
    background-color: rgba(255, 255, 255, 0.4);
    border-radius: 6px;
    word-break: break-word;
    display: none;
}

/* ▼▼▼ 【全新添加】语音与翻译消息内部布局修正 ▼▼▼ */

/* 1. 将语音和翻译消息的内容区都变为垂直弹性布局 */
.message-bubble.is-voice-message .content,
.message-bubble.is-translation .content { /* <-- 新增了这一行 */
    display: flex;
    flex-direction: column;
}

/* 2. 【核心】让用户的语音和翻译消息内容都靠右对齐 */
.message-bubble.user.is-voice-message .content,
.message-bubble.user.is-translation .content { /* <-- 新增了这一行 */
    align-items: flex-end;
}

/* 3. 让AI的语音和翻译消息内容都靠左对齐，保持一致性 */
.message-bubble.ai.is-voice-message .content,
.message-bubble.ai.is-translation .content { /* <-- 新增了这一行 */
    align-items: flex-start;
}
/* ▲▲▲ 新增代码粘贴结束 ▲▲▲ */


/* 2. 旋转加载动画的样式 */
.loading-spinner {
    display: none; /* 默认隐藏 */
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color); /* 旋转部分的颜色 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 8px; /* 和波形图、时长保持一点间距 */
}

/* 3. 定义旋转动画 */
@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
#shared-history-viewer-content {
    display: flex;
    flex-direction: column; /* 让气泡垂直排列 */
    gap: 20px; /* 在每个气泡之间增加20像素的间距 */
    padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
#music-player-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 230px;
    background-color: rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-50px);
    transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

#music-player-overlay.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.music-player-window { 
    width: 70%; 
    min-height: 420px;
    background-color: rgba(255, 255, 255, 0.6); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    border-radius: 25px; 
    box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
    border: 1px solid rgba(255, 255, 255, 0.18); 
    padding: 25px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    color: #1f1f1f; 
    position: relative;
    justify-content: space-between;
    padding-bottom: 15px;
}

.music-player-top-actions {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    width: calc(100% - 30px);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.top-left-cluster {
    display: flex;
    align-items: center;
    gap: 15px;
}
#music-return-btn, #music-exit-btn {
    background: none;
    border: none;
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
}
#music-exit-btn {
    font-size: 24px;
    font-weight: 400;
}

.music-progress-bar-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 25px;
    margin-bottom: 10px;
}
.time-display {
    font-size: 11px;
    color: #888;
    width: 35px;
    text-align: center;
    flex-shrink: 0;
    font-family: 'SF Mono', 'Menlo', monospace;
}
.progress-bar {
    flex-grow: 1;
    height: 5px;
    background-color: #e5e5e5;
    border-radius: 2.5px;
    cursor: pointer;
}
.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #333;
    border-radius: 2.5px;
}

#music-lyrics-container {
    width: 100%;
    height: 192px;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
}

#music-lyrics-list {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    text-align: center;
    line-height: 1.5;
    transition: all 0.5s ease;
    opacity: 0.7;
    transform: scale(0.95);
}

.lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    transform: scale(1);
}

.music-player-controls-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.music-controls {
    margin-top: 0;
}

#music-return-btn, #music-exit-btn, #music-playlist-btn {
    position: relative;
}

#music-return-btn { top: -2px; }
#music-playlist-btn { top: -3px; }

.playlist-item-actions {
    display: flex;
    align-items: center;
    gap: 12px;
}
.playlist-action-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    cursor: pointer;
    transition: color 0.2s, transform 0.2s;
    padding: 0;
    background: none;
    border: none;
}
.playlist-action-btn:hover {
    color: #000;
    transform: scale(1.1);
}
.playlist-action-btn svg {
    width: 18px;
    height: 18px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
}
.lyrics-btn {
    color: #888;
}
.lyrics-btn:hover {
    color: #000;
}
.share-btn {
    color: #888;
}
.share-btn:hover {
    color: #000;
}
.delete-track-btn {
    font-size: 24px;
    color: #AB4D3F;
    width: auto;
    height: auto;
}
.delete-track-btn:hover { color: #c00; }

/* --- 【核心修正】确保头像尺寸 --- */
.message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 20%;
    object-fit: cover;
    flex-shrink: 0; /* 防止被压缩 */
}

/* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

/* 1. 撤回消息的占位符样式 */
.recalled-message-placeholder {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
    cursor: pointer; /* 让它看起来可以点击 */
}

/* 2. 夜间模式下的适配 */
#phone-screen.dark-mode .recalled-message-placeholder {
    background-color: rgba(255, 255, 255, 0.15);
}

/* 3. AI撤回消息时的动画效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.message-wrapper.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */

/* 强制撤回消息的占位符不换行，并保持内容居中 */
.recalled-message-placeholder {
    white-space: nowrap; /* 核心：禁止文本换行 */
    display: inline-block; /* 让背景根据内容自适应宽度 */
    padding: 4px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
.world-book-group-container {
    margin-bottom: 12px;
}
.world-book-group-container:first-child {
    margin-top: 0;
}
.world-book-group-container:last-child {
    margin-bottom: 0;
}
.world-book-group-header {
    display: flex;
    align-items: center;
    cursor: pointer;
    background: transparent !important;
    margin: 0;
}
.world-book-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}
.world-book-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.world-book-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}
.world-book-group-content {
    max-height: 50000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.world-book-group-content.collapsed {
    max-height: 0;
}
#phone-screen.dark-mode .world-book-group-header {
    background-color: #1c1c1e;
}

/* ▼▼▼ 【新增】设定集一级分类头部样式 ▼▼▼ */
.setting-collection-header-wrapper {
    background-color: #f5f5f5;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    padding: 12px 16px;
    margin-bottom: 16px;
    display: flex;
    justify-content: center;
}

#phone-screen.dark-mode .setting-collection-header-wrapper {
    background-color: #2a2a2a;
    border-color: #404040;
}

.setting-collection-header {
    background: transparent !important;
    justify-content: center;
    width: 100%;
}

/* ▼▼▼ 【新增】设定集二级分类样式 ▼▼▼ */
.world-book-subgroup-container {
    margin-bottom: 8px;
}

.world-book-subgroup-header {
    display: flex;
    align-items: center;
    cursor: pointer;
    background: transparent !important;
    margin: 0;
    font-weight: 600;
    font-size: 15px;
}

.world-book-subgroup-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.world-book-subgroup-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.world-book-subgroup-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.world-book-subgroup-content {
    max-height: 50000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.world-book-subgroup-content.collapsed {
    max-height: 0;
}

#phone-screen.dark-mode .world-book-subgroup-header {
    background-color: #1c1c1e;
}
/* ▲▲▲ 设定集分类样式结束 ▲▲▲ */

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包/转账模态框页签样式 ▼▼▼ */
.frame-tabs {
    display: flex;
    background-color: #f0f0f0;
    padding: 4px;
    margin: 15px;
    border-radius: 8px;
}
.frame-tab {
    flex: 1;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #555;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}
.frame-tab.active {
    background-color: #ffffff;
    color: #000000;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段全新的CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 分类文件夹的样式 */
.wb-category-header {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    cursor: pointer;
    background-color: #ffffff; /* 纯白色背景 */
    font-weight: 600; /* 加粗字体 */
}
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e; /* 夜间模式下的背景色 */
}

/* 【新增】有勾选项目的分类标题显示淡灰色背景 */
.wb-category-header.has-checked-items {
  background-color: #f5f5f5;
  transition: background-color 0.2s ease;
}

#phone-screen.dark-mode .wb-category-header.has-checked-items {
    background-color: #3a3a3c;
}


/* 2. 展开/收起的小箭头 */
.wb-category-header .arrow {
    font-size: 12px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

/* 3. 当文件夹收起时，箭头旋转 */
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 4. 存放书籍条目的容器 */
.wb-book-container {
    padding-left: 0px; /* 修改：去掉左侧缩进，消除空白 */
    max-height: 10000px; /* 改为足够大的值，能显示所有世界书 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

/* 5. 当文件夹收起时，书籍容器的高度变为0，实现动画效果 */
.wb-book-container.collapsed {
    max-height: 0;
}

/* 6. 单个书籍条目（覆盖默认的label样式，微调间距） */
.wb-book-container label {
    display: flex !important; /* 修复：改用flexbox布局确保元素在同一行 */
    align-items: center !important;
    gap: 0px !important; /* 修改：去掉gap，因为不再有勾选框 */
    padding: 8px 12px !important;
    cursor: pointer;
    width: 100%;
    box-sizing: border-box;
    flex-wrap: nowrap !important; /* 核心：强制不换行 */
    background-color: #ffffff; /* 默认白色背景 */
    transition: background-color 0.2s ease; /* 添加背景色过渡动画 */
    margin: 0 !important; /* 去掉外边距 */
}

/* 书籍名称不换行 */
.wb-book-container label span {
    white-space: nowrap !important;
    overflow: hidden !important; /* 确保溢出隐藏 */
    text-overflow: ellipsis !important; /* 确保溢出显示省略号 */
    flex: 1 1 auto; /* 修复：在flex布局中占据剩余空间并可以缩放 */
    min-width: 0; /* 关键：允许元素在flex布局中被压缩 */
    line-height: normal !important;
    margin: 0 !important;
    padding: 0 !important;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px;
}

/* 勾选后的背景色样式 */
.wb-book-container label.checked {
    background-color: #F7F7F7 !important;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书关联选择器 - 视觉优化 ▼▼▼ */

/* 1. 让分类标题更突出 */
.wb-category-header > span:last-of-type {
    font-size: 14px;
    font-weight: 700; /* 加粗 */
    color: var(--text-primary);
}

/* 彩色箭头已移除，统一使用黑色箭头 */

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */


/* --- 请将这段全新的CSS粘贴到<style>标签末尾，并删除上次为时间戳添加的旧CSS --- */

/* 1. 将时间戳通过“绝对定位”固定在右上角 */
.chat-list-item .time {
    position: absolute;
    top: 12px;  /* 与顶部的距离，使其和名字差不多高 */
    right: 15px; /* 与右侧的距离，和列表的边距一致 */
    font-size: 12px;
    color: var(--text-secondary);
}

/* 2. 给中间的信息区域增加右边距，防止名字或消息过长时，与时间戳重叠 */
.chat-list-item .info {
    padding-right: 50px;
}

/* 3. 确保名字过长时能显示省略号 */
.chat-list-item .name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* ▼▼▼ 在这里粘贴日记和心声的CSS样式 ▼▼▼ */

/* === 日记卡片样式 === */

/* ▼▼▼ 左滑置顶功能样式 ▼▼▼ */
.chat-list-item {
    overflow: hidden;
}

.chat-list-item .swipe-actions {
    position: absolute;
    top: 0;
    right: -80px;
    width: 80px;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: transparent;
    transition: right 0.3s ease;
    z-index: 5;
}

.chat-list-item.swiped .swipe-actions {
    right: 0;
}

.pin-btn {
    background-color: #1E1E1E;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 10px 12px;
    font-size: 13px;
    width: 78px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
}

.pin-btn:hover {
    background-color: #2a2a2a;
}

.pin-btn:active {
    transform: scale(0.95);
}

/* 暗色模式适配 */
#phone-screen.dark-mode .chat-list-item .swipe-actions {
    background-color: transparent;
}

#phone-screen.dark-mode .pin-btn {
    background-color: #1E1E1E;
    color: #ffffff;
}

#phone-screen.dark-mode .pin-btn:hover {
    background-color: #2a2a2a;
}

/* 置顶聊天样式 */
.chat-list-item.pinned {
    background-color: #F7F7F7;
}

.chat-list-item.pinned:hover {
    background-color: #f0f0f0;
}

.chat-list-item.pinned .swipe-actions {
    background-color: transparent;
}

#phone-screen.dark-mode .chat-list-item.pinned {
    background-color: #2c2c2e;
}

#phone-screen.dark-mode .chat-list-item.pinned:hover {
    background-color: #2c2c2e;
}

#phone-screen.dark-mode .chat-list-item.pinned .swipe-actions {
    background-color: transparent;
}

/* ▼▼▼ 在这里粘贴新按钮的CSS ▼▼▼ */
.diary-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border-left: none; /* 去掉左侧边框 */
}
#phone-screen.dark-mode .diary-card {
    background-color: #1c1c1e;
    border-left-color: #E6A753;
}

.diary-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.diary-card .card-header .actions button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    padding: 5px;
}

.diary-card .card-body {
    font-size: 14px;
    line-height: 1.7;
    color: var(--text-primary);
    white-space: pre-wrap;
}

/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
/* === 日记页面背景色 === */
#diary-screen, #diary-list {
    background-color: #ffffff;
}
#phone-screen.dark-mode #diary-screen,
#phone-screen.dark-mode #diary-list {
    background-color: #1c1c1e; /* 夜间模式用深灰色背景 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▲▲▲ CSS样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的末尾 ▼▼▼ */

/* === 【全新】群聊心声弹窗样式 === */
#group-status-list {
    display: flex;
    flex-direction: column;
    gap: 18px; /* 每个成员之间的间距 */
}

.group-status-item {
    display: flex;
    align-items: flex-start; /* 头像和文字顶部对齐 */
    gap: 12px;
    padding-bottom: 18px;
    border-bottom: 1px solid var(--border-color);
}
#group-status-list .group-status-item:last-child {
    border-bottom: none; /* 最后一个不显示下边框 */
}
#phone-screen.dark-mode .group-status-item {
    border-bottom-color: #38383a;
}

.group-status-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0; /* 防止头像被压缩 */
}

.group-status-item .content-wrapper {
    display: flex;
    flex-direction: column;
}

.group-status-item .name {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
    margin-bottom: 5px;
}

.group-status-item .thought {
    font-size: 14px;
    line-height: 1.6;
    color: var(--text-secondary);
    white-space: pre-wrap; /* 保留换行符 */
    margin: 0; /* 移除 p 标签的默认边距 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】论坛功能样式 ▼▼▼ */

#forum-screen {
    background-color: #F7F7F7;
}
#phone-screen.dark-mode #forum-screen {
    background-color: #000000;
}

#forum-posts-container {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.forum-placeholder {
    text-align: center;
    color: var(--text-secondary);
    padding: 80px 20px;
    font-size: 15px;
    line-height: 1.8;
}

.forum-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}
#phone-screen.dark-mode .forum-post-item {
    background-color: #1c1c1e;
    border: 1px solid #333;
}

.forum-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}
.forum-post-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}
.forum-post-header .name {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.forum-post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
    margin-bottom: 15px;
}
#phone-screen.dark-mode .forum-post-content {
    color: #f0f0f0;
}

.forum-post-footer {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 15px;
    font-size: 13px;
    color: var(--text-secondary);
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
}
#phone-screen.dark-mode .forum-post-footer {
    border-top-color: #38383a;
}
.footer-action {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
}
.footer-action svg {
    width: 18px;
    height: 18px;
}
.footer-action.liked {
    color: #ff5252;
}
.footer-action.liked svg {
    fill: #ff5252;
}
.footer-action.forward-btn {
    align-items: center;
}
.footer-action.forward-btn svg {
    width: 22px;
    height: 22px;
    margin-top: -3px;
}

.forum-comments-section {
    margin-top: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
}
#phone-screen.dark-mode .forum-comments-section {
    background-color: #2c2c2e;
}

.forum-comment-item {
    font-size: 13px;
    line-height: 1.5;
    padding: 8px 0;
    border-bottom: 1px solid #e9e9e9;
}
#phone-screen.dark-mode .forum-comment-item {
    border-bottom-color: #38383a;
}
.forum-comment-item:last-child {
    border-bottom: none;
}
.forum-comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    margin-right: 5px;
}
.forum-comment-item .comment-text {
    color: var(--text-primary);
}

.forum-comment-input-area {
    display: flex;
    gap: 8px;
    margin-top: 12px;
}
.forum-comment-input-area input {
    flex-grow: 1;
    border: 1px solid var(--border-color);
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
    background-color: var(--secondary-bg);
}
#phone-screen.dark-mode .forum-comment-input-area input {
    background-color: #3a3a3c;
    border-color: #545458;
    color: #ffffff;
}
.forum-comment-input-area button {
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 15px;
    padding: 0 15px;
    font-size: 13px;
    cursor: pointer;
}

#forum-character-selector .forum-char-item {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    gap: 15px;
    margin: 4px 0;
    border-radius: 12px;
    transition: background-color 0.2s ease;
}
#forum-character-selector .forum-char-item:hover {
    background-color: #f0f0f0;
}
#forum-character-selector .forum-char-item.selected {
    background-color: #6B6B6B;
    margin: 4px 0;
}
#forum-character-selector .forum-char-item.selected:hover {
    background-color: #5A5A5A;
}
#forum-character-selector .forum-char-item.selected .forum-char-name {
    color: white;
}
.forum-char-avatar {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}
.forum-char-name {
    font-size: 14px;
    line-height: 1.4;
}
#forum-worldbook-selector .forum-wb-item {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    margin: 4px 0;
    border-radius: 12px;
    transition: background-color 0.2s ease;
}
#forum-worldbook-selector .forum-wb-item:hover {
    background-color: #f0f0f0;
}
#forum-worldbook-selector .forum-wb-item.selected {
    background-color: #6B6B6B;
    margin: 4px 0;
}
#forum-worldbook-selector .forum-wb-item.selected:hover {
    background-color: #5A5A5A;
}
#forum-worldbook-selector .forum-wb-item.selected .forum-wb-name {
    color: white;
}
.forum-wb-name {
    font-size: 14px;
    line-height: 1.4;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】论坛AI回复等待动画 ▼▼▼ */
.ai-reply-loader {
    font-size: 13px;
    color: var(--text-secondary);
    padding: 10px 0;
    text-align: left;
    margin-left: 10px; /* 让它和评论稍微对齐 */
}
.ai-reply-loader span {
    animation: blink 1.4s infinite both;
}
.ai-reply-loader span:nth-child(2) {
    animation-delay: 0.2s;
}
.ai-reply-loader span:nth-child(3) {
    animation-delay: 0.4s;
}
@keyframes blink {
    0%, 80%, 100% { opacity: 0; }
    40% { opacity: 1; }
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */


/* ▼▼▼ 【强力修正】限制动态、论坛和聊天内容里的图片最大宽度 ▼▼▼ */
.qzone-post-item .chat-image,
.forum-post-item .chat-image,
.favorite-item-card .chat-image,
#chat-messages .message-bubble .chat-image {
    max-width: 200px !important; /* 你可以随意调整这个数值 */
    width: auto !important;      /* 确保宽度自适应 */
    height: auto !important;     /* 保持图片原始的宽高比 */
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的CSS，粘贴到 <style> 标签的末尾 ▼▼▼ */

/* === 【核心】修正主输入行布局 === */
#chat-input-main-row {
    align-items: flex-end; /* 保持所有元素底部对齐 */
}

#chat-input-main-row .chat-action-icon-btn {
    width: 40px;  /* 统一左右按钮大小 */
    height: 40px;
    flex-shrink: 0; /* 防止按钮被压缩 */
}

/* === 【核心】移除旧的顶部按钮栏 === */
#chat-input-actions-top {
    display: none !important; /* 强制隐藏，不再需要 */
}

/* ▼▼▼ 请用这段【新代码】替换旧的 #chat-plus-panel 和 #plus-panel-grid 样式 ▼▼▼ */

/* === 【全新】加号功能面板样式 (已修改为类选择器) === */
.chat-plus-panel {
    max-height: 0; /* 默认收起 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
    padding: 0 15px; /* 收起时没有上下内边距 */
    box-sizing: border-box;
    display: none; /* 【核心修改】默认不显示，由JS控制 */
    position: relative; /* 确保定位正确 */
    z-index: 1; /* 确保在合适的层级 */
}
.chat-plus-panel.visible {
    display: block; /* 【核心修改】激活时设为block，让动画生效 */
    max-height: 300px; /* 展开时给一个足够大的高度 */
    padding: 20px 15px; /* 展开时增加上下内边距 */
}

/* 当面板展开时，聊天消息区域的调整 */
#chat-interface-screen.panel-expanded #chat-messages {
    /* 核心修改：让聊天记录底部“弹起”的高度，大致等于功能面板的高度 */
    /* 这个值可以根据你的面板实际高度微调，240px 是一个比较好的初始值 */
    padding-bottom: 240px; 
}

/* === 【全新】功能面板内网格布局 (已修改为类选择器) === */
.plus-panel-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 每行4个 */
    gap: 25px 15px; /* 上下间距25px，左右间距15px */
    justify-items: center; /* 水平居中 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* === 【全新】网格内单个功能项样式 === */
.plus-panel-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 图标和文字的间距 */
}

.plus-panel-icon-bg {
    width: 58px;
    height: 58px;
    background-color: #FFFFFF;
    border-radius: 12px;
    border: 1px solid rgba(0,0,0,0.05);
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s;
    color: var(--text-primary);
}
.plus-panel-icon-bg:active {
    background-color: #f0f0f0;
}
.plus-panel-icon-bg svg {
    width: 28px;
    height: 28px;
    stroke: var(--text-primary); /* 让SVG颜色跟随主题 */
}
.plus-panel-icon-bg {
    font-size: 24px; /* 为“转账”按钮的“￥”设置大小 */
}

.plus-panel-label {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 滑动容器样式 */
.plus-panel-container {
    overflow: hidden;
    width: 100%;
}

.plus-panel-pages {
    display: flex;
    width: 200%;
    transition: transform 0.3s ease;
}

.plus-panel-page {
    width: 50%;
    flex-shrink: 0;
}

.plus-panel-page:not(.active) {
    pointer-events: none; /* 禁用非活动页面的交互 */
}

/* 第二页的空页面样式 */
.empty-page {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 120px;
}

.empty-placeholder {
    color: #999;
    font-size: 14px;
    text-align: center;
}

/* 分页指示器样式 */
.plus-panel-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
    padding-bottom: 10px;
}

.pagination-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: #D0D0D0; /* 浅灰色 - 未选择状态 */
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.pagination-dot.active {
    background-color: #808080; /* 深灰色 - 当前页面状态 */
}

/* ▼▼▼ 请用这段【新代码】替换旧的 “发送按钮与加号按钮的切换逻辑” 样式 ▼▼▼ */

/* === 【全新】右侧常驻按钮显示样式 === */
#open-sticker-panel-btn,
#chat-plus-btn,
#wait-reply-btn {
    display: flex; /* 确保这些图标按钮总是可见并居中 */
}
#send-btn {
    display: block; /* 确保发送按钮总是可见 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 请将这段新样式添加到 <style> 标签内 ▼▼▼ */

/* 强制隐藏“发送”按钮，但保留其功能，让回车键可以继续使用 */
#send-btn {
    display: none !important;
}

/* ▲▲▲ 新样式添加结束 ▲▲▲ */

/* ▼▼▼ 请将这段【新代码】粘贴到 <style> 的末尾 ▼▼▼ */

/* 【最终强力修正版】强制统一聊天界面右上角所有操作按钮和内部图标的尺寸与对齐 */
.header .header-actions .action-btn {
    width: 35px !important;      /* 强制宽度 */
    
    padding: 0 !important;       /* 移除内边距对尺寸的影响 */
    box-sizing: border-box !important; /* 统一盒子模型计算方式 */
}

.header .header-actions .action-btn svg,
.header .header-actions .action-btn img {
    width: 24px !important;      /* 强制图标宽度 */
    height: 24px !important;     /* 强制图标高度 */
    vertical-align: middle !important; /* 【关键】强制所有图标垂直居中对齐 */
}

/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段【新代码】粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】气泡预设功能区样式 === */
#bubble-presets-list {
    display: flex;
    flex-direction: column;
    gap: 8px; /* 预设条目之间的间距 */
    max-height: 120px; /* 给一个最大高度，超出则滚动 */
    overflow-y: auto;
}

.bubble-preset-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background-color: var(--secondary-bg);
    border-radius: 6px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.bubble-preset-item .preset-name {
    font-weight: 500;
    color: var(--text-primary);
}

/* === 【全新修正】气泡预设 - 图标按钮样式 === */

/* 1. 【核心修复】让按钮容器（preset-actions）横向排列内部的按钮 */
.bubble-preset-item .preset-actions {
    display: flex;
    align-items: center;
    gap: 8px; /* 使用 gap 来设置按钮之间的间距，比 margin 更现代 */
}

/* 2. 统一设置两个按钮的圆形基础样式 (移除了 margin-left) */
.bubble-preset-item .preset-actions button {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #1E1E1E;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease, opacity 0.2s ease;
    font-size: 0;
    color: transparent;
    padding: 0;
    background-repeat: no-repeat;
    background-position: center;
    background-size: 60%;
}

/* 3. 鼠标悬浮时给一点反馈 (不变) */
.bubble-preset-item .preset-actions button:hover {
    opacity: 0.8;
    transform: scale(1.1);
}

/* 4. 为“应用”按钮设置“对勾”SVG图标 (不变) */
.bubble-preset-item .preset-actions .apply-btn {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3E%3C/svg%3E");
}

/* 5. 为“删除”按钮设置“X”SVG图标 (不变) */
.bubble-preset-item .preset-actions .delete-btn {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/%3E%3C/svg%3E");
}
/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
/* 6. 【全新】为“编辑”按钮设置“铅笔”SVG图标 */
.bubble-preset-item .preset-actions .edit-btn {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z'/%3E%3C/svg%3E");
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
.preset-placeholder {
    text-align: center;
    color: var(--text-secondary);
    font-size: 14px;
    margin: 10px 0;
}

/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】约定绑定角色功能样式 ▼▼▼ */

/* 1. 绑定按钮的样式 */
.bind-char-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 32px;
    height: 32px;
    background-color: #FFFFFF;
    border: 1px solid #EAEAEA;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}
.bind-char-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
}
.bind-char-btn svg {
    width: 18px;
    height: 18px;
    fill: #1E1E1E;
}

/* 2. 绑定模态框的网格布局 */
#bind-character-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    padding: 10px;
}

/* 3. 单个角色选项的样式 */
.bind-char-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 10px;
    border-radius: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.bind-char-item .avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
}
.bind-char-item .name {
    font-size: 12px;
    color: var(--text-primary);
    text-align: center;
}

/* 4. 角色被选中时的样式 */
.bind-char-item.selected {
    background-color: #F7F7F7;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ========== 【晴空】API设置页面美化方案开始 ========== */

/* 1. 应用晴空色彩方案到API设置页面 */
#api-settings-screen {
    background-color: #F7F7F7 !important; /* 主背景色 - 带有极微灰度的柔和白 */
}

#api-settings-screen .form-container {
    background-color: #F7F7F7 !important; /* 确保内容背景统一 */
}

/* 2. 输入框美化格式 - 晴空方案 */
#api-settings-screen .form-group input,
#api-settings-screen .form-group textarea,
#wallpaper-screen .form-group input,
#wallpaper-screen .form-group textarea{
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    border-radius: 8px !important; /* 小圆角 */
    padding: 12px 16px !important; /* 内边距 */
    font-size: 16px !important;
    transition: all 0.2s ease-in-out !important;
    box-sizing: border-box !important;
    width: 100% !important; /* 确保宽度正常 */
    display: block !important; /* 确保正常显示 */
    position: relative !important; /* 恢复正常定位 */
    z-index: auto !important; /* 恢复正常层级 */
}

#api-settings-screen .form-group input::placeholder,
#api-settings-screen .form-group textarea::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

#api-settings-screen .form-group input:focus,
#api-settings-screen .form-group textarea:focus {
    outline: none !important;
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

/* 3. 下拉框样式 - 晴空方案 */
#api-settings-screen .form-group select {
    background-color: #FFFFFF !important;
    color: #1E1E1E !important;
    border: 1px solid #DCDCDC !important;
    border-radius: 8px !important;
    padding: 12px 16px !important;
    font-size: 16px !important;
    transition: all 0.2s ease-in-out !important;
    box-sizing: border-box !important;
    width: 100% !important; /* 确保宽度正常 */
    display: block !important; /* 确保正常显示 */
    position: relative !important; /* 恢复正常定位 */
    z-index: auto !important; /* 恢复正常层级 */
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%236B6B6B" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>') !important;
    background-repeat: no-repeat !important;
    background-position: right 16px center !important;
    background-size: 12px !important;
    cursor: pointer !important;
}

#api-settings-screen .form-group select:focus {
    outline: none !important;
    border-color: #1E1E1E !important;
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important;
}

/* 4. 表单分组毛玻璃气泡容器样式 */
#api-settings-screen .form-group,
#wallpaper-screen .form-group {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 20px !important; /* 内边距 */
    margin-bottom: 20px !important;
    min-height: auto !important; /* 高度自适应 */
    height: auto !important; /* 高度自适应 */
    overflow: visible !important; /* 允许内容完全显示 */
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

#api-settings-screen .form-group:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮，去掉缩放避免影响布局 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 5. 标签样式优化 */
#api-settings-screen .form-group label,
#wallpaper-screen .form-group label {
    color: #1E1E1E !important; /* 一级文本色 */
    font-weight: 500 !important;
    margin-bottom: 8px !important;
    display: block !important;
    position: relative !important; /* 确保正常定位 */
    z-index: 1 !important; /* 确保文字在上层显示 */
    line-height: 1.4 !important; /* 增加行高确保文字完整显示 */
}

/* 6. 按钮美化 */
#api-settings-screen .form-button {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
    border: none !important;
    border-radius: 8px !important;
    padding: 12px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

#api-settings-screen .form-button:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 悬浮效果 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 7. 特殊按钮样式 - 让保存预设按钮与拉取模型按钮一致 */
#api-settings-screen #save-api-preset-btn {
    background-color: #1E1E1E !important; /* 与拉取模型按钮保持一致的深色背景 */
    color: #FFFFFF !important;
    border: none !important;
    border-radius: 12px !important;
    padding: 12px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    margin-bottom: 10px !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

#api-settings-screen #save-api-preset-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 悬浮效果 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 8. 开关按钮美化 */
#api-settings-screen input[type="checkbox"] {
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    width: 44px !important;
    height: 24px !important;
    background-color: #DCDCDC !important; /* 关闭状态轨道颜色 */
    border-radius: 24px !important;
    position: relative !important;
    cursor: pointer !important;
    transition: background-color 0.2s ease-in-out !important;
    margin: 0 !important;
}

#api-settings-screen input[type="checkbox"]:before {
    content: '' !important;
    position: absolute !important;
    width: 20px !important;
    height: 20px !important;
    border-radius: 50% !important;
    top: 2px !important;
    left: 2px !important;
    background-color: #FFFFFF !important; /* 滑块颜色 */
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important; /* 微妙立体感 */
    transition: transform 0.2s ease-in-out !important;
}

#api-settings-screen input[type="checkbox"]:checked {
    background-color: #1E1E1E !important; /* 开启状态轨道颜色 */
}

#api-settings-screen input[type="checkbox"]:checked:before {
    transform: translateX(20px) !important; /* 滑块移动 */
}

/* 9. 数字输入框特殊样式 */
#api-settings-screen input[type="number"] {
    text-align: center !important;
    width: 80px !important; /* 固定较小宽度 */
    min-width: 80px !important;
    max-width: 80px !important;
    flex-shrink: 0 !important; /* 防止被压缩 */
    margin-left: auto !important; /* 推到右边 */
}

/* 移除数字输入框的上下调节箭头 */
#api-settings-screen input[type="number"]::-webkit-outer-spin-button,
#api-settings-screen input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none !important;
    margin: 0 !important;
}

#api-settings-screen input[type="number"] {
    -moz-appearance: textfield !important; /* Firefox */
}

/* 为包含数字输入框的表单组优化布局 */
#api-settings-screen .form-group[style*="display: flex"] {
    align-items: flex-start !important; /* 顶部对齐 */
    gap: 15px !important; /* 增加间距 */
}

#api-settings-screen .form-group[style*="display: flex"] label {
    flex: 1 !important; /* 标签占据剩余空间 */
    margin-bottom: 0 !important; /* 移除底部间距 */
}

/* 10. 分割线美化 */
#api-settings-screen hr {
    border: none !important;
    height: 1px !important;
    background-color: rgba(0, 0, 0, 0.1) !important; /* 半透明边框色 */
    margin: 20px 0 !important;
}

/* 11. 提示信息美化 */
#api-settings-screen p,
#wallpaper-screen p {
    color: #6B6B6B !important; /* 二级文本色 */
    font-size: 14px !important;
    line-height: 1.5 !important; /* 增加行高 */
    margin: 5px 0 !important; /* 适当的上下间距 */
    position: relative !important; /* 确保正常定位 */
    z-index: 1 !important; /* 确保文字显示在上层 */
}

/* 12. 代码标签美化 */
#api-settings-screen code {
    background-color: rgba(0, 0, 0, 0.05) !important; /* 极淡的半透明黑色 */
    color: #1E1E1E !important;
    padding: 2px 6px !important;
    border-radius: 4px !important;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace !important;
    display: inline !important; /* 确保正常显示 */
}

/* 13. API预设列表容器美化 */
#api-settings-screen #api-presets-list {
    margin-top: 10px !important;
    position: relative !important;
    z-index: 1 !important;
}

/* 14. 警告文字样式 */
#api-settings-screen p[style*="color: #ff6b6b"] {
    color: #ff6b6b !important;
    font-size: 12px !important;
    line-height: 1.4 !important;
    margin-top: 5px !important;
}

/* 15. 辅助说明文字样式 */
#api-settings-screen p[style*="color: #999"] {
    color: #6B6B6B !important;
    font-size: 12px !important;
    line-height: 1.4 !important;
    margin-top: 5px !important;
}

/* 16. 确保所有文本内容正常显示 */
#api-settings-screen .form-group * {
    position: relative !important;
    z-index: 1 !important;
}

/* ========== 【晴空】API设置页面美化方案结束 ========== */

/* ========== 外观设置页面优化开始 ========== */

/* 1. 调整上传壁纸按钮和夜间模式开关的距离 */
#wallpaper-screen .form-group[style*="display: flex"] {
    margin-top: 30px !important; /* 增加与上方元素的距离 */
    margin-bottom: 20px !important;
}

/* 2. 夜间模式开关按钮样式 - 完整的开关样式 */
#wallpaper-screen .toggle-switch {
    position: relative !important;
    display: inline-block !important;
    width: 44px !important;  /* 宽度 */
    height: 24px !important; /* 高度 */
}

/* 隐藏原生的checkbox */
#wallpaper-screen .toggle-switch input {
    opacity: 0 !important;
    width: 0 !important;
    height: 0 !important;
}

/* 轨道样式 */
#wallpaper-screen .toggle-switch .slider {
    position: absolute !important;
    cursor: pointer !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    background-color: #DCDCDC !important; /* 关闭状态的轨道颜色 */
    border-radius: 24px !important; /* 使其变为圆角矩形 */
    transition: background-color 0.2s ease-in-out !important;
}

/* 滑块样式 (使用::before伪元素创建) */
#wallpaper-screen .toggle-switch .slider::before {
    position: absolute !important;
    content: "" !important;
    height: 20px !important; /* 滑块直径 */
    width: 20px !important;  /* 滑块直径 */
    left: 2px !important;    /* 初始位置 */
    bottom: 2px !important;  /* 初始位置 */
    background-color: #FFFFFF !important; /* 滑块颜色 */
    border-radius: 50% !important; /* 使其变为圆形 */
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important; /* 微妙的立体感阴影 */
    transition: transform 0.2s ease-in-out !important;
}

/* --- 核心交互逻辑 --- */
/* 当checkbox被选中时，改变轨道的背景色 */
#wallpaper-screen .toggle-switch input:checked + .slider {
    background-color: #1E1E1E !important; /* 开启状态的轨道颜色 */
}

/* 当checkbox被选中时，移动滑块 */
#wallpaper-screen .toggle-switch input:checked + .slider::before {
    transform: translateX(20px) !important; /* 滑块移动距离 = 轨道宽度 - 滑块宽度 - (左边距*2) */
}

/* 3. 优化夜间模式标签样式 */
#wallpaper-screen .form-group[style*="display: flex"] label[for="theme-toggle-switch"] {
    color: var(--text-primary) !important;
    font-weight: 500 !important;
    flex: 1 !important;
}

/* ========== 外观设置页面优化结束 ========== */

/* ========== 【晴空】转账卡片美化开始 ========== */

/* 1. 转账卡片主体美化 - 毛玻璃气泡效果 */
.transfer-card {
    width: 200px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 20px !important; /* 增加内边距 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    position: relative !important;
    overflow: hidden !important; /* 防溢出处理 */
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

/* 2. 悬浮效果 */
.transfer-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 3. 移除原有背景样式 */
.message-bubble.user .transfer-card,
.message-bubble.ai .transfer-card {
    background: rgba(255, 255, 255, 0.7) !important;
}

/* 4. 转账标题样式 */
.transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    margin-bottom: 12px !important;
    text-shadow: none !important;
}

/* 5. 转账金额样式 */
.transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    text-shadow: none !important;
}

/* 6. 转账备注样式 */
.transfer-note {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    opacity: 1 !important; /* 重置透明度 */
    border-top: 1px solid rgba(0, 0, 0, 0.1) !important; /* 半透明边框色 */
    padding-top: 8px !important;
    margin-top: 8px !important;
    word-break: break-all !important;
    text-shadow: none !important;
}

/* 7. 移除原有装饰图标 */
.transfer-card::before {
    display: none !important; /* 移除原有的🐾图标 */
}

/* 8. 添加新的装饰元素 - 更简洁的设计 */
.transfer-card::after {
   
    position: absolute !important;
    right: 15px !important;
    top: 15px !important;
    font-size: 20px !important;
    opacity: 0.3 !important;
}

/* 9. 强制覆盖聊天消息中的样式 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important;
}

#chat-messages .transfer-card .transfer-title {
    color: #1E1E1E !important;
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    color: #1E1E1E !important;
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    color: #6B6B6B !important;
    font-size: 13px !important;
    opacity: 1 !important;
}

/* ========== 【晴空】转账卡片美化结束 ========== */

/* ========== 【晴空】礼物卡片美化开始 ========== */

/* 1. 礼物卡片主体美化 - 毛玻璃气泡效果 */
.gift-card {
    width: 200px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 白色半透明背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和灰色阴影 */
    padding: 20px !important; /* 增加内边距 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    position: relative !important;
    overflow: hidden !important;
}

/* 2. 悬浮效果 */
.gift-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.15) !important;
}

/* 3. 消息气泡样式统一 */
.message-bubble.user .gift-card,
.message-bubble.ai .gift-card {
    background: rgba(255, 255, 255, 0.7) !important;
}

/* 4. 礼物标题样式 */
.gift-title {
    font-size: 16px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    margin-bottom: 12px !important;
}

/* 5. 礼物名称样式 */
.gift-name {
    font-size: 20px !important;
    font-weight: bold !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    text-align: center !important;
}

/* 6. 礼物价格样式 */
.gift-price {
    font-size: 16px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    text-align: center !important;
    font-weight: 500 !important;
}

/* 7. 强制覆盖聊天消息中的样式 */
#chat-messages .gift-card .gift-title,
#chat-messages .gift-card .gift-name,
#chat-messages .gift-card .gift-price {
    text-shadow: none !important;
}

#chat-messages .gift-card .gift-title {
    color: #1E1E1E !important;
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .gift-card .gift-name {
    color: #1E1E1E !important;
    font-size: 20px !important;
    font-weight: bold !important;
}

#chat-messages .gift-card .gift-price {
    color: #6B6B6B !important;
    font-size: 16px !important;
    font-weight: 500 !important;
}

/* 8. 礼物消息气泡背景透明化 */
.message-bubble.is-gift .content { 
    padding: 0 !important; 
    background: transparent !important; 
    box-shadow: none !important; 
    border: none !important; 
    backdrop-filter: none !important; 
    -webkit-backdrop-filter: none !important; 
}

/* 9. 礼物状态文本样式 */
.gift-status {
    text-align: center !important;
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-top: 12px !important;
    padding-top: 8px !important;
    border-top: 1px solid rgba(0, 0, 0, 0.1) !important;
}

/* 10. 礼物操作按钮样式 */
.gift-actions {
    display: flex !important;
    gap: 12px !important;
    margin-top: 15px !important;
    padding-top: 12px !important;
    border-top: 1px solid rgba(0, 0, 0, 0.1) !important;
}

.gift-decline-btn, 
.gift-accept-btn {
    flex: 1 !important;
    padding: 10px 16px !important;
    border: 1px solid !important;
    border-radius: 8px !important;
    cursor: pointer !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    transition: all 0.2s ease !important;
    background: none !important;
}

.gift-decline-btn {
    color: #6B6B6B !important;
    border-color: #DCDCDC !important;
}

.gift-decline-btn:hover {
    background-color: #f5f5f5 !important;
    transform: translateY(-1px) !important;
}

.gift-accept-btn {
    color: #1E1E1E !important;
    border-color: #1E1E1E !important;
    background-color: #1E1E1E !important;
    color: white !important;
}

.gift-accept-btn:hover {
    background-color: #000000 !important;
    transform: translateY(-1px) !important;
}

/* ========== 【晴空】礼物卡片美化结束 ========== */

/* ========== 【晴空】转账模态框美化开始 ========== */

/* 1. 转账模态框背景 */
#transfer-modal {
    background-color: rgba(0, 0, 0, 0.3) !important; /* 更柔和的遮罩 */
}

/* 2. 转账内容容器 - 毛玻璃效果 */
.transfer-content {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    width: 290px !important;
    padding: 30px !important; /* 增加内边距 */
    text-align: center !important;
    background-image: none !important; /* 移除原有背景图 */
}

/* 3. 转账模态框标题 */
.transfer-header {
    font-size: 20px !important;
    font-weight: bold !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 25px !important;
}

/* 4. 转账输入组 */
.transfer-input-group {
    margin-bottom: 20px !important;
    text-align: left !important;
}

.transfer-input-group label {
    display: block !important;
    font-size: 14px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    font-weight: 500 !important;
}

.transfer-input-group input {
    width: 100% !important;
    padding: 12px 16px !important;
    border-radius: 8px !important; /* 小圆角 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    font-size: 16px !important;
    box-sizing: border-box !important;
    transition: all 0.2s ease-in-out !important;
}

.transfer-input-group input::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

.transfer-input-group input:focus {
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    outline: none !important;
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

/* 5. 转账按钮组 */
.transfer-actions {
    display: flex !important;
    justify-content: space-between !important;
    gap: 15px !important;
    margin-top: 25px !important;
}

.transfer-actions button {
    flex: 1 !important;
    padding: 12px 20px !important;
    border: none !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.transfer-actions button:active {
    transform: scale(0.98) !important;
}

/* 6. 取消按钮样式 */
#transfer-cancel-btn {
    background-color: #f5f5f5 !important;
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #DCDCDC !important;
}

#transfer-cancel-btn:hover {
    background-color: #eeeeee !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

/* 7. 确认按钮样式 */
#transfer-confirm-btn {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
}

#transfer-confirm-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* ========== 【晴空】转账模态框美化结束 ========== */

/* ========== 【晴空】外卖卡片美化开始 ========== */

/* 1. AI发送的外卖卡片 - 改为晴空样式 */
.message-bubble.ai .waimai-card {
    width: 240px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 毛玻璃背景 */
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    overflow: hidden !important;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

.message-bubble.ai .waimai-card:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 2. 用户发送的外卖卡片 - 毛玻璃气泡效果 */
.message-bubble.user .waimai-card {
    width: 240px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    overflow: hidden !important;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

.message-bubble.user .waimai-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 3. AI外卖卡片的晴空样式 */
.message-bubble.ai .waimai-header {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    padding: 15px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
}

.message-bubble.ai .waimai-header .title-group {
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.ai .waimai-header .title-group .brand {
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-right: 5px !important;
}

.message-bubble.ai .waimai-catchphrase {
    font-size: 13px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    padding: 15px !important;
    line-height: 1.4 !important;
}

.message-bubble.ai .waimai-main {
    background: rgba(248, 249, 250, 0.8) !important; /* 极浅的背景色 */
    padding: 15px !important;
    text-align: center !important;
}

.message-bubble.ai .waimai-main .request-title {
    font-size: 12px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-bottom: 10px !important;
}

.message-bubble.ai .waimai-main .payment-box {
    background-color: #FFFFFF !important; /* 纯白背景 */
    border-radius: 12px !important;
    padding: 20px 15px !important;
    border: 1px solid rgba(0, 0, 0, 0.05) !important;
}

.message-bubble.ai .waimai-main .payment-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.ai .waimai-main .amount {
    font-size: 32px !important;
    font-weight: 700 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin: 8px 0 15px 0 !important;
}

.message-bubble.ai .waimai-main .countdown-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.ai .waimai-main .countdown-timer span {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: white !important;
    padding: 3px 6px !important;
    border-radius: 4px !important;
    font-size: 12px !important;
    font-weight: 500 !important;
}

/* 4. 用户外卖卡片的晴空样式 */
.message-bubble.user .waimai-header {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    padding: 15px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
}

.message-bubble.user .waimai-header .title-group {
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.user .waimai-header .title-group .brand {
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-right: 5px !important;
}

.message-bubble.user .waimai-catchphrase {
    font-size: 13px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    padding: 15px !important;
    line-height: 1.4 !important;
}

.message-bubble.user .waimai-main {
    background: rgba(248, 249, 250, 0.8) !important; /* 极浅的背景色 */
    padding: 15px !important;
    text-align: center !important;
}

.message-bubble.user .waimai-main .request-title {
    font-size: 12px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-bottom: 10px !important;
}

.message-bubble.user .waimai-main .payment-box {
    background-color: #FFFFFF !important; /* 纯白背景 */
    border-radius: 12px !important;
    padding: 20px 15px !important;
    border: 1px solid rgba(0, 0, 0, 0.05) !important;
}

.message-bubble.user .waimai-main .payment-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.user .waimai-main .amount {
    font-size: 32px !important;
    font-weight: 700 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin: 8px 0 15px 0 !important;
}

.message-bubble.user .waimai-main .countdown-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.user .waimai-main .countdown-timer span {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: white !important;
    padding: 3px 6px !important;
    border-radius: 4px !important;
    font-size: 12px !important;
    font-weight: 500 !important;
}

/* 5. 外卖详情按钮美化 */
.message-bubble.user .waimai-details-btn {
    background-color: rgba(0, 0, 0, 0.05) !important;
    color: #1E1E1E !important;
    padding: 10px !important;
    text-align: center !important;
    font-size: 13px !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    border: none !important;
}

.message-bubble.user .waimai-details-btn:hover {
    background-color: rgba(0, 0, 0, 0.08) !important;
}

.message-bubble.ai .waimai-details-btn {
    background-color: rgba(0, 0, 0, 0.05) !important;
    color: #1E1E1E !important;
    padding: 10px !important;
    text-align: center !important;
    font-size: 13px !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    border: none !important;
}

.message-bubble.ai .waimai-details-btn:hover {
    background-color: rgba(0, 0, 0, 0.08) !important;
}

/* 6. 外卖操作按钮美化 - 晴空样式 */
.waimai-user-actions {
    display: flex !important;
    gap: 15px !important;
    padding: 20px !important;
    background: transparent !important;
}

.waimai-user-actions button {
    flex: 1 !important;
    padding: 10px 20px !important; /* 按照晴空方案调整 */
    border-radius: 8px !important;
    border: none !important;
    font-size: 12px !important; /* 缩小字体防止换行 */
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
    white-space: nowrap !important; /* 防止文字换行 */
    overflow: hidden !important; /* 隐藏溢出 */
    text-overflow: ellipsis !important; /* 文字溢出显示省略号 */
}

.waimai-decline-btn {
    background-color: #f5f5f5 !important;
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #DCDCDC !important;
}

.waimai-decline-btn:hover {
    background-color: #eeeeee !important;
    transform: translateY(-2px) !important; /* 按照晴空方案标准 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

.waimai-pay-btn {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
}

.waimai-pay-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 按照晴空方案标准 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 7. 外卖状态样式优化 */
.message-bubble.status-paid .waimai-main {
    background: rgba(230, 247, 235, 0.8) !important; /* 淡绿色背景表示已支付 */
}

.message-bubble.status-rejected .waimai-main {
    background: rgba(254, 242, 242, 0.8) !important; /* 淡红色背景表示已拒绝 */
    opacity: 0.8 !important;
}

/* ========== 【晴空】外卖卡片美化结束 ========== */

/* ========== 【晴空】链接卡片美化开始 ========== */

/* 1. 链接卡片主体美化 - 毛玻璃气泡效果 */
.link-share-card {
    width: 210px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 16px !important; /* 增加内边距 */
    cursor: pointer !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 10px !important;
}

.link-share-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
    background: rgba(255, 255, 255, 0.8) !important; /* 悬浮时稍微增加不透明度 */
}

/* 2. 链接标题样式 */
.link-share-card .title {
    font-weight: 600 !important;
    font-size: 15px !important;
    line-height: 1.4 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    display: -webkit-box !important;
    -webkit-line-clamp: 2 !important;
    -webkit-box-orient: vertical !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
}

/* 3. 链接描述样式 */
.link-share-card .description {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    line-height: 1.4 !important;
    display: -webkit-box !important;
    -webkit-line-clamp: 3 !important;
    -webkit-box-orient: vertical !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
}

/* 4. 链接底部信息样式 */
.link-share-card .footer {
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    font-size: 12px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-top: 6px !important;
    padding-top: 8px !important;
    border-top: 1px solid rgba(0, 0, 0, 0.05) !important; /* 微妙分割线 */
}

.link-share-card .footer-icon {
    width: 14px !important;
    height: 14px !important;
    flex-shrink: 0 !important;
    opacity: 0.7 !important;
}

/* 5. 链接卡片在消息气泡中的样式 */
.message-bubble.is-share-link .content {
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* ========== 【晴空】链接卡片美化结束 ========== */

/* ========== 【晴空】位置卡片美化开始 ========== */

/* 1. 位置卡片主体美化 - 毛玻璃气泡效果 */
.location-card {
    width: 240px !important;
    background: rgba(255, 255, 255, 0.8) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 16px !important; /* 增加内边距 */
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 12px !important;
}

.location-card:hover {
    transform: translateY(-1px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 10px 32px 0 rgba(0, 0, 0, 0.12) !important;
    background: rgba(255, 255, 255, 0.85) !important; /* 悬浮时稍微增加不透明度 */
}

/* 2. 位置卡片头部样式 */
.location-header {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    padding-bottom: 8px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08) !important; /* 微妙分割线 */
}

.location-icon {
    width: 20px !important;
    height: 20px !important;
    color: #34C759 !important; /* 绿色位置图标，类似微信 */
    flex-shrink: 0 !important;
}

.location-title {
    font-weight: 600 !important;
    font-size: 16px !important;
    color: #1E1E1E !important; /* 一级文本色 */
}

/* 3. 位置内容区域 */
.location-content {
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
}

/* 4. 位置信息项 */
.location-card .location-item {
    display: flex !important;
    align-items: flex-start !important;
    gap: 12px !important;
}

.location-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    font-weight: 500 !important;
    min-width: 60px !important; /* 确保标签对齐 */
    flex-shrink: 0 !important;
}

.location-value {
    font-size: 14px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    line-height: 1.4 !important;
    word-break: break-all !important; /* 长文本换行 */
}

/* 5. 位置卡片在消息气泡中的样式 */
.message-bubble.is-location .content {
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* ========== 【晴空】位置卡片美化结束 ========== */

/* ========== 监控模式选择面板样式 ========== */
.monitor-mode-option-btn {
    display: flex !important;
    align-items: center !important;
    justify-content: flex-start !important;
    width: 100% !important;
    padding: 16px 20px !important;
    margin-bottom: 12px !important;
    background-color: #FFFFFF !important;
    border: 1px solid #DCDCDC !important;
    border-radius: 12px !important;
    cursor: pointer !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    color: #1E1E1E !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08) !important;
    gap: 12px !important;
}

.monitor-mode-option-btn:hover {
    background-color: #F8F9FA !important;
    border-color: #1E1E1E !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12) !important;
}

.monitor-mode-option-btn:active {
    transform: translateY(0) !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08) !important;
}

.monitor-mode-option-btn:last-child {
    margin-bottom: 0 !important;
}

.monitor-mode-option-btn svg {
    color: #1E1E1E !important;
    flex-shrink: 0 !important;
}

.monitor-mode-option-btn span {
    flex: 1 !important;
    text-align: left !important;
}

/* ========== 【晴空】模态框页面美化开始 ========== */

/* 1. 通用模态框背景美化 */
.modal {
    background-color: rgba(0, 0, 0, 0.3) !important; /* 更柔和的遮罩 */
}

/* 2. 通用模态框内容容器 - 毛玻璃效果 */
.modal-content {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important; /* 增加圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    overflow: hidden !important;
}

/* 3. 模态框头部美化 */
.modal-header {
    background: transparent !important;
    padding: 20px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    text-align: center !important;
    display: flex !important;
    justify-content: center !important; /* 居中对齐 */
    align-items: center !important;
}

/* 4. 模态框主体区域美化 */
.modal-body {
    padding: 20px !important;
    overflow-y: auto !important;
    flex: 1 !important;
}

/* 5. 表单组样式统一 */
.modal-body .form-group {
    margin-bottom: 20px !important;
}

.modal-body .form-group label {
    display: block !important;
    font-size: 14px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    font-weight: 500 !important;
}

.modal-body .form-group input,
.modal-body .form-group textarea {
    width: 100% !important;
    padding: 12px 16px !important;
    border-radius: 8px !important; /* 小圆角 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    font-size: 16px !important;
    box-sizing: border-box !important;
    transition: all 0.2s ease-in-out !important;
}

.modal-body .form-group input::placeholder,
.modal-body .form-group textarea::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

.modal-body .form-group input:focus,
.modal-body .form-group textarea:focus {
    outline: none !important;
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

/* 6. 模态框底部按钮美化 */
.modal-footer {
    background: transparent !important;
    padding: 20px !important;
    display: flex !important;
    justify-content: space-between !important;
    gap: 15px !important;
}

.modal-footer button {
    flex: 1 !important;
    padding: 12px 20px !important;
    border-radius: 8px !important;
    border: none !important;
    cursor: pointer !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.modal-footer .save {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
}

.modal-footer .save:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

.modal-footer .cancel {
    background-color: #f5f5f5 !important;
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #DCDCDC !important;
}

.modal-footer .cancel:hover {
    background-color: #eeeeee !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

/* ========== 【晴空】模态框页面美化结束 ========== */

/* ========== 【晴空】转账操作模态框特殊美化开始 ========== */

/* 1. 转账操作模态框容器 */
.transfer-actions-content {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    width: 280px !important;
    padding: 0 !important;
    position: relative !important;
    overflow: hidden !important;
}

/* 2. 转账操作头部 */
.transfer-actions-header {
    background: transparent !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
    padding: 20px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    text-align: center !important;
    font-size: 18px !important;
}

/* 3. 转账操作主体 */
.transfer-actions-body {
    padding: 20px !important;
    text-align: center !important;
}

.transfer-actions-body p {
    color: #6B6B6B !important; /* 二级文本色 */
    font-size: 14px !important;
    line-height: 1.5 !important;
    margin: 0 !important;
}

.transfer-actions-body strong {
    color: #1E1E1E !important; /* 一级文本色 */
    font-weight: 600 !important;
}

/* 4. 转账操作按钮区域 */
.transfer-actions-footer {
    padding: 0 20px 20px 20px !important;
    display: flex !important;
    gap: 15px !important;
    justify-content: space-between !important;
}

/* 【开心收下】按钮 - 主按钮样式 */
#transfer-action-accept {
    flex: 1 !important;
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 纯白色文字 */
    border: none !important; /* 无边框设计 */
    border-radius: 8px !important; /* 8px圆角 */
    padding: 10px 20px !important; /* 标准内边距 */
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

#transfer-action-accept:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 向上平移2px */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; /* 柔和阴影 */
}

/* 【残忍拒绝】按钮 - 次要按钮样式 */
#transfer-action-decline {
    flex: 1 !important;
    background-color: #FFFFFF !important; /* 浅灰背景 */
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #F7F7F7 !important; /* 浅边框 */
    border-radius: 8px !important; /* 8px圆角 */
    padding: 10px 20px !important; /* 标准内边距 */
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

#transfer-action-decline:hover {
    background-color: #FFFFFF !important; /* 悬浮时背景变浅 */
    transform: translateY(-2px) !important; /* 向上平移2px */
    
}

/* 保留通用样式作为后备 */
.transfer-actions-footer .action-btn {
    flex: 1 !important;
    padding: 10px 20px !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

/* 5. 转账操作关闭按钮 */
.transfer-actions-content .cancel-btn {
    position: absolute !important;
    top: 15px !important;
    right: 15px !important;
    background: rgba(0, 0, 0, 0.05) !important;
    border: none !important;
    border-radius: 50% !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    color: #6B6B6B !important;
    font-size: 18px !important;
    transition: all 0.2s ease-in-out !important;
}

.transfer-actions-content .cancel-btn:hover {
    background: rgba(0, 0, 0, 0.1) !important;
    transform: scale(1.1) !important;
}

/* ========== 【晴空】转账操作模态框特殊美化结束 ========== */

/* ========== 【晴空】自定义提示框美化开始 ========== */

/* 1. 自定义提示框背景 */
#custom-modal-overlay {
    background-color: rgba(0, 0, 0, 0.3) !important; /* 更柔和的遮罩 */
}

/* ▼▼▼ 用这段新代码替换旧的 #custom-modal 样式 ▼▼▼ */
/* 2. 自定义提示框容器 - 毛玻璃效果 */
#custom-modal {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    width: 280px !important;

    /* --- 以下是保证垂直居中的核心代码 --- */
    display: flex !important;
    flex-direction: column !important;
    justify-content: center !important;
    min-height: 240px !important; /* 可以适当调高最小高度以获得更好看的间距 */
}

/* 3. 自定义提示框头部美化 */
.custom-modal-header {
    background: transparent !important;
    padding: 20px !important;
    font-size: 18px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    text-align: center !important;
}

/* 4. 自定义提示框主体区域美化 */
.custom-modal-body {
    padding: 20px !important;
    text-align: center !important;
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    line-height: 1.5 !important;
}

.custom-modal-body p {
    margin: 0 0 15px 0 !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

/* 5. 自定义提示框输入框美化 */
.custom-modal-body input,
.custom-modal-body textarea {
    width: 100% !important;
    padding: 12px 16px !important;
    border-radius: 8px !important; /* 小圆角 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    font-size: 16px !important;
    box-sizing: border-box !important;
    transition: all 0.2s ease-in-out !important;
    margin-top: 10px !important;
}

.custom-modal-body input::placeholder,
.custom-modal-body textarea::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

.custom-modal-body input:focus,
.custom-modal-body textarea:focus {
    outline: none !important;
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

.custom-modal-body textarea {
    resize: vertical !important;
    min-height: 80px !important;
}

/* 6. 自定义提示框底部按钮美化 */
.custom-modal-footer {
    background: transparent !important;
    padding: 0 !important;
    display: flex !important;
}

.custom-modal-footer button {
    flex: 1 !important;
    background: none !important;
    border: none !important;
    padding: 15px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.custom-modal-footer button:first-child {
    border-bottom-left-radius: 20px !important;
}

.custom-modal-footer button:last-child {
    border-bottom-right-radius: 20px !important;
}

.custom-modal-footer button:hover {
    background-color: rgba(0, 0, 0, 0.05) !important; /* 极淡的半透明背景 */
}

/* 7. 确定按钮特殊样式 - 晴空主按钮风格 */
.custom-modal-footer .confirm-btn {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
    font-weight: 600 !important;
    margin: 10px !important;
    border-radius: 20px !important; /* 所有四个角都与模态框一致 */
    padding: 10px 20px !important; /* 晴空方案标准内边距 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important; /* 与外卖按钮相同的阴影 */
}

.custom-modal-footer .confirm-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 向上平移2px */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; /* 柔和阴影 */
}

/* 8. 取消按钮调整 */
.custom-modal-footer button:not(.confirm-btn) {
    background-color: #f5f5f5 !important; /* 与外卖按钮相同的背景色 */
    color: #6B6B6B !important; /* 与外卖按钮相同的文字色 */
    border: 1px solid #DCDCDC !important; /* 与外卖按钮相同的边框 */
    margin: 10px 5px 10px 10px !important;
    border-radius: 20px !important; /* 所有四个角都与模态框一致 */
    padding: 10px 15px !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important; /* 与外卖按钮相同的阴影 */
}

.custom-modal-footer button:not(.confirm-btn):hover {
    background-color: #eeeeee !important;
    transform: translateY(-2px) !important; /* 与外卖按钮相同的悬浮效果 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important; /* 与外卖按钮相同的悬浮阴影 */
}

/* 9. 危险按钮样式 */
.custom-modal-footer .confirm-btn.btn-danger {
    background-color: #AB4D3F !important;
    color: #FFFFFF !important;
}

.custom-modal-footer .confirm-btn.btn-danger:hover {
    background-color: #d70015 !important;
}

/* ========== 【晴空】自定义提示框美化结束 ========== */
#chat-input:focus {
    outline: none; /* 首先移除浏览器默认样式 */
    
}
/* ▼▼▼ API预设按钮圆形美化样式开始 ▼▼▼ */
/* API预设列表中的操作按钮重新设计为圆形按钮 */
#api-settings-screen .preset-action-btn {
    width: 36px !important;
    height: 36px !important;
    border-radius: 50% !important;
    background-color: #1E1E1E !important;
    color: #FFFFFF !important;
    border: none !important;
    cursor: pointer !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    margin: 0 4px !important;
    padding: 0 !important;
    font-size: 0 !important; /* 隐藏文字 */
    transition: all 0.3s ease !important;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important;
}

#api-settings-screen .preset-action-btn:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25) !important;
}

/* 应用按钮SVG图标 */
#api-settings-screen .preset-action-btn[onclick*="applyApiPreset"]::before {
    content: '' !important;
    width: 18px !important;
    height: 18px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFFFFF'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3E%3C/svg%3E") !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    display: block !important;
}

/* 编辑按钮SVG图标 */
#api-settings-screen .preset-action-btn[onclick*="editApiPreset"]::before {
    content: '' !important;
    width: 18px !important;
    height: 18px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFFFFF'%3E%3Cpath d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z'/%3E%3C/svg%3E") !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    display: block !important;
}

/* 删除按钮SVG图标 */
#api-settings-screen .preset-action-btn[onclick*="deleteApiPreset"]::before {
    content: '' !important;
    width: 18px !important;
    height: 18px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFFFFF'%3E%3Cpath d='M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z'/%3E%3C/svg%3E") !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    display: block !important;
}
/* ▲▲▲ API预设按钮圆形美化样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】可见范围切换按钮美化样式 ▼▼▼ */

/* 1. 切换器的整体容器样式 */
.visibility-switcher {
    display: flex;
    background-color: #F7F7F7; /* 容器的浅灰色背景板 */
    border-radius: 8px;
    padding: 4px;
    margin-bottom: 15px; /* 调整与下方元素的间距 */
}

/* 2. 隐藏原始的radio圆点 */
.visibility-switcher input[type="radio"] {
    display: none;
}

/* 3. 将<span>标签美化成按钮样式 */
.visibility-switcher span {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    padding: 0 16px;
    line-height: 1;
    position: relative; /* 新增：开启相对定位，为微调做准备 */
    top: 1px; /* 新增：将文字整体向下移动1像素 */
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}

/* 4. 【核心】当radio被选中时，改变它后面<span>的样式 */
.visibility-switcher input[type="radio"]:checked + span {
    background-color: #1E1E1E; /* 您现有的主色调 */
    color: #FFFFFF; /* 纯白色文字 */
    box-shadow: 0 1px 4px rgba(0,0,0,0.15); /* 添加一点微妙的阴影 */
}

/* 5. 让两个按钮平分宽度 */
.visibility-switcher label {
    flex: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修正版】动态可见范围 - 分组选择器样式 ▼▼▼ */

/* 1. 整体容器改为灵活的标签式布局 */
#post-visibility-groups {
    display: flex;
    flex-wrap: wrap; /* 允许换行，实现横向显示 */
    gap: 10px; /* 标签之间的间距 */
    background-color: transparent;
    border: none;
    padding: 0;
    margin-top: 10px;
}

/* 2. 隐藏原始的复选框 */
#post-visibility-groups input[type="checkbox"] {
    display: none;
}

/* 3. 将label本身设计成一个圆角气泡（未选中状态）*/
#post-visibility-groups label {
    display: inline-block; /* 宽度根据内容自适应 */
    padding: 8px 16px;
    background-color: #F7F7F7; /* 修改点：将背景色改为 #F7F7F7 */
    color: var(--text-secondary);
    border: 2px solid transparent;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* 4. 【核心】使用:has()选择器，当label内的复选框被选中时，改变label的样式 */
#post-visibility-groups label:has(input[type="checkbox"]:checked) {
    background-color: #FFFFFF;
    color: #1E1E1E;
    border: 2px solid #1E1E1E;
    font-weight: 600;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】动态上传按钮美化样式 ▼▼▼ */
.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
    padding: 10px 15px; /* 设置合适的内边距 */
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    background-color: #F7F7F7; /* 您指定的背景色 */
    color: #1E1E1E; /* 黑色文字 */
    border: 2px solid #1E1E1E; /* 您指定的黑色边框 */
    border-radius: 12px; /* 圆润的边角 */
    transition: background-color 0.2s ease; /* 添加悬浮过渡效果 */
}

.post-image-upload-options button:hover {
    background-color: #e9ecef; /* 鼠标悬浮时颜色变得稍深 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【修复】强制显示动态上传按钮 ▼▼▼ */
#image-mode-content.active .post-image-upload-options {
    display: flex !important; /* 强制使用flex布局并显示 */
    width: 100%;
    gap: 10px; /* 确保按钮间有空隙 */
}
/* ▲▲▲ 修复代码粘贴结束 ▲▲▲ */

/* 聊天字体大小滑块样式 - 重新设计 */
#font-size-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 60%;
    height: 10px;
    border-radius: 5px;
    background: #ddd;
    outline: none;
    opacity: 0.8;
    transition: opacity 0.2s;
    margin: 15px 0;
    cursor: pointer; /* <-- 新增：让整个滑块条都可以点击 */
}

#font-size-slider:hover {
    opacity: 1;
}

/* Webkit浏览器 (Chrome, Safari) */
#font-size-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    /* ▼▼▼ 核心修改：通过设置宽高为0来隐藏圆球 ▼▼▼ */
    width: 0;
    height: 0;
}

/* 隐藏圆球的悬浮效果 */
#font-size-slider::-webkit-slider-thumb:hover {
    transform: none;
    background: transparent;
}

/* Mozilla Firefox */
#font-size-slider::-moz-range-thumb {
    /* ▼▼▼ 核心修改：通过设置宽高为0并移除边框来隐藏圆球 ▼▼▼ */
    width: 0;
    height: 0;
    border: none;
}

/* 隐藏圆球的悬浮效果 */
#font-size-slider::-moz-range-thumb:hover {
    transform: none;
    background: transparent;
}

#font-size-slider::-moz-range-track {
    width: 100%;
    height: 10px;
    cursor: pointer;
    background: #ddd;
    border-radius: 5px;
}

/* IE样式 */
#font-size-slider::-ms-track {
    width: 100%;
    height: 6px;
    cursor: pointer;
    background: transparent;
    border-color: transparent;
    border-width: 16px 0;
    color: transparent;
}

#font-size-slider::-ms-fill-lower {
    background: #000;
    border-radius: 10px;
}

#font-size-slider::-ms-fill-upper {
    background: #ddd;
    border-radius: 10px;
}

#font-size-slider::-ms-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #000;
    cursor: pointer;
    border: none;
}

/* 玻璃气泡按钮样式 */
.glass-bubble-button {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    overflow: hidden;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.glass-bubble-button:hover {
    transform: translateY(-4px) scale(1.02) !important;
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}
  
  /* ▼▼▼ 【全新】统一上传/移除背景按钮的文字样式 ▼▼▼ */
.bg-upload-container button {
    font-size: 14px;
    font-weight: 500;
}

/* ▼▼▼ 【全新】微信风格操作面板样式 ▼▼▼ */
#wechat-style-actions-panel {
    position: absolute;
    z-index: 1001;
    display: none;
    opacity: 0;
    background-color: #333333;
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
    min-width: 240px;
    transform-origin: center center;
    transition: opacity 0.2s ease, transform 0.2s ease;
}

/* 按压渐出动画 */
@keyframes wechat-panel-press-in {
    0% {
        transform: scale(0.5);
        opacity: 0;
    }
    60% {
        transform: scale(1.02);
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

/* 按压渐灭动画 */
@keyframes wechat-panel-press-out {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(0.8);
        opacity: 0;
    }
}

/* 动画状态类 */
#wechat-style-actions-panel.press-in {
    animation: wechat-panel-press-in 0.18s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

#wechat-style-actions-panel.press-out {
    animation: wechat-panel-press-out 0.12s ease-out forwards;
}

#wechat-style-actions-panel::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid #333333;
}

/* 当面板在消息下方时，小三角指向上方 */
#wechat-style-actions-panel.below-message::after {
    top: -8px;
    bottom: auto;
    border-top: none;
    border-bottom: 8px solid #333333;
}

.wechat-action-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px;
    min-height: 60px;
    cursor: pointer;
    border-radius: 6px;
    transition: background-color 0.2s;
}

.wechat-action-btn:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.wechat-action-btn svg {
    width: 24px;
    height: 24px;
    margin-bottom: 6px;
    fill: #FFFFFF;
}

.wechat-action-btn button {
    background: none;
    border: none;
    padding: 0;
    font-family: inherit;
    font-size: 11px;
    color: white;
    cursor: pointer;
    text-align: center;
    line-height: 1.2;
}
/* ▲▲▲ 微信风格操作面板样式结束 ▲▲▲ */

/* ▼▼▼ 圆形勾选框样式 ▼▼▼ */
.share-target-checkbox {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: 20px;
    height: 20px;
    border: 2px solid #1E1E1E;
    border-radius: 50%;
    background-color: transparent;
    cursor: pointer;
    position: relative;
    transition: all 0.3s ease;
}

.share-target-checkbox:checked {
    background-color: #1E1E1E;
    border-color: #1E1E1E;
}

.share-target-checkbox:hover {
    border-color: #333333;
}

.share-target-checkbox:hover:checked {
    background-color: #333333;
}
/* ▲▲▲ 圆形勾选框样式结束 ▲▲▲ */
  /* --- 【最终强力修正】自定义弹窗垂直居中 --- */

/* 1. 强制弹窗容器为Flex布局并给予最小高度 */
#custom-modal {
    display: flex !important;
    flex-direction: column !important;
    min-height: 240px !important; /* 确保有足够的垂直空间 */
}

/* 2. 让头部和脚部占据固定空间，不要伸缩 */
#custom-modal .custom-modal-header,
#custom-modal .custom-modal-footer {
    flex-shrink: 0 !important;
}

/* 3. 【核心】让中间的内容区占据所有剩余空间，并将其内部内容（输入框）改为顶部对齐 */
#custom-modal .custom-modal-body {
    flex-grow: 1 !important;
    display: flex !important;
    flex-direction: column !important;
    /* ▼▼▼ 核心修改就在这里 ▼▼▼ */
    justify-content: flex-start !important; /* 将垂直居中 (center) 改为顶部对齐 (flex-start) */
    padding-top: 20px !important;           /* (推荐) 增加一点上边距，避免输入框紧贴标题 */
}

/* --- 【强力修正】隐藏单聊和群聊心声弹窗的头部 --- */
#status-modal .modal-header,
#group-status-modal .modal-header {
    display: none !important; /* 关键：添加 !important 标记 */
}

/* ▼▼▼ 【全新】外观设置 - 左右并排布局样式 ▼▼▼ */
.settings-row-container {
    display: flex; /* 开启flex布局，让内部元素横向排列 */
    gap: 15px; /* 在两个设置项之间增加15像素的间距 */
    width: 100%;
    box-sizing: border-box;
    padding: 0 10px; /* 保证左右两边有边距 */
    margin-top: 20px; /* <--- 在这里添加新代码，20px可以随意调整 */
}

/* 让容器内的每个设置项（.form-group）都占据一半的可用空间 */
.settings-row-container > .form-group {
    flex: 1; 
    min-width: 0; /* flex布局中的重要属性，防止内容溢出 */
}

/* 确保夜间模式开关的内部也正确对齐 */
.settings-row-container .form-group:not(.padding-setting-container) {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
/* ▲▲▲ 专属样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】模拟翻译器功能样式 ▼▼▼ */

/* 1. 让翻译气泡的内容区透明，以便自定义内部样式 */
.message-bubble.is-translation .content {
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* 2. 翻译前（显示外语）的容器样式 */
.translation-body {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 4px 8px;
    gap: 8px; /* 图标和文字的间距 */
}




/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】自定义HTML模块样式 ▼▼▼ */
.message-wrapper.html-module-wrapper {
    
    display: flex;
    justify-content: center; /* 水平居中 */
    align-self: center; /* 确保容器本身在聊天流中居中 */
    margin: 10px 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】自定义HTML模块样式 ▼▼▼ */
.message-wrapper.html-module-wrapper {
    
    display: flex;
    justify-content: center; /* 水平居中 */
    align-self: center; /* 确保容器本身在聊天流中居中 */
    margin: 10px 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】HTML模块强制居中与响应式修复 ▼▼▼ */
.message-wrapper.html-module-wrapper .message-bubble > orange > div {
    width: 100% !important;
    max-width: 420px !important;
    box-sizing: border-box !important;
    margin-left: auto !important;
    margin-right: auto !important;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】HTML指令输入弹窗样式 ▼▼▼ */
/* ▼▼▼ 【全新】HTML指令输入弹窗样式 ▼▼▼ */
#html-prompt-modal .modal-content {
    height: auto;
    max-height: 70%;
}

#html-prompt-modal .modal-body {
    padding: 15px;
}

#html-prompt-modal #html-prompt-input {
    width: 100%;
    min-height: 150px;
    resize: vertical;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    padding: 10px;
    font-size: 14px;
    box-sizing: border-box;
}

#html-prompt-modal .modal-footer {
    justify-content: space-between;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】半透明风格日期时间戳样式 ▼▼▼ */
.date-divider {
    align-self: center;
    padding: 3px 10px;
    margin: -3px 0;
    /* 核心修改：使用半透明的黑色作为背景 */
    background-color: rgba(0, 0, 0, 0.1);
    /* 核心修改：文字颜色调整为深灰色以保证清晰 */
    color: var(--text-secondary);
    font-size: 11px;
    font-weight: 500;
    border-radius: 4px;
    text-align: center;
}
#phone-screen.dark-mode .date-divider {
    /* 核心修改：暗色模式下使用半透明的白色 */
    background-color: rgba(255, 255, 255, 0.15);
    color: #8d8d92;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】图片及其他卡片气泡包裹问题修正 ▼▼▼ */

/* 1. 为所有“卡片式”消息的 .content 容器应用透明背景 */
/* 这会覆盖掉默认主题和自定义主题中对 .content 的样式，让卡片本身显露出来 */
.message-bubble.has-image .content,
.message-bubble.is-ai-image .content,
.message-bubble.is-transfer .content,
.message-bubble.is-waimai-request .content,
.message-bubble.is-red-packet .content,
.message-bubble.is-poll .content,
.message-bubble.is-link-share .content,
.message-bubble.is-location .content,
.message-bubble.is-gift .content {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* 2. 为图片内容设置一个合适的内边距，避免图片紧贴边缘 */
.message-bubble.has-image .content,
.message-bubble.is-ai-image .content {
    padding: 5px !important;
}

/* 3. 为其他本身不需要内边距的卡片类型，移除内边距 */
.message-bubble.is-transfer .content,
.message-bubble.is-waimai-request .content,
.message-bubble.is-red-packet .content,
.message-bubble.is-poll .content,
.message-bubble.is-link-share .content,
.message-bubble.is-location .content,
.message-bubble.is-gift .content {
    padding: 0 !important;
}

/* ▲▲▲ 修正代码粘贴结束 ▲▲▲ */

/* ▼▼▼ 【修复】模拟时间戳位置修正 ▼▼▼ */
/*
  问题：您新的 .timestamp 样式使用了 position: absolute，这会错误地将居中的【模拟时间戳】也拉到气泡旁边。
  修复：我们使用一个更高优先级的规则，强制 .simulated-timestamp 恢复它原本的布局方式，而不影响普通的时间戳。
*/
.timestamp.simulated-timestamp {
    position: relative !important; /* 强制恢复其相对定位，让它回到正常的文档流中 */
    display: inline-block !important; /* 确保它能像一个独立的块一样居中 */
    z-index: 10 !important; /* 确保它在顶层 */
    
    /* 重置掉从 .user .timestamp / .ai .timestamp 继承来的错误定位 */
    left: auto !important; 
    right: auto !important;
    bottom: auto !important;

    /* 恢复它自己的外边距，用于和上下消息分隔 */
    margin-bottom: 3px !important;
}
/* ▲▲▲ 修复代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
.lock-actions-container {
    display: flex; /* 核心：让内部元素横向排列 */
    justify-content: center; /* 讓按鈕在容器內居中 */
    gap: 15px; /* 按钮之间的间距 */
    margin-top: 0px; /* 让按钮组和上面的文字有一点距离 */
    width: 100%;
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】人设展开编辑器样式 ▼▼▼ */
.persona-label-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px; /* 保持和原版一致的间距 */
}

.expand-persona-btn {
    /* 尺寸与定位 */
    width: 32px;
    height: 32px;
    flex-shrink: 0;
    
    /* 外观重置与美化 */
    background-color: rgba(0, 0, 0, 0.05); /* 使用半透明背景，更好地适应日间/夜间模式 */
    border: none;
    border-radius: 50%; /* 保持圆形 */
    padding: 0; /* 移除内边距，确保SVG精确定位 */
    cursor: pointer;
    
    /* 内容居中 */
    display: flex;
    align-items: center;
    justify-content: center;
    
    /* 交互效果 */
    transition: background-color 0.2s ease, transform 0.1s ease;
}

.expand-persona-btn:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 悬浮时加深背景 */
}

.expand-persona-btn:active {
    transform: scale(0.9); /* 点击时轻微缩小 */
}

/* SVG图标本身样式 */
.expand-persona-btn svg {
    width: 16px; /* 图标尺寸略小于按钮 */
    height: 16px;
    color: var(--text-secondary); /* 使用次要文字颜色，确保清晰 */
}

.expand-persona-btn:hover {
    background-color: #e0e0e0;
}

.persona-editor-expanded .expanded-textarea {
    width: 100%;
    min-height: 550px; /* 展开后提供更大的编辑区 */
    resize: vertical;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid var(--border-color);
    font-size: 14px;
    box-sizing: border-box;
}

.persona-editor-expanded .expanded-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 10px;
}

.persona-editor-expanded .expanded-actions button {
    padding: 8px 16px;
    border-radius: 6px;
    border: 1px solid transparent;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
}

.persona-editor-expanded .expanded-actions .cancel-expanded-btn {
    background-color: #f0f0f0;
    border-color: #ddd;
    color: var(--text-primary);
}

.persona-editor-expanded .expanded-actions .save-expanded-btn {
    background-color: var(--accent-color);
    color: white;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】微信风格顶栏毛玻璃效果 ▼▼▼ */
#chat-interface-screen .header {
    position: absolute; /* 1. 改为绝对定位，让其脱离文档流浮动起来 */
    top: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.8); /* 2. 背景色改为半透明 */
    backdrop-filter: blur(15px); /* 3. 添加背景模糊（毛玻璃核心） */
    -webkit-backdrop-filter: blur(15px); /* 4. 兼容Safari浏览器 */
    border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* 5. 边框也改为更柔和的半透明色 */
    box-sizing: border-box; /* 6. 确保宽度计算正确 */
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】聊天设置窗口位置微调 ▼▼▼ */
#chat-settings-modal {
    padding-top: 30px; /* 增加40px的顶部内边距，使其内容整体下移15px */
    box-sizing: border-box; /* 确保内边距不会影响整体布局 */
}
/* ▲▲▲ 添加结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】修复iOS添加到桌面后，模态框遮罩无法覆盖底部安全区的问题 ▼▼▼ */
.modal,
#custom-modal-overlay,
#transfer-modal,
#battery-alert-modal,
#incoming-call-modal {
    position: fixed; /* 1. 统一并强制使用 fixed 定位，使其相对于屏幕视口 */
    top: 0;
    left: 0;
    right: 0;      /* 2. 新增 right: 0 */
    bottom: 0;     /* 3. 新增 bottom: 0 */
    height: auto;  /* 4. 将原来的 height: 100% 或类似设置改为 auto */
    width: auto;   /* 5. 将原来的 width: 100% 改为 auto */
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修正版】简约风格的刷新锚点按钮 ▼▼▼ */
#refresh-memory-anchor-btn {
    width: 32px;
    height: 32px;
    background-color: rgba(0, 0, 0, 0.05); /* 使用一个非常淡的灰色背景 */
    border: 1px solid rgba(0, 0, 0, 0.08); /* 添加一个几乎看不见的边框增加质感 */
    transition: background-color 0.2s ease; /* 添加悬浮过渡效果 */
}

#refresh-memory-anchor-btn:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 鼠标悬浮时背景加深一点 */
}

/* 更改SVG图标的颜色并强制移除内部填充 */
#refresh-memory-anchor-btn svg {
    fill: none !important; /* 【核心修复】强制移除白色填充 */
    stroke: var(--text-secondary); 
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ========== 【手机界面】样式开始 ========== */
/* 手机界面基础样式 */
.phone-content {
    flex: 1;
    overflow: hidden;
    background-color: #F7F7F7; /* 核心修改：将渐变背景改为淡灰色 */
    position: relative;
}

.phone-view {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    display: flex;
    flex-direction: column;
    padding: 20px;
}

.phone-view.active {
    opacity: 1;
    visibility: visible;
}

/* 手机home界面app九宫格布局 */
.phone-app-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 25px;
    padding: 40px 20px;
    flex: 1;
    align-content: center;
}

.phone-app-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.phone-app-item:active {
    transform: scale(0.9);
}

.phone-app-icon {
    width: 65px;
    height: 65px;
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(10px);
}

.phone-app-icon svg {
    width: 32px;
    height: 32px;
    fill: #333;
}

.phone-app-label {
    color: white;
    font-size: 12px;
    font-weight: 500;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    text-align: center;
}

/* 各个app界面的通用样式 */
.phone-app-view {
    background: #f8f9fa;
    border-radius: 12px 12px 0 0;
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.phone-app-header {
    background: #fff;
    padding: 25px 20px; /* 核心修改：增加了上下内边距 */
    border-bottom: 1px solid #e9ecef;
    display: flex;
    align-items: center;
    justify-content: center; /* 修改：改为居中对齐 */
    position: relative; /* 新增：为标题绝对定位做准备 */
}

.phone-app-back {
    position: absolute;
    left: 15px;
    font-size: 18px;
    cursor: pointer;
    color: #1e1e1e; /* 核心修改：颜色改为 #1e1e1e */
    min-width: 30px;
    min-height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 5px;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.phone-app-title {
    font-weight: 600;
    color: #1c1c1e;
    /* 新增：以下是让标题在有返回按钮的情况下依然能完美居中的代码 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.phone-app-content {
    flex: 1;
    overflow-y: auto;
    background: #fff;
}

/* Loading状态 */
.phone-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 40px;
    color: #666;
    gap: 10px; /* 新增此行 */
}

.phone-loading-spinner {
    width: 15px;
    height: 15px;
    border: 2px solid var(--border-color);
    border-top-color: var(--text-secondary);
    border-radius: 50%;
    animation: phone-spin 1s linear infinite;
    flex-shrink: 0; /* 新增此行防止被压缩 */
}

@keyframes phone-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* 空状态 */
.phone-empty {
    text-align: center;
    padding: 40px;
    color: #999;
}

/* 微信界面样式 */
.wechat-chat-list {
    padding: 0;
}

.wechat-chat-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s;
}

.wechat-chat-item:hover {
    background-color: #f8f9fa;
}

.wechat-avatar {
    width: 50px;
    height: 50px;
    border-radius: 8px;
    background: #ddd;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 15px;
    color: white;
    font-weight: bold;
    font-size: 18px;
    flex-shrink: 0; /* 新增此行防止被压缩 */
}

.wechat-chat-info {
    flex: 1;
}

.wechat-contact-name {
    font-weight: 600;
    color: #1c1c1e;
    margin-bottom: 5px;
}

.wechat-last-message {
    color: #8e8e93;
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 微信聊天详情样式 */
.wechat-message-list {
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.wechat-message {
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.wechat-message.sent {
    flex-direction: row-reverse;
}

.wechat-message-avatar {
    width: 35px;
    height: 35px;
    border-radius: 6px;
    background: #ddd;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 12px;
    flex-shrink: 0;
}

.wechat-message-content {
    max-width: 70%;
    background: #fff;
    border: 1px solid #e8e8e8;
    border-radius: 8px;
    padding: 10px 15px;
    font-size: 14px;
    line-height: 1.4;
    position: relative;
}

.wechat-message.sent .wechat-message-content {
    background: #95ec69;
    border: none; /* 核心修改：移除边框 */
}

.wechat-message-content::before {
    content: '';
    position: absolute;
    top: 10px;
    left: -8px;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 8px 8px 8px 0;
    border-color: transparent #e8e8e8 transparent transparent;
}

.wechat-message.sent .wechat-message-content::before {
    left: auto;
    right: -8px;
    border-width: 8px 0 8px 8px;
    border-color: transparent transparent transparent #95ec69;
}

/* 购物车界面样式 */
.shopping-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.shopping-item-info {
    flex: 1;
}

.shopping-item-name {
    font-weight: 600;
    color: #1c1c1e;
    margin-bottom: 5px;
}

.shopping-item-store {
    color: #8e8e93;
    font-size: 14px;
}

.shopping-item-price {
    color: #ff3b30;
    font-weight: bold;
    font-size: 16px;
}

/* 备忘录界面样式 */
.memo-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}

.memo-item:hover {
    background-color: #f8f9fa;
}

.memo-title {
    font-weight: 600;
    color: #1c1c1e;
    margin-bottom: 5px;
}

.memo-preview {
    color: #8e8e93;
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 浏览器界面样式 */
.browser-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}

.browser-item:hover {
    background-color: #f8f9fa;
}

.browser-query {
    font-weight: 600;
    color: #1c1c1e;
    margin-bottom: 5px;
}

.browser-preview {
    color: #8e8e93;
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 相册界面样式 */
.photos-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2px;
    padding: 20px;
}

.photo-item {
    aspect-ratio: 1;
    background: #f0f0f0;
    border-radius: 8px;
    cursor: pointer;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    color: #999;
}

.photo-item:hover {
    opacity: 0.8;
}

/* 钱包界面样式 */
.wallet-balance {
    text-align: center;
    padding: 40px 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    margin: 20px;
    border-radius: 12px;
}

.wallet-balance-title {
    font-size: 14px;
    opacity: 0.8;
    margin-bottom: 10px;
}

.wallet-balance-amount {
    font-size: 32px;
    font-weight: bold;
}

.wallet-transactions {
    padding: 0 20px;
}

.wallet-transaction {
    padding: 15px 0;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.wallet-transaction-desc {
    font-weight: 500;
    color: #1c1c1e;
}

.wallet-transaction-amount {
    font-weight: bold;
}

.wallet-transaction-amount.income {
    color: #34c759;
}

.wallet-transaction-amount.expense {
    color: #ff3b30;
}

/* 足迹界面样式 (全新美化版) */
#location-content .location-item {
    position: relative;
    padding: 15px 20px 20px 45px; /* 增加左边距为时间线留出空间 */
    border: none; /* 移除旧边框 */
}

/* 时间线竖线 */
#location-content .location-item::before {
    content: '';
    position: absolute;
    left: 20px;
    top: 0;
    bottom: 0;
    width: 2px;
    background-color: #e9ecef;
}
/* 最后一个项目没有下半段竖线 */
#location-content .location-item:last-child::before {
    bottom: auto;
    height: 25px;
}

/* 时间线圆点 */
#location-content .location-item::after {
    content: '';
    position: absolute;
    left: 15px;
    top: 20px; /* 与时间文字垂直对齐 */
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: #1e1e1e;
    border: 2px solid #fff;
    box-shadow: 0 0 0 2px #1e1e1e;
}

.location-time {
    display: block; 
    color: #8e8e93;
    font-size: 13px;
    margin-bottom: 10px;
    font-weight: 500;
}

.location-place {
    display: block; /* 确保地点独占一行 */
    font-weight: 600;
    color: #1c1c1e;
    font-size: 16px;
    margin-bottom: 8px; 
}

.location-activity {
    display: block; /* 确保活动独占一行 */
    color: #666;
    font-size: 14px;
    line-height: 1.5;
}

/* 使用记录界面样式 (仿iOS风格) */
/* 移除容器的内边距，让列表项撑满 */
#usage-content {
    padding: 0; /* 核心修改：移除所有内边距 */
    background-color: #FFFFFF; 
}

.usage-item {
    background-color: #FFFFFF;
    padding: 12px 20px;
    border-top: 1px solid #e9ecef;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: -1px; /* 让边框重叠，更美观 */
    position: relative; /* 为箭头伪元素定位 */
}

/* 模拟iOS列表右侧的箭头 */
.usage-item::after {
    content: '›';
    font-size: 22px;
    color: #c7c7cc;
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
}

.usage-app-name {
    font-weight: 500; /* 字体更柔和 */
    font-size: 16px;
    color: #1c1c1e;
}

.usage-duration {
    color: #8e8e93;
    font-size: 15px;
    margin-right: 20px; /* 留出箭头空间 */
}
/* ========== 【手机界面】样式结束 ========== */
/* === 【全新】世界书多选模式样式 (已修复背景色问题) === */

/* 1. 给所有列表项增加一个过渡效果，让padding和背景色变化更平滑 */
#world-book-screen .list-item {
    transition: padding-left 0.3s ease, background-color 0.2s ease;
}

/* 2. 当进入选择模式时，为所有列表项增加左内边距，为勾选框腾出空间 */
#world-book-screen.wb-selection-mode .list-item {
    padding-left: 55px; /* 核心修改：不再使用transform，而是用padding挤出空间 */
}

/* 3. 勾选框的样式 (使用伪元素创建) */
#world-book-screen .list-item::before {
    content: '';
    position: absolute;
    /* 定位在新增的内边距区域内 */
    left: 20px; 
    top: 50%;
    transform: translateY(-50%) scale(0.5); /* 默认缩小隐藏 */
    width: 20px;
    height: 20px;
    border: 2px solid #DCDCDC;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默认透明 */
}

/* 4. 当进入选择模式时，让勾选框动画出现 */
#world-book-screen.wb-selection-mode .list-item::before {
    opacity: 1;
    transform: translateY(-50%) scale(1);
}

/* 5. 当列表项被选中时，勾选框的样式 */
#world-book-screen .list-item.selected::before {
    background-color: #1E1E1E;
    border-color: #1E1E1E;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3E%3C/svg%3E");
    background-size: 80%;
    background-position: center;
    background-repeat: no-repeat;
}

/* 6. 【核心修复】当列表项被选中时，改变它自身的背景色 */
#world-book-screen.wb-selection-mode .list-item.selected {
    background-color: rgba(30, 30, 30, 0.05) !important;
}

/* 7. 控制头部按钮的显隐 (这部分保持不变) */
#world-book-screen.wb-selection-mode #wb-default-controls {
    display: none;
}
#world-book-screen.wb-selection-mode #wb-selection-controls {
    display: flex;
}

/* 8. 控制头部标题的显隐 (这部分保持不变) */
#world-book-screen.wb-selection-mode #world-book-default-title {
    display: none;
}
#world-book-screen.wb-selection-mode #world-book-selection-title {
    display: block;
}
/* 【全新】为消息编辑器的文本框禁用手动缩放 */
#message-editor-modal .message-editor-block textarea {
    resize: none;
    overflow-y: hidden; /* 默认隐藏滚动条，由JS控制 */
}
/* 【全新添加】放大“查手机”刷新按钮内部的SVG图标 */
#phone-refresh-btn svg {
    transform: scale(1.05); /* 将图标放大25%，你可以调整这个数值 */
    transition: transform 0.2s ease; /* (可选)增加一个平滑的过渡效果 */
}

/* ▼▼▼ 【最终决定版】表情包操作与批量删除样式 v5.0 ▼▼▼ */

/* 1. 长按菜单样式 (无变化) */
#sticker-actions-panel { display: flex; gap: 4px; }
#sticker-actions-panel button { background: none; border: none; color: white; padding: 8px 12px; font-size: 13px; cursor: pointer; border-radius: 6px; transition: background-color 0.2s; }
#sticker-actions-panel button:hover { background-color: rgba(255, 255, 255, 0.15); }

/* 2. 【最终方案】为选中的外框容器应用边框样式 - 深灰色边框 */
#sticker-panel.selection-mode .sticker-item.selected {
    border-color: #333333 !important; /* 深灰色边框 */
    background-color: rgba(51, 51, 51, 0.1) !important; /* 浅灰色背景 */
}

/* 3. 移除旧的长按删除按钮 (无变化) */
.sticker-item .delete-btn { display: none !important; }

/* 4. 批量删除头部的圆形图标按钮样式 (无变化) */
#sticker-selection-controls button {
    width: 38px; height: 38px; border-radius: 50%; border: none;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.2s ease;
}
#sticker-selection-controls button svg { color: #FFFFFF; }
#cancel-sticker-selection-btn { background-color: #333333; }
#delete-selected-stickers-btn { background-color: #AB4D3F; }
#sticker-selection-controls button:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】微信风格气泡弹入动画 v2.0 (无抖动Bug) ▼▼▼ */

/* 1. 定义动画本身：从轻微缩小+透明，变为正常大小+不透明 */
@keyframes wechat-pop-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* 2. 将动画应用到新消息上，并使用一个带有回弹效果的缓动函数，使其更灵动 */
.message-wrapper.animate-in {
  animation: wechat-pop-in 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

/* 3. 【画龙点睛】为不同方向的气泡设置不同的动画原点 */
.message-wrapper.ai.animate-in {
  transform-origin: bottom left; /* AI/对方的气泡（左侧），从左下角弹出 */
}
.message-wrapper.user.animate-in {
  transform-origin: bottom right; /* 你的气泡（右侧），从右下角弹出 */
}

/* ▲▲▲ 新动画代码结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放列表美化样式 ▼▼▼ */

/* 1. 面板主体样式：改为晴空设计风格的纯色背景 */
#music-playlist-panel {
    background-color: #F7F7F7;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    border-top: 1px solid #EAEAEA;
}

/* 2. 头部样式：调整对齐与边框 */
.playlist-header {
    padding: 12px 15px;
    border-bottom: 1px solid #EAEAEA;
    font-weight: 600;
    color: var(--text-primary);
}

/* 3. 左上角返回按钮样式：使其与聊天返回键一致 */
.playlist-header #close-playlist-btn {
    font-size: 28px;
    font-weight: 400;
    color: var(--accent-color);
}

/* 4. 右上角圆形SVG按钮组 */
.playlist-header .playlist-header-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}
.playlist-header .playlist-header-action-btn {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #1E1E1E;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s, transform 0.1s;
}
.playlist-header .playlist-header-action-btn:hover {
    opacity: 0.8;
}
.playlist-header .playlist-header-action-btn:active {
    transform: scale(0.9);
}
.playlist-header .playlist-header-action-btn svg {
    width: 16px;
    height: 16px;
    color: white; /* 核心修正：直接定义图标颜色为白色 */
    stroke: currentColor; /* 确保线条使用我们定义的颜色 */
}

/* 5. 列表主体与项目样式微调 */
.playlist-body {
    background-color: #FFFFFF;
    padding: 0;
}
.playlist-item {
    padding: 12px 20px;
    border-bottom: 1px solid #F0F0F0;
    transition: background-color 0.2s;
}
.playlist-item:last-child {
    border-bottom: none;
}
.playlist-item:hover {
    background-color: #F9F9F9;
}
.playlist-item.playing {
    background-color: #F7F7F7;
}
.playlist-item.playing .title {
    color: var(--accent-color);
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】用于高亮显示当前模式的样式 ▼▼▼ */
.monitor-mode-option-btn.current-mode {
    background-color: #f0f0f0 !important; /* 稍深的灰色背景 */
    font-weight: 600; /* 加粗字体 */
    cursor: default; /* 鼠标样式改为默认，表示不可点击 */
    border-color: #dcdcdc !important; /* 添加一个浅色边框以示区分 */
}

/* 覆盖掉原有的悬浮效果，使其在悬浮时无变化 */
.monitor-mode-option-btn.current-mode:hover {
    transform: none !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08) !important;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
  
/* ▼▼▼ 把这一整块全新的CSS，粘贴到这里 ▼▼▼ */
/* 【全新】修复操作菜单 (Action Sheet) 的样式 */
#preset-actions-modal #custom-modal,
#status-diary-action-modal #custom-modal,
#post-actions-modal #custom-modal {
    min-height: auto !important; /* 高度由内容决定 */
    height: auto !important;
    justify-content: flex-start !important; /* 内容从顶部开始排列 */
    overflow: hidden !important; /* 【核心】裁剪内部元素的边角 */
    padding: 0 !important; /* 移除内边距，让按钮填满 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到这里 ▼▼▼ */
/* 【全新】调整人设预设输入框的高度 */
#preset-persona-input {
    min-height: 500px; /* 设置最小高度为500px */
    resize: vertical; /* (推荐) 允许用户可以手动调整输入框大小 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【心声弹窗换行修复】▼▼▼ */
#status-modal-thought {
    white-space: pre-wrap !important;
}
/* ▲▲▲ 修复代码结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】修复主动回复中长模拟时间戳压缩气泡的问题 ▼▼▼ */
.message-wrapper.ai.is-simulated-message {
    max-width: 100%;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* ▼▼▼ 【新增】世界书选择模态框动画 ▼▼▼ */
@keyframes slideUp {
    from {
        transform: translateY(100%);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes slideDown {
    from {
        transform: translateY(0);
        opacity: 1;
    }
    to {
        transform: translateY(100%);
        opacity: 0;
    }
}

@keyframes fadeInOut {
    0%, 100% { opacity: 0; }
    50% { opacity: 1; }
}
/* ▲▲▲ 动画添加结束 ▲▲▲ */

/* ▼▼▼ 【修复】强制QZone头部按钮SVG为线条样式 ▼▼▼ */
#qzone-screen .qzone-header .circle-btn svg {
    fill: none !important; /* 强制覆盖全局填充 */
    stroke: white !important; /* 强制描边为白色 */
    /* stroke-width 会继承自 SVG 内部设置 */
    width: 18px; /* 保持图标大小一致 */
    height: 18px;
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】便签纸风格心声和散记弹窗 ▼▼▼ */
#status-modal,
#group-status-modal {
    z-index: 1001 !important;
}

#status-modal,
#group-status-modal {
    background-color: rgba(0, 0, 0, 0.3) !important;
    backdrop-filter: blur(8px) !important;
    -webkit-backdrop-filter: blur(8px) !important;
}

#status-modal .modal-content,
#group-status-modal .modal-content {
    width: 320px !important;
    max-height: 80vh !important;
    background-color: #ffffff !important;
    border-radius: 0 !important;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12) !important;
    display: flex !important;
    flex-direction: column !important;
    position: relative !important;
    /* padding: 20px !important;  <--- 注释掉或删除旧的这一行 */
    padding: 20px 16px 20px 20px !important; /* <--- 替换成这行 (上 右 下 左) */
    border: none !important;
    overflow: visible !important;
}

/* 顶部打孔效果 */
#status-modal .modal-content::before,
#group-status-modal .modal-content::before {
    content: '';
    position: absolute;
    top: -10px;
    left: 0;
    right: 0;
    height: 20px;
    background-image: radial-gradient(circle at 50% 0, transparent 8px, #ffffff 8px);
    background-size: 25px 20px;
    background-repeat: repeat-x;
}

/* 底部打孔效果 */
#status-modal .modal-content::after,
#group-status-modal .modal-content::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 0;
    right: 0;
    height: 20px;
    background-image: radial-gradient(circle at 50% 100%, transparent 8px, #ffffff 8px);
    background-size: 25px 20px;
    background-repeat: repeat-x;
}

/* 调整模态框body样式 */
#status-modal .modal-body,
#group-status-modal .modal-body {
    padding: 0 !important;
    background: transparent !important;
    border: none !important;
    color: #1E1E1E;
    font-size: 16px;
    flex-grow: 1;
    overflow-y: auto;
}

/* 心声卡片样式 */
.modal-body .profile-section {
    background-color: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    gap: 12px;
}

.modal-body .profile-section-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding-bottom: 12px;
    border-bottom: 1px solid #f0f0f0;
}

.modal-body .profile-section label {
    font-size: 15px;
    font-weight: 600;
    color: #555;
    margin: 0;
}

.modal-body .profile-section p {
    font-size: 15px;
    color: #333;
    line-height: 1.7;
    margin: 0;
    white-space: pre-wrap;
}

/* 调整状态文本样式 */
#status-modal-thought {
    margin: 0 !important;
    color: #333333 !important;
    font-size: 15px !important;
    line-height: 1.8 !important;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
}

/* 心声和散记的内容结构样式 */
.modal-body .thought-content {
    margin-bottom: 0;
}

.modal-body .thought-content:last-child {
    margin-bottom: 0;
}

.modal-body .thought-content .voice,
.modal-body .thought-content .jottings {
    margin-bottom: 20px;
}

.modal-body .thought-content .jottings {
    margin-top: 0;
}

/* 心声和散记的标签样式 */
.modal-body .thought-content .label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    color: #000000;
    font-size: 13px;
    margin-bottom: 8px;
}

.modal-body .thought-content .label svg {
    width: 16px;
    height: 16px;
}

/* 心声和散记的文本内容样式 */
.modal-body .thought-content .text {
    font-size: 14px;
    color: #000000;
    line-height: 1.7;
    white-space: pre-wrap;
    word-wrap: break-word;
    margin: 0;
    padding-left: 0;
}

/* 群聊心声列表项样式 */
#group-status-modal .modal-body .group-member-thought {
    margin-bottom: 16px !important;
    text-align: left;
    padding-bottom: 12px;
    border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
}

#group-status-modal .modal-body .group-member-thought:last-child {
    border-bottom: none !important;
    margin-bottom: 0 !important;
}

#group-status-modal .modal-body .member-name {
    font-weight: 600;
    color: #1E1E1E;
    margin-bottom: 6px;
    font-size: 14px;
}

#group-status-modal .modal-body .member-thought {
    color: #333333;
    font-size: 14px;
    line-height: 1.7;
    white-space: pre-wrap;
    word-wrap: break-word;
}
/* ▲▲▲ 便签纸样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】修复心声与散记弹窗字体大小与对齐 ▼▼▼ */

/* 1. 统一内容字体大小，并确保左边距一致 */
#status-modal .modal-body .thought-content .text,
#group-status-modal .modal-body .thought-content .text {
    font-size: var(--chat-font-size, 15px); /* 使用聊天字体大小, 并设置一个适中的默认值 */
    color: #333333; /* 统一颜色为深灰色，确保清晰 */
    line-height: 1.8; /* 统一行高，增加可读性 */
    padding-left: 0; /* 强制左内边距为0 */
    margin-left: 0;  /* 强制左外边距为0 */
    /* 移除旧的特定颜色设置（如果存在），让它继承 */
}

/* 2. 统一标题字体大小 */
#status-modal .modal-body .thought-content .label,
#group-status-modal .modal-body .thought-content .label {
    font-size: var(--chat-font-size, 15px); /* 使用聊天字体大小 */
    color: #000000; /* 统一标题颜色为黑色 */
    gap: 8px; /* 稍微调整图标和文字的间距 */
}

/* 3. 微调群聊弹窗内每个成员块的间距和分隔线 */
#group-status-modal .modal-body .thought-content {
    padding-bottom: 16px; /* 增加底部内边距 */
    margin-bottom: 16px; /* 增加底部外边距 */
    border-bottom: 1px dashed rgba(0, 0, 0, 0.1); /* 使用虚线分隔 */
}
#group-status-modal .modal-body .thought-content:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none; /* 最后一个不显示分隔线 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */


/* ▼▼▼ 【全新】预设 Part 选择按钮圆形美化样式 ▼▼▼ */

/* 1. 基础圆形按钮样式 */
#preset-part-save-panel-container .preset-part-btn {
    width: 32px;                 /* 设置宽度 */
    height: 32px;                /* 设置高度 */
    min-width: 32px;             /* 确保最小尺寸 */
    border-radius: 50%;          /* 使其变为圆形 */
    background-color: #1E1E1E;   /* 您指定的背景色 */
    border: none;                /* 移除边框 */
    padding: 0;                  /* 移除内边距 */
    cursor: pointer;             /* 鼠标指针样式 */
    display: flex;               /* 使用flex布局居中SVG */
    align-items: center;         /* 垂直居中 */
    justify-content: center;     /* 水平居中 */
    transition: opacity 0.2s, transform 0.1s; /* 添加过渡效果 */
}

/* 2. SVG 图标样式 */
#preset-part-save-panel-container .preset-part-btn svg {
    width: 18px;                 /* SVG宽度 */
    height: 18px;                /* SVG高度 */
    /* fill 或 stroke 颜色已在SVG代码中通过 'white' 指定 */
}

/* 3. 悬浮和点击效果 */
#preset-part-save-panel-container .preset-part-btn:hover {
    opacity: 0.8;                /* 悬浮时降低透明度 */
}

#preset-part-save-panel-container .preset-part-btn:active {
    transform: scale(0.9);       /* 点击时轻微缩小 */
}

/* (可选) 如果需要为特定按钮设置不同背景色，可以这样做：*/
/*
#preset-part-save-panel-container .part1-btn { background-color: #FFB6C1; }
#preset-part-save-panel-container .part2-btn { background-color: #DDA0DD; }
#preset-part-save-panel-container .cancel-part-btn { background-color: #999; }
*/

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */


/* ▼▼▼ 【新增】专门缩小"导入角色卡"按钮图标的尺寸 ▼▼▼ */
#import-character-card-btn svg {
    width: 21px !important;  /* 设置为你想要的宽度，例如 18px */
    height: 21px !important; /* 设置为你想要的高度，例如 18px */
}
/* ▲▲▲ 新增代码粘贴结束 ▲▲▲ */

/* ▼▼▼ 【新增】音乐搜索功能 CSS ▼▼▼ */

/* 搜索结果项样式 */
.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

.search-result-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
}

.search-result-item .artist {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.search-result-item .source {
    font-size: 10px;
    color: var(--accent-color);
    background-color: rgba(0, 123, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    margin-left: 8px;
    display: inline-block;
    width: fit-content;
}

/* 搜索源选择器 */
#music-source-selector-modal {
    z-index: 250 !important;
}

#music-search-results-modal {
    z-index: 250 !important;
}

/* 专辑图片旋转动画 */
#music-album-cover {
    transition: transform 0.3s ease;
}

#music-album-cover.rotating {
    animation: spin 10s linear infinite;
}

#music-album-cover.paused {
    animation-play-state: paused;
}

/* ▲▲▲ 音乐搜索功能 CSS 结束 ▲▲▲ */

/* ▼▼▼ 步骤 3：在 <style> 标签的末尾添加这段新代码 ▼▼▼ */
            #app-dock {
                position: absolute; /* 新增：将Dock改为绝对定位 */
                width: auto; /* 修改：让宽度自适应 */
                left: 15px; /* 修改：左右各留15px间距 (总共减少30px) */
                right: 15px; /* 修改：左右各留15px间距 */
                padding: 20px 25px; /* 气泡的内部边距 */
                /* 适配iPhone底部安全区，让它紧贴底部但又不会被小黑条挡住 */
                padding-bottom: 20px; /* 修改：安全区已由 'bottom' 属性处理 */
                bottom: calc(5px + env(safe-area-inset-bottom)); /* 修改：使用你指定的底部距离 (已修正为bottom) */

                /* 你要求的"圆润的气泡，浅白色透明"样式 */
                background-color: rgba(255, 255, 255, 0.2); /* 浅白色透明 */
                border-radius: 28px; /* 圆润的气泡 */
                backdrop-filter: blur(15px);
                -webkit-backdrop-filter: blur(15px);

                box-sizing: border-box;
                z-index: 100; /* 确保Dock在翻页容器上面 */
            }

/* 确保Dock内的app-row是均匀分布的 */
#app-dock .app-row {
    justify-content: center; /* 修改点：从 space-around 改为 center 居中 */
    gap: 35px; /* 修改点：在这里设置你想要的间距，35px会比原来的25px更宽 */
}
/* ▲▲▲ 步骤 3：添加结束 ▲▲▲ */

/* ▼▼▼ Profile 部分样式（从兔k1024.html复制） ▼▼▼ */
#profile-widget {
    position: relative;
    width: 100%;
    max-width: 380px;
    flex-shrink: 0;
}

#profile-banner-img {
    display: block;
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 24px 24px 0 0;
    position: relative;
    z-index: 1;
    mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
}

#profile-widget .profile-avatar-container {
    position: absolute;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: white;
    padding: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 3;
}

#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

#profile-widget .profile-info {
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.85) 20%, rgba(255, 255, 255, 0));
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    border-radius: 24px;
    margin-top: -24px;
    padding-top: 54px;
    min-height: 120px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: 15px;
    padding-right: 15px;
    padding-bottom: 15px;
    text-align: center;
    color: #1c1c1e;
    position: relative;
    z-index: 2;
}

#profile-username {
    font-size: 18px;
    font-weight: 600;
    margin: 0 0 2px 0;
}

#profile-sub-username {
    font-size: 13px;
    color: #8a8a8a;
    margin: 0 0 10px 0;
}

#profile-bio {
    font-size: 14px;
    margin: 0 0 12px 0;
    color: #333;
}

#profile-location {
    font-size: 12px;
    color: #8a8a8a;
    margin: 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background-color: rgba(0,0,0,0.05);
    padding: 3px 9px;
    border-radius: 10px;
}

.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(0, 0, 0, 0.4);
    opacity: 0.85;
    border-radius: 4px;
}

/* Dark Mode适配 */
#phone-screen.dark-mode #profile-widget .profile-info {
    background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0));
    color: #f9fafb;
}

#phone-screen.dark-mode #profile-username,
#phone-screen.dark-mode #profile-bio,
#phone-screen.dark-mode #profile-location span {
    color: #f9fafb;
}

#phone-screen.dark-mode #profile-sub-username,
#phone-screen.dark-mode #profile-location {
    color: #9ca3af;
}

#phone-screen.dark-mode #profile-location {
    background-color: rgba(255,255,255,0.1);
}
/* ▲▲▲ Profile 部分样式结束 ▲▲▲ */

/* ▼▼▼ 隐藏clock-container并调整Profile位置 ▼▼▼ */
            #clock-container {
                display: none;
            }
            #profile-widget {
                margin-top: 10px; /* (原-20px + 30px) */
                padding-top: 0;
            }
            /* ▲▲▲ 调整结束 ▲▲▲ */

/* ▼▼▼ 主内容容器（Widget + AppGrid水平布局） ▼▼▼ */
            #main-content-wrapper {
                display: flex;
                flex-direction: row;
                gap: 15px;
                width: 100%;
                max-width: 380px;
                margin-top: 60px; /* (原20px + 40px) */
                /* align-items: flex-start; */ /* 移除：注释掉此行，允许子元素垂直拉伸 */
                flex: 1; /* 新增：让这个容器填满 profile 和 app-dock 之间的所有垂直空间 */
            }

/* ▼▼▼ Desktop Widget Column 样式（从330机复制） ▼▼▼ */
        #desktop-widget-column {
            display: flex;
            flex-direction: column;
            gap: 35px; /* 修改：固定垂直间距为 35px */
            flex: 0 0 auto;
            width: 160px;
        }

.desktop-widget {
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 18px;
    padding: 12px 15px;
    color: #1f1f1f;
    font-weight: 500;
    font-size: 13px;
    display: flex;
    align-items: center;
}

.desktop-widget.text-only {
            width: 190px; /* 新增：使其宽度与下面的小组件一致 */
            background-color: transparent;
            border: none;
            padding: 0;
            box-shadow: none;
            justify-content: flex-start;
        }

.desktop-widget.icon-left {
    width: 160px;
    justify-content: flex-start;
    gap: 8px;
    flex-direction: row;
}

.desktop-widget.icon-left img {
    flex-shrink: 0;
}

.desktop-widget.icon-left span {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.desktop-widget.icon-right {
    width: 160px;
    justify-content: flex-start;
    gap: 8px;
    flex-direction: row;
}

.desktop-widget.icon-right img {
    flex-shrink: 0;
    order: 2;
}

.desktop-widget.icon-right span {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    order: 1;
}

.desktop-widget img {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
}

.desktop-widget p, .desktop-widget span {
    margin: 0;
}

.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(255, 255, 255, 0.8);
    cursor: pointer;
    opacity: 0.9;
    border-radius: 4px;
}
/* ▲▲▲ Desktop Widget Column 样式结束 ▲▲▲ */


/* ▼▼▼ 【新增】修复 .back-btn.circle-btn 空心图标样式 ▼▼▼ */
/*
  这个新规则的优先级更高，
  它会覆盖掉 .circle-btn svg 的默认空心设置
*/
.back-btn.circle-btn svg {
    width: 16px;
    height: 16px;
    fill: white;   /* 1. 将图标的填充色设为白色 */
    stroke: none;  /* 2. 移除图标的描边 */
    vertical-align: middle;
    flex-shrink: 0;
    transform: translate(0, 0);
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */

/* ▼▼▼ 【修正】修复返回按钮和保存按钮的空心图标 ▼▼▼ */
/*
  这个规则用逗号分开了两个选择器，
  它会同时对 .back-btn 和 .save-btn 生效
*/
.back-btn.circle-btn svg,
.circle-btn.save-btn svg {
    width: 16px;
    height: 16px;
    fill: white;   /* 1. 将图标的填充色设为白色 */
    stroke: none;  /* 2. 移除图标的描边 */
    vertical-align: middle;
    flex-shrink: 0;
    transform: translate(0, 0);
}
/* ▲▲▲ 修正样式结束 ▲▲▲ */

/* ▼▼▼ 【新增】单独调整×符号位置（往左） ▼▼▼ */
#cancel-contact-picker-btn svg {
    transform: translate(-1px, 0) !important;
}
/* ▲▲▲ 调整结束 ▲▲▲ */

/* ▼▼▼ 【新增】单独调整对勾符号位置（往下往右） ▼▼▼ */
#confirm-contact-picker-btn svg {
    transform: translate(6px, 5px) !important;
}
/* ▲▲▲ 调整结束 ▲▲▲ */

/* 【新增】骰子动画样式 */
@keyframes dice-roll {
    0% {
        transform: scale(1) rotate(0deg);
    }
    25% {
        transform: scale(1.2) rotate(180deg);
    }
    50% {
        transform: scale(0.9) rotate(360deg);
    }
    75% {
        transform: scale(1.1) rotate(540deg);
    }
    100% {
        transform: scale(1) rotate(720deg);
    }
}

.dice-container {
    display: inline-block;
    margin: 0;
    position: relative;
    top: 20px;
}

/* 骰子消息气泡特殊样式 - 透明背景,不显示气泡 */
.dice-message-bubble {
    background: transparent !important;
    box-shadow: none !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
    gap: 8px;
    margin-bottom: 0 !important;
}

.dice-message-bubble .content {
    background: transparent !important;
}

.dice-message-bubble .avatar {
    align-self: center;
}

/* 骰子消息wrapper样式 - 减小上下间距 */
.message-wrapper:has(.dice-message-bubble) {
    margin: -5px 0 !important;
    margin-top: -25px !important;
}

/* 骰子后面的系统消息样式 - 调整上边距 */
.message-wrapper:has(.dice-message-bubble) + .message-wrapper.system-pat {
    margin-top: 15px !important;
}

/* 骰子前面的消息 - 减小下边距 */
.message-wrapper:has(+ .message-wrapper:has(.dice-message-bubble)) {
    margin-bottom: -0px !important;
}

/* 缩短地图聊天输入框宽度 */
.map-chat-input {
    width: 85% !important;
}

/* 私信输入框固定底部 - 第一步：给滚动区域加底部内边距 */
#message-detail-scrollable {
    padding-bottom: 120px !important;
    box-sizing: border-box !important;
}

/* 私信输入框固定底部 - 第二步：固定输入框位置 */
.message-input-area {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    z-index: 10 !important;
    border-top: 1px solid var(--x-border-color) !important;
    padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
}

/* ▼▼▼ 【全新】"kk查岗"功能样式 ▼▼▼ */

/* 角色选择屏幕 */
#kk-char-selection-screen {
  min-height: 100%;
  min-height: calc(var(--vh, 1vh) * 100);
}

/* 监控屏幕 */
#kk-monitor-screen {
  min-height: 100%;
  min-height: calc(var(--vh, 1vh) * 100);
}

/* 角色选择列表样式 */
.character-select-item {
  display: flex;
  align-items: center;
  padding: 10px 15px;
  border-bottom: 1px solid var(--border-color);
  cursor: pointer;
}
.character-select-item:hover {
  background-color: #f5f5f5;
}
.character-select-item img {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  margin-right: 12px;
}
.character-select-item .name {
  font-weight: 500;
}

/* 房屋总览 */
#kk-house-view-screen {
  display: flex;
  flex-direction: column;
  color: white;
  min-height: 100%;
  min-height: calc(var(--vh, 1vh) * 100);
}
#kk-house-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  filter: blur(5px) brightness(0.7);
  transform: scale(1.1);
}
#kk-house-info-panel {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 20px;
  padding-bottom: calc(20px + env(safe-area-inset-bottom));
  background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
  text-align: center;
}
#kk-house-location {
  margin: 0 0 10px;
  font-size: 24px;
  font-weight: bold;
}
#kk-house-description {
  margin: 0 0 20px;
  font-size: 14px;
  opacity: 0.9;
}
#kk-house-areas {
  display: flex;
  justify-content: center;
  gap: 15px;
  flex-wrap: wrap;
}
.kk-area-button {
  padding: 12px 25px;
  border: 1px solid rgba(255, 255, 255, 0.5);
  background-color: rgba(255, 255, 255, 0.1);
  color: white;
  border-radius: 20px;
  cursor: pointer;
  backdrop-filter: blur(5px);
}

/* 区域探索 */
#kk-area-view-screen {
  display: flex;
  flex-direction: column;
  min-height: 100%;
  min-height: calc(var(--vh, 1vh) * 100);
}
#kk-area-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  filter: brightness(0.6);
}
.kk-item-list-container {
  position: relative;
  z-index: 1;
  margin-top: 60px;
  padding: 20px;
  padding-bottom: calc(20px + env(safe-area-inset-bottom));
  color: white;
  flex-grow: 1;
  overflow-y: auto;
}
#kk-area-description {
  font-size: 18px;
  margin: 0 0 10px;
  font-weight: 500;
  background-color: rgba(0, 0, 0, 0.45);
  -webkit-backdrop-filter: blur(8px);
  backdrop-filter: blur(8px);
  color: #ffffff;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
  padding: 10px 15px;
  border-radius: 12px;
  line-height: 1.6;
}
.kk-instruction-text {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 20px;
}
#kk-area-items-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 15px;
}
.kk-item-button {
  padding: 20px 10px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  background-color: rgba(0, 0, 0, 0.4);
  color: white;
  border-radius: 12px;
  cursor: pointer;
  font-size: 16px;
  backdrop-filter: blur(3px);
  transition: background-color 0.2s;
}
.kk-item-button:hover {
  background-color: rgba(0, 0, 0, 0.6);
}

/* 电脑界面 */
#kk-computer-desktop {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  padding: 20px;
  padding-bottom: calc(20px + env(safe-area-inset-bottom));
  align-content: flex-start;
  justify-items: center;
}
.kk-desktop-icon {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  width: 70px;
  cursor: pointer;
  text-align: center;
}
.kk-desktop-icon img {
  width: 60px;
  height: 60px;
  border-radius: 12px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}
.kk-desktop-icon span {
  font-size: 13px;
  color: #333;
}

/* 文件浏览器 */
#kk-file-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.kk-file-item {
  padding: 12px 15px;
  background-color: #f5f5f5;
  border-radius: 8px;
  cursor: pointer;
  font-family: monospace;
}
.kk-file-item:hover {
  background-color: #e9e9e9;
}

/* Steam游戏列表项 */
.character-data-item {
  position: relative;
  padding: 12px 40px 12px 15px;
  background-color: #f5f5f5;
  border-radius: 8px;
  margin-bottom: 8px;
}
.character-data-item .title {
  font-weight: 500;
  margin-bottom: 4px;
}
.character-data-item .content {
  font-size: 13px;
  color: #666;
}
.item-delete-btn {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  width: 24px;
  height: 24px;
  border: none;
  background-color: #ff4444;
  color: white;
  border-radius: 50%;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}
.item-delete-btn:hover {
  background-color: #cc0000;
}

/* 监控功能样式 */
#kk-monitor-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  padding: 15px;
  padding-bottom: calc(15px + env(safe-area-inset-bottom));
  height: 100%;
  overflow-y: auto;
  box-sizing: border-box;
}

.kk-monitor-item {
  position: relative;
  height: 450px;
  border-radius: 16px;
  background-size: cover;
  background-position: center;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
}

.kk-monitor-item .monitor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), transparent);
  color: white;
  font-weight: bold;
  font-size: 16px;
  text-shadow: 0 1px 3px black;
}

.kk-monitor-item .rec-dot {
  width: 12px;
  height: 12px;
  background-color: #ff3b30;
  border-radius: 50%;
  animation: pulse-rec 1.5s infinite;
}

@keyframes pulse-rec {
  0% {
    opacity: 1;
    box-shadow: 0 0 5px #ff3b30;
  }
  50% {
    opacity: 0.4;
    box-shadow: 0 0 15px #ff3b30;
  }
  100% {
    opacity: 1;
    box-shadow: 0 0 5px #ff3b30;
  }
}

.frosted-glass-panel {
  margin: 15px;
  background-color: rgba(0, 0, 0, 0.25);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  padding: 15px;
  color: white;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.monitor-content-text {
  font-size: 14px;
  line-height: 1.7;
  max-height: 120px;
  overflow-y: auto;
  margin-bottom: 10px;
}

.monitor-interaction-controls {
  margin-top: 15px;
  display: flex;
  justify-content: space-around;
  align-items: center;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
  padding-top: 12px;
}

.monitor-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  font-size: 22px;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color 0.2s;
}

.monitor-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

.kk-monitor-item.active-character-location {
  border: 2px solid #00ff80;
  box-shadow: 0 0 20px rgba(0, 255, 128, 0.5);
}

/* ▲▲▲ "kk查岗"样式结束 ▲▲▲ */

  </style>

  <!-- 加载屏幕样式和脚本 -->
  <style>
    /* 加载屏幕容器 */
    #page-loading-overlay {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: 100% !important;
      background-color: #F7F7F7 !important;
      display: flex !important;
      justify-content: center !important;
      align-items: center !important;
      z-index: 99999 !important;
      opacity: 1 !important;
      visibility: visible !important;
      transition: opacity 0.5s ease, visibility 0.5s ease !important;
    }

    /* 加载屏幕隐藏状态 */
    #page-loading-overlay.hidden {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* 加载动画容器 */
    .page-loading-content {
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      gap: 30px !important;
    }

    /* 加载动画图片 - 上下飘动 */
    .page-loading-spinner {
      width: 100px !important;
      height: 100px !important;
      background-size: contain !important;
      background-repeat: no-repeat !important;
      background-position: center !important;
      animation: page-loading-float 3s ease-in-out infinite !important;
    }

    /* 上下飘动效果 */
    @keyframes page-loading-float {
      0%, 100% {
        transform: translateY(0px);
      }
      25% {
        transform: translateY(-15px);
      }
      50% {
        transform: translateY(0px);
      }
      75% {
        transform: translateY(-10px);
      }
    }

    /* 加载提示文字 */
    .page-loading-text {
      font-size: 14px !important;
      color: #6B6B6B !important;
      font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
      text-align: center !important;
      letter-spacing: 0.5px !important;
    }
  </style>

  <script>
    // 页面加载动画控制
    (function() {
      // 默认加载动画 URL
      let customLoadingUrl = 'https://iili.io/KlDHDmX.png';

      // 尝试从 localStorage 读取之前保存的自定义 URL
      try {
        const savedUrl = localStorage.getItem('customLoadingAnimationUrl');
        console.log('从 localStorage 读取的 URL:', savedUrl);
        if (savedUrl) {
          customLoadingUrl = savedUrl;
          console.log('使用自定义加载动画 URL:', customLoadingUrl);
        } else {
          console.log('没有找到保存的 URL，使用默认:', customLoadingUrl);
        }
      } catch (e) {
        console.error('读取localStorage失败:', e);
      }

      // 创建加载屏幕 HTML
      const loadingHTML = `
        <div id="page-loading-overlay">
          <div class="page-loading-content">
            <div class="page-loading-spinner" style="background-image: url('${customLoadingUrl}');"></div>
          </div>
        </div>
      `;

      console.log('加载屏幕 HTML:', loadingHTML);

      // 在 HTML 解析到这里时立即注入加载屏幕
      document.write(loadingHTML);

      // 【新增】定义隐藏加载动画的函数，提前定义以便window.load事件使用
      window.hidePageLoadingOverlay = function() {
        const overlay = document.getElementById('page-loading-overlay');
        if (!overlay || overlay.classList.contains('hidden')) return;
        overlay.classList.add('hidden');
        setTimeout(() => {
          const currentOverlay = document.getElementById('page-loading-overlay');
          if (currentOverlay) {
            currentOverlay.remove();
          }
        }, 500);
      };

      // 【修改】加载动画由preloadAllStickersInBackground控制
      // 前5个角色的表情包加载完后就会隐藏加载动画
      // 不再有fallback强制隐藏
      window.addEventListener('load', function() {
        // 这里不再做任何事，加载动画的隐藏完全由preloadAllStickersInBackground控制
      });
    })();
  </script>
</head>
<body>
        <div id="phone-screen">

            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>
            
            <div id="home-screen" class="screen active">
                <!-- 可滑动的页面容器 -->
                <div id="home-pages-container">
                    <div class="home-pages-wrapper">
                        <!-- 第一页 -->
                        <div class="home-page" data-page="0">
                            <div id="clock-container"><div id="main-time">12:00</div><div id="main-date">星期一, 1月1日</div></div>

                            <!-- ▼▼▼ Profile 元素（从兔k1024.html复制） ▼▼▼ -->
                            <div id="profile-widget">
                                <img id="profile-banner-img" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image">
                                <div class="profile-avatar-container">
                                    <img id="profile-avatar-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
                                </div>
                                <div class="profile-info">
                                    <p id="profile-username" class="editable-text">你的昵称</p>
                                    <p id="profile-sub-username" class="editable-text">@your_id</p>
                                    <p id="profile-bio" class="editable-text">点击这里编辑你的个性签名</p>
                                    <p id="profile-location" class="editable-text" data-placeholder="点击编辑地点"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg><span>点击编辑地点</span></p>
                                </div>
                            </div>
                            <!-- ▲▲▲ Profile 元素结束 ▲▲▲ -->

                            <!-- ▼▼▼ 主内容容器（Widget + AppGrid水平布局） ▼▼▼ -->
                            <div id="main-content-wrapper">
                                <!-- ▼▼▼ Desktop Widget Column（从330机复制） ▼▼▼ -->
                                <div id="desktop-widget-column">
                                    <div class="desktop-widget text-only">
                                        <p id="widget-text-1" class="editable-text">Be fearless in pursuit of happiness</p>
                                    </div>
                                    <div class="desktop-widget icon-left">
                                        <img id="widget-avatar-1" src="https://i.imgur.com/1n3a43H.jpeg" class="editable-image">
                                        <span id="widget-text-2" class="editable-text">Dare to be different</span>
                                    </div>
                                    <div class="desktop-widget icon-right">
                                        <span id="widget-text-3" class="editable-text">* Keep your spirit free</span>
                                        <img id="widget-avatar-2" src="https://i.imgur.com/5A0tE9a.jpeg" class="editable-image">
                                    </div>
                                </div>
                                <!-- ▲▲▲ Desktop Widget Column 结束 ▲▲▲ -->

                                <!-- ▼▼▼ App Grid容器 ▼▼▼ -->
                                <div id="app-grid">
                            <div class="app-row"> <div class="app-icon" onclick="showScreen('world-book-screen')">
                                    <div class="icon-bg">
                                        <img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界书">
                                    </div>
                                    <span class="label">世界书</span>
                                </div>
                                <div class="app-icon" onclick="showScreen('chat-list-screen')">
                                    <div class="icon-bg">
                                        <img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ">
                                    </div>
                                    <span class="label">Chat</span>
                                </div>
                            </div>
                            <div class="app-row"> <div class="app-icon" onclick="showScreen('forum-screen')">
                                    <div class="icon-bg">
                                        <img id="icon-img-forum" src="https://i.postimg.cc/W3y7GZ1W/IMG-6443.jpg" alt="论坛">
                                    </div>
                                    <span class="label">论坛</span>
                                </div>
                                                    <div class="app-icon" onclick="showScreen('x-social-screen')">
                                                <div class="icon-bg">
                                                    <img id="icon-img-x-social" src="https://i.postimg.cc/YChdnZ7y/IMG-7390.png" alt="X软件">
                                                </div>
                                                <span class="label">X软件</span>
                                            </div>
                            </div>
                                </div>
                                <!-- ▲▲▲ App Grid 结束 ▲▲▲ -->
                            </div>
                            <!-- ▲▲▲ 主内容容器结束 ▲▲▲ -->
                        </div>

                        <!-- 第二页 -->
                        <div class="home-page" data-page="1">
                            <!-- 音乐播放器装饰组件 -->
                            <div id="music-widget">
                                <div class="music-widget-container">
                                    <img id="music-cover-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image music-cover">
                                    <p id="music-title" class="editable-text music-title">点击编辑歌曲名</p>

                                    <!-- 进度条 -->
                                    <div class="music-progress-container">
                                        <span class="music-time">2:46</span>
                                        <div class="music-progress-bar">
                                            <div class="music-progress-fill"></div>
                                        </div>
                                        <span class="music-time">4:50</span>
                                    </div>

                                    <!-- 播放控制按钮 -->
                                    <div class="music-controls">
                                        <button class="music-btn">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                                            </svg>
                                        </button>
                                        <button class="music-btn music-btn-large">
                                            <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                                            </svg>
                                        </button>
                                        <button class="music-btn">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                                            </svg>
                                        </button>
                                    </div>

                                    <p id="music-widget-label" class="editable-text music-widget-label">Colorful Widget</p>
                                </div>
                            </div>

                            <!-- 小卡片组件 -->
                            <div id="mini-card-widget">
                                <img id="mini-card-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image mini-card-image">
                                <p id="mini-card-text" class="editable-text mini-card-text">点击编辑文字</p>
                            </div>

                            <!-- kk查岗入口按钮 -->
                            <div id="kk-checkin-entry" style="display: flex; flex-direction: column; align-items: center; margin-top: -190px; margin-left: 70px; cursor: pointer;">
                                <div style="width: 60px; height: 60px; border-radius: 12px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1); background-color: var(--secondary-bg);">
                                    <img id="kk-checkin-icon-img" src="https://i.postimg.cc/MGwrL0nf/kitty.png" alt="查岗" style="width: 100%; height: 100%; object-fit: cover;">
                                </div>
                                <p style="margin-top: 8px; font-size: 12px; color: #666; font-weight: 500;">查岗</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 分页指示器 -->
                <div id="home-page-indicator">
                    <span class="page-dot active"></span>
                    <span class="page-dot"></span>
                </div>

            <div id="app-dock">
                <div class="app-row">
                    <div class="app-icon" onclick="showScreen('api-settings-screen')">
                        <div class="icon-bg">
                            <img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API设置">
                        </div>
                        <span class="label">API设置</span>
                    </div>
                    <div class="app-icon" onclick="showScreen('preset-manager-screen')">
                        <div class="icon-bg">
                            <img id="icon-img-preset" src="https://i.postimg.cc/jS7VFFzK/48f6a5613i7390a98ea9534f61ff5fde.png" alt="预设库">
                        </div>
                        <span class="label">预设</span>
                    </div>
                    <div class="app-icon" onclick="showScreen('wallpaper-screen')">
                        <div class="icon-bg">
                            <img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外观设置">
                        </div>
                        <span class="label">外观设置</span>
                    </div>
                    <div class="app-icon" onclick="showScreen('font-settings-screen')">
                        <div class="icon-bg">
                            <img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字体">
                        </div>
                        <span class="label">字体</span>
                    </div>
                </div>
            </div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
            </div>
          

<div id="world-book-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="world-book-back-btn">‹</span>
        
        <span id="world-book-default-title">世界书</span>
        <span id="world-book-selection-title" style="display: none;">已选择 0 项</span>

        <div class="header-actions">
            <div id="wb-default-controls">
                <span class="action-btn" id="add-world-book-btn">+</span>
            </div>
            <div id="wb-selection-controls" style="display: none;">
                <button id="wb-delete-btn" class="circle-btn" title="删除" style="background-color: #AB4D3F;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v6M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <div id="world-book-list"></div>
</div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 设置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p><div class="form-group"><label for="proxy-url">反代地址 (不需要添加/v1噢~)</label><input type="text" id="proxy-url" placeholder="例如: https://api.openai.com"></div><div class="form-group"><label for="api-key">密钥 (直连轮询用英文逗号隔开)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">模型</label><select id="model-select"></select></div><div class="form-group"><label for="temperature-slider">API温度 (Temperature): <span id="temperature-value">0.8</span></label><input type="range" id="temperature-slider" min="0" max="2" step="0.1" value="0.8" style="width: 100%; accent-color: #000000;"></div><button class="form-button" id="fetch-models-btn">拉取模型</button>

<!-- ▼▼▼ 【Minimax TTS】语音设置开始 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">以下是 Minimax 语音（TTS）的设置，用于AI发送语音消息。</p>

<!-- 🔥【新增】服务区选择 -->
<div class="form-group">
    <label for="minimax-domain-select">Minimax TTS 服务区</label>
    <select id="minimax-domain-select" class="form-input">
        <option value="https://api.minimax.chat">🇨🇳 国内 (api.minimax.chat)</option>
        <option value="https://api.minimaxi.chat">🌏 海外 (api.minimaxi.chat)</option>
    </select>
</div>

<div class="form-group">
    <label for="minimax-group-id">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="输入你的 Minimax Group ID">
</div>
<div class="form-group">
    <label for="minimax-api-key">Minimax API Key</label>
    <input type="password" id="minimax-api-key" placeholder="输入你的 Minimax API Key">
</div>
<div class="form-group">
    <label for="minimax-speech-model-select">Minimax 语音模型 (TTS Model)</label>
    <select id="minimax-speech-model-select" class="form-input">
        <!-- 选项将由JS填充 -->
    </select>
</div>
<button class="form-button" id="fetch-minimax-speech-models-btn">拉取语音模型</button>
<!-- ▲▲▲ 【Minimax TTS】语音设置结束 ▲▲▲ -->

<!-- ▼▼▼ API预设功能开始 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group">
    <label>API预设管理</label>
    <button class="form-button" id="save-api-preset-btn" style="background-color: #28a745; margin-bottom: 10px;">保存当前配置为预设</button>
    <div id="api-presets-list" style="margin-top: 10px;">
        <!-- 预设列表将动态加载到这里 -->
    </div>
</div>
<!-- ▲▲▲ API预设功能结束 ▲▲▲ -->

<!-- ▼▼▼ 将这段代码粘贴到 API 设置页面的"保存设置"按钮上方 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        启用后台角色活动
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：此功能会显著增加API调用和费用！
        </p>
    </label>
    <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 将这段代码粘贴到“启用后台角色活动”开关的下方 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="background-interval-input" style="margin-bottom: 0;">
        后台活动检测间隔 (秒)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            建议值 60-300。值越大，费用越低，但角色反应越慢。
        </p>
    </label>
    <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑后冷静期 (小时)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超过这个时间后，AI才有几率重新申请好友。
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 新增通知音频URL ▼▼▼ -->
<div class="form-group">
    <label for="notification-sound-url">
        通知消息提示音 (音频URL)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            填入音频URL（如catbox链接），通知栏出现时自动播放。留空则不播放声音。
        </p>
    </label>
    <input type="text" id="notification-sound-url" placeholder="例如: https://files.catbox.moe/xxxxx.mp3" style="width: 100%;">
</div>
<!-- ▲▲▲ 通知音频URL结束 ▲▲▲ -->

<!-- ▼▼▼ 系统级通知设置 ▼▼▼ -->
<div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label style="margin-bottom: 0;">
            允许系统推送
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                iOS需添加到主屏幕才能生效
            </p>
        </label>
        <button id="enable-system-notifications-btn" style="padding: 8px 15px; background-color: #1e1e1e; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">点击授权</button>
    </div>
    <div class="form-group" style="display: flex; justify-content: space-between; align-items: flex-start; gap: 10px;">
        <div style="display: flex; flex-direction: column;">
            <label style="margin-bottom: 0; display: block;">
                测试系统通知
            </label>
            <div id="notification-status" style="font-size: 12px; color: #999; margin-top: 8px; padding: 4px 8px; background-color: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 6px; text-align: left; width: fit-content;">
                状态: 未授权
            </div>
        </div>
        <button id="test-system-notify-btn" style="padding: 8px 15px; background-color: #1e1e1e; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; white-space: nowrap;">发送测试</button>
    </div>
</div>
<!-- ▲▲▲ 系统级通知设置结束 ▲▲▲ -->

<!-- ▼▼▼ NovelAI 图像生成系统配置 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="novelai-switch" style="margin-bottom: 0;">
        启用 NovelAI 图像生成
       
        </p>
    </label>
    <input type="checkbox" id="novelai-switch" style="width: auto; height: 20px;">
</div>

<div id="novelai-details" style="display: none;">
    <div class="form-group">
        <label for="novelai-model" style="color: #333;">NovelAI 模型</label>
        <select id="novelai-model" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; border-radius: 4px;">
            <option value="nai-diffusion-4-curated-preview">NAI Diffusion V4.5 Curated (精选版无nsfw)</option>
            <option value="nai-diffusion-4-5-full">NAI Diffusion V4.5 Full（完整版含nsfw）</option>
            <option value="nai-diffusion-3">NAI Diffusion Anime V3（旧版）</option>
            <option value="nai-diffusion-furry-3">NAI Diffusion Furry V3（旧旧版）</option>
        </select>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            💡 必须有oplus订阅的apikey才可以使用！
        </p>
    </div>

    <div class="form-group">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label for="novelai-api-key" style="color: #333; margin-bottom: 0;">NovelAI API Key</label>
            <span id="novelai-key-toggle" style="cursor: pointer; user-select: none; font-size: 18px;">🔑</span>
        </div>
        <div style="position: relative; width: 100%;">
            <input type="password" id="novelai-api-key" placeholder="pst-xxxxxxxxxxxxxxxx" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding-right: 15px; width: 100%; box-sizing: border-box;">
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            💡 在 <a href="https://novelai.net" target="_blank" style="color: #007bff;">NovelAI官网</a> 获取API Key
        </p>
    </div>

    <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button type="button" id="novelai-settings-btn" style="flex: 1; background-color: #1e1e1e; border: none; padding: 10px 20px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; color: white;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="white" stroke="none">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6M4.22 4.22l4.24 4.24m3.08 3.08l4.24 4.24M1 12h6m6 0h6m-17.78 7.78l4.24-4.24m3.08-3.08l4.24-4.24" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
            </svg>
            
        </button>
        <button type="button" id="novelai-test-btn" style="flex: 1; background-color: #1e1e1e; border: none; padding: 10px 20px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; color: white;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
           
        </button>
    </div>
</div>
<!-- ▲▲▲ NovelAI 图像生成系统配置结束 ▲▲▲ -->

<button class="form-button" id="save-api-settings-btn">保存设置</button>
			<hr style="margin:20px 0; opacity:.3">

			<button class="form-button" id="export-data-btn">导出数据</button>

<!-- ▼▼▼ NovelAI 生成设置弹窗 ▼▼▼ -->
<div id="novelai-settings-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto;">
        <div class="modal-header" style="display: flex !important; justify-content: center !important; align-items: center !important; position: relative;">
            <span>NovelAI 生成设置</span>
            <span class="close" id="close-novelai-settings" style="cursor: pointer; font-size: 28px; font-weight: bold; position: absolute; right: 20px;">&times;</span>
        </div>
        <div class="modal-body" style="padding: 20px;">
            <div class="form-group">
                <label style="color: #333;">图像尺寸（oplus可无限出小图）</label>
                <select id="nai-resolution" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <optgroup label="小">
                        <option value="512x768">纵向 (512x768)</option>
                        <option value="768x512">横向 (768x512)</option>
                        <option value="640x640">正方形 (640x640)</option>
                    </optgroup>
                    <optgroup label="正常">
                        <option value="832x1216">竖图 (832x1216)</option>
                        <option value="1216x832">横图 (1216x832)</option>
                        <option value="1024x1024" selected>方图 (1024x1024)</option>
                    </optgroup>
                    <optgroup label="壁纸">
                        <option value="1088x1920">纵向 (1088x1920)</option>
                        <option value="1920x1088">风景 (1920x1088)</option>
                    </optgroup>
                </select>
                <small style="color: #666;">建议使用官方支持的标准尺寸以获得最佳效果</small>
            </div>

            <div class="form-group">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div>
                        <label style="color: #333; margin-bottom: 0; display: block;">采样步数 (Steps)</label>
                        <small style="color: #666; margin-top: 4px; display: block;">推荐值: 28 (值越高质量越好但耗时越长)</small>
                    </div>
                    <input type="number" id="nai-steps" value="28" min="1" max="50" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 80px; border-radius: 4px; flex-shrink: 0;">
                </div>
            </div>

            <div class="form-group">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div>
                        <label style="color: #333; margin-bottom: 0; display: block;">提示词相关性 (CFG Scale)</label>
                        <small style="color: #666; margin-top: 4px; display: block;">推荐值: 5 (控制图像与提示词的相关程度)</small>
                    </div>
                    <input type="number" id="nai-cfg-scale" value="5" min="1" max="20" step="0.5" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 80px; border-radius: 4px; flex-shrink: 0;">
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">采样器 (Sampler)</label>
                <select id="nai-sampler" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <option value="k_euler">Euler</option>
                    <option value="k_euler_ancestral" selected>Euler Ancestral</option>
                    <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                    <option value="k_dpmpp_2m">DPM++ 2M</option>
                    <option value="k_dpmpp_sde">DPM++ SDE</option>
                    <option value="ddim">DDIM</option>
                </select>
            </div>

            <div class="form-group">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div>
                        <label style="color: #333; margin-bottom: 0; display: block;">随机种子 (Seed)</label>
                        <small style="color: #666; margin-top: 4px; display: block;">-1 表示随机，固定种子可复现相同图像</small>
                    </div>
                    <input type="number" id="nai-seed" value="-1" min="-1" max="9999999999" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 80px; border-radius: 4px; flex-shrink: 0;">
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">负面提示词预设 (UC Preset)</label>
                <select id="nai-uc-preset" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <option value="0">Preset 0 - Heavy</option>
                    <option value="1" selected>Preset 1 - Light</option>
                    <option value="2">Preset 2 - Human Focus</option>
                    <option value="3">Preset 3 - None</option>
                </select>
            </div>

            <div class="form-group">
                <label style="color: #333;">质量标签</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="nai-quality-toggle" checked style="width: auto;">
                    <span style="color: #666; font-size: 14px;">自动添加质量提升标签</span>
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">SMEA (提升细节)</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="nai-smea" checked style="width: auto;">
                    <span style="color: #666; font-size: 14px;">启用SMEA增强</span>
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">SMEA DYN (动态优化)</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="nai-smea-dyn" style="width: auto;">
                    <span style="color: #666; font-size: 14px;">启用动态SMEA</span>
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">默认正面提示词</label>
                <textarea id="nai-default-positive" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="masterpiece, best quality, 1girl, beautiful...">masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style</textarea>
                <small style="color: #666;">此提示词将在生成时自动使用（如果测试弹窗中未填写）</small>
            </div>

            <div class="form-group">
                <label style="color: #333;">默认负面提示词</label>
                <textarea id="nai-default-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="lowres, bad anatomy, bad hands, text, error...">lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry</textarea>
            </div>

            <div class="form-group" style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px;">
                <label style="color: #333;">🌐 CORS 代理设置</label>
                <select id="nai-cors-proxy" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <option value="">❌ 直连（无代理）</option>
                    <option value="https://corsproxy.io/?">✅ corsproxy.io（推荐）</option>
                    <option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
                    <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere（需激活）</option>
                    <option value="custom">🔧 自定义代理</option>
                </select>
                <small style="color: #e74c3c; display: block; margin-top: 8px;">
                    ⚠️ 本地运行会遇到CORS跨域问题，需使用代理。推荐使用 corsproxy.io
                </small>
            </div>

            <div id="nai-custom-proxy-group" class="form-group" style="display: none;">
                <label style="color: #333;">自定义代理地址</label>
                <input type="text" id="nai-custom-proxy-url" placeholder="https://your-proxy.com/?" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                <small style="color: #666;">代理URL应以 / 或 ? 结尾，例如：https://proxy.com/?</small>
            </div>
        </div>
        <div class="modal-footer">
            <button id="reset-nai-settings-btn" class="form-button form-button-secondary" style="margin-right: 10px;">恢复默认</button>
            <button id="save-nai-settings-btn" class="form-button form-button-secondary">保存设置</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ NovelAI 生成设置弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ NovelAI 测试生成弹窗 ▼▼▼ -->
<div id="novelai-test-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header" style="display: flex !important; justify-content: center !important; align-items: center !important; position: relative;">
            <span>🖼️ NovelAI 测试生成</span>
            <span class="close" id="close-novelai-test" style="cursor: pointer; font-size: 28px; font-weight: bold; line-height: 1; position: absolute; right: 20px;">&times;</span>
        </div>
        <div class="modal-body" style="padding: 20px;">
            <div class="form-group">
                <label style="color: #333;">正面提示词（此处提示词仅用于该弹窗测试）</label>
                <textarea id="nai-test-prompt" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="1girl, solo, long hair, blue eyes, smile...">1girl, solo, long hair, blue eyes, smile, outdoors, cherry blossoms, spring</textarea>
            </div>

            <div class="form-group">
                <label style="color: #333;">负面提示词（可选，留空使用默认）</label>
                <textarea id="nai-test-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="留空将使用设置中的默认负面提示词"></textarea>
            </div>

            <div style="margin: 20px 0;">
                <button id="nai-generate-btn" style="background-color: #1E1E1E; color: white; border: none; padding: 12px 30px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; width: 100%; box-sizing: border-box;">
                    生成图像
                </button>
            </div>

            <div id="nai-test-status" style="text-align: center; color: #666; margin: 15px 0; display: none;">
                正在生成中，请稍候...
            </div>

            <div id="nai-test-result" style="display: none; margin-top: 20px;">
                <div style="font-weight: bold; color: #333; margin-bottom: 10px;">生成结果：</div>
                <div style="text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                    <img id="nai-result-image" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <button id="nai-download-btn" class="form-button-secondary" style="margin: 0;">下载图像</button>
                </div>
            </div>

            <div id="nai-test-error" style="display: none; margin-top: 15px; padding: 12px; background: #f8d7da; color: #721c24; border-radius: 6px; border: 1px solid #f5c6cb;"></div>
        </div>
        <div class="modal-footer">
            <button id="close-nai-test-btn" class="form-button">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ NovelAI 测试生成弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 角色专属NAI出图设置弹窗 ▼▼▼ -->
<div id="character-nai-prompts-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <span>角色专属NAI提示词配置</span>
            <span class="close" id="close-character-nai-prompts" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
        </div>
        <div class="modal-body">
            <p style="font-size: 13px; color: #666; margin-bottom: 20px; background-color: #f0f8ff; padding: 12px; border-radius: 6px; border-left: 3px solid #007bff;">
                💡 这里配置的提示词仅用于当前角色的NAI出图，不影响其他角色或系统设置
            </p>

            <div class="form-group">
                <label for="character-nai-positive" style="color: #333; font-weight: 600;">
                    正面提示词 (Positive Prompt)
                </label>
                <textarea id="character-nai-positive" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px;" placeholder="例如: masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style"></textarea>
                <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
                    描述你希望生成的图像风格，可填入画师串
                </small>
            </div>

            <div class="form-group">
                <label for="character-nai-negative" style="color: #333; font-weight: 600;">
                    负面提示词 (Negative Prompt)
                </label>
                <textarea id="character-nai-negative" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px;" placeholder="例如: lowres, bad anatomy, bad hands, text, error, missing fingers"></textarea>
                <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
                    描述你希望避免的元素
                </small>
            </div>
        </div>
        <div class="modal-footer">
            <button id="reset-character-nai-prompts-btn" class="form-button form-button-secondary" style="margin-right: 10px;">清空配置</button>
            <button id="save-character-nai-prompts-btn" class="form-button form-button-secondary">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 角色专属NAI出图设置弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】部分导出选择面板 ▼▼▼ -->
<div id="export-options-modal" class="modal">
    <div class="modal-content" style="width: 85%; max-width: 400px;">
        <div class="modal-header">
            <span>选择导出数据</span>
            <button class="action-button" id="close-export-modal" style="font-size: 20px; display: none;">×</button>
        </div>
        <div class="modal-body" style="padding: 20px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                    <input type="checkbox" id="export-chats" checked style="margin-right: 16px; cursor: pointer; flex-shrink: 0;">
                    <span>聊天记录</span>
                </label>
                <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                    <input type="checkbox" id="export-world-books" checked style="margin-right: 16px; cursor: pointer; flex-shrink: 0;">
                    <span>世界书</span>
                </label>
                <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                    <input type="checkbox" id="export-world-book-categories" checked style="margin-right: 16px; cursor: pointer; flex-shrink: 0;">
                    <span>世界书分类</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-presets-config" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>预设和配置</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（API、人设、气泡、提示词、全局设置）</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-qzone" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>QZone 空间</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（设置、动态、相册、照片、分组）</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-media" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>多媒体</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（贴纸、音乐）</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-other" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>其他内容</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（收藏、记忆、论坛帖子）</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-npc" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>NPC</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（自定义NPC设置）</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-call-records" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>通话记录</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（通话历史记录）</span>
                </label>
                <label style="display: flex; flex-direction: row; align-items: center; margin-bottom: 15px; cursor: pointer; flex-wrap: nowrap; min-width: 0;">
                    <input type="checkbox" id="export-character-nai-prompts" checked style="margin-right: 28px; cursor: pointer; flex-shrink: 0;">
                    <span>角色NAI提示词</span>
                    <span style="font-size: 11px; color: #888; margin-left: 2px; white-space: nowrap;">（每个角色的专属提示词）</span>
                </label>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-export-modal">取消</button>
            <button class="save" id="confirm-export-modal">导出</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 部分导出选择面板结束 ▲▲▲ -->

<!-- ① 普通按钮，和"导出"一个 class -->
<button class="form-button" id="import-btn">导入备份文件</button>
<hr style="margin:20px 0; opacity:.3">

<!-- ▼▼▼ 新增：本地备份和恢复功能 ▼▼▼ -->
<button class="form-button" id="save-local-backup-btn" style="background-color: #2196F3;">保存备份到本地</button>
<button class="form-button" id="restore-local-backup-btn" style="background-color: #FF9800;">从本地恢复备份</button>
<p id="local-backup-status" style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;"></p>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<hr style="margin:20px 0; opacity:.3">
<button class="form-button form-button-secondary" id="open-card-diagnostic-tool">角色卡诊断工具</button>

<!-- ② 真正的文件选择器，完全隐藏 -->
<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- 主头部 (只在消息列表显示) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <!-- ▼▼▼ 【新增】导入角色卡按钮 ▼▼▼ -->
            <span class="action-btn" id="import-character-card-btn" title="导入角色卡">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </span>
            <!-- ▲▲▲ 导入按钮结束 ▲▲▲ -->
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- 消息列表视图 -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JS会在这里生成聊天列表 -->
        </div>
    </div>

    <!-- 动态界面视图 -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
            <span>好友动态</span>
            <div class="header-actions">
            <button class="circle-btn" id="qzone-refresh-btn" title="刷新" style="margin-right: 8px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
            </button>
            <button class="circle-btn" id="qzone-autorefresh-btn" title="自动刷新设置" style="margin-right: 8px;">
                 <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="9"></circle>
                    <polyline points="12 6 12 12 16 14"></polyline>
                </svg>
            </button>
            <button class="circle-btn" id="qzone-npc-settings-btn" title="NPC设置">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
        </div>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                <div class="action-item" id="create-post-btn"><span>动态</span></div>
                <div class="action-item" id="open-album-btn"><span>相册</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- 收藏界面视图 -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header">
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>我的收藏</span>
        <!-- 新增的编辑按钮 -->
        <button class="circle-btn" id="favorites-edit-btn" title="编辑">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
        </button>
    </div>

        <!-- 【新增】角色选择器 -->
        <div id="favorites-character-selector" class="character-selector">
            <button class="char-btn char-btn-active" data-chat-id="all">全部收藏</button>
            <!-- 角色按钮将由JS动态生成 -->
        </div>

        <!-- 【修改】搜索栏容器 -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- 收藏内容将由JS动态生成在这里 -->
        </div>

<!-- 新增：收藏页底部操作栏 -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>我们的回忆</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 回忆卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
    
    <!-- 底部导航栏 -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>消息</span>
    </div>
    <div class="nav-item" data-view="qzone-screen" style="position: relative;">
        <span>动态</span>
        <span class="unread-indicator" style="display: none;"></span>
    </div>
    <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>回忆</span>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>收藏</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. 页面头部，包含返回按钮和标题 -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>我的相册</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- 相册列表将由 JS 动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. 页面头部 -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">相册名称</span>
        <span class="action-btn" id="album-upload-photo-btn">上传</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- 照片列表将由 JS 动态生成在这里 -->
        </div>

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. 关闭按钮 -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. 上一张照片按钮 -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. 图片容器 -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="全屏照片预览">
    </div>
    
    <!-- 4. 下一张照片按钮 -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

    <!-- 【最终修正版】Header，已将状态栏和搜索功能正确整合 -->
    <div class="header">
        <!-- 默认控件：包含标题、状态栏和常规按钮 -->
        <div class="default-controls">
            <span class="back-btn" id="back-to-list-btn">‹</span>
            
            <!-- ▼▼▼ 【核心新增】标题和状态的容器 ▼▼▼ -->
            <div id="chat-header-title-wrapper">
                <span id="chat-header-title">聊天对象</span>
                <div id="chat-header-status">
                    <span class="status-dot"></span>
                    <span class="status-text">在线</span>
                </div>
            </div>
            <!-- ▲▲▲ 新增结束 ▲▲▲ -->

            <div class="header-actions">
                <span class="action-btn" id="show-status-diary-btn" title="心声和散记">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 21.35L10.55 20.03C5.4 15.36 2 12.27 2 8.5C2 5.42 4.42 3 7.5 3C9.24 3 10.91 3.81 12 5.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5C22 12.27 18.6 15.36 13.45 20.03L12 21.35Z"/>
    </svg>
</span>
<span class="action-btn" id="chat-settings-btn" title="聊天设置">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <circle cx="5" cy="12" r="2"></circle>
        <circle cx="12" cy="12" r="2"></circle>
        <circle cx="19" cy="12" r="2"></circle>
    </svg>
</span>            </div>
        </div>

        <!-- 多选模式控件 (保持不变) -->
        <div class="selection-controls">
    <span id="selection-cancel-btn" class="circle-btn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
            <path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </span>
    <span id="selection-count"></span>
    <div class="header-actions">
       <span id="selection-select-below-btn" class="action-btn circle-btn" title="选中此条以下所有消息">
           <svg width="18" height="18" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
               <path d="M4 14H13" stroke="white" stroke-width="2" stroke-linecap="round"/>
               <path d="M4 18H13" stroke="white" stroke-width="2" stroke-linecap="round"/>
               <path d="M4 10H13" stroke="white" stroke-width="2" stroke-linecap="round"/>
               <path d="M17 6V18L20 15" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
           </svg>                       
       </span>
       <span id="selection-favorite-btn" class="action-btn circle-btn">
           <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
               <path d="M12 21.35L10.55 20.03C5.4 15.36 2 12.27 2 8.5C2 5.42 4.42 3 7.5 3C9.24 3 10.91 3.81 12 5.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5C22 12.27 18.6 15.36 13.45 20.03L12 21.35Z"/>
           </svg>
       </span>
       <span id="selection-share-btn" class="action-btn circle-btn"> 
           <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
               <path d="M18 8C19.6569 8 21 6.65685 21 5C21 3.34315 19.6569 2 18 2C16.3431 2 15 3.34315 15 5C15 5.18692 15.0134 5.37099 15.0395 5.55023L8.56995 9.27511C8.05506 8.48189 7.08837 8 6 8C4.34315 8 3 9.34315 3 11C3 12.6569 4.34315 14 6 14C7.08837 14 8.05506 13.5181 8.56995 12.7249L15.0395 16.4498C15.0134 16.629 15 16.8131 15 17C15 18.6569 16.3431 20 18 20C19.6569 20 21 18.6569 21 17C21 15.3431 19.6569 14 18 14C16.9116 14 15.9449 14.4819 15.43 15.2751L8.96054 11.5502C8.98658 11.371 9 11.1869 9 11C9 10.8131 8.98658 10.629 8.96054 10.4498L15.43 6.72489C15.9449 7.51811 16.9116 8 18 8Z"/>
           </svg>
       </span>
       <span id="selection-delete-btn" class="action-btn circle-btn" style="color: #AB4D3F;">
           <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
               <path d="M3 6H5H21M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19ZM10 11V17M14 11V17" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
           </svg>
       </span>
    </div>
</div>

    </div>

    <!-- 聊天消息区域 (保持不变) -->
    <div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>

    <!-- 输入区域 (保持不变) -->
    <div id="chat-input-area">
    <div id="reply-preview-bar">
        <div class="reply-preview-content">
            <div class="sender">回复 xxx:</div>
            <div class="text">被引用的消息内容...</div>
        </div>
        <span id="cancel-reply-btn">×</span>
    </div>

    <div id="chat-input-main-row">
    <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><path d="M12 19v4"></path><path d="M8 23h8"></path></svg></button>

    <textarea id="chat-input" rows="1" enterkeyhint="send"></textarea>

    <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg></button>
    <button id="chat-plus-btn" class="chat-action-icon-btn action-button" title="更多功能">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </button>
    <div id="input-actions-wrapper">
        <button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/hjkGB1Yz/66424753ch46672e554ee2d87c2031f5.png" alt="等待回复"></button>
        <button id="send-btn" class="action-button">发送</button>
    </div>
</div>

    <div id="chat-plus-panel-single" class="chat-plus-panel">
        <div class="plus-panel-container">
            <div class="plus-panel-pages">
                <div class="plus-panel-page active" data-page="1">
                    <div class="plus-panel-grid">
            <div class="plus-panel-item">
                <button id="send-photo-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg></button>
                <span class="plus-panel-label">照片</span>
            </div>
            <div class="plus-panel-item">
                <button id="upload-image-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></button>
                <span class="plus-panel-label">上传</span>
            </div>
            <div class="plus-panel-item">
                <button id="transfer-btn" class="plus-panel-icon-bg">￥</button>
                <span class="plus-panel-label">转账</span>
            </div>
            <div class="plus-panel-item">
                <button id="send-waimai-request-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg></button>
                <span class="plus-panel-label">外卖</span>
            </div>
            <div class="plus-panel-item">
                <button id="video-call-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
                <span class="plus-panel-label">视频通话</span>
            </div>
            <div class="plus-panel-item">
                <button id="voice-call-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg></button>
                <span class="plus-panel-label">语音通话</span>
            </div>
            <div class="plus-panel-item">
                <button id="diary-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"></path><path d="M8 7h8"></path><path d="M8 11h8"></path><path d="M8 15h5"></path></svg></button>
                <span class="plus-panel-label">日记</span>
            </div>
            <div class="plus-panel-item">
                <button id="regenerate-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg></button>
                <span class="plus-panel-label">重新生成</span>
            </div>
                    </div>
                </div>
                <div class="plus-panel-page" data-page="2">
               <div class="plus-panel-grid">
    <div class="plus-panel-item">
                <button id="html-prompt-btn-panel" class="plus-panel-icon-bg">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                </button>
                <span class="plus-panel-label">HTML</span>
            </div>
                <div class="plus-panel-item">
        <button id="location-btn-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">位置</span>
    </div>
                <div class="plus-panel-item">
        <button id="mode-switch-btn" class="plus-panel-icon-bg">
            <!-- 星星图标 -->
            <svg id="mode-switch-icon" width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
            </svg>
        </button>
        <span id="mode-switch-label" class="plus-panel-label">切换模式</span>
    </div>
                <div class="plus-panel-item">
        <button id="memory-summary-btn" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">记忆</span>
    </div>
    <div class="plus-panel-item">
        <button id="listen-together-btn-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">一起听</span>
    </div>
    <div class="plus-panel-item">
        <button id="gift-btn-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="5" rx="1"></rect>
                <rect x="4" y="9" width="16" height="10" rx="1"></rect>
                <path d="M12 4v5"></path>
                <path d="M8 4c0-1.1.9-2 2-2s2 .9 2 2-2 2-2 2-2-.9-2-2z"></path>
                <path d="M16 4c0-1.1-.9-2-2-2s-2 .9-2 2 2 2 2 2 2-.9 2-2z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">礼物</span>
    </div>
    <div class="plus-panel-item">
        <button id="phone-check-btn" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                <line x1="12" y1="18" x2="12.01" y2="18"></line>
            </svg>
        </button>
        <span class="plus-panel-label">查手机</span>
    </div>
    <div class="plus-panel-item">
        <button id="share-link-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
        <span class="plus-panel-label">链接</span>
    </div>
</div>

                    <div class="plus-panel-grid">
                        <!-- 第二页为空 -->
                    </div>
                </div>
                <div class="plus-panel-page" data-page="3">
                    <div class="plus-panel-grid">
                        <div class="plus-panel-item">
                            <button id="nai-gallery-plus-btn" class="plus-panel-icon-bg">
                                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><path d="M21 15l-5-5L5 21"></path></svg>
                            </button>
                            <span class="plus-panel-label">NAI画廊</span>
                        </div>
                        <div class="plus-panel-item">
                            <button id="world-event-btn" class="plus-panel-icon-bg">
                                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="2" y1="12" x2="22" y2="12"></line>
                                    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                                </svg>
                            </button>
                            <span class="plus-panel-label">大世界事件</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- 分页指示器 -->
        <div class="plus-panel-pagination">
            <div class="pagination-dot active" data-page="1"></div>
            <div class="pagination-dot" data-page="2"></div>
            <div class="pagination-dot" data-page="3"></div>
        </div>
    </div>

    <div id="chat-plus-panel-group" class="chat-plus-panel">
        <div class="plus-panel-container">
            <div class="plus-panel-pages">
                <div class="plus-panel-page active" data-page="1">
                    <div class="plus-panel-grid">
             <div class="plus-panel-item">
                <button id="send-photo-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg></button>
                <span class="plus-panel-label">照片</span>
            </div>
            <div class="plus-panel-item">
                <button id="upload-image-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></button>
                <span class="plus-panel-label">上传</span>
            </div>
            <div class="plus-panel-item">
                <button id="transfer-btn-group" class="plus-panel-icon-bg">￥</button>
                <span class="plus-panel-label">红包</span> </div>
            <div class="plus-panel-item">
                <button id="send-waimai-request-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg></button>
                <span class="plus-panel-label">外卖</span>
            </div>
            <div class="plus-panel-item">
                <button id="group-video-call-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
                <span class="plus-panel-label">群视频</span>
            </div>
            <div class="plus-panel-item">
                <button id="group-voice-call-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg></button>
                <span class="plus-panel-label">群语音</span>
            </div>
            <div class="plus-panel-item">
                <button id="send-poll-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"></path><path d="M6 6h.01"></path><path d="M8 12h10"></path><path d="M6 12h.01"></path><path d="M8 18h10"></path><path d="M6 18h.01"></path></svg></button>
                <span class="plus-panel-label">投票</span>
            </div>
            <div class="plus-panel-item">
                <button id="regenerate-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg></button>
                <span class="plus-panel-label">重新生成</span>
            </div>
                    </div>
                </div>
                <div class="plus-panel-page" data-page="2">
                    <div class="plus-panel-grid">
    <div class="plus-panel-item">
        <button id="html-prompt-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
        </button>
        <span class="plus-panel-label">HTML</span>
    </div>
    <div class="plus-panel-item">
        <button id="location-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">位置</span>
    </div>
    <div class="plus-panel-item">
        <button id="memory-summary-btn-group" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">记忆</span>
    </div>
    <div class="plus-panel-item">
        <button id="listen-together-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">一起听</span>
    </div>
    <div class="plus-panel-item">
        <button id="gift-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="5" rx="1"></rect>
                <rect x="4" y="9" width="16" height="10" rx="1"></rect>
                <path d="M12 4v5"></path>
                <path d="M8 4c0-1.1.9-2 2-2s2 .9 2 2-2 2-2 2-2-.9-2-2z"></path>
                <path d="M16 4c0-1.1-.9-2-2-2s-2 .9-2 2 2 2 2 2 2-.9 2-2z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">礼物</span>
    </div>
    <div class="plus-panel-item">
        <button id="share-link-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
        <span class="plus-panel-label">链接</span>
    </div>
    <div class="plus-panel-item">
        <button id="nai-gallery-plus-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><path d="M21 15l-5-5L5 21"></path></svg></button>
        <span class="plus-panel-label">NAI画廊</span>
    </div>
    <div style="visibility: hidden;"></div>
</div>
                    <div class="plus-panel-grid">
                        <!-- 第二页为空 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- 分页指示器 -->
        <div class="plus-panel-pagination">
            <div class="pagination-dot active" data-page="1"></div>
            <div class="pagination-dot" data-page="2"></div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
       

<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

    <!-- NAI画廊面板 -->
    <div id="nai-gallery-panel">
        <div id="nai-gallery-panel-header">
            <button class="nai-header-btn" id="close-nai-gallery-btn" title="关闭"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
            <span class="title">NAI画廊</span>
            <button class="nai-header-btn" id="manage-nai-gallery-btn" title="管理"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg></button>
        </div>
        <div id="nai-gallery-grid"></div>
        <div id="nai-gallery-action-bar">
            <label class="select-all-label">
                <input type="checkbox" id="select-all-nai-gallery-checkbox"> 全选
            </label>
            <button id="download-selected-nai-gallery-btn" class="action-bar-btn" title="下载"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg></button>
            <button id="delete-selected-nai-gallery-btn" class="action-bar-btn" title="删除"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
        </div>
    </div>

    <!-- 表情面板 (保持不变) -->
    <div id="sticker-panel">
        <div id="sticker-panel-header">
            <div id="sticker-default-controls" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <div style="display: flex; gap: 10px;">
                    <button class="svg-btn" id="add-sticker-btn" title="添加URL">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg>
                    </button>
                    <button class="svg-btn" id="upload-sticker-btn" title="本地上传">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </button>
                    <button class="svg-btn" id="batch-add-sticker-btn" title="批量添加">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line><line x1="12" y1="12" x2="12" y2="18"></line></svg>
                    </button>
                </div>
            </div>
            <div id="sticker-selection-controls" style="display: none; justify-content: space-between; align-items: center; width: 100%;">
                <button id="cancel-sticker-selection-btn" title="取消">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                <span id="sticker-selection-count" style="font-weight: 600;">已选择 0 个</span>
                <button id="delete-selected-stickers-btn" title="删除选中">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                </button>
            </div>
            </div>
        <div id="sticker-grid"></div>
    </div>
    <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- 音乐播放器 (保持不变) -->
<div id="music-player-overlay">
    <div class="music-player-window">
        
        <!-- 1. 顶部操作栏 -->
        <div class="music-player-top-actions">
            <div class="top-left-cluster">
                <button id="music-return-btn">‹</button>
                <button id="music-exit-btn">×</button>
            </div>
            <span id="music-playlist-btn">☰</span>
        </div>
        
        <!-- 2. 歌曲信息 -->
        <div id="music-time-counter">已经一起听了0.0小时</div>
        <div id="music-player-song-title">请添加歌曲</div>
        <div id="music-player-artist">...</div>
        
        <!-- 3. 【全新】歌词显示区域 -->
        <div id="music-lyrics-container">
            <div id="music-lyrics-list">
                <!-- 歌词将由JS动态生成在这里 -->
                <div class="lyric-line">♪ 暂无歌词 ♪</div>
            </div>
        </div>
        
        <!-- 4. 【全新】播放控制区的包裹容器 -->
        <div class="music-player-controls-wrapper">
            <!-- a. 新的iOS风格进度条 -->
            <div class="music-progress-bar-container">
                <div id="music-current-time" class="time-display">0:00</div>
                <div class="progress-bar">
                    <div id="music-progress-fill" class="progress-bar-fill"></div>
                </div>
                <div id="music-total-time" class="time-display">0:00</div>
            </div>
            
            <!-- b. 播放控制按钮 -->
            <div class="music-controls">
                <button id="music-prev-btn">◀</button>
                <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                <button id="music-next-btn">▶</button>
                <button id="music-mode-btn">顺序</button>
            </div>
        </div>

    </div>
</div>
    
    <div id="music-playlist-panel">
        <div class="playlist-header">
            <span class="panel-btn" id="close-playlist-btn">‹</span>
            <span>播放列表</span>
            <div class="playlist-header-actions">
                <button class="playlist-header-action-btn" id="add-song-local-btn" title="本地上传">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                </button>
                 <button class="playlist-header-action-btn" id="add-song-from-url-btn" title="添加URL">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                </button>
                <button class="playlist-header-action-btn" id="add-song-search-btn" title="搜索歌曲">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                        <circle cx="11" cy="11" r="8" stroke="currentColor" stroke-width="2"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line>
                    </svg>
                </button>
            </div>
        </div>
        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" multiple style="display: none;">
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- 预览界面容器 -->
        <div class="preview-container">
            <div class="preview-section">
                <div id="wallpaper-preview">点击下方上传</div>
                <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
                <input type="file" id="wallpaper-upload-input" accept="image/*">
            </div>
            <div class="preview-section">
                <div id="chat-background-preview">点击下方上传</div>
                <button class="form-button" onclick="document.getElementById('chat-background-upload-input').click();">上传全局聊天背景</button>
                <input type="file" id="chat-background-upload-input" accept="image/*">
            </div>
        </div>

<!-- ▼▼▼ 将【上面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
<div class="settings-row-container">
    <div class="form-group padding-setting-container">
        <div class="padding-setting-label">
            <label for="chat-list-padding-top-input">列表顶部边距</label>
            <p>微调列表与顶栏的间距 (px)</p>
        </div>
        <input type="number" id="chat-list-padding-top-input">
    </div>

    <div class="form-group">
        <label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
        <label class="toggle-switch">
            <input type="checkbox" id="theme-toggle-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标设置</label>
        </div>
        <div id="icon-settings-grid">
            <!-- 图标设置项将由JS动态生成在这里 -->
        </div>

        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">等待回复按钮样式设置</label>
        </div>
        <div class="form-group">
            <label for="wait-reply-btn-custom-input">自定义按钮样式</label>
            <p style="font-size: 12px; color: var(--text-secondary); margin: 8px 0;">可以输入 SVG 代码或图片 URL</p>
            <textarea id="wait-reply-btn-custom-input" placeholder="例如：<svg xmlns=&quot;http://www.w3.org/2000/svg&quot;...></svg> 或 https://...png" style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; font-family: monospace; resize: vertical;"></textarea>
        </div>
        <div style="width: 100%; display: flex; gap: 10px;">
            <button class="form-button" id="preview-wait-reply-btn-style" style="flex: 1;">预览样式</button>
            <button class="form-button form-button-secondary" id="reset-wait-reply-btn-style" style="flex: 1;">恢复默认</button>
        </div>

        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">加载动画设置</label>
        </div>
        <div class="form-group">
            <label for="loading-animation-url-input">自定义加载动画 URL</label>
            <p style="font-size: 12px; color: var(--text-secondary); margin: 8px 0;">输入加载动画图片的完整 URL</p>
            <input type="text" id="loading-animation-url-input" placeholder="https://...png">
        </div>
        <div style="width: 100%; display: flex; gap: 10px;">
            <button class="form-button" id="preview-loading-animation-btn" style="flex: 1;">预览加载动画</button>
            <button class="form-button form-button-secondary" id="reset-loading-animation-btn" style="flex: 1;">恢复默认</button>
        </div>

        <!-- 【核心修改3】按钮文字也改一下 -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- 文章内容将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>字体设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="font-url-input">字体文件URL (.ttf, .otf, .woff等)</label>
            <input type="text" id="font-url-input" placeholder="https://..../font.ttf">
        </div>

        <div class="form-group">
            <label>实时预览</label>
<div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                <p style="margin: 0;">这是字体预览效果，12345。</p>
            </div>
        </div>

        <button class="form-button" id="save-font-btn">保存并应用</button>
        <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
    </div>
</div>

<!-- ▼▼▼ 【新增】预设管理界面 ▼▼▼ -->
<div id="preset-manager-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>预设库</span>
        <div class="header-actions">
            <span class="action-btn" id="import-preset-btn" title="导入预设" style="margin-top: 8px;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2V14M12 14L7 9M12 14L17 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M3 18H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </span>
            <span class="action-btn" id="add-preset-btn">+</span>
        </div>
    </div>
    <div id="preset-list" class="list-container"></div>
</div>

<!-- ▼▼▼ 【新增】预设导入隐藏文件输入 ▼▼▼ -->
<input type="file" id="preset-import-file-input" style="display:none" accept=".json">
<!-- ▲▲▲ 预设导入隐藏文件输入结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】预设内容查看模态框 ▼▼▼ -->
<div id="preset-content-modal" class="modal" style="display:none; overflow: hidden;">
    <div class="modal-content" style="display: flex; flex-direction: column; height: 80vh; max-height: 80vh; border-radius: 12px; background-color: #FFFFFF; overflow: hidden;">
        <div style="padding: 16px; border-bottom: 1px solid #EAEAEA; display: flex; justify-content: center; align-items: center; position: relative; flex-shrink: 0;">
            <span style="font-weight: 600; font-size: 16px; color: #1E1E1E;">查看条目内容</span>
            <span id="preset-content-close-btn" style="cursor: pointer; font-size: 24px; color: #666; position: absolute; right: 16px;">×</span>
        </div>
        <div style="padding: 0 16px 16px 16px; flex-shrink: 0;">
            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 500;">条目名称</label>
            <input id="preset-content-name-input" type="text" placeholder="输入条目名称（可选）" style="width: 100%; padding: 8px 12px; border: 1px solid #DCDCDC; border-radius: 6px; font-size: 14px; box-sizing: border-box; color: #1E1E1E;">
        </div>
        <div style="flex: 1; overflow-y: auto; padding: 16px; overflow-x: hidden;">
            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 8px; font-weight: 500;">条目内容</label>
            <div id="preset-content-display" style="white-space: pre-wrap; word-break: break-word; color: #1E1E1E; font-size: 14px; line-height: 1.6; font-family: 'Monaco', 'Menlo', monospace;  overflow-y: auto;"></div>
        </div>
        <div style="padding: 16px; border-top: 1px solid #EAEAEA; display: flex; gap: 12px; justify-content: flex-end; flex-shrink: 0;">
            <button id="preset-content-cancel-btn" style="padding: 10px 20px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500;">取消</button>
            <button id="preset-content-save-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background-color: #1E1E1E; color: #FFFFFF; cursor: pointer; font-weight: 500;">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 预设内容查看模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】预设条目添加选项模态框 ▼▼▼ -->
<div id="preset-item-add-modal" class="modal" style="display:none; overflow: hidden;">
    <div class="modal-content" style="border-radius: 12px; background-color: #FFFFFF; padding: 20px;">
        <div style="text-align: center; margin-bottom: 24px;">
            <span style="font-weight: 600; font-size: 18px; color: #1E1E1E;">添加条目</span>
        </div>
        <div style="display: flex; flex-direction: column; gap: 12px;">
            <button id="add-preset-item-blank-btn" style="padding: 16px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s;">
                <div style="font-weight: 600; margin-bottom: 4px;">➕ 新建空白条目</div>
                <div style="font-size: 12px; color: #666;">创建一个空白条目，手动输入内容</div>
            </button>
            <button id="add-preset-item-from-library-btn" style="padding: 16px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s;">
                <div style="font-weight: 600; margin-bottom: 4px;">📚 从自定义库导入</div>
                <div style="font-size: 12px; color: #666;">从已保存的自定义预设库中选择</div>
            </button>
        </div>
        <button id="cancel-preset-item-add-btn" style="margin-top: 16px; width: 100%; padding: 12px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #F5F5F5; color: #1E1E1E; cursor: pointer; font-weight: 500;">取消</button>
    </div>
</div>
<!-- ▲▲▲ 预设条目添加选项模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】自定义预设库选择模态框 ▼▼▼ -->
<div id="custom-preset-select-modal" class="modal" style="display:none; overflow: hidden;">
    <div class="modal-content" style="display: flex; flex-direction: column; height: 80vh; max-height: 80vh; border-radius: 12px; background-color: #FFFFFF; overflow: hidden;">
        <div style="padding: 16px; border-bottom: 1px solid #EAEAEA; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
            <span style="font-weight: 600; font-size: 16px; color: #1E1E1E;">选择预设条目</span>
            <span id="custom-preset-select-close-btn" style="cursor: pointer; font-size: 24px; color: #666;">×</span>
        </div>
        <div style="flex: 1; overflow-y: auto; padding: 16px;">
            <div id="custom-preset-items-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
        </div>
        <div style="padding: 16px; border-top: 1px solid #EAEAEA; display: flex; gap: 12px; justify-content: flex-end; flex-shrink: 0;">
            <button id="custom-preset-select-cancel-btn" style="padding: 10px 20px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 自定义预设库选择模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】新条目part选择模态框 ▼▼▼ -->
<div id="new-item-part-selection-modal" class="modal" style="display:none; overflow: hidden;">
    <div class="modal-content" style="border-radius: 12px; background-color: #FFFFFF; padding: 20px;">
        <div style="text-align: center; margin-bottom: 24px;">
            <span style="font-weight: 600; font-size: 18px; color: #1E1E1E;">选择条目类型</span>
            <div style="font-size: 12px; color: #999; margin-top: 8px;">前后条目的类型不一致，请为新条目选择类型</div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 12px;">
            <button id="select-part1-btn" style="padding: 16px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s;">
                <div style="font-weight: 600; margin-bottom: 4px;">♡ Part 1</div>
                <div style="font-size: 12px; color: #666;">主情节部分</div>
            </button>
            <button id="select-part2-btn" style="padding: 16px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s;">
                <div style="font-weight: 600; margin-bottom: 4px;">✧ Part 2</div>
                <div style="font-size: 12px; color: #666;">补充信息部分</div>
            </button>
        </div>
        <button id="cancel-part-selection-btn" style="margin-top: 16px; width: 100%; padding: 12px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #F5F5F5; color: #1E1E1E; cursor: pointer; font-weight: 500;">取消</button>
    </div>
</div>
<!-- ▲▲▲ 新条目part选择模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】预设编辑界面 ▼▼▼ -->
<div id="preset-editor-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="preset-editor-back-btn">‹</span>
        <span id="preset-editor-title">新建预设</span>
        <div style="display: flex; align-items: center; gap: 8px;">
            <button class="circle-btn save-btn" id="custom-preset-library-btn" title="自定义预设条目库" style="width: 30px; height: 30px; background-color: #1E1E1E; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" fill="white" style="width: 16px; height: 16px;">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
            </button>
            <button class="circle-btn save-btn" id="save-preset-btn">
                <svg viewBox="0 0 24 24">
                    <path fill="white" d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/>
                </svg>
            </button>
        </div>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="preset-name-input">预设名称</label>
            <input type="text" id="preset-name-input" placeholder="输入预设名称">
        </div>
        <div class="form-group">
            <label>条目列表</label>
            <button class="form-button form-button-secondary" id="add-preset-item-btn">添加条目</button>
        </div>
        <div id="preset-items-container"></div>
    </div>
</div>
<!-- ▲▲▲ 预设管理界面结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】论坛页面 ▼▼▼ -->
<div id="forum-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>论坛</span>
        <div class="header-actions">
            <span class="action-btn" id="forum-refresh-btn" title="刷新论坛内容">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
            </span>
        </div>
    </div>
    <div id="forum-posts-container" class="list-container">
        <!-- 论坛帖子将由JS动态生成在这里 -->
        <div class="forum-placeholder">
            <p>点击右上角的刷新按钮 🔄</p>
            <p>根据你和角色的故事生成专属论坛吧！</p>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群聊类型选择弹窗 ▼▼▼ -->
<div id="group-chat-type-modal" class="modal">
    <div class="modal-content" style="max-width: 90%; width: auto;">
        <div class="modal-header">
            <span>创建群聊</span>
        </div>
        <div class="modal-body" style="padding: 30px 20px; text-align: center; display: flex; flex-direction: column; gap: 15px;">
            <p style="color: var(--text-secondary); margin: 10px 0;">请选择群聊类型：</p>
            <button id="create-normal-group-btn" class="form-button" style="background-color: var(--accent-color); font-size: 16px; padding: 15px;">
                👥 创建普通群聊 (我参与)
            </button>
            <button id="create-spectator-group-btn" class="form-button" style="background-color: var(--accent-color); font-size: 16px; padding: 15px;">
                👁️ 创建旁观群聊 (我围观)
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-group-type-modal-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 群聊类型选择弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <div class="back-btn circle-btn" id="cancel-contact-picker-btn">
            <svg viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
        </div>
        <span>选择联系人</span>
        <div class="save-btn circle-btn" id="confirm-contact-picker-btn" title="完成(0)">
            <svg viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">
                <path fill="white" d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
            </svg>
        </div>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- 联系人列表将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>群成员管理</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- 现有成员列表会在这里动态生成 -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">从好友列表添加</button>
        <button id="create-new-member-btn">创建群内新成员</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">邀请你视频通话</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>拒绝</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>接听</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 1. 顶部栏 (保持不变) -->
    <div class="video-call-top-bar">
        <span id="call-timer">00:00</span>
    </div>
    
    <!-- 2. 【升级】参与者头像网格区域 -->
    <div class="video-call-avatar-area">
        <div id="participant-avatars-grid">
            <!-- JS会在这里动态生成头像 -->
        </div>
    </div>

    <!-- 3. 对话框区域 (保持不变) -->
    <div id="video-call-main" class="video-call-main">
        <!-- 对话内容会动态生成在这里 -->
    </div>
    
    <!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
    <div class="video-call-controls">
        <button id="user-speak-btn" class="control-btn speak-btn"></button>
        <button id="hang-up-btn" class="control-btn hangup-btn"></button>
        <!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
         
        <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】语音通话界面 ▼▼▼ -->
<div id="voice-call-screen" class="screen">
    <!-- 1. 顶部栏 -->
    <div class="voice-call-top-bar">
        <span id="voice-call-timer">00:00</span>
    </div>

    <!-- 2. 参与者头像网格区域 -->
    <div class="voice-call-avatar-area">
        <div id="voice-participant-avatars-grid">
            <!-- JS会在这里动态生成头像 -->
        </div>
    </div>

    <!-- 3. 对话框区域 -->
    <div id="voice-call-main" class="voice-call-main">
        <!-- 对话内容会动态生成在这里 -->
    </div>

    <!-- 4. 底部控制栏 -->
    <div class="voice-call-controls">
        <button id="voice-user-speak-btn" class="control-btn voice-speak-btn"></button>
        <button id="voice-hang-up-btn" class="control-btn voice-hangup-btn"></button>
        <button id="voice-join-call-btn" class="control-btn voice-join-btn" style="display: none;"></button>
    </div>
</div>
<!-- ▲▲▲ 语音通话界面结束 ▲▲▲ -->

<div id="status-modal" class="modal">
    <div class="modal-content" style="width: 320px; height: auto;">
        <div class="modal-body">
            <div class="thought-content" style="padding-top: 20px;">
                <div class="voice">
                    <div class="label">
                        <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        心声
                    </div>
                    <p class="text" id="status-modal-thought">...</p>
                </div>
                <div style="height: 6px;"></div>
                <div class="jottings">
                    <div class="label">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                        散记
                    </div>
                    <p class="text" id="status-modal-jottings">...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="group-status-modal" class="modal">
    <div class="modal-content" style="width: 320px; height: auto;">
        <div class="modal-body" id="group-status-list">
        </div>
    </div>
</div>

<div id="diary-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="diary-back-btn">‹</span>
        <span id="diary-screen-title">TA的日记</span>
        <button id="diary-create-btn" class="circle-btn" title="写日记">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <line x1="12" y1="5" x2="12" y2="19" stroke="white" stroke-width="2" stroke-linecap="round"></line>
                <line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="2" stroke-linecap="round"></line>
            </svg>
        </button>
    </div>
    <div id="diary-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        </div>
</div>

<!-- ▼▼▼ 查手机界面开始 ▼▼▼ -->
<div id="phone-interface-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="phone-back-btn">‹</span>
        <span>手机</span>
        <div class="header-actions">
            <button id="phone-clear-btn" class="circle-btn" title="清空数据" style="background-color: #AB4D3F;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button id="phone-refresh-btn" class="circle-btn" title="刷新数据">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                    </svg>
                </button>
            </div>
        </div>
    <div class="phone-content">
        <div id="phone-home" class="phone-view active">
            <!-- 9个app的九宫格布局将在这里添加 -->
        </div>

        <!-- 微信app界面 -->
        <div id="phone-wechat" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">微信</span>
                </div>
                <div class="phone-app-content" id="wechat-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>

        <!-- 微信聊天详情界面 -->
        <div id="phone-wechat-chat" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title" id="wechat-chat-title">聊天记录</span>
                </div>
                <div class="phone-app-content" id="wechat-chat-content">
                    <!-- 聊天消息将在这里显示 -->
                </div>
            </div>
        </div>

        <!-- 购物车app界面 -->
        <div id="phone-shopping" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">购物车</span>
                </div>
                <div class="phone-app-content" id="shopping-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>

        <!-- 备忘录app界面 -->
        <div id="phone-memo" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">备忘录</span>
                </div>
                <div class="phone-app-content" id="memo-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>
<div id="phone-memo-detail" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title" id="memo-detail-title">备忘录</span>
                </div>
                <div class="phone-app-content" id="memo-detail-content" style="padding: 20px; white-space: pre-wrap; word-wrap: break-word;">
                    </div>
            </div>
        </div>
        <!-- 浏览器app界面 -->
        <div id="phone-browser" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">浏览器</span>
                </div>
                <div class="phone-app-content" id="phone-browser-list">
                    <div class="phone-empty">
                        暂无浏览记录<br>
                        <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- 浏览器详情界面 -->
        <div id="phone-browser-detail" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title" id="browser-detail-title">网页内容</span>
                </div>
                <div class="phone-app-content" id="browser-detail-content" style="padding: 20px;">
                    <!-- 网页内容将在这里显示 -->
                </div>
            </div>
        </div>

        <!-- 相册app界面 -->
        <div id="phone-photos" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">相册</span>
                </div>
                <div class="phone-app-content" id="photos-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>

        <!-- 相册详情界面 -->
        <div id="phone-photo-detail" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back" onclick="showPhoneView('phone-photos')">‹</span>
                    <span class="phone-app-title">照片详情</span>
                </div>
                <div class="phone-app-content" id="photo-detail-content" style="padding: 20px;">
                    <!-- 照片详情将在这里显示 -->
                </div>
            </div>
        </div>

        <!-- 钱包app界面 -->
        <div id="phone-wallet" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">钱包</span>
                </div>
                <div class="phone-app-content" id="wallet-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>

        <!-- 足迹app界面 -->
        <div id="phone-location" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">足迹</span>
                </div>
                <div class="phone-app-content" id="location-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>

        <!-- 使用记录app界面 -->
        <div id="phone-usage" class="phone-view">
            <div class="phone-app-view">
                <div class="phone-app-header">
                    <span class="phone-app-back">‹</span>
                    <span class="phone-app-title">使用记录</span>
                </div>
                <div class="phone-app-content" id="usage-content">
                    <div class="phone-loading">
                        <div class="phone-loading-spinner"></div>
                        暂无数据，请先刷新
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 查手机界面结束 ▲▲▲ -->

<div id="edit-diary-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header"><span>编辑日记</span></div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="diary-text-input" rows="5" placeholder="记录下此刻的心情吧..." maxlength="150"></textarea>
                <div style="text-align: right; font-size: 12px; color: #888; margin-top: 5px;" id="diary-char-counter">0 / 150</div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-diary-edit-btn">取消</button>
            <button class="save" id="save-diary-edit-btn">保存修改</button>
        </div>
    </div>
</div>

<div id="status-diary-action-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="action-show-status">查看心声</button>
            <button id="action-show-diary">打开日记本</button>
            <button id="action-cancel-selection" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">正在呼叫...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>取消</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
<div id="call-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="call-history-back-btn">‹</span>
        <span id="call-history-title">通话记录</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 通话记录卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        </div>
    </div>
  
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>聊天设置</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input type="text" id="chat-name-input"></div>
<div class="form-group" id="chat-remark-group" style="display: none;"><label for="chat-remark-input">用户备注</label><input type="text" id="chat-remark-input" placeholder="输入你想给这个角色的备注"></div>
<div class="form-group" id="chat-original-name-group">
        <label for="chat-original-name-input">真实姓名</label>
        <input type="text" id="chat-original-name-input" placeholder="（可选）角色的真实姓名">
    </div>
    <!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
    <div class="form-group" id="assign-group-section" style="display: none;"> <!-- 默认隐藏，只对单聊显示 -->
        <label for="assign-group-select">好友分组</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- 分组选项将由JS动态生成 -->
            </select>
<button id="manage-groups-btn" class="circle-btn" style="border: none; flex-shrink: 0;">
    <svg viewBox="0 0 24 24">
        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
    </svg>
</button>  </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>群头像</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>关联世界书 (线上)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <div class="form-group" id="world-book-link-group-offline" style="display: none;">
                <label>关联世界书 (线下)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container-offline" class="checkboxes-container">
                    </div>
                </div>
            </div>

            <!-- 【新增】预设选择 - 分为线下模式和监控模式 -->
            <div class="form-group" id="preset-select-offline-group">
                <label for="preset-select-offline">应用预设(线下模式)</label>
                <select id="preset-select-offline">
                    <option value="">-- 不使用预设 --</option>
                </select>
            </div>

            <div class="form-group" id="preset-select-monitor-group">
                <label for="preset-select-monitor">应用预设(监控模式)</label>
                <select id="preset-select-monitor">
                    <option value="">-- 不使用预设 --</option>
                </select>
            </div>
            <!-- 【新增结束】 -->

<div class="form-group" id="ai-persona-group">
    <div class="persona-label-wrapper">
        <label for="ai-persona">对方人设 (AI Persona)</label>
        <button class="expand-persona-btn" data-target="ai" title="展开编辑器">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path>
            </svg>
        </button>
    </div>
    <textarea id="ai-persona" rows="3"></textarea>
    <div class="persona-editor-expanded" id="ai-persona-editor-expanded" style="display: none;">
        <textarea class="expanded-textarea"></textarea>
        <div class="expanded-actions">
            <button class="cancel-expanded-btn">取消</button>
            <button class="save-expanded-btn">保存</button>
        </div>
    </div>
</div>            <div class="form-group" id="ai-avatar-group"><label>对方头像</label><div class="avatar-upload"><img id="ai-avatar-preview"><button onclick="document.getElementById('ai-avatar-input').click()" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="上传对方头像">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
    </svg>
</button><button id="manage-ai-avatar-library-btn" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="管理头像库">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M3 5h18v2H3zm0 6h18v2H3zm0 6h18v2H3z"/>
    </svg>
</button><button id="manage-couple-avatar-library-btn" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="情侣头像库">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
    </svg>
</button><button id="manage-ai-stickers-btn" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="AI表情包库">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/>
    </svg>
</button>
<input type="file" id="ai-avatar-input" accept="image/*"></div></div>
<div class="form-group" id="my-persona-group">
    <div class="persona-label-wrapper">
        <label for="my-persona">我的人设 (My Persona)</label>
        <button class="expand-persona-btn" data-target="my" title="展开编辑器">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path>
            </svg>
        </button>
    </div>
    <textarea id="my-persona" rows="3"></textarea>
    <div class="persona-editor-expanded" id="my-persona-editor-expanded" style="display: none;">
        <textarea class="expanded-textarea"></textarea>
        <div class="expanded-actions">
            <button class="cancel-expanded-btn">取消</button>
            <button class="save-expanded-btn">保存</button>
        </div>
    </div>
</div><div class="form-group" id="my-avatar-group"><label>我的头像</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="上传我的头像">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
    </svg>
</button><button id="open-persona-library-btn" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="预设">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
    </svg>
</button><input type="file" id="my-avatar-input" accept="image/*"></div></div>
<div class="form-group" id="group-members-group"><label>群成员人设</label><div id="group-members-settings"></div>

    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成员</button>

</div>
<div class="form-group">
    <label for="summarize-reserve-input">总结保留条数</label>
    <div style="display: flex; align-items: center; gap: 10px;">
        <input type="number" id="summarize-reserve-input" value="100" style="flex-grow: 1;">
    </div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px; margin-bottom: 0;">
        执行“总结”时，保留最近的 N 条消息不被总结。
    </p>
</div>
<div class="form-group">
    <label for="memory-anchor-input">记忆锚点</label>
    <div style="display: flex; align-items: center; gap: 10px;">
    <input type="number" id="memory-anchor-input" value="0" style="flex-grow: 1;">
    <button id="refresh-memory-anchor-btn" class="circle-btn" title="刷新锚点到当前已总结位置" style="border: none; flex-shrink: 0;">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 4v6h-6"></path>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
        </svg>
    </button>
</div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px; margin-bottom: 0;">
        AI将从第 N 条消息开始读取上下文。点击右侧刷新按钮可将锚点设为当前已总结消息的末尾。
    </p>
</div>
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <div style="flex: 1; margin-right: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary);">群聊互通记忆</label>
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: -3px; margin-bottom: 0;">
            开启后，AI在生成群聊回复时会参考单聊记忆，反之亦然
        </p>
    </div>
    <label class="memory-switch">
        <input type="checkbox" id="cross-chat-memory-switch">
        <span class="memory-switch-slider"></span>
    </label>
</div>

<!-- ▼▼▼ 后台活动检测间隔 - 独立开关 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <div style="flex: 1; margin-right: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary);">后台活动检测</label>
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: -3px; margin-bottom: 0;">
            开启后，该角色可以在后台主动发消息、发动态等
        </p>
    </div>
    <label class="memory-switch">
        <input type="checkbox" id="background-activity-enabled-switch">
        <span class="memory-switch-slider"></span>
    </label>
</div>

<div class="form-group" id="background-interval-group" style="display: none; margin-top: 10px;">
    <label for="background-activity-interval-input">后台活动检测间隔 (秒)</label>
    <input type="number" id="background-activity-interval-input" min="30" value="60" placeholder="建议值 60-300">
    <small style="color: #999; font-size: 12px; margin-top: 5px; display: block;">
        建议值 60-300。值越大，费用越低，但角色反应越慢。
    </small>

    <!-- 测试按钮 -->
    <button id="test-background-activity-btn" style="width: 100%; margin-top: 10px; padding: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 13px;">
        🧪 测试后台活动（必定触发）
    </button>
</div>
<!-- ▲▲▲ 后台活动检测间隔结束 ▲▲▲ -->

<!-- ▼▼▼ 朋友圈可见性开关 - 新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
    <div style="flex: 1; margin-right: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary);">朋友圈可见性</label>
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: -3px; margin-bottom: 0;">
            开启后，该角色可以看到其他人的朋友圈并评论
        </p>
    </div>
    <label class="memory-switch">
        <input type="checkbox" id="moments-visibility-switch">
        <span class="memory-switch-slider"></span>
    </label>
</div>

<div class="form-group" id="moments-config-group" style="display: none; margin-top: 10px;">
    <label style="display: block; margin-bottom: 8px; font-weight: 500;">可见的朋友圈角色</label>
    <div id="moments-characters-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
        <!-- 角色列表将由JS动态生成 -->
    </div>

    <label style="display: block; margin-bottom: 8px; font-weight: 500; margin-top: 10px;">自定义角色关系（作为prompt的一部分）</label>
    <textarea id="custom-relationship-input" placeholder="例如：我是你的好朋友，我们一起上班..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; resize: vertical;"></textarea>
    <small style="color: #999; font-size: 12px; margin-top: 5px; display: block;">
        这里的内容会被添加到AI的prompt中，用来指导AI的回复风格和内容
    </small>
</div>
<!-- ▲▲▲ 朋友圈可见性开关结束 ▲▲▲ -->

<div class="form-group"><label for="active-reply-interval">主动回复间隔</label><input type="number" id="active-reply-interval" value="0" min="0" step="0.1" placeholder="输入小时数"><small style="color: #999; font-size: 12px; margin-top: 5px; display: block;">当距离AI上次回复超过N小时后，进入聊天会自动触发AI主动回复。最小间隔0.1小时（6分钟），输入0可关闭。</small></div>

<!-- ▼▼▼ 【Minimax TTS】语音ID配置 ▼▼▼ -->
<div class="form-group" id="minimax-voice-id-group">
    <label for="minimax-voice-id-input">Minimax 语音ID</label>
    <input type="text" id="minimax-voice-id-input" placeholder="例如：male-01">
</div>

<!-- 🔥【新增】语速设置 -->
<div class="form-group" id="minimax-voice-speed-group" style="margin-top: 15px;">
    <label for="minimax-voice-speed-input" style="display: block; margin-bottom: 8px;">
        <i class="fas fa-tachometer-alt"></i> 语音语速: <span id="minimax-voice-speed-value">1.0</span>x
    </label>
    <input type="range" id="minimax-voice-speed-input" min="0.5" max="2.0" value="1.0" step="0.1"
           style="width: 100%; accent-color: #000000;"
           oninput="document.getElementById('minimax-voice-speed-value').textContent = this.value">
    <small style="color: #999; font-size: 12px; margin-top: 5px; display: block;">
        调整语音播放的语速（0.5倍 - 2.0倍）
    </small>
</div>

<!-- 🔥【新增】语言增强设置 -->
<div class="form-group" id="minimax-language-group" style="margin-top: 15px;">
    <label for="minimax-language-input" style="display: block; margin-bottom: 8px;">
        <i class="fas fa-language"></i> Minimax 语言增强
    </label>
    <small style="color: #999; font-size: 12px; margin-bottom: 10px; display: block;">
        增强对特定语言或方言的识别能力。通常选择"自动判断"即可。
    </small>
    <select class="form-input" id="minimax-language-input" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        <option value="">无 (默认)</option>
        <option value="auto">自动判断</option>
        <option value="Chinese">中文普通话</option>
        <option value="Chinese,Yue">粤语</option>
        <option value="English">英语</option>
        <option value="Japanese">日语</option>
        <option value="Korean">韩语</option>
        <option value="French">法语</option>
        <option value="Spanish">西班牙语</option>
        <option value="Arabic">阿拉伯语</option>
        <option value="Russian">俄语</option>
        <option value="Portuguese">葡萄牙语</option>
        <option value="German">德语</option>
        <option value="Turkish">土耳其语</option>
        <option value="Dutch">荷兰语</option>
        <option value="Ukrainian">乌克兰语</option>
        <option value="Vietnamese">越南语</option>
        <option value="Indonesian">印尼语</option>
        <option value="Italian">意大利语</option>
        <option value="Thai">泰语</option>
        <option value="Polish">波兰语</option>
        <option value="Romanian">罗马尼亚语</option>
        <option value="Greek">希腊语</option>
        <option value="Czech">捷克语</option>
        <option value="Finnish">芬兰语</option>
        <option value="Hindi">印地语</option>
        <option value="Bulgarian">保加利亚语</option>
        <option value="Danish">丹麦语</option>
        <option value="Hebrew">希伯来语</option>
        <option value="Malay">马来语</option>
        <option value="Persian">波斯语</option>
        <option value="Slovak">斯洛伐克语</option>
        <option value="Swedish">瑞典语</option>
        <option value="Croatian">克罗地亚语</option>
        <option value="Filipino">菲律宾语</option>
        <option value="Hungarian">匈牙利语</option>
        <option value="Norwegian">挪威语</option>
    </select>
</div>
<!-- ▲▲▲ 【Minimax TTS】语音ID配置 ▲▲▲ -->

<!-- ▼▼▼ 单聊NAI出图设置 ▼▼▼ -->
<div class="form-group" id="nai-character-settings-group" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label style="font-weight: 600; color: var(--accent-color);">NAI出图设置</label>
    <p style="font-size: 12px; color: #666; margin-top: 5px;">
        为当前角色配置专属的NovelAI出图提示词
    </p>
    <button id="character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px;">配置角色专属提示词</button>

    <!-- NAI提示词输入区域 -->
    <div id="character-nai-prompts-container" style="display: none; margin-top: 15px; padding: 15px; background-color: #ffffff; border-radius: 8px;">
        <div class="form-group">
            <label for="character-nai-positive-input" style="color: #333; font-weight: 600;">正面提示词 (Positive Prompt)</label>
            <textarea id="character-nai-positive-input" rows="4" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;" placeholder="例如: masterpiece, best quality, 1girl, beautiful, detailed face"></textarea>
        </div>
        <div class="form-group">
            <label for="character-nai-negative-input" style="color: #333; font-weight: 600;">负面提示词 (Negative Prompt)</label>
            <textarea id="character-nai-negative-input" rows="4" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;" placeholder="例如: lowres, bad anatomy, bad hands, text, error"></textarea>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: space-between;">
            <button id="character-nai-reset-btn" class="form-button form-button-secondary" style="flex: 0 1 auto;">清空</button>
            <button id="character-nai-save-btn" class="form-button form-button-secondary" style="flex: 0 1 auto; margin-left: auto;">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 单聊NAI出图设置 ▲▲▲ -->

<!-- ▼▼▼ 群聊NAI出图设置 ▼▼▼ -->
<div class="form-group" id="group-nai-settings-group" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label style="font-weight: 600; color: var(--accent-color);">NAI出图设置</label>
    <p style="font-size: 12px; color: #666; margin-top: 5px;">
        为当前角色配置专属的NovelAI出图提示词
    </p>
    <button id="group-character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px;">配置角色专属提示词</button>

    <!-- 群聊NAI提示词输入区域 -->
    <div id="group-character-nai-prompts-container" style="display: none; margin-top: 15px; padding: 15px; background-color: #ffffff; border-radius: 8px;">
        <div class="form-group">
            <label for="group-character-nai-positive-input" style="color: #333; font-weight: 600;">正面提示词 (Positive Prompt)</label>
            <textarea id="group-character-nai-positive-input" rows="4" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;" placeholder="例如: masterpiece, best quality, 1girl, beautiful, detailed face"></textarea>
        </div>
        <div class="form-group">
            <label for="group-character-nai-negative-input" style="color: #333; font-weight: 600;">负面提示词 (Negative Prompt)</label>
            <textarea id="group-character-nai-negative-input" rows="4" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;" placeholder="例如: lowres, bad anatomy, bad hands, text, error"></textarea>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: space-between;">
            <button id="group-character-nai-reset-btn" class="form-button form-button-secondary" style="flex: 0 1 auto;">清空</button>
            <button id="group-character-nai-save-btn" class="form-button form-button-secondary" style="flex: 0 1 auto; margin-left: auto;">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 群聊NAI出图设置 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新代码粘贴到"聊天气泡主题"的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->

<div class="form-group">
    <div class="persona-label-wrapper">
        <label for="custom-css-input">
            自定义气泡样式 (CSS)
            <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
        </label>
        <button class="expand-persona-btn" data-target="css" title="展开编辑器">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path>
            </svg>
        </button>
    </div>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
    <div class="persona-editor-expanded" id="css-editor-expanded" style="display: none;">
        <textarea class="expanded-textarea"></textarea>
        <div class="expanded-actions">
            <button class="cancel-expanded-btn">取消</button>
            <button class="save-expanded-btn">保存</button>
        </div>
    </div>
</div>
<div class="form-group">
    <button class="form-button form-button-secondary" id="save-bubble-preset-btn" style="margin-top: -10px;">将当前样式存为预设</button>
</div>

<div class="form-group">
    <label>我的气泡预设</label>
    <div id="bubble-presets-list">
        <p class="preset-placeholder">还没有保存任何预设...</p>
    </div>
</div>
<!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label>实时预览</label>
    <div id="settings-preview-area">
        <!-- JS会在这里生成预览内容 -->
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

            <div class="form-group">
                <label>聊天背景</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary glass-bubble-button" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上传背景图</button>
                    <button type="button" id="remove-bg-btn">移除背景</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #AB4D3F; color: white; border-color: #AB4D3F;">拉黑对方</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button></div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header" style="position: relative;"><span>我的人设库</span><button id="add-persona-preset-btn" class="circular-svg-button" title="添加人设预设">
        <svg viewBox="0 0 24 24">
            <path d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L19 5V6.5C19 7.3 18.3 8 17.5 8S16 7.3 16 6.5V5L14 7V9C14.6 9 15.1 9.4 15.3 10H21C21 9.4 21 9.2 21 9ZM3 9C3 9.2 3 9.4 3 10H8.7C8.9 9.4 9.4 9 10 9V7L8 5V6.5C8 7.3 7.3 8 6.5 8S5 7.3 5 6.5V5L3 7V9ZM12 10.5C11.2 10.5 10.5 11.2 10.5 12S11.2 13.5 12 13.5 13.5 12.8 13.5 12 12.8 10.5 12 10.5ZM12 15C9.8 15 8 16.8 8 19V20C8 20.6 8.4 21 9 21H15C15.6 21 16 20.6 16 20V19C16 16.8 14.2 15 12 15Z"/>
        </svg>
    </button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div></div></div>
    
    <div id="persona-editor-modal" class="modal"><div class="modal-content"><div class="modal-header"><span id="persona-editor-title">添加人设预设</span></div><div class="modal-body"><div class="form-group"><label>预设头像</label><div class="avatar-upload"><img id="preset-avatar-preview"><button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button><input type="file" id="preset-avatar-input" accept="image/*"></div></div><div class="form-group"><label for="preset-persona-input">预设人设</label><textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea></div></div><div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">取消</button><button class="save" id="save-persona-preset-btn">保存</button></div></div></div>

    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>编辑群成员</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
    <div class="form-group"><label>头像</label><div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">上传头像</button><input type="file" id="member-avatar-input" accept="image/*"></div></div>
    <div class="form-group" id="main-role-switch-group" style="display: none;"><label>设为主要角色</label><label class="memory-switch"><input type="checkbox" id="member-is-main-role-checkbox"><span class="memory-switch-slider"></span></label></div>
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>

    <div id="world-event-modal" class="modal">
        <div class="modal-content" style="max-width: 85%;">
            <div class="modal-header">大世界事件</div>
            <div class="modal-body">
                <textarea id="world-event-input" placeholder="输入事件内容..." style="width: 100%; min-height: 300px; resize: none; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 14px; font-family: inherit; box-sizing: border-box;"></textarea>
            </div>
            <div class="modal-footer">
                <button id="world-event-generate-btn" class="save">生成</button>
            </div>
        </div>
    </div>

    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 【新增】编辑API预设模态框 ▼▼▼ -->
    <div id="edit-api-preset-modal" class="modal" style="display:none; overflow: hidden;">
        <div class="modal-content" style="display: flex; flex-direction: column; height: auto; max-height: 90%; border-radius: 12px; background-color: #FFFFFF; overflow: hidden;">
            <div style="padding: 16px; border-bottom: 1px solid #EAEAEA; display: flex; justify-content: center; align-items: center; position: relative; flex-shrink: 0;">
                <span style="font-weight: 600; font-size: 16px; color: #1E1E1E;">编辑API预设</span>
                <span id="edit-api-preset-close-btn" style="cursor: pointer; font-size: 24px; color: #666; position: absolute; right: 16px;">×</span>
            </div>
            <div style="flex: 1; overflow-y: auto; padding: 16px;">
                <!-- 预设名称 -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 500;">预设名称</label>
                    <input id="edit-preset-name" type="text" placeholder="输入预设名称" style="width: 100%; padding: 8px 12px; border: 1px solid #DCDCDC; border-radius: 6px; font-size: 14px; box-sizing: border-box; color: #1E1E1E;">
                </div>
                <!-- 反代地址 -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 500;">反代地址</label>
                    <input id="edit-preset-proxy-url" type="text" placeholder="例如: https://api.openai.com" style="width: 100%; padding: 8px 12px; border: 1px solid #DCDCDC; border-radius: 6px; font-size: 14px; box-sizing: border-box; color: #1E1E1E;">
                </div>
                <!-- 密钥 -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 500;">密钥</label>
                    <input id="edit-preset-api-key" type="password" placeholder="sk-..." style="width: 100%; padding: 8px 12px; border: 1px solid #DCDCDC; border-radius: 6px; font-size: 14px; box-sizing: border-box; color: #1E1E1E;">
                </div>
                <!-- 模型选择 -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 500;">模型</label>
                    <select id="edit-preset-model-select" style="width: 100%; padding: 8px 12px; border: 1px solid #DCDCDC; border-radius: 6px; font-size: 14px; box-sizing: border-box; color: #1E1E1E; background-color: #FFFFFF;"></select>
                </div>
                <!-- 拉取模型按钮 -->
                <div style="margin-bottom: 16px;">
                    <button id="edit-preset-fetch-models-btn" style="width: 100%; padding: 10px; border: none; background-color: #FFFFFF; color: #1E1E1E; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 14px;">拉取模型</button>
                </div>
            </div>
            <div style="padding: 16px; border-top: 1px solid #EAEAEA; display: flex; gap: 12px; justify-content: flex-end; flex-shrink: 0;">
                <button id="edit-api-preset-cancel-btn" style="padding: 10px 20px; border: 1px solid #DCDCDC; border-radius: 8px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500;">取消</button>
                <button id="edit-api-preset-save-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background-color: #1E1E1E; color: #FFFFFF; cursor: pointer; font-weight: 500;">保存</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 编辑API预设模态框结束 ▲▲▲ -->

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>
<div id="sticker-actions-panel" style="position: absolute; z-index: 1001; display: none; background-color: #333333; border-radius: 8px; padding: 5px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
    <button id="edit-sticker-meaning-btn">改含义</button>
    <button id="delete-sticker-btn">删除</button>
    <button id="batch-delete-stickers-btn">批量删除</button>
</div>

    <audio id="audio-player" style="display:none;"></audio>
<!-- ▼▼▼ 【Minimax TTS】语音播放器 ▼▼▼ -->
<audio id="tts-audio-player" style="display:none;"></audio>
<!-- ▲▲▲ 【Minimax TTS】语音播放器 ▲▲▲ -->

<!-- ▼▼▼ 用下面这段【完整】的模态框代码，替换掉你现有的 id="create-post-modal" 的整个 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span>发布动态</span>
        </div>
        <div class="modal-body">
            <!-- 公开文字输入区 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="分享新鲜事...（非必填的公开文字）"></textarea>
            </div>

            <!-- === 模式切换开关 (新增) === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

<!-- ▼▼▼ 【修正后】的可见范围设置 ▼▼▼ -->
<div class="form-group">
    <label>可见范围</label>
    <div class="visibility-switcher">
    <label>
        <input type="radio" name="visibility" value="public" checked>
        <span>公开</span>
    </label>
    <label>
        <input type="radio" name="visibility" value="include">
        <span>指定分组</span>
    </label>
</div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
        <!-- 分组多选框将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 修正结束 ▲▲▲ -->

            <!-- === 图片模式区域 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
<div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="图片预览">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                        <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>图片描述 (必填，给AI看)</label>
                    <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                </div>
            </div>

            <!-- === 文字图模式区域 (新增) === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">取消</button>
            <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理好友分组</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分组</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
<div style="display: flex; gap: 10px; align-items: center;">
    
    <button id="add-new-group-btn" class="circle-btn" style="border: none;">
        <svg viewBox="0 0 24 24" fill="white">
            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
        </svg>
    </button>
</div>                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分组列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<!-- 新的微信风格操作面板 -->
<div id="wechat-style-actions-panel">
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
        </svg>
        <button id="edit-message-btn">编辑消息</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
        </svg>
        <button id="copy-message-btn">复制文本</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
        </svg>
        <button id="recall-message-btn">撤回</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>
        </svg>
        <button id="quote-message-btn">引用</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/>
        </svg>
        <button id="select-message-btn">进入多选</button>
    </div>
</div>

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">编辑动态</button>
            <button id="copy-post-btn">复制内容</button>           
            <button id="cancel-post-action-btn">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 编辑器容器，JS会在这里动态生成文本框 -->
            <div id="message-editor-container"></div>
            <!-- 添加新消息的按钮 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 添加下一条消息
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
            <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品信息</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">代付金额 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">取消</button>
            <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新建约定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">约定标题</label>
                <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">约定日期与时间</label>
                <input type="datetime-local" id="countdown-date-input">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">取消</button>
            <button class="save" id="confirm-create-countdown-btn">保存约定</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0;">
<!-- 1. 页签切换 -->
<div class="frame-tabs">
    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
</div>

            <!-- 2. 拼手气红包内容区 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>总金额 (元)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>红包个数</label>
                    <input type="number" id="rp-group-count" placeholder="填写红包个数">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
            </div>

            <!-- 3. 专属红包内容区 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>发送给</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>金额 (元)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">的红包</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">元</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 领取详情将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发起投票</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">投票问题</label>
                <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
            </div>
            <div class="form-group">
                <label>投票选项 (至少2项)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 投票选项将由JS动态生成在这里 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加选项</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">取消</button>
            <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header" style="position: relative;">
            <span id="ai-avatar-library-title">对方的头像库</span>
            <button id="add-ai-avatar-btn" class="circular-svg-button" title="添加头像">
                <svg viewBox="0 0 24 24">
                    <path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14ZM19 7V4H17V7H14V9H17V12H19V9H22V7H19Z"/>
                </svg>
            </button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <!-- 头像库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【新增】AI表情包库管理模态框 ▼▼▼ -->
<div id="ai-stickers-library-modal" class="modal">
    <div class="modal-content" style="height: 70%; width: 90% !important; max-width: 90% !important;">
        <div class="modal-header" style="position: relative;">
            <span id="ai-stickers-library-title">AI表情包库</span>
            <button id="add-ai-sticker-btn" class="circular-svg-button" title="添加表情包">
                <svg viewBox="0 0 24 24">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
            </button>
            <button id="import-txt-ai-sticker-btn" class="circular-svg-button" title="导入TXT表情包">
                <svg viewBox="0 0 24 24">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="12" y1="19" x2="12" y2="13"></line>
                    <line x1="9" y1="16" x2="15" y2="16"></line>
                </svg>
            </button>
            <button id="batch-add-ai-sticker-btn" class="circular-svg-button" title="批量添加表情包">
                <svg viewBox="0 0 24 24">
                    <path d="M3 5h18v2H3zm0 6h18v2H3zm0 6h18v2H3z"/>
                </svg>
            </button>
            <button id="manage-ai-sticker-library-btn" class="circular-svg-button" title="管理表情包">
                <svg viewBox="0 0 24 24">
                    <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                </svg>
            </button>
            <button id="search-ai-sticker-btn" class="circular-svg-button" title="搜索表情包">
                <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
            </button>
            <input type="file" id="import-txt-ai-sticker-input" accept=".txt,.docx" style="display: none;">
        </div>
        <div id="ai-stickers-stats" style="text-align: center; font-size: 12px; color: #999; padding: 8px 0; border-bottom: 1px solid #eee;"></div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-stickers-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; align-items: center;">
                <!-- 表情包库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-stickers-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 【新增】AI表情包库管理模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 【新增】AI表情包搜索模态框 ▼▼▼ -->
<div id="ai-sticker-search-modal" class="modal">
    <div class="modal-content" style="height: auto; width: 80% !important; max-width: 500px !important;">
        <div class="modal-header" style="position: relative;">
            <span>搜索表情包</span>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="ai-sticker-search-input" placeholder="输入表情包含义（如：快理我）" style="flex: 1; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--bg-secondary); color: var(--text-primary); box-sizing: border-box;">
                <button id="ai-sticker-search-btn" class="save" style="width: auto; padding: 0 15px;">搜索</button>
            </div>
            <div id="ai-sticker-search-results" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; align-items: center; max-height: 400px; overflow-y: auto;">
                <!-- 搜索结果将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-sticker-search-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 【新增】AI表情包搜索模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】情侣头像库模态框 ▼▼▼ -->
<div id="couple-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%; width: 90% !important; max-width: 90% !important;">
        <div class="modal-header" style="position: relative;">
            <span id="couple-avatar-library-title">情侣头像库</span>
            <button id="add-couple-avatar-btn" class="circular-svg-button" title="添加情侣头像">
                <svg viewBox="0 0 24 24">
                    <path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14ZM19 7V4H17V7H14V9H17V12H19V9H22V7H19Z"/>
                </svg>
            </button>
        </div>
        <div class="modal-body" style="padding: 0 !important; display: block !important; width: 100% !important;">
            <div id="couple-avatar-library-grid" style="">
                <!-- 情侣头像库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-couple-avatar-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 400px; height: 600px;">
        <div class="modal-header">
            <span>分享链接</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">标题</label>
                <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
            </div>
            <div class="form-group">
                <label for="link-description-input">摘要 (可选)</label>
                <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">来源名称 (可选)</label>
                <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
            </div>
            <div class="form-group">
                <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">取消</button>
            <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
<div id="transfer-actions-modal" class="modal">
    <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
            <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
        </div>
        <div class="transfer-actions-footer">
            <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
            <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
<div id="call-transcript-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="transcript-modal-title">通话详情</span>
        </div>
        <div class="modal-body" id="transcript-modal-body" style="background-color: #F7F7F7;">
            <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="delete-transcript-btn" style="background-color: #AB4D3F; color: white; border-color: #AB4D3F;">删除记录</button>
            <button class="save" id="close-transcript-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
<div id="share-target-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>分享到...</span>
        </div>
        <div class="modal-body" id="share-target-list" style="padding: 0;">
            <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-target-btn">取消</button>
            <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】转发方式选择模态框 ▼▼▼ -->
<div id="forward-method-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>选择转发方式</span>
        </div>
        <div class="modal-body" style="padding: 20px; text-align: center;">
            <div style="margin-bottom: 20px;">
                <button id="merge-forward-btn" class="forward-method-btn" style="width: 100%; padding: 15px; margin-bottom: 10px; border: none; background: #F0F0F0; color: #333; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 500;">
                    📦 合并转发
                    <div style="font-size: 12px; color: #999; margin-top: 5px; font-weight: normal;">转发为一个包含全部消息的卡片</div>
                </button>
                <button id="single-forward-btn" class="forward-method-btn" style="width: 100%; padding: 15px; border: none; background: #F0F0F0; color: #333; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 500;">
                    💬 逐条转发
                    <div style="font-size: 12px; color: #999; margin-top: 5px; font-weight: normal;">逐条转发消息，显示为用户消息</div>
                </button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-forward-method-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
<div id="shared-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div class="modal-body" id="shared-history-viewer-content" style="background-color: #F7F7F7;">
            <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【NPC管理】自定义NPC设置模态框 ▼▼▼ -->
<div id="npc-manager-modal" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 500px; max-height: 85vh; overflow: hidden; display: flex; flex-direction: column;">
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; padding: 16px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; text-align: left !important;">
            <span id="npc-modal-title" style="flex: 1;">NPC管理</span>
            <button id="npc-modal-close" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text-secondary); flex-shrink: 0; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-left: auto;">&times;</button>
        </div>

        <!-- 选项卡 -->
        <div id="npc-tabs" style="display: flex; gap: 0; border-bottom: 1px solid var(--border-color); flex-shrink: 0; background-color: #f9f9f9;">
            <button class="npc-tab-btn" data-tab="characters" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-size: 14px; font-weight: 500; border-bottom: 2px solid transparent; color: var(--text-secondary);">角色列表</button>
            <button class="npc-tab-btn npc-tab-active" data-tab="list" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-size: 14px; font-weight: 500; border-bottom: 2px solid #1E1E1E; color: #1E1E1E;">NPC列表</button>
            <button class="npc-tab-btn" data-tab="create" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-size: 14px; font-weight: 500; border-bottom: 2px solid transparent; color: var(--text-secondary);">添加NPC</button>
        </div>

        <!-- 模态框内容区 -->
        <div class="modal-body" style="overflow-y: auto; flex: 1; padding: 16px;">

            <!-- 【新增】角色列表标签页内容 -->
            <div id="characters-tab" class="npc-tab-content" style="display: none; flex-direction: column; gap: 12px; width: 100%;">
                <div id="character-list-container" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 角色项目将由JS动态生成 -->
                </div>
                <div id="character-empty-state" style="text-align: center; color: var(--text-secondary); padding: 30px 20px; display: none;">
                    <p>暂无角色</p>
                </div>
            </div>

            <!-- NPC列表标签页 -->
            <div id="npc-list-tab" class="npc-tab-content" style="display: flex; flex-direction: column; gap: 12px; width: 100%;">
                <div id="npc-list-container" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- NPC项目将由JS动态生成 -->
                </div>
                <div id="npc-empty-state" style="text-align: center; color: var(--text-secondary); padding: 30px 20px; display: none;">
                    <p>还没有自定义NPC，点击"添加NPC"来创建一个</p>
                </div>
            </div>

            <!-- NPC创建/编辑表单 -->
            <div id="npc-create-tab" class="npc-tab-content" style="display: none; width: 100%;">
                <form id="npc-form" style="display: flex; flex-direction: column; gap: 14px; width: 100%;">

                    <!-- 头像上传 -->
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="font-weight: 500; font-size: 14px;">NPC头像</label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <img id="npc-avatar-preview" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #f0f0f0;">
                            <button type="button" id="npc-avatar-upload-btn" style="padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 6px; background-color: #fff; cursor: pointer; font-size: 13px;">上传头像</button>
                            <input type="file" id="npc-avatar-input" accept="image/*" style="display: none;">
                        </div>
                    </div>

                    <!-- NPC昵称 -->
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="font-weight: 500; font-size: 14px;">NPC昵称</label>
                        <input type="text" id="npc-name-input" placeholder="输入NPC的昵称" style="padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    </div>

                    <!-- NPC人设 -->
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="font-weight: 500; font-size: 14px;">NPC人设</label>
                        <textarea id="npc-persona-input" placeholder="描述NPC的性格、背景、特点等" style="padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; box-sizing: border-box; min-height: 100px; resize: vertical;"></textarea>
                    </div>

                    <!-- 关联角色 -->
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="font-weight: 500; font-size: 14px;">关联角色（NPC会评论这些角色的帖子）</label>
                        <div id="npc-characters-container" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 8px; background-color: #fafafa;">
                            <!-- 角色复选框将由JS动态生成 -->
                        </div>
                    </div>

                    <!-- 保存按钮 -->
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button type="button" id="npc-cancel-btn" style="flex: 1; padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background-color: #fff; cursor: pointer; font-weight: 500; font-size: 14px;">取消</button>
                        <button type="submit" id="npc-save-btn" style="flex: 1; padding: 12px; border: none; border-radius: 6px; background-color: #1E1E1E; color: white; cursor: pointer; font-weight: 500; font-size: 14px;">保存NPC</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【新增】自动刷新设置模态框 ▼▼▼ -->
<div id="autorefresh-settings-modal" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 400px;">
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; padding: 16px; border-bottom: 1px solid var(--border-color); text-align: left !important;">
            <span style="flex: 1;">自动刷新设置</span>
            <button id="autorefresh-modal-close" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text-secondary); flex-shrink: 0; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-left: auto;">&times;</button>
        </div>
        <div class="modal-body" style="padding: 20px; display: flex; flex-direction: column; gap: 20px;">

            <!-- 启用/禁用开关 -->
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label style="font-weight: 500; font-size: 14px;">启用自动刷新</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="autorefresh-enabled" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
            </div>

            <!-- 刷新间隔设置 -->
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <label style="font-weight: 500; font-size: 14px;">刷新间隔（分钟）</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="autorefresh-interval" min="1" max="60" value="5" style="flex: 1; cursor: pointer;">
                    <span id="autorefresh-interval-display" style="min-width: 40px; text-align: right; font-weight: 500; font-size: 14px;">5分钟</span>
                </div>
                <p style="font-size: 12px; color: var(--text-secondary); margin: 0;">最小1分钟，最大60分钟</p>
            </div>

            <!-- 状态显示 -->
            <div id="autorefresh-status" style="padding: 12px; border-radius: 6px; background-color: #f9f9f9; font-size: 13px; color: var(--text-secondary); text-align: center;">
                自动刷新已禁用
            </div>

            <!-- 操作按钮 -->
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button id="autorefresh-cancel-btn" style="flex: 1; padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background-color: #fff; cursor: pointer; font-weight: 500; font-size: 14px;">取消</button>
                <button id="autorefresh-save-btn" style="flex: 1; padding: 12px; border: none; border-radius: 6px; background-color: #1E1E1E; color: white; cursor: pointer; font-weight: 500; font-size: 14px;">保存</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 自动刷新设置模态框添加结束 ▲▲▲ -->

<!-- ▼▼▼ 【统一】世界书管理模态框 ▼▼▼ -->
<div id="world-book-unified-modal" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 500px; height: 90%; max-height: 90vh;">
        <div class="modal-header">
            <span id="unified-modal-title">世界书管理</span>
            <button id="unified-modal-close" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text-secondary);">&times;</button>
        </div>
        <div class="modal-body" style="overflow-y: auto;">
            <!-- 主菜单 -->
            <div id="unified-main-menu" class="unified-view">
                <div class="unified-menu-item" data-action="create-book">
                    <div class="menu-icon">📖</div>
                    <div class="menu-text">
                        <div class="menu-title">创建新世界书</div>
                        <div class="menu-desc">添加一本新的世界观设定书</div>
                    </div>
                    <div class="menu-arrow">›</div>
                </div>
                <div class="unified-menu-item" data-action="manage-categories">
                    <div class="menu-icon">📂</div>
                    <div class="menu-text">
                        <div class="menu-title">管理分类</div>
                        <div class="menu-desc">创建、删除和整理世界书分类</div>
                    </div>
                    <div class="menu-arrow">›</div>
                    
                </div>
                <div class="unified-menu-item" data-action="import-book">
                    <div class="menu-icon">📥</div>
                    <div class="menu-text">
                        <div class="menu-title">导入世界书</div>
                        <div class="menu-desc">从 .json 或 .txt 文件导入条目</div>
                    </div>
                    <div class="menu-arrow">›</div>
                </div>
            </div>
            

            <!-- 创建世界书视图 -->
            <div id="unified-create-book" class="unified-view" style="display: none;">
                <div class="form-group">
                    <label for="unified-book-name">书名</label>
                    <input type="text" id="unified-book-name" placeholder="请输入世界书的名称..." class="input-field">
                </div>
                <div class="form-group">
                    <label for="unified-book-category">分类</label>
                    <select id="unified-book-category" class="input-field">
                        <!-- 选项将由JS动态生成 -->
                    </select>
                </div>
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label for="unified-book-content">内容</label>
                    <!-- 搜索框 -->
                    <div class="wb-search-container" style="margin-bottom: 10px;">
                        <input type="text" id="wb-content-search" placeholder="搜索内容..." class="input-field" style="padding-right: 80px;">
                        <button id="wb-search-btn" class="wb-search-btn">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="white">
                                <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                            </svg>
                        </button>
                        <button id="wb-search-clear" class="wb-search-clear-btn" style="display: none;">✕</button>
                    </div>
                    <textarea id="unified-book-content" placeholder="在此处输入详细的世界观设定..." class="input-field" style="flex-grow: 1; min-height: 450px; resize: vertical;"></textarea>
                </div>
                <div class="unified-actions">
                </div>
            </div>

            <!-- 管理分类视图 -->
            <div id="unified-manage-categories" class="unified-view" style="display: none;">
                <div class="form-group">
                    <label>新建分类</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="unified-new-category-name" placeholder="输入分类名..." class="input-field" style="flex-grow: 1;">
                        <button id="unified-add-category-btn" class="primary-button" style="width: auto; padding: 0 20px;">+</button>
                    </div>
                </div>
                <div style="margin: 20px 0; height: 1px; background: rgba(255, 255, 255, 0.2);"></div>
                <div id="unified-categories-list" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 分类列表将由JS动态生成 -->
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="primary-button" id="unified-modal-done" style="width: 100%;">保存世界书</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 统一模态框结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】论坛生成设置模态框 ▼▼▼ -->
<div id="forum-settings-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>生成论坛八卦</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>选择参与八卦的角色 (可多选)</label>
                <div id="forum-character-selector" style="max-height: 200px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                    <!-- 角色选项将由JS动态生成 -->
                </div>
                <div class="form-group">
    <label>选择关联的世界书 (可选)</label>
    <div id="forum-worldbook-selector" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
        </div>
</div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-forum-settings-btn">取消</button>
            <button class="save" id="generate-forum-posts-btn">开始生成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
 <div id="html-prompt-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>发送HTML生成指令</span>
        </div>
        <div class="modal-body">
            <textarea id="html-prompt-input" placeholder="在此输入您对HTML模块的要求，例如：生成二十条{{char}}最近和朋友的聊天记录..."></textarea>
        </div>
        <div class="modal-footer">
            <button id="cancel-html-prompt-btn" class="circle-btn" style="background-color: #1E1E1E;" title="取消">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
            <button id="send-html-prompt-btn" class="circle-btn" style="background-color: #1E1E1E;" title="发送指令">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
            </button>
        </div>
    </div>
</div>
 <div id="bind-character-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span>绑定到角色</span>
        </div>
        <div class="modal-body">
            <div id="bind-character-grid">
                </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="cancel-char-binding-btn" class="circle-btn" style="background-color: #1E1E1E;" title="取消">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
                    <path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <button id="confirm-char-binding-btn" class="circle-btn" style="background-color: #1E1E1E;" title="确认绑定">
                <svg width="16" height="16" viewBox="0 0 24 24" style="fill: white; stroke: none;">
                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
                    </svg>
            </button>
        </div>
    </div>
</div>

<!-- 礼物模态框 -->
<div id="gift-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>赠送礼物</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="gift-name-input">礼物名称</label>
                <input type="text" id="gift-name-input" placeholder="请输入礼物名称">
            </div>
            <div class="form-group">
                <label for="gift-price-input">礼物价格</label>
                <input type="number" id="gift-price-input" placeholder="请输入礼物价格" min="0" step="0.01">
            </div>
            <div class="form-group" id="gift-recipient-group" style="display: none;">
                <label for="gift-recipient-select">赠送对象</label>
                <select id="gift-recipient-select">
                    <option value="random">拼手气（随机赠送）</option>
                </select>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-gift-btn">取消</button>
            <button class="save" id="send-gift-btn">赠送</button>
        </div>
    </div>
</div>

<script>
        // iOS全屏处理：动态计算并强制设置应用高度，以修复PWA启动时的空白问题
        // 【新增】全局控制开关，用于在下载时禁用高度重新计算
        window.isVhUpdateDisabled = false;

        function setVhProperty() {
            // 【新增】如果在下载/导出期间，禁止更新 --vh，防止 iOS 视口变化导致底部空白
            if (window.isVhUpdateDisabled) {
                console.log('⚠️ [VH更新] 已禁用，跳过本次更新');
                return;
            }

            // 这个函数的功能保持不变，它计算并设置 --vh 变量
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            console.log('✅ [VH更新] 设置 --vh 为:', `${vh}px`);
        }

        // --- 核心修复：更频繁、更积极地调用高度计算函数 ---

        // 为了应对iOS PWA启动时，浏览器尺寸不稳定的问题，
        // 我们在页面加载过程中的多个关键节点都调用一次 setVhProperty 函数。
        // 这大大增加了捕获到最终正确屏幕高度的几率。

        // 1. 立即执行一次
        setVhProperty();

        // 2. 在页面所有资源（如图片）加载完成后再次执行，此时尺寸更可能稳定
        window.addEventListener('load', setVhProperty);

        // 3. 监听窗口尺寸变化（这部分和原来一样）
        // 【修改】用箭头函数包装，以便在需要时能够移除监听器
        window.setVhOnResize = () => setVhProperty();
        window.addEventListener('resize', window.setVhOnResize);

        window.setVhOnOrientationChange = () => {
            // 旋转屏幕后，多次延迟执行以确保获取最终尺寸
            setTimeout(setVhProperty, 100);
            setTimeout(setVhProperty, 300);
        };
        window.addEventListener('orientationchange', window.setVhOnOrientationChange);

        // 4. 作为最后的保险，在启动后短暂延迟再次执行，捕获那些最晚稳定下来的情况
        setTimeout(setVhProperty, 150);
        setTimeout(setVhProperty, 500);

        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(',')[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}用户向你发送了一张图片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 尝试解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 验证解析结果是否为数组
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失败，返回原始文本
            }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了状态',
            change_music:'切换了歌曲',
            create_memory:'记录了回忆',
            create_countdown:'创建了约定/倒计时',
            text:'发送了文本',
            sticker:'发送了表情',
            ai_image:'发送了图片',
            voice_message:'发送了语音',
            transfer:'发起了转账',
            waimai_request:'发起了外卖请求',
            waimai_response:{
                paid:'回应了外卖-同意',
                rejected:'回应了外卖-拒绝'
            },
            video_call_request:'发起了视频通话',
            video_call_response:{
                accept:'回应了视频通话-接受',
                reject:'回应了视频通话-拒绝'
            },
            qzone_post:{
                shuoshuo:'发布了说说',
                text_image:'发布了文字图'
            },
            qzone_comment:'评论了动态',
            qzone_like:'点赞了动态',
            pat_user:'拍一拍了用户',
            block_user:'拉黑了用户',
            friend_request_response:'回应了好友申请',
            change_avatar:'更换了头像',
            share_link:'分享了链接',
            accept_transfer:'回应了转账-接受',
            decline_transfer:'回应了转账-拒绝/退款',
            send_gift:'赠送了礼物',
            accept_gift:'接受了礼物',
            decline_gift:'拒绝了礼物',
            quote_reply:'引用了回复',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含义是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/离开' : '空闲'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 图片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 点赞的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 结果是:${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 头像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'decline_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'send_gift'){
                    return [{text:`${time}[${text}] 礼物名称:${obj.giftName} 价格:¥${obj.giftPrice}`}]
                }else if(itemType === 'accept_gift'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'decline_gift'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的内容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

if(Array.isArray(res) && res.length > 1) {
	res = `${res[0]}${res[1].content}`
}

        return [{text:res}]
    }

    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision,isGemini) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增这一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
                        let  includesImages = false;
                        if(Array.isArray(item.content) && item.content.length === 2){
                              includesImages =  item.content.some((sub)=>{
                                return sub.type === 'image_url' && sub.image_url.url
                            })
                        }
                        return {
                            role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        const db = new Dexie('GeminiChatDB');
        // --- 已修正 ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, apiPresets: [], userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null, promptPresets: [], backgroundActivityChats: new Set(), customNPCs: [], isNPCRefreshing: false, autoRefreshSettings: { enabled: false, interval: 5, timerId: null }, customPresetItems: [], newCommentPostIds: new Set() };

        // ⚠️ 【Minimax TTS】全局变量已在第29067行定义，此处不重复定义

        // 【新增】主动回复API调用的中断控制器
        let activeReplyAbortController = null;

        // 线上/线下模式状态
        let offlineMode = {
            isOffline: false,     // 当前是否为线下模式
            isMonitorMode: false, // 当前是否为监控模式
            chatHistory: {}       // 每个聊天的线下模式记录
        };
        
        // 提取消息内容的通用函数（已简化，不再处理特殊标签）
        function extractMessageContent(msg) {
            // 【新增】处理naiimag类型消息
            if (msg.type === 'naiimag') {
                return `[NovelAI生成的图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
            }

            if (!msg.content) return '';

            // 【核心修复】检查msg.meaning来识别表情包（用户发送的）
            // 将其转换为 [表情:含义] 格式，让AI可以理解
            if (msg.meaning) {
                // 同时检查内容是否是URL或Base64，确保这真的是一个表情包
                if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                    return `[表情:${msg.meaning}]`;
                }
            }

            // 【新增】检查AI发送的 [表情:含义] 格式，确保它在历史记录中保持原样
            if (typeof msg.content === 'string' && msg.content.match(/^\[表情:[^\]]+\]$/)) {
                return msg.content;
            }

            // 其他所有情况，返回原始文本内容
            return msg.content;
        }
        // --- 修正结束 ---
let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    startTime: null, // 新增：记录会话开始时间
    playedIndices: new Set(), // 新增：记录实际播放过的歌曲索引
    // 【新增】歌词相关状态
    parsedLyrics: [],      // 当前歌曲解析后的歌词数组
    currentLyricIndex: -1  // 当前高亮的歌词行索引
};
        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let newChatBackgroundBase64 = null;
        let isSelectionMode = false;
        let isWbSelectionMode = false;
        let selectedWorldBooks = new Set();
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;
        let activeStickerId = null; // 用于暂存被长按的表情ID
let isStickerSelectionMode = false; // 表情批量删除模式的开关
const selectedStickerIds = new Set(); // 存储被选中的表情ID
        // 【新增】在JS顶部，变量定义区，添加这个新变量
let editingBubblePresetId = null; // 用于追踪正在编辑的气泡预设ID
// (程煜：新增的Web Audio API变量)
let audioContext = null;
let notificationAudioBuffer = null; // 用来存预加载的音频数据
let isAudioContextUnlocked = false; // 标记是否已经“解锁”

let waimaiTimers = {}; // 用于存储外卖倒计时

let activeMessageTimestamp = null;
let lyricCommentaryIntervalId = null; // <-- 在这里粘贴新代码
let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
let activePostId = null; // <-- 新增：用于存储当前操作的动态ID

        let photoViewerState = {
            isOpen: false,
            photos: [], // 存储当前相册的所有照片URL
            currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

// 【全局头像常量】确保所有函数都能访问
const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;
        // ▼▼▼ 新增：通知音频预加载对象 ▼▼▼
        let notificationAudioCache = {}; // 用来缓存已加载的音频对象
        // ▲▲▲ 新增：通知音频预加载对象 ▲▲▲
        let isLoadingMore = false; // 新增：用于防止加载更多时自动滚动的标志
        let currentForumPosts = []; // 用于存储当前论坛的帖子数据

// ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
    'forum': 'https://i.postimg.cc/W3y7GZ1W/IMG-6443.jpg',
    'x-social': 'https://i.postimg.cc/YChdnZ7y/IMG-7390.png',
    'preset': 'https://i.postimg.cc/jS7VFFzK/48f6a5613i7390a98ea9534f61ff5fde.png',
    'kk-checkin': 'https://i.postimg.cc/MGwrL0nf/kitty.png'
};
// ▲▲▲ 添加结束 ▲▲▲

        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() {
            modalOverlay.classList.remove('visible');
            modalConfirmBtn.classList.remove('btn-danger');
            if (modalResolve) modalResolve(null);
        }

        // 显示导入加载动画（支持实时更新）
        function showImportLoading(title, message) {
            if (!document.getElementById('import-loading-overlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'import-loading-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                    backdrop-filter: blur(4px);
                `;

                const loadingBox = document.createElement('div');
                loadingBox.id = 'import-loading-box';
                loadingBox.style.cssText = `
                    background: white;
                    border-radius: 16px;
                    padding: 30px;
                    text-align: center;
                    min-width: 280px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
                `;

                loadingBox.innerHTML = `
                    <div style="
                        width: 50px;
                        height: 50px;
                        border: 3px solid #f0f0f0;
                        border-top: 3px solid #1E1E1E;
                        border-radius: 50%;
                        margin: 0 auto 20px;
                        animation: spin 0.8s linear infinite;
                    "></div>
                    <div id="import-loading-title" style="font-size: 16px; font-weight: 500; margin-bottom: 8px; color: #1E1E1E;">${title}</div>
                    <div id="import-loading-message" style="font-size: 14px; color: #888; white-space: pre-wrap;">${message}</div>
                    <style>
                        @keyframes spin {
                            to { transform: rotate(360deg); }
                        }
                    </style>
                `;

                overlay.appendChild(loadingBox);
                document.body.appendChild(overlay);
            }
        }

        // 更新导入加载动画的消息
        function updateImportLoading(message) {
            const messageEl = document.getElementById('import-loading-message');
            if (messageEl) {
                messageEl.textContent = message;
            }
        }

        // 隐藏导入加载动画
        function hideImportLoading() {
            const overlay = document.getElementById('import-loading-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '确定';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '好的';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '确定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }

// ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        // 核心修改1：为textarea移除固定的rows和resize，并添加overflow:hidden
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" style="width: 100%; padding: 12px 16px; border-radius: 8px; border: 1px solid #DCDCDC; font-size: 16px; box-sizing: border-box; resize: none; overflow-y: hidden;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 核心修改2：如果这是一个textarea，就绑定自动增高事件
        if (type === 'textarea') {
            input.addEventListener('input', () => autoGrowTextarea(input));
            // 初始加载时也调用一次，以设置正确的初始高度
            setTimeout(() => autoGrowTextarea(input), 0);
        }
        
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                        // 应用模板后也要触发一次高度计算
                        if(type === 'textarea') autoGrowTextarea(input);
                    } catch(e) {
                        console.error("解析格式模板失败:", e);
                    }
                } else if (btn.dataset.type === 'text') { // 特殊处理说说的按钮
                    input.value = "在这里输入说说的内容...";
                    input.focus();
                    if(type === 'textarea') autoGrowTextarea(input);
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ Profile 编辑功能函数（新增） ▼▼▼

/**
 * 显示选择菜单模态框
 * @param {string} title - 模态框的标题
 * @param {Array<object>} options - 按钮选项数组, e.g., [{ text: '按钮文字', value: '返回值' }]
 * @returns {Promise<string|null>} - 返回用户点击按钮的value，如果取消则返回null
 */
function showChoiceModal(title, options) {
    return new Promise(resolve => {
        const modal = document.getElementById('preset-actions-modal');
        const footer = modal.querySelector('.custom-modal-footer');

        // 保存原始的gap值
        const originalGap = footer.style.gap;

        footer.innerHTML = '';
        footer.style.gap = '12px'; // 缩小按钮间距
        footer.style.display = 'flex'; // 确保flex布局生效
        footer.style.flexWrap = 'wrap'; // 允许换行（如果需要的话）

        options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.style.flex = '1 1 auto'; // 让按钮均匀分布
            button.onclick = () => {
                // 移除点击外部关闭的监听
                document.removeEventListener('click', closeOnOutsideClick);
                modal.classList.remove('visible');
                // 恢复原始样式
                footer.style.gap = originalGap;
                resolve(option.value);
            };
            footer.appendChild(button);
        });

        // 不再添加取消按钮，改为点击外部自动关闭
        const closeOnOutsideClick = (e) => {
            // 检查点击是否在modal及其内容外部
            const modalContent = modal.querySelector('#custom-modal') || modal;
            if (!modalContent.contains(e.target)) {
                document.removeEventListener('click', closeOnOutsideClick);
                modal.classList.remove('visible');
                // 恢复原始样式
                footer.style.gap = originalGap;
                resolve(null);
            }
        };

        modal.classList.add('visible');
        // 延迟添加点击外部关闭的监听，避免立即触发
        setTimeout(() => {
            document.addEventListener('click', closeOnOutsideClick);
        }, 100);
    });
}

/**
 * 本地上传图片
 * @returns {Promise<string|null>} - 返回图片的Base64 Data URL
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result);
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null);
            }
        };

        input.click();
    });
}

/**
 * 处理编辑文本的函数
 * @param {HTMLElement} element - 被编辑的元素
 */
async function handleEditText(element) {
    const elementId = element.id;
    const placeholder = element.dataset.placeholder || "请输入新的内容：";
    const textSpan = element.querySelector('span');
    const isComplexElement = !!textSpan;
    const targetElement = isComplexElement ? textSpan : element;
    const currentValue = targetElement.textContent;

    const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue === placeholder ? "" : currentValue);

    if (newValue !== null) {
        const trimmedValue = newValue.trim();
        targetElement.textContent = trimmedValue ? trimmedValue : placeholder;
        state.globalSettings.widgetData[elementId] = isComplexElement ? element.innerHTML : targetElement.textContent;
        await db.globalSettings.put(state.globalSettings);
    }
}

/**
 * 处理编辑图片的函数
 * @param {HTMLElement} element - 被编辑的图片元素
 */
async function handleEditImage(element) {
    const elementId = element.id;

    const choice = await showChoiceModal("修改图片", [
        { text: '从本地上传', value: 'local' },
        { text: '使用网络URL', value: 'url' }
    ]);

    let newValue = null;

    if (choice === 'local') {
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        newValue = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
    }

    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
    } else if (choice === 'url' && newValue !== null) {
        alert("请输入一个有效的图片URL！");
    }
}

// ▲▲▲ Profile 编辑功能函数结束 ▲▲▲

        // 显示位置输入弹窗
        function showLocationModal() {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = '发送位置';
                
                // 创建位置输入表单
                modalBody.innerHTML = `
                    <div style="text-align: left; padding: 10px 0;">
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 14px; color: #333;">当前位置（可选）</label>
                            <input type="text" id="current-location" placeholder="请输入您的当前位置" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 14px; color: #333;">距离（可选）</label>
                            <input type="text" id="distance-input" placeholder="如：1.5公里、500米" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 14px; color: #333;">目标地点（可选）</label>
                            <input type="text" id="target-location" placeholder="请输入目标地点" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="font-size: 12px; color: #999; margin-top: 8px;">
                            提示：三个字段都是可选的，至少填写一个即可发送
                        </div>
                    </div>
                `;
                
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '发送';
                
                modalConfirmBtn.onclick = () => {
                    const currentLocation = document.getElementById('current-location').value.trim();
                    const distance = document.getElementById('distance-input').value.trim();
                    const targetLocation = document.getElementById('target-location').value.trim();
                    
                    // 至少需要填写一个字段
                    if (!currentLocation && !distance && !targetLocation) {
                        alert('请至少填写一个位置信息');
                        return;
                    }
                    
                    const locationData = {
                        currentLocation: currentLocation || '',
                        distance: distance || '',
                        targetLocation: targetLocation || ''
                    };
                    
                    // 先关闭模态框，再发送消息
                    hideCustomModal();
                    resolve(locationData);
                    
                    // 稍微延迟发送，确保模态框完全关闭
                    setTimeout(() => {
                        sendLocationMessage(locationData);
                    }, 100);
                };
                
                modalCancelBtn.onclick = () => {
                    resolve(null);
                    hideCustomModal();
                };
                
                showCustomModal();
                
                // 自动聚焦到第一个输入框
                setTimeout(() => {
                    document.getElementById('current-location').focus();
                }, 100);
            });
        }

        // 发送位置消息
        function sendLocationMessage(locationData) {
            if (!state.activeChatId) return;
            
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
            
            // 构建位置消息内容
            let locationText = '📍 位置信息\n';
            if (locationData.currentLocation) {
                locationText += `当前位置：${locationData.currentLocation}\n`;
            }
            if (locationData.distance) {
                locationText += `距离：${locationData.distance}\n`;
            }
            if (locationData.targetLocation) {
                locationText += `目标地点：${locationData.targetLocation}`;
            }
            
            // 创建位置消息
            const locationMsg = {
                role: 'user',
                content: locationText, // 直接使用文本字符串，与普通消息格式一致
                timestamp: Date.now(),
                isLocation: true, // 标记为位置消息
                locationData: locationData
            };
            
            // 添加到聊天记录
            chat.history.push(locationMsg);
            db.chats.put(chat);
            
            // 显示消息
            appendMessage(locationMsg, chat);
            scrollToBottom();
            
            // 关闭功能面板
            hidePlusPanel();
        }

        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

db.version(27).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId', // <-- 【核心修改1】在这里添加 categoryId
    worldBookCategories: '++id, name',    // <-- 【核心修改2】新增这个表
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName', // <--【核心修改】在这里加上 customName
    forumPosts: '++id', // <-- 添加这一行,用于存储论坛帖子
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name', // <-- 【新增】预设表
    customPresetItems: '++id, name' // <-- 【新增】自定义预设条目库表
});

db.version(28).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name', // <-- 【新增】自定义NPC表
    customPresetItems: '++id, name' // <-- 【新增】自定义预设条目库表
});

// ▼▼▼ 新增：版本29添加本地备份表 ▼▼▼
db.version(29).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name',
    customPresetItems: '++id, name', // <-- 【新增】自定义预设条目库表
    localBackups: '&id, timestamp' // <-- 【新增】本地备份表，用于离线备份恢复
});

db.version(30).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name',
    customPresetItems: '++id, name',
    localBackups: '&id, timestamp',
    worldEvents: '&id, chatId, timestamp' // <-- 【新增】大世界事件表，按chatId和时间戳索引
});
// ▲▲▲ 新增结束 ▲▲▲

db.version(32).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name',
    customPresetItems: '++id, name',
    localBackups: '&id, timestamp',
    worldEvents: '&id, chatId, timestamp',
    aiStickers: '&meaning' // 【新增】AI表情包表，存储表情包元数据和宽高
});

// ▼▼▼ 【新增】数据库版本 33：添加角色专属NAI提示词表 ▼▼▼
db.version(33).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name',
    customPresetItems: '++id, name',
    localBackups: '&id, timestamp',
    worldEvents: '&id, chatId, timestamp',
    aiStickers: '&meaning',
    characterNaiPrompts: '&chatId' // 【新增】每个角色的NAI提示词，key为chatId，包含正面/负面提示词
});
// ▲▲▲ 数据库版本 33 结束 ▲▲▲

db.version(34).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name',
    customPresetItems: '++id, name',
    localBackups: '&id, timestamp',
    worldEvents: '&id, chatId, timestamp',
    aiStickers: '&meaning',
    characterNaiPrompts: '&chatId'
});
// ▲▲▲ 数据库版本 34 结束 ▲▲▲

db.version(35).stores({
    chats: '&id, isGroup, groupId',
    apiConfig: '&id',
    globalSettings: '&id',
    apiPresets: '&id, name',
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
    callRecords: '++id, chatId, timestamp, customName',
    forumPosts: '++id',
    bubblePresets: '++id, name, css',
    promptPresets: '++id, name',
    customNPCs: '++id, name',
    customPresetItems: '++id, name',
    localBackups: '&id, timestamp',
    worldEvents: '&id, chatId, timestamp',
    aiStickers: '&meaning',
    characterNaiPrompts: '&chatId',
    naiGalleryImages: '++id, chatId, timestamp' // 【新增】NAI画廊图片表，按chatId和时间戳索引
});
// ▲▲▲ 数据库版本 35 结束 ▲▲▲

window.db = db;

        // ===================================================================
        // 3. 所有功能函数定义
        // ===================================================================

// ▼▼▼ 【新增】表情包 Blob 缓存管理系统 ▼▼▼

/**
 * 【Blob 缓存管理】将 URL 或 Base64 转换为 Blob 对象
 * @param {string} source - URL 或 Base64 字符串
 * @returns {Promise<Blob>}
 */
async function convertToBlob(source) {
    try {
        // 情况1：Base64 Data URL（本地上传的表情）
        if (source.startsWith('data:')) {
            const response = await fetch(source);
            return await response.blob();
        }

        // 情况2：网络 URL（AI 表情包库添加的）
        const response = await fetch(source);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.blob();
    } catch (e) {
        console.warn(`❌ Blob 转换失败 (${source.substring(0, 50)}...): ${e.message}`);
        throw e;
    }
}

/**
 * 【Blob 缓存管理】获取本地 Blob URL（如果有缓存则用缓存，否则从网络加载）
 * @param {string} id - 表情包 ID（userStickers）或 meaning（aiStickers）
 * @param {string} source - 原始 URL 或 Base64
 * @param {boolean} isBlobStored - 是否已有 blobData 存储
 * @returns {Promise<string>} 返回 Blob URL
 */
async function getStickerBlobUrl(id, source, isBlobStored = false) {
    try {
        // 如果已经有缓存的 Blob，则直接从数据库获取
        if (isBlobStored) {
            const table = source.includes('meaning=') ? 'aiStickers' : 'userStickers';
            const key = source.includes('meaning=') ? id : id;
            const record = await db[table].get(key);

            if (record && record.blobData) {
                const blob = new Blob([record.blobData]);
                return URL.createObjectURL(blob);
            }
        }

        // 否则从源 URL 加载并缓存
        const blob = await convertToBlob(source);

        // 异步保存到数据库（不阻塞 UI）
        (async () => {
            try {
                const table = source.includes('meaning=') ? 'aiStickers' : 'userStickers';
                const record = await (table === 'aiStickers'
                    ? db.aiStickers.get(id)
                    : db.userStickers.get(id)
                );

                if (record) {
                    record.blobData = blob;
                    await db[table].put(record);
                    console.log(`✅ 表情包 Blob 已缓存: ${id}`);
                }
            } catch (e) {
                console.warn(`⚠️ Blob 缓存失败: ${e.message}`);
            }
        })();

        return URL.createObjectURL(blob);
    } catch (e) {
        console.error(`❌ getStickerBlobUrl 失败: ${e.message}`);
        // 降级方案：返回原始 URL
        return source;
    }
}

/**
 * 【Blob 缓存管理】批量预加载表情包 Blob 到数据库
 * 在后台静默完成，不影响 UI
 * @param {Array} stickers - 表情包数组（需要有 id, url, meaning 字段）
 * @param {boolean} isAiStickers - 是否是 AI 表情包
 */
async function preloadStickerBlobs(stickers, isAiStickers = false) {
    if (!stickers || stickers.length === 0) return;

    const table = isAiStickers ? 'aiStickers' : 'userStickers';
    const batchSize = 3; // 每次并发 3 个

    for (let i = 0; i < stickers.length; i += batchSize) {
        const batch = stickers.slice(i, i + batchSize);

        await Promise.all(batch.map(async (sticker) => {
            try {
                // 检查是否已经有 blobData
                const existing = await db[table].get(isAiStickers ? sticker.meaning : sticker.id);
                if (existing && existing.blobData) {
                    return; // 已有缓存，跳过
                }

                // 转换并保存 Blob
                const blob = await convertToBlob(sticker.url);
                const key = isAiStickers ? sticker.meaning : sticker.id;
                const toSave = isAiStickers
                    ? { ...sticker, blobData: blob }
                    : { ...sticker, blobData: blob };

                await db[table].put(toSave);
                console.log(`✅ 预加载 Blob: ${key}`);
            } catch (e) {
                console.warn(`⚠️ 预加载失败 (${isAiStickers ? sticker.meaning : sticker.id}): ${e.message}`);
            }
        }));

        // 每批之间稍等，避免卡顿
        await new Promise(r => setTimeout(r, 100));
    }
}

// ▲▲▲ 【新增】表情包 Blob 缓存管理系统结束 ▲▲▲

/**
 * 【新增】AI表情包一键迁移脚本
 * 从旧世界书格式迁移表情包数据到 aiStickers 数据库表
 *
 * 使用方法：在浏览器控制台执行
 * await migrateAiStickersFromWorldBook(chat.settings.aiPersona)
 *
 * @param {string} worldBookContent - 世界书内容（或者直接读 chat.settings.aiPersona）
 * @returns {Promise<Object>} 返回迁移统计结果
 */
async function migrateAiStickersFromWorldBook(worldBookContent) {
    if (!worldBookContent || typeof worldBookContent !== 'string') {
        console.error('❌ 迁移失败：输入的世界书内容无效');
        return { success: false, error: '内容无效' };
    }

    const stats = {
        total: 0,
        success: 0,
        failed: 0,
        skipped: 0,
        details: []
    };

    // 正则表达式：匹配旧格式 "含义 + 文件名"
    // 例如：亲亲你m4x4tk.jpeg
    const stickerRegex = /^(.+?)(\S+\.(?:jpeg|jpg|png|gif))$/gm;

    let match;
    while ((match = stickerRegex.exec(worldBookContent)) !== null) {
        stats.total++;
        const meaning = match[1].trim();
        const urlPart = match[2].trim();

        // 拼接完整 URL
        const fullUrl = `https://files.catbox.moe/${urlPart}`;

        try {
            // 检查是否已存在
            const existing = await db.aiStickers.where('meaning').equals(meaning).first();
            if (existing) {
                console.warn(`⏭️  跳过已存在的表情包：${meaning}`);
                stats.skipped++;
                stats.details.push({ meaning, status: '跳过', reason: '已存在' });
                continue;
            }

            // 创建 Image 对象以获取宽高
            const img = new Image();
            img.crossOrigin = 'anonymous'; // 允许跨域获取尺寸

            let width = 100, height = 100; // 默认值

            await new Promise((resolve) => {
                img.onload = () => {
                    width = img.naturalWidth;
                    height = img.naturalHeight;
                    console.log(`✓ 成功加载 ${meaning}：${width}x${height}`);
                    resolve();
                };

                img.onerror = () => {
                    console.warn(`⚠️  ${meaning} 加载失败，使用默认尺寸 100x100`);
                    // 使用默认值，不中止迁移
                    resolve();
                };

                img.src = fullUrl; // 触发加载
            });

            // 存入数据库
            await db.aiStickers.put({
                meaning,
                url: fullUrl,
                width,
                height
            });

            stats.success++;
            stats.details.push({ meaning, status: '成功', width, height });
            console.log(`✅ 表情包 "${meaning}" 已存入数据库`);

        } catch (err) {
            stats.failed++;
            stats.details.push({ meaning, status: '失败', error: err.message });
            console.error(`❌ 迁移 "${meaning}" 时出错：`, err);
        }
    }

    // 输出总结
    console.log(`
╔════════════════════════════════════════╗
║     AI表情包迁移完成！                 ║
╠════════════════════════════════════════╣
║ 总计：${stats.total} 个表情包
║ ✅ 成功：${stats.success} 个
║ ❌ 失败：${stats.failed} 个
║ ⏭️  跳过：${stats.skipped} 个
╚════════════════════════════════════════╝
    `);

    return stats;
}

/**
 * 【全新】文本框自动增高辅助函数
 * @param {HTMLElement} element - 需要自动增高的textarea元素
 */
function autoGrowTextarea(element) {
    const maxHeight = 550; // 你要求的最大高度
    element.style.height = 'auto'; // 先重置高度，以便获取内容所需的真实高度
    const newHeight = element.scrollHeight;
    
    // 如果内容所需高度没有超过最大限制
    if (newHeight <= maxHeight) {
        element.style.height = newHeight + 'px';
        element.style.overflowY = 'hidden'; // 高度自适应时隐藏滚动条
    } else {
        // 如果超过了，则将高度固定为最大值，并显示滚动条
        element.style.height = maxHeight + 'px';
        element.style.overflowY = 'auto'; 
    }
}
// === 【全新】世界书多选功能核心函数 ===

/**
 * 进入世界书多选模式
 * @param {string} bookId - 第一个被长按选中的书籍ID
 */
function enterWbSelectionMode(bookId) {
    if (isWbSelectionMode) return;
    isWbSelectionMode = true;

    const screen = document.getElementById('world-book-screen');
    screen.classList.add('wb-selection-mode');

    // 更新头部UI
    document.getElementById('world-book-default-title').style.display = 'none';
    document.getElementById('world-book-selection-title').style.display = 'block';
    document.getElementById('wb-default-controls').style.display = 'none';
    document.getElementById('wb-selection-controls').style.display = 'flex';

    // 选中第一个项目
    toggleWbSelection(bookId);
}

/**
 * 退出世界书多选模式
 */
function exitWbSelectionMode() {
    if (!isWbSelectionMode) return;
    isWbSelectionMode = false;

    const screen = document.getElementById('world-book-screen');
    screen.classList.remove('wb-selection-mode');

    // 恢复头部UI
    document.getElementById('world-book-default-title').style.display = 'block';
    document.getElementById('world-book-selection-title').style.display = 'none';
    document.getElementById('wb-default-controls').style.display = 'flex';
    document.getElementById('wb-selection-controls').style.display = 'none';
    
    // 清理
    selectedWorldBooks.clear();
    document.querySelectorAll('#world-book-list .list-item.selected').forEach(item => {
        item.classList.remove('selected');
    });
}

/**
 * 切换单个书籍的选中状态
 * @param {string} bookId - 被点击的书籍ID
 */
function toggleWbSelection(bookId) {
    const itemEl = document.querySelector(`.list-item[data-book-id="${bookId}"]`);
    if (!itemEl) return;

    if (selectedWorldBooks.has(bookId)) {
        selectedWorldBooks.delete(bookId);
        itemEl.classList.remove('selected');
    } else {
        selectedWorldBooks.add(bookId);
        itemEl.classList.add('selected');
    }

    // 更新标题计数
    const title = document.getElementById('world-book-selection-title');
    if (selectedWorldBooks.size > 0) {
        title.textContent = `已选择 ${selectedWorldBooks.size} 项`;
    } else {
        // 如果清空了所有选择，则自动退出多选模式
        exitWbSelectionMode();
    }
}

/**
 * 删除所有选中的世界书条目
 */
async function deleteSelectedWorldBooks() {
    if (selectedWorldBooks.size === 0) return;

    const confirmed = await showCustomConfirm(
        '删除确认',
        `确定要删除选中的 ${selectedWorldBooks.size} 个世界书条目吗？此操作不可撤销。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = Array.from(selectedWorldBooks);
        await db.worldBooks.bulkDelete(idsToDelete);

        // 从内存中也删除
        state.worldBooks = state.worldBooks.filter(book => !idsToDelete.includes(book.id));
        
        await showCustomAlert('删除成功', '选中的条目已被删除。');
        
        exitWbSelectionMode();
        renderWorldBookScreen(); // 重新渲染列表
    }
}

/**
 * 【全新】格式化微信风格的日期时间戳
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的时间字符串
 */
/**
 * 【V3 稳定版】格式化日期分隔符的显示文本
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的日期字符串，或'TODAY'表示不显示
 */
function formatDateDivider(timestamp) {
    const messageDate = new Date(timestamp);
    const now = new Date();
    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfYesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);

    if (messageDate >= startOfToday) {
        return 'TODAY'; // 返回一个特殊值，告诉渲染函数今天不需要显示
    } else if (messageDate >= startOfYesterday) {
        return '昨天'; // 昨天只显示“昨天”
    } else {
        const month = messageDate.getMonth() + 1;
        const day = messageDate.getDate();
        if (messageDate.getFullYear() !== now.getFullYear()) {
            return `${messageDate.getFullYear()}年${month}月${day}日`; // 跨年份显示完整日期
        }
        return `${month}月${day}日`; // 今年内只显示月和日
    }
}

/**
 * 【全新】判断两个时间戳是否在同一天
 * @param {number} ts1
 * @param {number} ts2
 * @returns {boolean}
 */
function isSameDay(ts1, ts2) {
    if (!ts1 || !ts2) return false; // 如果有一个不存在，则认为不是同一天
    const date1 = new Date(ts1);
    const date2 = new Date(ts2);
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
}

// ▼▼▼ 【全新】论坛功能核心函数 ▼▼▼

// ▼▼▼ 用这个【新版本】替换旧的 openForumSettingsModal 函数 ▼▼▼
/**
 * 打开论坛生成设置的模态框
 */
async function openForumSettingsModal() {
    const charSelector = document.getElementById('forum-character-selector');
    const wbSelector = document.getElementById('forum-worldbook-selector');
    charSelector.innerHTML = '';
    wbSelector.innerHTML = '';

    // 【核心新增】加载世界书列表 - 初始化（不自动勾选）
    const worldBooks = state.worldBooks;

    const renderWorldBooks = () => {
        wbSelector.innerHTML = '';

        if (worldBooks.length === 0) {
            wbSelector.innerHTML = '<p style="color: var(--text-secondary);">还没有创建任何世界书。</p>';
        } else {
            // 获取当前选中的角色
            const selectedCharItems = document.querySelectorAll('#forum-character-selector .forum-char-item.selected');
            const selectedCharNames = Array.from(selectedCharItems).map(item => {
                const nameSpan = item.querySelector('.forum-char-name');
                return nameSpan ? nameSpan.textContent : null;
            }).filter(name => name);

            // 【新增】分离自动匹配的世界书和普通世界书
            const autoMatchedBooks = [];
            const normalBooks = [];

            worldBooks.forEach(book => {
                // 检查是否有任何选中的角色名在世界书名字里
                const isMatched = selectedCharNames.length > 0 &&
                    selectedCharNames.some(charName => book.name.includes(charName));

                if (isMatched) {
                    autoMatchedBooks.push(book);
                } else {
                    normalBooks.push(book);
                }
            });

            // 【新增】合并列表：自动匹配的在前，普通的在后
            const sortedBooks = [...autoMatchedBooks, ...normalBooks];

            // 【新增】标记哪些是自动匹配的（用于样式区分）
            const autoMatchedBookIds = new Set(autoMatchedBooks.map(b => b.id));

            sortedBooks.forEach(book => {
                const item = document.createElement('div');
                const isAutoMatched = autoMatchedBookIds.has(book.id);
                item.innerHTML = `<input type="checkbox" name="forum-wb" value="${book.id}" style="display: none;"><span class="forum-wb-name">${book.name}</span>`;
                item.classList.add('forum-wb-item');

                // 【核心修复】获取 checkbox 元素并设置其 checked 属性
                const checkbox = item.querySelector('input[type="checkbox"]');
                if (isAutoMatched) {
                    checkbox.checked = true;
                    item.classList.add('selected');
                } else {
                    checkbox.checked = false;
                }

                // 添加点击切换功能
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    const checkbox = this.querySelector('input[type="checkbox"]');
                    const isSelected = this.classList.contains('selected');

                    if (isSelected) {
                        this.classList.remove('selected');
                        checkbox.checked = false;
                    } else {
                        this.classList.add('selected');
                        checkbox.checked = true;
                    }
                });

                wbSelector.appendChild(item);
            });
        }
    };

    // 加载角色列表
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    if (characters.length === 0) {
        charSelector.innerHTML = '<p style="color: var(--text-secondary);">还没有可以讨论的角色哦~</p>';
    } else {
        characters.forEach(chat => {
            const item = document.createElement('div');
            const avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            item.innerHTML = `<input type="checkbox" name="forum-char" value="${chat.id}" style="display: none;"><img src="${avatarSrc}" class="forum-char-avatar" alt="${chat.name}"><span class="forum-char-name">${chat.name}</span>`;
            item.classList.add('forum-char-item');

            // 添加点击切换功能 - 选择角色时触发世界书更新
            item.addEventListener('click', function(e) {
                e.preventDefault();
                const checkbox = this.querySelector('input[type="checkbox"]');
                const isSelected = this.classList.contains('selected');

                if (isSelected) {
                    this.classList.remove('selected');
                    checkbox.checked = false;
                } else {
                    this.classList.add('selected');
                    checkbox.checked = true;
                }

                // 【新增】当角色选择变化时，重新渲染世界书列表
                renderWorldBooks();
            });

            charSelector.appendChild(item);
        });
    }

    // 【新增】初始渲染世界书（不选中任何角色时，不自动勾选）
    renderWorldBooks();

    document.getElementById('forum-settings-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 【记忆功能】手动总结记忆的核心函数 (V2 - 增加防丢失回滚机制)
async function manualSummarizeMemory(chatId) {
    const chat = state.chats[chatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert('配置错误', '请先在API设置中配置好API信息！');
        return;
    }

    const unsummarizedMessages = chat.history.filter(msg => !msg.isSummarized);
    const reserveCount = chat.settings.summarizeReserveCount || 100;
    const messagesToSummarize = unsummarizedMessages.slice(0, -reserveCount);

    if (messagesToSummarize.length === 0) {
        await showCustomAlert('无需总结', '没有需要总结的新内容。最近的对话仍在上下文窗口内。');
        return;
    }
// 【全新添加】从用户人设中提取名字 (V2 - 智能解析版)
    const myPersona = chat.settings.myPersona || '';
    // 提取第一行作为名字的潜在来源
    const firstLine = (myPersona.split('\n')[0] || '').trim();
    
    let extractedUserName = '';

    // 正则表达式，用于匹配 【任意单词: "名字"】 这种格式，例如 username: "江窈"
    const nameRegex = /^\s*\w+\s*:\s*"([^"]+)"\s*$/;
    const match = firstLine.match(nameRegex);

    if (match && match[1]) {
        // 如果成功匹配，只提取引号中的内容
        extractedUserName = match[1].trim();
    } else {
        // 如果不匹配，则退回使用整行作为名字（兼容用户只写名字的情况）
        extractedUserName = firstLine.substring(0, 50);
    }

    // 如果第一行处理后仍然为空，则尝试从前50个字符中提取（备用逻辑）
    if (!extractedUserName) {
        extractedUserName = myPersona.substring(0, 50).split('.')[0].split(',')[0].trim();
    }
    // 最终确认要用于总结的名字，如果提取失败则使用备用名
    const userNameForSummary = extractedUserName || (chat.isGroup ? (chat.settings.myNickname || 'User') : 'User');
    // 1. 在执行任何操作前，先备份关键数据
    const originalSummary = chat.memorySummary;
    const textarea = document.getElementById('memory-summary-textarea');
    const originalTextareaValue = textarea.value;

    // 【回滚功能】保存当前记忆状态到lastMemorySummary，供用户主动回滚使用
    chat.lastMemorySummary = chat.memorySummary;

    // 【回滚功能】保存即将被标记为已总结的消息ID列表，供回滚时恢复
    chat.lastSummarizedMessageIds = messagesToSummarize.map(msg => msg.id || msg.timestamp);

    // 显示加载状态
    textarea.value = '正在总结记忆...';
    textarea.disabled = true;

    try {
        // 构建总结Prompt...
        const userNickname = chat.isGroup ? (chat.settings.myNickname || 'User') : 'User';
        const recentMessagesInSummary = unsummarizedMessages.slice(-8);
        const recentMessageTimestamps = recentMessagesInSummary.map(msg => msg.timestamp);

        const dialogHistory = messagesToSummarize.map(msg => {
            const sender = msg.role === 'user' ? userNickname : (msg.senderName || chat.name);
            let content = msg.content;
            // 【新增】处理naiimag类型消息
            if (msg.type === 'naiimag') {
                content = `[NovelAI生成的图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
            }
            // 【修复】检查msg.meaning来识别表情包，因为本地表情包可能没有type字段
            else if (msg.meaning) {
                content = `[发送了一个表情，意思是: '${msg.meaning}']`;
            } else if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                const abstractContent = extractAbstractContent(typeof msg.content === 'string' ? msg.content : '');
                content = abstractContent || msg.content;
            } else if (typeof content !== 'string') {
                content = '[发送了图片或其他媒体内容]';
            }
            return `${sender}: ${content}`;
        }).join('\n');

        const summaryPrompt = `你是一个专业的剧情总结助手。你的任务是彻底重构并整合所有剧情信息，生成一份完全客观、格式严谨的事件报告。

参与者说明：
- **“${userNameForSummary}”**: 这是用户的名字。在总结中，你必须始终使用“${userNameForSummary}”来指代用户。
- **AI角色**: ${chat.isGroup ? '在对话中，你扮演多个AI角色。他们的名字会作为发言前缀出现在下面的对话历史中。' : `在对话中，AI角色的名字是“${chat.name}”。`}

# 【【【最高优先级指令：客观性与重构】】】
1.  **去除主观评价**: 你必须仔细审查"旧的记忆摘要"。如果其中包含任何主观、臆测、或非事实性的评价（例如"他们的关系更近了"、"他似乎有些不安"），你【必须】将这些评价彻底删除。
2.  **整合重写**: 你的最终输出【不是】在旧摘要上做补充，而是要将【净化后的旧摘要事实】与【新的对话历史】完全融合，重新整理并撰写一份全新的、完整的事件报告。
3.  **细节完整**: 新的总结必须细节全面周到，整理并包含所有已发生的关键经历。
4.  **时间标注铁律**: 在"情景"部分的描述中，凡是提到关键的、有时间节点的事件，【必须】在其后用括号标注出具体的发生日期（例如：几月几日）。
5.  **【【【原摘要事件保留铁律】】】**: 原摘要中的所有关键事件、情节线索和原情节【绝对不能】被完全删除。即使进行了高浓度的概括、合并或简化，这些事件也必须在新摘要中保持可见。如果原摘要有某个事件，新摘要中必须能够追溯到这个事件。禁止因为"整合"或"去重"就将原有事件彻底抹除。

# 总结核心铁律
1.  **【【【称呼铁律】】】**: 
    - 当需要指代用户时，【必须】使用使用具体的角色名称称呼。
    - ${chat.isGroup ? '当需要指代AI角色时，【必须】使用他们在对话历史中出现的【具体角色名】进行称呼。' : `当需要指代AI角色时，【必须】使用“${chat.name}”这个名字。`}
    - **【【【绝对禁止】】】**使用“用户”、“AI”、“玩家”、“User”或任何人称代词（你/我）来指代对话的任何一方。必须始终使用角色的具体名字。
- **【【【强制替换原则】】】**: 总结中所有指代用户的地方，【必须无一例外地】替换为“${userNameForSummary}”这个具体的名字。
    2.  **【客观中立】**: 采用客观、中性的语言，避免任何主观感受、情感描述或价值判断。
3.  **只记事实】**: 只记录事实性信息：对话内容、行为、事件、时间等。
4.  **【禁止推测】**: 不要添加推测、猜测或解释性内容。
5.  **【第三人称】**: 始终保持第三人称叙述视角。
6.  **【【【绝对禁止主观臆断铁律】】】**: 你【绝对不能】对角色的关系、情绪或内心状态进行任何形式的概括、推断或定性描述。例如，严禁使用“他们的关系更加亲密了”、“A在调情”、“B的防线崩溃了”这类由你脑补的、原文没有直接说明的判断性语句。你【只能】像法庭记录员一样，客观、直接地记录【发生了什么事】和【说了什么话】。
7.- 保留关键事件和重要细节，避免冗余描述
- 直接陈述事实，避免评价
- 使用简洁清晰的语言，避免修饰
- 突出事件发展脉络和关键转折点
- 保留重要的约定、物品、事件以及情感发展
- 不回避任何敏感内容，保证记录完全还原前文
- 可以精简合并较为久远之前的事件
- 无需加粗标注
- 以流水账形式记录
# 【【【强制输出格式】】】

你的回复【必须且只能】严格遵循以下格式，不得添加任何解释性文字或偏离此结构。



涉及人物身份:

  主角:

  主要NPC:（简要描述npc性格和人物之间的关系）

  次要NPC:（简要描述npc性格和人物之间的关系）

当前财产:

  钱财项:

  物资项:

  特殊持有物:

人物关系及变化:

  -

情景 (起): 【检查原摘要是否有开端事件，若有则必须保留或高浓度概括后继续呈现】

  -

情景 (承): 【检查原摘要是否有发展过程，若有则必须保留或高浓度概括后继续呈现】

  -

情景 (转): 【检查原摘要是否有转折变化，若有则必须保留或高浓度概括后继续呈现】

  -

情景 (合): 【检查原摘要是否有结局或当前状态，若有则必须保留或高浓度概括后继续呈现】

  -

未解决事件 (未来对话提示):
【执行规则】
1. 只记录尚未完成、未解决、或即将发生但尚未发生的事项。
2. 按时间顺序排列，未完成的排在前面，不得随意删除或更改顺序。
3. 表达需具体明确，不得笼统、模糊或跳步。
4. 格式要求：
  - 时间：[承诺或事件的发生时间，必须真实准确]
  - 对象：[涉及人物]
  - 事项：[具体内容]
  - 状态：未完成
# 你的工作资料
## 旧的记忆摘要 (需要你审查并提取客观事实)：
${originalSummary || '无'}

## 新的对话历史：
${dialogHistory}

请将新的对话内容与旧记忆合并（最后返回的总结必须连带旧的记忆摘要重点提炼内容），生成一个新的记忆摘要。要求：
1. 只保留重要的个人信息、关系发展、重要事件
2. 去除重复和不重要的细节，但【绝对禁止】删除原摘要中的任何关键事件或情节线索，即使简化也要保留痕迹
3. 保持时间线的连贯性，原摘要中的事件顺序必须被尊重
4. 越久之前的事情可以越省略，但绝对不可以完全忽略掉这件事，发生过的事情一定都要总结
5. 总结长度控制在1500字以内
6. 用客观、简洁的语言描述
7. 只返回摘要内容，不要其他解释
8. 【【【强制检查】】】：完成总结后，逐一检查原摘要中的每个主要事件是否都在新摘要中被保留或继承（即使以高浓度概括的形式）。如果原摘要有事件在新摘要中完全消失，则立即补充该事件

现在，请开始工作，生成一份全新的、完全符合上述所有规则的事件报告。

新记忆摘要：`;

        const messagesPayload = [{ role: 'user', content: summaryPrompt }];
        // 【调试代码】打印完整的发送给AI的上下文
        console.log('【调试】发送给AI的完整上下文:', { summaryPrompt, messagesPayload });
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = isGemini ? toGeminiRequestData(model, apiKey, summaryPrompt, messagesPayload, isGemini) : null;

        const response = isGemini
            ? await fetch(geminiConfig.url, { ...geminiConfig.data, mode: 'cors' })
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesPayload, temperature: 0.3 }),
                mode: 'cors'
            });

        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status}`);
        }
        const data = await response.json();
        let newSummary;
        if (isGemini) {
            if (!data.candidates || data.candidates.length === 0) throw new Error('API返回了空的回应');
            newSummary = data.candidates[0].content.parts[0].text;
        } else {
            if (!data.choices || data.choices.length === 0) throw new Error('API返回了空的回应');
            newSummary = data.choices[0].message.content;
        }

        // 成功获取到新摘要后，更新内存中的数据
        chat.memorySummary = newSummary.trim();
        messagesToSummarize.forEach(msg => { msg.isSummarized = true; });

        // 将更新后的数据保存到数据库
        await db.chats.put(chat);

        // 只有在数据库成功保存后，才更新UI统计
        textarea.value = newSummary.trim();
        await updateMemoryStats(chatId);
        await showCustomAlert('总结完成', `已总结 ${messagesToSummarize.length} 条消息！`);

    } catch (error) {
        console.error('记忆总结失败:', error);

        // 2. 在catch块中，使用备份数据进行回滚
        // 恢复内存中的聊天状态
        chat.memorySummary = originalSummary;
        messagesToSummarize.forEach(msg => {
            // 因为 messagesToSummarize 里的对象就是 chat.history 里的原对象引用，
            // 所以我们直接把之前做的标记改回去即可。
            msg.isSummarized = false;
        });
        
        // 恢复UI显示
        textarea.value = originalTextareaValue;
        
        await showCustomAlert('总结失败', `操作已回滚，您的旧记忆没有丢失。\n错误信息：${error.message}`);
    } finally {
        // 无论成功还是失败，最后都确保输入框是可用的
        textarea.disabled = false;
    }
}

// 【记忆功能】简单的token计算函数（估算）
function estimateTokens(text) {
    if (!text) return 0;
    // 简单估算：中文字符按1.5个token计算，英文单词按1个token计算
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
    const otherChars = text.length - chineseChars - text.match(/[a-zA-Z]/g)?.length || 0;
    return Math.ceil(chineseChars * 1.5 + englishWords + otherChars * 0.5);
}

/**
 * 【V3-错误修复版】更新消息统计显示，现在包括人设和世界书的Token
 */
async function updateMemoryStats(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // --- 消息计数部分 (保持不变) ---
    const totalCount = chat.history.length;
    const summarizedCount = chat.history.filter(msg => msg.isSummarized === true).length;
    const pendingCount = totalCount - summarizedCount;

    document.getElementById('summarized-count').textContent = summarizedCount;
    document.getElementById('pending-count').textContent = pendingCount;
    document.getElementById('total-count').textContent = totalCount;

    // --- 全新Token计算逻辑（支持三种模式） ---
    let contextTokens = 0;

    // 1. 【新增】计算角色人设的Token
    const aiPersona = chat.settings.aiPersona || '';
    contextTokens += estimateTokens(aiPersona);

    // 2. 计算核心记忆的Token (保持不变)
    if (chat.memorySummary && chat.memorySummary.trim()) {
        contextTokens += estimateTokens(chat.memorySummary);
    }

    // 3. 【新增】根据线上/线下/监控模式，计算对应世界书的Token
    // offlineMode.isOffline 是一个全局变量，反映了当前聊天窗口的模式
    const worldBookIdsToUse = offlineMode.isOffline
        ? chat.settings.linkedWorldBookIdsOffline
        : chat.settings.linkedWorldBookIds;

    if (worldBookIdsToUse && worldBookIdsToUse.length > 0) {
        worldBookIdsToUse.forEach(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            if (worldBook && worldBook.content) {
                contextTokens += estimateTokens(worldBook.content);
            }
        });
    }

    // 4. 【新增】计算预设内容的Token（根据模式选择对应预设）
    let presetIdToUse = null;
    if (offlineMode.isMonitorMode) {
        // 监控模式使用 presetIdMonitor
        presetIdToUse = chat.presetIdMonitor;
    } else if (offlineMode.isOffline) {
        // 线下模式使用 presetIdOffline
        presetIdToUse = chat.presetIdOffline;
    } else {
        // 线上模式使用 presetId
        presetIdToUse = chat.presetId;
    }

    if (presetIdToUse) {
        try {
            const preset = await db.promptPresets.get(presetIdToUse);
            if (preset && preset.items && preset.items.length > 0) {
                const enabledItems = preset.items.filter(item => item.enabled);
                enabledItems.forEach(item => {
                    contextTokens += estimateTokens(item.content);
                });
            }
        } catch (e) {
            // 预设查询失败，继续计算其他部分
        }
    }

    // 5. 【修改】计算上下文消息的Token，应用8条消息规则
    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const contextMessages = chat.history.slice(memoryAnchor);

    // 【修正】实现8条消息内外的不同Token计算逻辑
    // 最近8条消息（包括用户消息和AI消息）的时间戳
    const recentMessages = contextMessages.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    contextMessages.forEach(msg => {
        // ========== ▼▼▼ 核心修复代码就在这里 ▼▼▼ ==========
        // 跳过分享卡片和论坛卡片，因为AI会单独处理它们，不计入原始上下文
        if (msg.type === 'share_card' || msg.type === 'forum_card') {
            return; // 使用 return 来跳过当前循环
        }
        // ========== ▲▲▲ 修复代码结束 ▲▲▲ ==========

        // 【新增】识别并跳过表情包消息中的base64/URL部分
        // 表情包消息特征：role='user', content是base64或http开头的URL, 且有meaning字段
        if (msg.role === 'user' && msg.meaning && typeof msg.content === 'string' &&
            (msg.content.startsWith('data:') || msg.content.startsWith('http'))) {
            // 这是一个表情包，只计算含义的token，不计算整个content的token
            contextTokens += estimateTokens(msg.meaning);
            if (msg.senderName) {
                contextTokens += estimateTokens(msg.senderName);
            }
            return; // 跳出本次循环，不再继续下面的通用计算
        }

        let contentToCalculate;

        // 对所有AI消息应用8条消息规则：最近8条计算全文，之外的有摘要就计算摘要
        if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
            // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
            if (typeof msg.content === 'string') {
                const abstractContent = extractAbstractContent(msg.content);
                contentToCalculate = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
            } else {
                contentToCalculate = msg.content;
            }
        } else {
            // 8条消息以内的所有消息，或用户消息，计算完整内容Token
            contentToCalculate = msg.content;
        }

        // 计算Token
        if (typeof contentToCalculate === 'string') {
            contextTokens += estimateTokens(contentToCalculate);
        } else if (Array.isArray(contentToCalculate)) {
            contentToCalculate.forEach(item => {
                if (item.type === 'text') {
                    contextTokens += estimateTokens(item.text || '');
                }
            });
        }

        if (msg.senderName) {
            contextTokens += estimateTokens(msg.senderName);
        }
    });

    // 6. 更新UI
    document.getElementById('context-token-count').textContent = contextTokens.toLocaleString();
}

// ▼▼▼ 请将下面这个完整的、优化后的函数，粘贴到您的代码中 ▼▼▼

async function generateForumPosts() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息！');
        return;
    }

    // --- 1. 获取用户配置 ---
    const selectedCharIds = Array.from(document.querySelectorAll('input[name="forum-char"]:checked')).map(cb => cb.value);
    const selectedWbIds = Array.from(document.querySelectorAll('input[name="forum-wb"]:checked')).map(cb => cb.value);

    if (selectedCharIds.length === 0) {
        alert('请至少选择一个角色参与八卦！');
        return;
    }

    document.getElementById('forum-settings-modal').classList.remove('visible');
    const container = document.getElementById('forum-posts-container');
    const placeholder = document.createElement('div');
    placeholder.className = 'forum-placeholder';
    placeholder.innerHTML = `<p>正在连接赛博空间...</p><div class="loading-spinner" style="display: block; margin: 20px auto; border-top-color: var(--accent-color);"></div>`;
    container.innerHTML = '';
    container.appendChild(placeholder);
    
    const statusP = placeholder.querySelector('p');

    try {
        // --- 2. 准备基础资料 ---
        statusP.textContent = '正在分析角色资料与世界观...';
        const userPersona = state.chats[selectedCharIds[0]]?.settings.myPersona || '一个普通用户';
        
        const worldBookEntries = selectedWbIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `### ${book.name}\n${book.content}` : '';
        }).join('\n\n');

        let rawContext = `# 核心资料\n## 用户人设\n${userPersona}\n\n`;
        if (worldBookEntries) {
            rawContext += `## 世界观设定(必须严格遵守以下所有设定)\n${worldBookEntries}\n\n`;
        }

        selectedCharIds.forEach(id => {
            const chat = state.chats[id];
            if (chat) {
                rawContext += `## 角色: ${chat.name}\n- 人设: ${chat.settings.aiPersona}\n\n`;

                // 【与单聊一致】添加核心记忆
                if (chat.memorySummary) {
                    rawContext += `### 核心记忆\n${chat.memorySummary.trim()}\n\n`;
                }

                rawContext += `### 与 ${chat.name} 的近期聊天记录:\n`;

                // 【与单聊一致】使用 memoryAnchor 机制
                const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
                const historySlice = chat.history.slice(memoryAnchor);

                // 【安全修复】应用8条消息规则
                const recentMessages = historySlice.slice(-8);
                const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

                const history = historySlice.map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;

                    // 【核心修复】对线下模式AI消息应用8条消息规则
                    let content;
                    if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                        // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                        if (typeof msg.content === 'string') {
                            const abstractContent = extractAbstractContent(msg.content);
                            content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                        } else {
                            content = msg.content || '';
                        }
                    } else {
                        // 8条消息以内的所有消息，或用户消息，或线上模式消息，使用完整内容
                        content = msg.content || '';
                    }

                    // 【新增】处理naiimag类型消息
                    if (msg.type === 'naiimag') {
                        content = `[NovelAI生成的图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
                    }
                    // 【修复问题2和3】表情包只发送含义，不发送base64编码（检查msg.meaning来识别表情包）
                    else if (msg.meaning) {
                        content = `[发送了一个表情，意思是: '${msg.meaning}']`;
                    } else {
                        content = String(content).substring(0, 300).replace(/`/g, "'").replace(/\${/g, '{');
                        if (msg.type) content = `[${msg.type}]`;
                    }
                    return `${sender}: ${content}`;
                }).join('\n');
                rawContext += `${history}\n\n`;
            }
        });

        // --- 3. 【优化流程】直接构建最终的帖子生成指令 ---
        statusP.textContent = '正在撰写论坛帖子...';
        
        const postGenerationPrompt = `你是一个论坛八卦内容生成AI。你的任务是根据提供的资料，创作10条论坛八卦帖子。

# 【【【最高指令：禁忌角色】】】
-   **绝对禁止扮演的角色**: "${state.qzoneSettings.nickname}"
-   这个名字属于【用户/玩家】，是本次模拟的观察者。在任何情况下，你的回复中【绝对不能】出现由"${state.qzoneSettings.nickname}"发布的帖子或评论。这是一个不可违背的核心铁律。

# 【【【核心设定：路人视角的限制】】】
**重点理解**：路人（不是参与对话的人）是【无法直接看到私聊对话内容】的。他们看不到用户和角色之间说过什么。
-   路人只能根据以下信息进行八卦：
    1. 看到的【公开行为】或【角色的言行变化】（比如某人突然变得不同寻常）
    2. 【听到的传言】或【间接转述】（"我听说..."、"好像..."、"有人说..."）
    3. 【微妙的迹象】（比如两个人的互动频率变化、语气变化）
    4. 【自己的猜测和脑补】（完全可能猜错，带有很强的不确定性）

# 【【【内容核心与口吻指令】】】
1.  **内容来源**：你帖子的核心内容，必须取材于"近期聊天记录"里的【具体事件】。
2.  **绝对禁止的直接陈述**：以下表述【绝对禁止出现】：
    - "我看到他们聊天说..." ❌
    - "他在私聊里说..." ❌
    - "用户和角色的对话是..." ❌
    - "他们之间的信息是..." ❌
    - 任何形式的【私聊对话原文引用】❌
3.  **必须使用的口吻**：
    - "听说最近他们好像..." ✓
    - "我猜测可能是..." ✓
    - "根据他最近的行为来看..." ✓
    - "有人说他们好像在..." ✓
    - "我感觉他好像..." ✓
    - "不知道是真是假，但是..." ✓

# 核心规则:
1.  **你的身份**: 你是【旁观者/八卦群众】或下方列表中的【AI角色】。你的任务是模拟这些人的口吻进行发帖和评论。你【不是】一个能看到所有私聊的管理员。
2.  **内容来源**: 所有内容都必须基于下面提供的【原始资料】，但【转化】成路人能够看到/听到/推断出的形式。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，包含10个帖子对象，生成的帖子正文下面至少要有三条评论，绝不能包含任何解释性文字。
4.  **帖子类型**: 你可以自由选择发布两种类型的帖子:
    - **纯文字帖 ("shuoshuo")**: 只有文字内容。
    - **图文帖 ("text_image")**: 包含一段公开的文字（可选）和一张图片（图片内容由隐藏的文字描述定义）。
5.  **身份识别与互动**: 这是一个匿名论坛，但角色和用户的ID（名字）是公开的。
    - **当一个AI角色（例如"角色A"）在自己的帖子下方发表评论时**，你扮演的其他AI角色或路人，有一定概率要表现出认出TA的样子。
    - **互动示例**: 你可以生成像"咦，这不是A本人吗？怎么亲自下场了？"、"抓住野生A一只！"或者"前排吃瓜，等正主回复。"这样的评论，来增加真实感。请自然地将这类互动分布在评论中。

# 【【【图文帖 ("text_image") 生成核心指令】】】
当你决定发布一张图片时，你必须像一个真正的八卦路人一样思考。你的"图片"应该是间接的、有想象力的证据，而不是直接的聊天记录截图。
1.  **【【【绝对禁止】】】**：
    - 直接描述或"截图"你看到的后台聊天记录。
    - 用"私聊对话"、"聊天截图"、"聊天记录"等名义发布图片。
2.  **【【【图片应该是什么】】】**：
    - 路人能看到的行为证据（比如"他最近在某地出现的时间线"、"他发的朋友圈"等）
    - 间接推断出的物证（比如"我在某处看到他们俩一起出现"的描述）
    - 其他角色转述的信息（比如"我朋友说他跟我说..."）
3.  **【【【描述格式】】】**："hiddenContent" 必须清晰地说明这是一张什么样的图片，而不是直接引用私聊内容。

    结构如下：
    \`\`\`json
    [
      {
        "posterName": "（AI角色名或路人名）",
        "postType": "shuoshuo",
        "postContent": "帖子的纯文字内容。",
        "likes": "（随机数字）",
        "comments": [ { "commenterName": "...", "commentText": "..." } ]
      },
      {
        "posterName": "（AI角色名或路人名）",
        "postType": "text_image",
        "publicText": "（可选的、显示在图片上方的公开文字）",
        "hiddenContent": "【必填】对这张"图片"的详细文字描述。当用户点击图片时会看到这段内容。这应该是路人合理能看到或推断出的内容。",
        "likes": "（随机数字）",
        "comments": [ { "commenterName": "...", "commentText": "..." } ]
      }
    ]
    \`\`\`

# 你需要参考的【原始资料】:
${rawContext}

现在，请严格遵守以上所有规则，特别是【最高指令】和【路人视角的限制】，开始你的创作。`;

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 500000);

        const messagesForFinal = [{ role: 'user', content: postGenerationPrompt }];
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfigFinal = isGemini ? toGeminiRequestData(model, apiKey, postGenerationPrompt, messagesForFinal, isGemini) : null;

        // 【调试】打印完整的 prompt 内容
        console.log("【论坛生成 - 完整PROMPT】", postGenerationPrompt);
        console.log("【论坛生成 - 优化流程】发送单次API请求...");

        const finalResponse = isGemini 
            ? await fetch(geminiConfigFinal.url, { ...geminiConfigFinal.data, mode: 'cors', signal: controller.signal })
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForFinal, temperature: parseFloat(state.apiConfig.temperature) || 0.9 }),
                mode: 'cors',
                signal: controller.signal
            });

        clearTimeout(timeoutId);
        
        if (!finalResponse.ok) throw new Error(`[创作阶段] API 请求失败: ${finalResponse.status}`);
        const finalData = await finalResponse.json();
        
        let rawContent;
        if (isGemini) {
            if (!finalData.candidates || finalData.candidates.length === 0) throw new Error("[创作阶段] API 返回了空的回应。");
            rawContent = finalData.candidates[0].content.parts[0].text;
        } else {
            if (!finalData.choices || finalData.choices.length === 0) throw new Error("[创作阶段] API 返回了空的回应。");
            rawContent = finalData.choices[0].message.content;
        }
        
        const jsonString = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const posts = JSON.parse(jsonString);

        if (Array.isArray(posts)) {
            await db.forumPosts.clear();
            const addedIds = await db.forumPosts.bulkAdd(posts, { allKeys: true });
            
            const postsWithIds = posts.map((post, index) => {
                post.id = addedIds[index];
                return post;
            });
            
            currentForumPosts = postsWithIds;
            renderForumPosts(currentForumPosts);
        } else {
            throw new Error("API返回的最终结果不是一个有效的数组。");
        }

    } catch (error) {
        console.error("生成论坛帖子失败:", error);
        if (error.name === 'AbortError') {
            container.innerHTML = `<div class="forum-placeholder"><p>哎呀，生成失败了...</p><p style="font-size: 12px; color: #ff6b6b;">错误：请求超时（超过500秒无响应）。可能是网络问题或AI任务过重。</p></div>`;
        } else {
            container.innerHTML = `<div class="forum-placeholder"><p>哎呀，生成失败了...</p><p style="font-size: 12px; color: #ff6b6b; white-space: pre-wrap;">${error.message}</p></div>`;
        }
    }
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新升级版】将帖子数据渲染到页面上
 * @param {Array} postsToRender - 帖子对象数组
 */
function renderForumPosts(postsToRender) {
    const container = document.getElementById('forum-posts-container');
    container.innerHTML = '';

    if (!postsToRender || postsToRender.length === 0) {
        // 保持占位符逻辑不变
        container.innerHTML = `<div class="forum-placeholder">
            <p>点击右上角的刷新按钮 🔄</p>
            <p>根据你和角色的故事生成专属论坛吧！</p>
        </div>`;
        return;
    }

    // 创建一个包含所有AI角色和用户信息的查找列表，用于正确显示头像
    const allCharacters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const userCharacter = { name: state.qzoneSettings.nickname, settings: { myAvatar: state.qzoneSettings.avatar } };
    const characterLookup = [...allCharacters, userCharacter];

    postsToRender.forEach(post => {
        const postEl = document.createElement('div');
        postEl.className = 'forum-post-item';
        postEl.dataset.postId = post.id; // 关键：将帖子的唯一ID添加到DOM元素上

        const poster = characterLookup.find(c => c.name === post.posterName);
        const posterAvatar = poster ? (poster.settings.aiAvatar || poster.settings.myAvatar) : defaultAvatar;

        // --- ▼▼▼ 核心修复代码 ▼▼▼ ---
        // 1. 根据 postType 决定如何生成帖子内容
        let contentHtml = '';
        if (post.postType === 'text_image') {
            // 如果是图文帖，就创建图片和可选的公开文字
            const publicTextHtml = post.publicText ? `<div class="forum-post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            const hiddenContent = post.hiddenContent || '（AI没有提供图片描述）'; // 提供一个备用描述
            contentHtml = `${publicTextHtml}<div style="margin-top:10px;"><img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${hiddenContent}"></div>`;
        } else {
            // 否则，默认为是纯文字帖
            const postContent = post.postContent || ''; // 安全处理，防止 postContent 不存在
            contentHtml = `<div class="forum-post-content">${postContent.replace(/\n/g, '<br>')}</div>`;
        }
        // --- ▲▲▲ 核心修复代码结束 ▲▲▲ ---

        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsHtml = post.comments.map(comment => `
                <div class="forum-comment-item">
                    <span class="commenter-name">${comment.commenterName}:</span>
                    <span class="comment-text">${comment.commentText.replace(/\n/g, '<br>')}</span>
                </div>
            `).join('');
        }
        
        if (post.isAwaitingReply) {
            commentsHtml += `
                <div class="ai-reply-loader">
                    正在输入<span>.</span><span>.</span><span>.</span>
                </div>
            `;
        }

        // 确保forwardCount字段存在
        if (!post.hasOwnProperty('forwardCount')) {
            post.forwardCount = 0;
        }

        postEl.innerHTML = `
            <div class="forum-post-header">
                <img src="${posterAvatar}" class="avatar">
                <span class="name">${post.posterName}</span>
            </div>
            ${contentHtml} 
            <div class="forum-post-footer">
                <div class="footer-action like-btn ${post.isLikedByUser ? 'liked' : ''}">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                    <span class="like-count">${post.likes}</span>
                </div>
                <div class="footer-action">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                    <span>${post.comments?.length || 0}</span>
                </div>
                <div class="footer-action forward-btn" data-post-id="${post.id}">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 17 5-5-5-5"></path><path d="m4 18v-2a4 4 0 0 1 4-4h12"></path></svg>
                    <span class="forward-count">${post.forwardCount}</span>
                </div>
            </div>
            <div class="forum-comments-section">${commentsHtml}</div>
            <div class="forum-comment-input-area">
                <input type="text" placeholder="发表你的看法...">
                <button>发送</button>
            </div>
        `;
        container.appendChild(postEl);
    });
}

/**
 * 【全新】当用户在论坛评论后，触发AI生成回复
 * @param {object} post - 被评论的帖子对象
 * @param {string} userCommentText - 用户的评论内容
 */
async function triggerAiForumReply(post, userCommentText) {
    console.log(`用户评论了帖子ID ${post.id}，正在触发AI回复...`);
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn('API配置不完整，无法触发AI回复。');
        return;
    }

    const userName = state.qzoneSettings.nickname || '我';

    // --- 【核心修改】 ---
    // 1. 获取所有可用的AI角色，而不仅仅是帖子里提到过的角色
    const allCharacters = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    // 2. 将所有角色的信息都提供给AI
    const characterInfo = allCharacters.map(c => `- 角色名: ${c.name}\n  人设: ${c.settings.aiPersona}`).join('\n');
    // --- 【修改结束】 ---

    const replyPrompt = `
# 你的任务
你是一个论坛AI，负责模拟多个角色进行互动。用户刚刚在一条帖子上发表了评论，你需要生成3到5条新的、有意义的回复来回应用户的评论，让论坛看起来更活跃。

# 核心规则
【【【身份铁律】】】: 用户的昵称是"${userName}"。你【绝对、永远、在任何情况下都不能】扮演用户"${userName}"进行回复。
# 【【【格式禁令】】】
你的任务只是生成公开评论，绝对不能在评论中包含任何角色的内心想法（thought）、心理活动或OS。只写出角色会公开发表在论坛上的话。

# 【【【角色扮演核心指令：开放的论坛生态】】】
这是一个开放的论坛！任何角色都可能看到这条帖子和用户的评论。
1.  **角色池**: 你可以扮演下方“可扮演的AI角色列表”中的【任何一个角色】，也可以扮演匿名的“吃瓜网友”（网名需要随机生成）。
2.  **选角逻辑**: 请根据每个角色的性格，以及原帖与用户评论的内容，【逻辑地选择】几个最有可能被吸引过来参与讨论的角色进行回复。**即使某个角色没有在原帖中出现，只要话题和他/她相关，或者符合他/她的八卦性格，就可以让他/她出现！**
3.  **内容相关**: 你的回复必须紧密围绕"原帖内容"和"用户的评论"展开。

【【【输出格式】】】: 你的回复【必须且只能】是一个严格的JSON数组，包含3到5个评论对象。每个对象格式如下：
[
{ "commenterName": "（AI角色名或'随机网名'）", "commentText": "评论内容..." },
{ "commenterName": "（AI角色名或'随机网名'）", "commentText": "另一条评论内容..." }
]

# 【【【核心互动情景：身份识别与互动！】】】
这是一个匿名论坛，但所有人的ID（名字）都是公开的，这为八卦提供了绝佳的土壤。你的回复需要体现出这一点：

1.  **识别用户**: 正在评论的用户“${userName}”很有可能就是原帖中正在八卦讨论的“当事人/正主”。当你的AI角色回复时，有概率（20%）要表现出认出或怀疑用户身份的样子。
    - **示例**: “楼上是本人吗？”、“前排吃瓜，正主来了！”、“咦，这个ID有点眼熟……”。
2.  **识别其他AI角色**: 同样地，如果一个AI角色（比如“角色A”）在评论区非常活跃或者回复了关键信息，你扮演的其他AI角色或路人也有概率（20%）认出TA，并进行互动。
    - **示例**: “A也在啊，这下热闹了。”、“A的观点我同意！”、“楼上A的说法有点道理。”
3.  **回复身份概率**：你的主要身份是路人网友。只有很小的概率（大约八次里有一次）让AI角色本人回复用户。绝大多数回复都应来自随机路人。
请将这两类互动自然地、随机地分布在你生成的3-5条新回复中，让整个评论区看起来像真实的论坛一样充满互动和猜测。
你需要参考的上下文信息
# 可扮演的AI角色列表 (你可以从下面【所有角色】中自由选择):
${characterInfo || '(无特定AI角色，请扮演普通网友)'}

# 原帖内容:
发布者: ${post.posterName}

内容: ${post.postContent || post.publicText || '(图片动态)'}

# 用户的最新评论:
评论者: ${userName}

内容: "${userCommentText}"

现在，请严格遵守以上所有规则，开始你的创作。`;

    const messagesForApi = [{ role: 'user', content: replyPrompt }];

    try {
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, replyPrompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8 })
            });

        if (!response.ok) throw new Error('AI论坛回复API调用失败');
        
        const data = await response.json();
        const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
        // 清理JSON字符串中的多余标记
        const jsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const newComments = JSON.parse(jsonString);

        if (Array.isArray(newComments)) {
            const targetPost = currentForumPosts.find(p => p.id === post.id);
            if (targetPost) {
                // 将新评论追加到帖子的评论列表中
                newComments.forEach(comment => {
                    if (comment.commenterName && comment.commentText) {
                         targetPost.comments.push({
                            commenterName: comment.commenterName,
                            commentText: comment.commentText
                        });
                    }
                });
                
            }
        } else {
            console.warn("AI没有返回有效的评论数组:", newComments);
        }

    } catch (error) {
        console.error("触发AI论坛回复失败:", error);
    }
}


/**        
 * 根据规则格式化聊天列表的时间戳
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的时间字符串
 */
function formatChatListTimestamp(timestamp) {
    if (!timestamp) return ''; // 如果没有消息，则不显示时间

    const messageDate = new Date(timestamp);
    const now = new Date();

    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfYesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);

    const hours = String(messageDate.getHours()).padStart(2, '0');
    const minutes = String(messageDate.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;

    if (messageDate >= startOfToday) {
        // 今天：直接显示时间
        return timeString;
    } else if (messageDate >= startOfYesterday) {
        // 昨天：显示“昨天” + 时间
        return `昨天 ${timeString}`;
    } else {
        // 更早：显示 月/日 + 时间
        const month = messageDate.getMonth() + 1;
        const day = messageDate.getDate();
        return `${month}/${day} ${timeString}`;
    }
}

     function isIOS() {
         // 使用正则表达式匹配 'iPhone', 'iPad', 'iPod'
         if(/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream){
             document.body.classList.add('ios');
         }
    }

        // 主屏幕翻页功能
        (function() {
            const pagesContainer = document.querySelector('.home-pages-wrapper');
            const pageIndicator = document.getElementById('home-page-indicator');
            const pageDots = pageIndicator?.querySelectorAll('.page-dot');

            let currentPage = 0;
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            let startTime = 0;

            const SWIPE_THRESHOLD = 50; // 滑动超过50px才算翻页
            const VELOCITY_THRESHOLD = 0.3; // 速度阈值，快速滑动时更容易翻页

            function updatePagePosition(animate = true) {
                if (!pagesContainer) return;

                if (animate) {
                    pagesContainer.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                } else {
                    pagesContainer.style.transition = 'none';
                }

                pagesContainer.style.transform = `translateX(-${currentPage * 100}%)`;

                // 更新指示器
                if (pageDots) {
                    pageDots.forEach((dot, index) => {
                        dot.classList.toggle('active', index === currentPage);
                    });
                }
            }

            function handleTouchStart(e) {
                startX = e.touches[0].clientX;
                currentX = startX;
                isDragging = true;
                startTime = Date.now();
                pagesContainer.style.transition = 'none';
            }

            function handleTouchMove(e) {
                if (!isDragging) return;

                currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                const containerWidth = pagesContainer.offsetWidth;
                const maxPages = pagesContainer.children.length - 1;

                // 计算新的位置，但限制在有效范围内
                let newTranslate = -currentPage * 100 + (diff / containerWidth) * 100;

                // 边界处理：到达边界时增加阻力
                if (newTranslate > 0) {
                    newTranslate = newTranslate * 0.3; // 左边界
                } else if (newTranslate < -maxPages * 100) {
                    const excess = newTranslate + maxPages * 100;
                    newTranslate = -maxPages * 100 + excess * 0.3; // 右边界
                }

                pagesContainer.style.transform = `translateX(${newTranslate}%)`;
            }

            function handleTouchEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                const diff = currentX - startX;
                const containerWidth = pagesContainer.offsetWidth;
                const maxPages = pagesContainer.children.length - 1;
                const duration = Date.now() - startTime;
                const velocity = Math.abs(diff) / duration;

                // 判断是否翻页
                if (Math.abs(diff) > SWIPE_THRESHOLD || velocity > VELOCITY_THRESHOLD) {
                    if (diff > 0 && currentPage > 0) {
                        // 向右滑，回到上一页
                        currentPage--;
                    } else if (diff < 0 && currentPage < maxPages) {
                        // 向左滑，去下一页
                        currentPage++;
                    }
                }

                updatePagePosition(true);
            }

            // 绑定事件
            if (pagesContainer) {
                pagesContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
                pagesContainer.addEventListener('touchmove', handleTouchMove, { passive: true });
                pagesContainer.addEventListener('touchend', handleTouchEnd, { passive: true });

                // 初始化位置
                updatePagePosition(false);
            }
        })();

        function showScreen(screenId) {
            if (screenId === 'chat-list-screen') {
                // 【新增】返回聊天列表时，重置所有后台活动的倒计时
                // 这样用户离开聊天后，倒计时会重新开始
                // 【修复4】同时清除活跃聊天的会话主动回复触发标志
                const chatsToSave = [];
                Object.values(state.chats).forEach(chat => {
                    let needsSave = false;
                    if (!chat.isGroup && chat.settings?.backgroundActivityEnabled) {
                        chat.settings.lastBackgroundCheckTime = Date.now();
                        needsSave = true;
                    }
                    if (needsSave) {
                        chatsToSave.push(chat);
                    }
                });
                // 只保存有改变的chat，避免不必要的数据库操作
                if (chatsToSave.length > 0) {
                    Promise.all(chatsToSave.map(chat => db.chats.put(chat))).catch(err => {
                        console.error('保存重置后的数据失败:', err);
                    });
                }

                window.renderChatListProxy();
                switchToChatListView('messages-view');
            }
            if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
            if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
            if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
            if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
            if (screenId === 'preset-manager-screen') renderPresetList(); // 【新增】加载预设列表

            // 【修复PWA底部空白】当切换到kk查岗相关页面时，重新计算viewport高度
            if (screenId.startsWith('kk-')) {
                // 方法1: 强制触发滚动以让iOS更新viewport
                window.scrollTo(0, 1);
                setTimeout(() => window.scrollTo(0, 0), 10);

                // 方法2: 多次重新计算viewport高度
                if (typeof setVhProperty === 'function') {
                    setTimeout(() => setVhProperty(), 0);
                    setTimeout(() => setVhProperty(), 50);
                    setTimeout(() => setVhProperty(), 150);
                    setTimeout(() => setVhProperty(), 300);
                    setTimeout(() => setVhProperty(), 500);
                }
            }

            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.classList.add('active');
            if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
            if (screenId === 'font-settings-screen') {
                document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                applyCustomFont(state.globalSettings.fontUrl || '', true);
            }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增这一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隐藏所有视图
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 显示目标视图
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部导航栏高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 修正结束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根据视图ID执行特定的渲染/更新逻辑
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#F7F7F7';
                    updateUnreadIndicator(0);
                    // 【修改】进入动态页面时只清空未读数，保留新评论标记以显示红点
                    state.qzoneSettings.unreadCommentsCount = 0;
                    // state.newCommentPostIds 不清空，这样可以显示红点
                    saveQzoneSettings(); // 后台保存，不等待
                    renderQzoneScreen();
                    renderQzonePosts();
                    // 【新增】清空后更新所有相关的UI指示器
                    updateBackBtnQzoneIndicator();
                    updateQzoneBottomNavIndicator();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                    break;
            }
        }
        
// X社交页面渲染函数
      function renderXSocialScreen() {
        // 暂时为空，后续添加X社交页面的渲染逻辑
        console.log("渲染X社交页面");
      }
      window.renderXSocialScreenProxy = renderXSocialScreen;

        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        // 【新增】更新聊天界面返回按钮的动态未读指示器
        function updateBackBtnQzoneIndicator() {
            const backBtn = document.getElementById('back-to-list-btn');
            if (!backBtn) return;

            const unreadComments = state.qzoneSettings?.unreadCommentsCount || 0;
            let indicator = backBtn.querySelector('.unread-indicator');

            if (unreadComments > 0) {
                // 创建或显示未读指示器
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator back-btn-indicator';
                    indicator.style.display = 'inline-block';
                    backBtn.appendChild(indicator);
                } else {
                    indicator.className = 'unread-indicator back-btn-indicator';
                    indicator.style.display = 'inline-block';
                }
            } else {
                // 隐藏未读指示器
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }
        }

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '刚刚';
            if (diffMinutes < 60) return `${diffMinutes}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }
// ▼▼▼ 请将下面【一整块代码】粘贴到 formatPostTimestamp 函数的下方 ▼▼▼

// ▼▼▼ 请用这个【已注入记忆上下文 v3.0】的版本，完整替换旧的 triggerAiPostReply 函数 ▼▼▼
/**
 * 【全新升级版 v3.0 - 已注入记忆上下文】当用户评论动态后，触发AI生成回复
 * @param {object} post - 被评论的动态对象
 * @param {string} userCommentText - 用户的评论内容
 */
async function triggerAiPostReply(post, userCommentText) {
    // 安全检查：如果帖子作者是用户自己，AI不回复
    if (!post || post.authorId === 'user') return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn('API配置不完整，无法触发AI回复。');
        return;
    }

    console.log(`用户评论了动态ID ${post.id}，正在触发AI回复...`);

    // --- 【角色识别与信息收集 - 保持不变】 ---
    const replierChatsData = []; // 修改变量名以区分

    // 1. 添加帖子作者 (如果是AI或NPC)
    if (post.authorId && post.authorId.startsWith('npc_')) {
        const npcId = post.authorId.substring(4);
        const postAuthorNPC = state.customNPCs.find(n => n.id.toString() === npcId);
        if (postAuthorNPC) {
            replierChatsData.push({
                npc: postAuthorNPC,
                id: post.authorId, // 使用 'npc_id' 作为唯一标识
                name: postAuthorNPC.name,
                persona: postAuthorNPC.persona,
                isNPC: true
            });
        }
    } else if (post.authorId !== 'user') { // 确保作者不是用户
        const postAuthorChat = state.chats[post.authorId];
        if (postAuthorChat) {
            replierChatsData.push({
                chat: postAuthorChat,
                id: post.authorId,
                name: postAuthorChat.name,
                persona: postAuthorChat.settings.aiPersona,
                isNPC: false
            });
        }
    }

    // 2. 添加之前评论过的AI角色和NPC
    if (post.comments && post.comments.length > 0) {
        const uniqueCommenters = new Set();
        post.comments.forEach(comment => {
            // 排除用户自己 和 帖子作者 (因为作者已经加过了)
            if (comment.commenterName !== state.qzoneSettings.nickname && comment.commenterName !== post.authorName) {
                uniqueCommenters.add(comment.commenterName);
            }
        });

        uniqueCommenters.forEach(commenterName => {
            // 检查是否是普通AI角色
            const commenterChat = Object.values(state.chats).find(chat => !chat.isGroup && chat.name === commenterName);
            if (commenterChat && replierChatsData.findIndex(r => r.id === commenterChat.id) === -1) {
                replierChatsData.push({
                    chat: commenterChat,
                    id: commenterChat.id,
                    name: commenterChat.name,
                    persona: commenterChat.settings.aiPersona,
                    isNPC: false
                });
            } else {
                // 检查是否是NPC角色
                const npc = state.customNPCs.find(n => n.name === commenterName);
                if (npc && replierChatsData.findIndex(r => r.id === `npc_${npc.id}`) === -1) {
                    replierChatsData.push({
                        npc: npc,
                        id: `npc_${npc.id}`, // 使用 'npc_id' 作为唯一标识
                        name: npc.name,
                        persona: npc.persona,
                        isNPC: true
                    });
                }
            }
        });
    }

    if (replierChatsData.length === 0) {
        console.log("没有找到需要回复的AI角色（可能是帖子作者被删除或没有其他AI评论者），AI回复流程终止。");
        return;
    }
     // --- ★★★ 核心修改：构建包含记忆的Prompt ★★★ ---
    try {
        // --- 1. 构建通用上下文 ---
        let commentsContext = '';
        if (post.comments && post.comments.length > 0) {
            commentsContext = '# 该动态下已有的评论\n';
            post.comments.forEach((comment, idx) => {
                const replyText = comment.replyTo ? `（回复 ${comment.replyTo}）` : '';
                let identityTag = '';
                if (comment.commenterName === state.qzoneSettings.nickname) {
                    identityTag = '【用户】'; // 标记用户
                } else {
                    const isAiChar = Object.values(state.chats).some(chat => chat.name === comment.commenterName);
                    const isNPC = state.customNPCs.some(npc => npc.name === comment.commenterName);
                    if (isAiChar) identityTag = '【角色】';
                    else if (isNPC) identityTag = '【NPC】';
                }
                commentsContext += `${idx + 1}. ${identityTag}${comment.commenterName}${replyText}: ${comment.text}\n`;
            });
        }

        let worldBooksContext = ''; // 世界书上下文（保持不变）
        const characterWorldBooks = new Map();
        replierChatsData.forEach((r) => {
            let wbContent = '';
            if (!r.isNPC && r.chat && r.chat.settings && r.chat.settings.characterWorldBookIds) {
                r.chat.settings.characterWorldBookIds.forEach(wbId => {
                    const wb = state.worldBooks.find(w => w.id === wbId);
                    if (wb) {
                        wbContent += `## ${wb.name}\n${wb.content}\n\n`;
                    }
                });
                if (wbContent) {
                    characterWorldBooks.set(r.name, wbContent);
                    if (!worldBooksContext) worldBooksContext = '# 世界书背景设定\n';
                    worldBooksContext += `## ${r.name} 的世界书\n${wbContent}`;
                }
            }
        });

        const userNickname = state.qzoneSettings.nickname || '用户';

        // --- 2. 为每个需要回复的角色构建专属上下文 ---
        let replierDescriptionsAndContext = '';
        replierChatsData.forEach((r, idx) => {
            replierDescriptionsAndContext += `\n## ${idx + 1}. ${r.name}（人设：${r.persona}）\n`;

            // --- ★★★ 核心新增：注入记忆和历史 ★★★ ---
            if (!r.isNPC && r.chat) { // NPC 没有独立的聊天历史和记忆
                // a. 核心记忆
                if (r.chat.memorySummary && r.chat.memorySummary.trim()) {
                    replierDescriptionsAndContext += `### ${r.name} 与用户的核心记忆:\n${r.chat.memorySummary.trim()}\n`;
                }

                // b. 最近聊天历史 (从记忆锚点之后)
                const memoryAnchor = parseInt(r.chat.settings.memoryAnchor) || 0;
                const historySlice = r.chat.history.slice(memoryAnchor);
                if (historySlice.length > 0) {
                     // 应用8条消息规则
                    const recentMessages = historySlice.slice(-8);
                    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

                    const recentHistory = historySlice.map(msg => {
                        const sender = msg.role === 'user' ? userNickname : r.name;
                        let content;
                        // 处理8条规则
                        if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                            const abstractContent = extractAbstractContent(extractMessageContent(msg));
                            content = abstractContent || extractMessageContent(msg);
                        } else {
                            content = extractMessageContent(msg);
                        }
                        return `${sender}: ${String(content).substring(0, 300)}...`; // 截断以控制长度
                    }).join('\n');
                    replierDescriptionsAndContext += `### ${r.name} 与用户的最近聊天摘要:\n${recentHistory}\n`;
                }
            }
            // --- ★★★ 新增结束 ★★★ ---
        });

        // --- 3. 构建最终 Prompt ---
        const replyPrompt = `
# 任务说明
用户 ("${userNickname}") 在一条动态下发表了新评论。需要以下角色根据**各自与用户的关系和记忆**，立即对此评论做出回应。

# 【【【表情包禁令】】】
你的回复【绝对禁止】使用 \`[表情:xx]\` 格式的表情包。你只能生成纯文本评论。

# 相关信息
- 动态原文: ${post.content || post.publicText || '(图片动态)'}
- 用户的新评论: "${userCommentText}"

${commentsContext}

${worldBooksContext}

# 需要回复的角色列表及与用户的关系背景
${replierDescriptionsAndContext}

# 评论者信息 (用户)
- 昵称: ${userNickname}
# 身份标记说明
- 【用户】= 真实人类用户
- 【角色】= 其他AI角色
- 【NPC】= 其他NPC

# 回复要求
1. 【【【身份识别与关系核心】】】请注意，发表新评论的是用户 ("${userNickname}")。你扮演的每个角色都**必须**根据你上方提供的**专属核心记忆和聊天摘要**来回应，体现出你认识用户，并且记得你们之间的经历！
2. 每个角色都必须生成一条回复，对【用户】的新评论做出回应。
3. 每条回复内容【必须】以 "@${userNickname}" 开头。
4. 回复内容应该体现该角色的人设和性格，**并结合其与用户的专属记忆与关系**。也可以与其他【角色】或【NPC】互动。
5. 每条回复应该20-80字，简短自然，像真实朋友圈回复一样。
6. 注意其他角色的评论内容，保证回复逻辑连贯、不重复。

# 输出格式
【必须】返回一个JSON数组，每个元素代表一个角色的回复，格式如下：
[
  {"characterName": "角色名", "type": "qzone_comment", "postId": ${post.id}, "commentText": "@${userNickname} 角色1的回复内容..."},
  {"characterName": "角色名", "type": "qzone_comment", "postId": ${post.id}, "commentText": "@${userNickname} 角色2的回复内容..."}
]

【重要】输出只包含JSON数组，不要其他文字！`;
        // --- ★★★ 修改结束 ★★★ ---

        const messagesForApi = [{ role: 'user', content: replyPrompt }];
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, replyPrompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.7 })
            });

        if (!response.ok) throw new Error('AI动态回复API调用失败');
        const data = await response.json();
        const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
        console.log("AI原始响应:", aiResponseContent);
        
        const responseArray = parseAiResponse(aiResponseContent);

        if (Array.isArray(responseArray) && responseArray.length > 0) {
            console.log(`✅ 收到API回复 (共${responseArray.length}条):`);
            responseArray.forEach(action => {
                console.log(`  - characterName: ${action.characterName}, type: ${action.type}`);
                // 【修改】现在使用 replierChatsData 查找
                const replier = replierChatsData.find(r => r.name === action.characterName);
                if (replier && action.type === 'qzone_comment' && action.commentText) {
                    const newComment = {
                        commenterName: action.characterName,
                        text: action.commentText,
                        timestamp: Date.now(),
                        replyTo: userNickname
                    };

                    // 【核心修改】找到用户的那条评论，插在它和它的所有回复的最后面
                    let insertIndex = -1;
                    // 先找用户的最后一条评论
                    for (let i = post.comments.length - 1; i >= 0; i--) {
                        if (post.comments[i].commenterName === userNickname) {
                            insertIndex = i + 1;
                            // 继续往后找，把所有回复用户的评论都跳过
                            for (let j = i + 1; j < post.comments.length; j++) {
                                if (post.comments[j].replyTo === userNickname) {
                                    insertIndex = j + 1;
                                } else {
                                    break;  // 遇到不是回复用户的评论，停止
                                }
                            }
                            break;
                        }
                    }

                    if (insertIndex !== -1) {
                        // 插入到用户评论和所有回复的后面
                        post.comments.splice(insertIndex, 0, newComment);
                        console.log(`  ✓ ${action.characterName} 回复用户（插入到位置 ${insertIndex}）`);
                    } else {
                        // 如果找不到用户的评论，就追加到末尾
                        post.comments.push(newComment);
                        console.log(`  ✓ ${action.characterName} 回复用户（追加到末尾）`);
                    }

                    // 【新增】记录新评论的标识（使用时间戳确保唯一性）
                    const newCommentId = `${post.id}_${newComment.timestamp}`;
                    state.newCommentPostIds.add(newCommentId); // 添加到集合中
                } else {
                    console.warn(`  ✗ ${action.characterName} 验证失败或数据不完整`);
                }
            });
             // 【新增】更新未读评论计数
            state.qzoneSettings.unreadCommentsCount = (state.qzoneSettings.unreadCommentsCount || 0) + responseArray.length;
            await saveQzoneSettings(); // 保存更新后的未读数

            console.log(`✅ 一次API调用完成，${responseArray.length}个角色已生成回复`);
        } else {
            console.warn("API没有返回有效的回复:", responseArray);
        }

    } catch (error) {
        console.error("触发AI动态回复失败:", error);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【新版本】完整替换旧的 renderQzonePosts 函数 ▼▼▼

async function renderQzonePosts(loadingPostId = null) {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;

    posts.forEach(post => {
        // 【核心】如果当前帖子的ID与传入的loadingPostId匹配，就给它加上等待状态
        if (loadingPostId && post.id === loadingPostId) {
            post.isAwaitingReply = true;
        }

        const postContainer = document.createElement('div');
        postContainer.className = 'qzone-post-container';
        postContainer.dataset.postId = post.id;

        const postEl = document.createElement('div');
        postEl.className = 'qzone-post-item';

        let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar;

        if (post.authorId === 'user') {
            authorAvatar = userSettings.avatar;
            authorNickname = userSettings.nickname;
        } else if (state.chats[post.authorId]) {
            const authorChat = state.chats[post.authorId];
            authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
            authorNickname = authorChat.name;
        } else if (post.authorId.startsWith('npc_')) {
            // 【NPC帖子处理】从已有的NPC信息中获取
            const npcId = post.authorId.substring(4); // 移除 'npc_' 前缀，获取真实ID
            const npc = state.customNPCs.find(n => n.id.toString() === npcId);
            if (npc) {
                authorAvatar = npc.avatar || defaultAvatar;
                authorNickname = npc.name;
            } else {
                // 备用方案：使用帖子中存储的信息
                authorAvatar = post.authorAvatar || defaultAvatar;
                authorNickname = post.authorName || '未知NPC';
            }
        } else {
            authorAvatar = defaultAvatar;
            authorNickname = '{{char}}';
        }

        let contentHtml = '';
        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

        if (post.type === 'shuoshuo') {
            contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
        } 
        else if (post.type === 'image_post' && post.imageUrl) {
            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
        } 
        else if (post.type === 'text_image') {
            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
        }

        let likesHtml = '';
        if (post.likes && post.likes.length > 0) {
            likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
        }

        let commentsHtml = '';
        let commentsInnerHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsInnerHtml = post.comments.map((comment, index) => {
                // 【修改】实现"xx回复xx"格式和二级评论缩进
                let namePart = comment.commenterName;
                let indentClass = '';  // 缩进class
                // 【新增】检查是否是新评论（使用时间戳判断）
                const newCommentId = `${post.id}_${comment.timestamp}`;
                const isNewComment = state.newCommentPostIds.has(newCommentId);
                const newMarkClass = isNewComment ? 'has-new-mark' : '';

                // 【核心修复】判断是否是二级评论：如果有 replyTo，并且上一条评论是被回复人或者也在回复同一个人，就显示为二级
                let isReply = false;
                let replyToName = '';

                if (comment.replyTo) {
                    replyToName = comment.replyTo;

                    // 检查上一条评论：
                    // 1. 上一条的发言人是被回复人，或者
                    // 2. 上一条也是回复同一个人的
                    if (index > 0) {
                        const prevComment = post.comments[index - 1];
                        if (prevComment.commenterName === replyToName || prevComment.replyTo === replyToName) {
                            isReply = true;
                            indentClass = 'comment-item-reply';
                        }
                    }

                    // 无论是否缩进，都显示"xx回复xx"格式
                    namePart = `${comment.commenterName}回复${replyToName}`;
                }

                return `
                    <div class="comment-item ${indentClass} ${newMarkClass}" data-comment-index="${index}" data-commenter="${comment.commenterName}" data-reply-to="${comment.replyTo || ''}" data-timestamp="${comment.timestamp}">
                        <span class="commenter-name">${namePart}:</span>
                        <span class="comment-text">${comment.text}</span>
                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                    </div>
                `;
            }).join('');
        }

        if (post.isAwaitingReply) {
            commentsInnerHtml += `
                <div class="ai-reply-loader">
                    正在输入<span>.</span><span>.</span><span>.</span>
                </div>
            `;
        }

        if (commentsInnerHtml) {
            commentsHtml = `<div class="post-comments-container">${commentsInnerHtml}</div>`;
        }

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                <span class="action-icon advance" title="推进剧情" data-post-id="${post.id}"><svg viewBox="0 0 24 24"><path d="M5 3l14 9-14 9V3z"></path></svg></span>
            </div>
            ${likesHtml}
            ${commentsHtml}
            <div class="post-footer">
                <div class="comment-reply-to" style="display:none; padding: 5px 10px; font-size: 12px; color: #666; background: #f5f5f5; border-radius: 4px; margin-bottom: 5px;">回复: <span class="reply-to-name"></span> <span class="reply-to-clear" style="cursor: pointer; color: #999;">×</span></div>
                <div class="comment-section">
                    <img src="${commentAvatar}" class="comment-avatar">
                    <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                    <div class="at-mention-popup"></div>
                </div>
                <button class="comment-send-btn">发送</button>
            </div>
        `;

        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>删除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        const popup = postContainer.querySelector('.at-mention-popup');

        // 【新增】评论回复功能：点击评论可以回复
        const replyToDiv = postContainer.querySelector('.comment-reply-to');
        const replyToName = postContainer.querySelector('.reply-to-name');
        const replyToClear = postContainer.querySelector('.reply-to-clear');
        postContainer.dataset.replyingToCommenter = null;  // 记录正在回复谁
        postContainer.dataset.replyingToTimestamp = null;  // 【新增】记录具体回复哪条评论（用时间戳标识）

        postContainer.querySelectorAll('.comment-item').forEach(commentItem => {
            commentItem.addEventListener('click', (e) => {
                // 不要在点击删除按钮时触发回复
                if (e.target.classList.contains('comment-delete-btn')) return;

                const commenter = commentItem.dataset.commenter;
                const timestamp = commentItem.dataset.timestamp;  // 【新增】获取时间戳
                postContainer.dataset.replyingToCommenter = commenter;
                postContainer.dataset.replyingToTimestamp = timestamp;  // 【新增】存储时间戳
                replyToName.textContent = commenter;
                replyToDiv.style.display = 'flex';
                commentInput.focus();
            });
        });

        replyToClear.addEventListener('click', () => {
            postContainer.dataset.replyingToCommenter = null;
            postContainer.dataset.replyingToTimestamp = null;  // 【新增】清除时间戳
            replyToDiv.style.display = 'none';
        });

        commentInput.addEventListener('input', () => {
            const value = commentInput.value;
            const atMatch = value.match(/@([\p{L}\w]*)$/u);
            if (atMatch) {
                const namesToMention = new Set();
                const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                if (authorNickname) namesToMention.add(authorNickname);
                postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                    namesToMention.add(nameEl.textContent.replace(':', ''));
                });
                namesToMention.delete(state.qzoneSettings.nickname);
                popup.innerHTML = '';
                if (namesToMention.size > 0) {
                    const searchTerm = atMatch[1];
                    namesToMention.forEach(name => {
                        if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const item = document.createElement('div');
                            item.className = 'at-mention-item';
                            item.textContent = name;
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                const newText = value.substring(0, atMatch.index) + `@${name} `;
                                commentInput.value = newText;
                                popup.style.display = 'none';
                                commentInput.focus();
                            });
                            popup.appendChild(item);
                        }
                    });
                    popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                } else {
                    popup.style.display = 'none';
                }
            } else {
                popup.style.display = 'none';
            }
        });
        commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });

        // 【新增】推进按钮点击事件
        const advanceBtn = postContainer.querySelector('.action-icon.advance');
        if (advanceBtn) {
            advanceBtn.addEventListener('click', async () => {
                await handleAdvancePost(post);
            });
        }
    });
}

// ▲▲▲ 替换到这里结束 ▲▲▲

// ▼▼▼ 【全新】推进剧情功能 - 让绑定的NPC评论动态 ▼▼▼

/**
 * 获取某个角色或NPC绑定的所有NPC
 * @param {string} authorId - 动态作者的ID (可以是 chatId, 'user', 或 'npc_xxx')
 * @returns {Array} - 绑定的NPC对象数组
 */
function getBoundNPCsForAuthor(authorId) {
    if (!authorId || !state.customNPCs || state.customNPCs.length === 0) {
        return [];
    }

    // 筛选出 associatedCharacters 数组中包含 authorId 的所有NPC
    const boundNPCs = state.customNPCs.filter(npc => {
        return npc.associatedCharacters && npc.associatedCharacters.includes(authorId);
    });

    console.log(`[推进] 作者 ${authorId} 绑定了 ${boundNPCs.length} 个NPC:`, boundNPCs.map(n => n.name));
    return boundNPCs;
}

/**
 * 处理推进按钮的点击事件
 * @param {Object} post - 动态对象
 */
async function handleAdvancePost(post) {
    console.log(`[推进] 开始推进动态 ID: ${post.id}`);

    // 1. 获取绑定的NPC列表
    const boundNPCs = getBoundNPCsForAuthor(post.authorId);

    if (boundNPCs.length === 0) {
        alert('该动态没有绑定任何NPC，无法推进剧情');
        console.log(`[推进] 动态作者 ${post.authorId} 没有绑定NPC`);
        return;
    }

    // 2. 显示加载状态
    const advanceBtn = document.querySelector(`.action-icon.advance[data-post-id="${post.id}"]`);
    if (advanceBtn) {
        advanceBtn.style.opacity = '0.5';
        advanceBtn.style.pointerEvents = 'none';
    }

    try {
        // 3. 构建prompt并调用API
        const prompt = await buildAdvancePrompt(post, boundNPCs);

        console.log(`[推进] 调用API，为 ${boundNPCs.length} 个NPC生成评论`);
        console.log('[推进] 完整Prompt内容:\n' + prompt);

        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先配置API');
            return;
        }

        const requestBody = {
            model: model,
            messages: [{ role: 'user', content: prompt }],
            temperature: 0.9
        };

        console.log('[推进] 完整API请求体:', JSON.stringify(requestBody, null, 2));

        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status}`);
        }

        const data = await response.json();
        const rawContent = data.choices[0].message.content.trim();

        console.log(`[推进] API返回内容:`, rawContent);

        // 4. 解析返回的JSON数组
        let comments;
        try {
            const jsonMatch = rawContent.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                comments = JSON.parse(jsonMatch[0]);
            } else {
                comments = JSON.parse(rawContent);
            }
        } catch (e) {
            console.error('[推进] JSON解析失败:', e);
            alert('AI返回格式错误，推进失败');
            return;
        }

        if (!Array.isArray(comments) || comments.length === 0) {
            console.log('[推进] AI未生成任何评论');
            alert('AI未生成评论');
            return;
        }

        // 5. 将评论插入到动态中（如果有replyTo，插入到被回复评论的后面）
        if (!post.comments) post.comments = [];

        comments.forEach(comment => {
            if (comment.npcName && comment.commentText) {
                const newComment = {
                    commenterName: comment.npcName,
                    text: comment.commentText,
                    timestamp: Date.now(),
                    replyTo: comment.replyTo || null
                };

                // 如果有replyTo，找到被回复的那条评论的位置
                if (comment.replyTo) {
                    // 从后往前找，找到最后一条该用户的评论（包括该用户回复别人的评论）
                    let insertIndex = -1;
                    for (let i = post.comments.length - 1; i >= 0; i--) {
                        if (post.comments[i].commenterName === comment.replyTo) {
                            insertIndex = i + 1;
                            break;
                        }
                        // 也要考虑如果有人回复了这个人，应该插入到那些回复的后面
                        if (post.comments[i].replyTo === comment.replyTo) {
                            insertIndex = i + 1;
                        }
                    }

                    if (insertIndex !== -1) {
                        // 插入到被回复评论的后面
                        post.comments.splice(insertIndex, 0, newComment);
                        console.log(`[推进] ${comment.npcName} 回复 ${comment.replyTo}: ${comment.commentText.substring(0, 30)}...`);
                    } else {
                        // 如果找不到被回复的评论，就追加到末尾
                        post.comments.push(newComment);
                        console.log(`[推进] ${comment.npcName} 评论(找不到replyTo目标，追加到末尾): ${comment.commentText.substring(0, 30)}...`);
                    }
                } else {
                    // 没有replyTo，直接追加到末尾
                    post.comments.push(newComment);
                    console.log(`[推进] ${comment.npcName} 评论: ${comment.commentText.substring(0, 30)}...`);
                }

                // 【新增】记录新评论的标识（使用时间戳确保唯一性），用于显示小红点
                const newCommentId = `${post.id}_${newComment.timestamp}`;
                state.newCommentPostIds.add(newCommentId);
            }
        });

        // 6. 更新数据库
        await db.qzonePosts.update(post.id, { comments: post.comments });

        // 7. 刷新动态页面
        await renderQzonePosts();

        console.log(`[推进] 推进完成，共添加 ${comments.length} 条评论`);

    } catch (error) {
        console.error('[推进] 推进失败:', error);
        alert('推进失败: ' + error.message);
    } finally {
        // 恢复按钮状态
        if (advanceBtn) {
            advanceBtn.style.opacity = '1';
            advanceBtn.style.pointerEvents = 'auto';
        }
    }
}

/**
 * 构建推进功能的Prompt（完全照抄单聊prompt结构）
 * @param {Object} post - 动态对象
 * @param {Array} npcList - 绑定的NPC对象数组
 * @returns {string} - 构建好的prompt
 */
async function buildAdvancePrompt(post, npcList) {
    const userNickname = state.qzoneSettings.nickname;
    const userPersona = state.qzoneSettings.userPersona || '';

    // === 1. 构建当前动态内容上下文 ===
    let postContent = '';
    if (post.type === 'shuoshuo') {
        postContent = post.content;
    } else if (post.type === 'text_image') {
        postContent = `[文字图] ${post.publicText || ''} (图片内容: ${post.hiddenContent})`;
    } else if (post.type === 'image_post') {
        postContent = `[图片动态] ${post.publicText || ''}`;
    }

    // 获取动态作者名字
    let authorName = '';
    if (post.authorId === 'user') {
        authorName = userNickname;
    } else if (state.chats[post.authorId]) {
        authorName = state.chats[post.authorId].name;
    } else if (post.authorId.startsWith('npc_')) {
        const npcId = post.authorId.substring(4);
        const npc = state.customNPCs.find(n => n.id.toString() === npcId);
        authorName = npc ? npc.name : '未知';
    }

    let postContext = `# 当前动态内容\n作者: ${authorName}\n内容: ${postContent}\n`;

    // === 2. 构建评论上下文 ===
    let commentsContext = '';
    // 统计每个NPC已经评论的次数
    const npcCommentCount = {};

    if (post.comments && post.comments.length > 0) {
        commentsContext = '\n# 该动态下已有的评论\n';
        post.comments.forEach((comment, idx) => {
            const replyText = comment.replyTo ? `（回复 ${comment.replyTo}）` : '';
            let identityTag = '';
            if (comment.commenterName === userNickname) {
                identityTag = '【用户】';
            } else {
                const isAiChar = Object.values(state.chats).some(chat => chat.name === comment.commenterName);
                const isNPC = state.customNPCs.some(npc => npc.name === comment.commenterName);
                if (isAiChar) {
                    identityTag = '【角色】';
                } else if (isNPC) {
                    identityTag = '【NPC】';
                    // 统计NPC的评论次数
                    npcCommentCount[comment.commenterName] = (npcCommentCount[comment.commenterName] || 0) + 1;
                }
            }
            commentsContext += `${idx + 1}. ${identityTag}${comment.commenterName}${replyText}: ${comment.text}\n`;
        });
    } else {
        commentsContext = '\n# 该动态下已有的评论\n暂无评论\n';
    }

    // === 2.5. 为每个NPC添加评论策略说明 ===
    let npcStrategyContext = '\n# 各NPC的评论策略\n';
    npcList.forEach(npc => {
        const hasCommented = npcCommentCount[npc.name] > 0;
        if (hasCommented) {
            npcStrategyContext += `- ${npc.name}：【已评论过】，本次评论【必须】使用 replyTo 回复其他人的评论，不能再发表独立评论\n`;
        } else {
            npcStrategyContext += `- ${npc.name}：【首次评论】，可以直接评论动态（不使用replyTo），或者回复已有评论（使用replyTo）\n`;
        }
    });
    commentsContext += npcStrategyContext;

    // === 3. 收集所有关联的角色，避免重复注入世界书和记忆 ===
    const associatedChatIds = new Set();
    npcList.forEach(npc => {
        const chatId = npc.associatedCharacters.find(id => id !== 'user' && state.chats[id]);
        if (chatId) {
            associatedChatIds.add(chatId);
        }
    });

    // === 4. 为所有关联的角色构建公共上下文（只注入一次）===
    let sharedContext = '';
    let characterPersonas = ''; // 角色人设（放在最前面）
    let userPersonaFromChat = ''; // 用户人设（从chat读取）

    for (const chatId of associatedChatIds) {
        const chat = state.chats[chatId];
        if (!chat) continue;

        // 收集角色人设（放在最前面）
        if (chat.settings && chat.settings.aiPersona && chat.settings.aiPersona.trim()) {
            characterPersonas += `\n## 角色 ${chat.name} 的人设\n${chat.settings.aiPersona.trim()}\n`;
        }

        // 收集用户人设（如果有的话）
        if (!userPersonaFromChat && chat.settings && chat.settings.myPersona && chat.settings.myPersona.trim()) {
            userPersonaFromChat = chat.settings.myPersona.trim();
        }

        sharedContext += `\n## 角色 ${chat.name} 的背景信息\n`;

        // 读取世界书 (读取characterWorldBookIds - 角色自己用的世界书)
        if (chat.settings && chat.settings.characterWorldBookIds && chat.settings.characterWorldBookIds.length > 0) {
            sharedContext += `### 世界书\n`;
            for (const wbId of chat.settings.characterWorldBookIds) {
                const wb = state.worldBooks.find(book => book.id === wbId);
                if (wb) {
                    sharedContext += `${wb.content}\n`;
                }
            }
        }

        // 读取核心记忆
        if (chat.memorySummary && chat.memorySummary.trim()) {
            sharedContext += `### 与用户的核心记忆\n${chat.memorySummary.trim()}\n`;
        }

        // 读取记忆锚点后的聊天记录（应用8条消息规则）
        const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
        const historySlice = chat.history.slice(memoryAnchor);

        if (historySlice.length > 0) {
            // 应用8条消息规则：最近8条完整显示，其他AI消息只显示摘要
            const recentMessages = historySlice.slice(-8);
            const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

            const processedHistory = historySlice.map(msg => {
                const sender = msg.role === 'user' ? userNickname : chat.name;
                let content;

                // 对于最近8条以外的AI消息，只显示摘要
                if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                    const rawContent = typeof msg.content === 'string' ? msg.content : '[非文本消息]';
                    const abstractContent = extractAbstractContent(rawContent);
                    content = abstractContent || rawContent;
                } else {
                    content = typeof msg.content === 'string' ? msg.content : '[非文本消息]';
                }

                return `${sender}: ${String(content).substring(0, 300)}...`;
            }).join('\n');

            sharedContext += `### 与用户的聊天记录（记忆锚点之后）\n${processedHistory}\n`;
        }
    }

    // === 5. 为每个NPC构建独立的人设 ===
    let npcContexts = '';

    for (const npc of npcList) {
        npcContexts += `\n## NPC: ${npc.name}\n`;
        npcContexts += `### 人设\n${npc.persona}\n`;
    }

    // === 5. 构建表情包上下文（告知NPC不能使用表情包）===
    const stickerWarning = `\n# 【【【表情包禁令】】】\n你的回复【绝对禁止】使用 \`[表情:xx]\` 格式的表情包。你只能生成纯文本评论。\n`;

    // === 6. 用户人设 ===
    // 优先使用 state.qzoneSettings.userPersona，如果没有就用从chat读取的
    let userPersonaContext = '';
    const finalUserPersona = userPersona || userPersonaFromChat;
    if (finalUserPersona && finalUserPersona.trim()) {
        userPersonaContext = `\n# 用户（${userNickname}）的人设\n${finalUserPersona.trim()}\n`;
    }

    // === 7. 组装最终prompt ===
    const finalPrompt = `# 任务说明
当前动态下的剧情需要推进。以下NPC需要根据**各自的人设、与用户的关系和记忆**，对这条动态进行评论。

${stickerWarning}

${characterPersonas}

${userPersonaContext}

${postContext}

${commentsContext}

${sharedContext}

${npcContexts}

# 评论规则
1. 每个NPC根据自己的人设和记忆，生成一条符合角色性格的评论
2. 评论内容要自然、真实，符合NPC的性格特点
3. 禁止使用表情包格式
4. 评论长度建议10-50字

# 【【【重要】】】replyTo 字段使用规则
- **如果NPC只是评论动态本身**（对动态内容发表看法），【不要】添加 replyTo 字段
- **只有当NPC想回复已有评论中的某条具体评论时**，才添加 replyTo 字段，并填写被回复人的名字
- **【重要】当你使用 replyTo 回复某人时，会自动回复该人的最后一条评论**
  - 例如：胡镜晓发了3条评论，你写 "replyTo": "胡镜晓"，会回复他的第3条评论
  - 你应该查看评论列表，确认你想回复的是该人最后一条评论的内容
- 示例：
  - 直接评论动态：{"npcName": "张三", "commentText": "这动态不错"}  （无replyTo）
  - 回复某条评论：{"npcName": "李四", "commentText": "我也觉得", "replyTo": "张三"}  （有replyTo，会回复张三的最后一条评论）

# 输出格式
【必须】返回一个JSON数组，每个元素代表一个NPC的评论，格式如下：
[
  {"npcName": "${npcList[0].name}", "commentText": "评论内容..."},
  {"npcName": "${npcList[1] ? npcList[1].name : 'NPC2'}", "commentText": "评论内容...", "replyTo": "被回复人名字"}
]

【重要】
1. 输出只包含JSON数组，不要其他文字
2. replyTo 字段是可选的，只在回复具体评论时才添加`;

    console.log('[推进] Prompt构建完成');
    return finalPrompt;
}

// ▲▲▲ 推进剧情功能结束 ▲▲▲
             
// ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        let message = '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';

        if (searchTerm) {
            message = '未找到相关收藏';
        } else {
            // 检查是否选中了某个角色
            const activeChatBtn = document.querySelector('.char-btn-active');
            if (activeChatBtn && activeChatBtn.dataset.chatId !== 'all') {
                message = '该角色没有收藏的消息';
            }
        }

        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    // ▼▼▼ 【修改】将聊天消息按 chatId 分组 ▼▼▼
    const groupedByChatId = {};
    const nonChatItems = []; // 非聊天消息的项（如动态帖子）

    for (const item of items) {
        if (item.type === 'chat_message') {
            if (!groupedByChatId[item.chatId]) {
                groupedByChatId[item.chatId] = [];
            }
            groupedByChatId[item.chatId].push(item);
        } else {
            nonChatItems.push(item);
        }
    }

    // ▲▲▲ 分组结束 ▲▲▲

    // ▼▼▼ 【修改】处理非聊天消息（如动态帖子）▼▼▼
    for (const item of nonChatItems) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '来自动态';
            let authorAvatar = defaultAvatar, authorNickname = '未知用户';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 新增/修改的代码开始 ▼▼▼

            // 1. 构造点赞区域的HTML
            let likesHtml = '';
            // 检查 post 对象中是否存在 likes 数组并且不为空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
            }

            // 2. 构造评论区域的HTML
            let commentsHtml = '';
            // 检查 post 对象中是否存在 comments 数组并且不为空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 将点赞和评论的HTML组合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;

            // ▲▲▲ 新增/修改的代码结束 ▲▲▲

            card.innerHTML = `
                <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                <div class="fav-card-content">${contentHtml}</div>
                ${footerHtml}`;

            listEl.appendChild(card);
        }
    }
    // ▲▲▲ 非聊天消息处理结束 ▲▲▲

    // ▼▼▼ 【修改】处理聊天消息，按 chatId 分组显示 ▼▼▼
    for (const chatId in groupedByChatId) {
        const chatMessages = groupedByChatId[chatId];
        const chat = state.chats[chatId];
        if (!chat) continue;

        // 按 originalTimestamp 正序排列消息
        chatMessages.sort((a, b) => (a.content.timestamp || 0) - (b.content.timestamp || 0));

        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = chatMessages.map(m => m.id).join(','); // 包含所有消息ID

        // 卡片头部：显示聊天对象和来源
        const sourceText = `来自与 ${chat.name} 的聊天`;
        let headerAvatar = '', headerName = '';

        if (chat.isGroup) {
            headerAvatar = chat.settings?.aiAvatar || defaultAvatar;
            headerName = chat.name;
        } else {
            headerAvatar = chat.settings?.aiAvatar || defaultAvatar;
            headerName = chat.name;
        }

        const headerHtml = `<img src="${headerAvatar}" class="avatar"><div class="info"><div class="name">${headerName}</div></div>`;

        // 【修改】卡片内容：显示所有消息，按时间顺序，相邻相同发送者的消息合并显示
        let messagesHtml = '';
        let lastSenderName = null; // 记录上一条消息的发送者

        for (let i = 0; i < chatMessages.length; i++) {
            const item = chatMessages[i];
            const msg = item.content;
            const isUser = msg.role === 'user';
            let senderName, senderAvatar;

            if (isUser) {
                senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
            } else {
                if (chat.isGroup) {
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    senderName = msg.senderName;
                    senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                } else {
                    senderName = chat.name;
                    senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
            }

            let msgContentHtml = '';
            if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                msgContentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
            } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                msgContentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
            } else {
                msgContentHtml = String(msg.content || '').replace(/\n/g, '<br>');
            }

            // 时间戳显示
            const msgTime = new Date(msg.timestamp || 0).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

            // 【修改】判断是否需要显示发送者信息（只在第一条消息或发送者改变时显示）
            const shouldShowSender = lastSenderName !== senderName;

            if (shouldShowSender) {
                // 显示发送者信息的消息 - 头像、ID、时间戳在同一行，消息在下方靠左
                messagesHtml += `
                <div style="display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 4px; margin-top: 0px;">
                    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px; line-height: 1;">
                        <img src="${senderAvatar}" class="avatar" style="width: 28px; height: 28px; border-radius: 50%;">
                        <span style="font-weight: 500; font-size: 13px;">${senderName}</span>
                        <span style="font-size: 11px; color: #999;">${msgTime}</span>
                    </div>
                    <div style="background: #f0f0f0; padding: 6px 10px; border-radius: 6px; word-break: break-word; line-height: 1.5; font-size: 13px; text-align: left; margin: 0px;">
                        ${msgContentHtml}
                    </div>
                </div>`;
            } else {
                // 不显示发送者信息的消息（相邻相同发送者）
                messagesHtml += `
                <div style="display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 4px; margin-top: 0px;">
                    <div style="background: #f0f0f0; padding: 6px 10px; border-radius: 6px; word-break: break-word; line-height: 1.5; font-size: 13px; text-align: left; margin: 0px;">
                        ${msgContentHtml}
                    </div>
                </div>`;
            }

            lastSenderName = senderName;
        }

        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content" style="background: white; padding: 4px 6px; border-radius: 8px;">
                ${messagesHtml}
            </div>`;

        listEl.appendChild(card);
    }
    // ▲▲▲ 聊天消息处理结束 ▲▲▲
}

// ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
            // 1. 从数据库获取最新数据并缓存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();

            // 2. 清空搜索框并隐藏清除按钮
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 【修改】构建角色选择器
            buildCharacterSelector();

            // 4. 【修改】默认不显示任何收藏，等用户选择角色
            document.getElementById('favorites-list').innerHTML = '';
        }

        // ▼▼▼ 【新增】构建角色选择器函数 ▼▼▼
        function buildCharacterSelector() {
            const selector = document.getElementById('favorites-character-selector');
            const chatBtns = selector.querySelectorAll('.char-btn');

            // 保留"全部收藏"按钮，删除其他按钮，并为"全部收藏"添加点击事件
            chatBtns.forEach((btn, idx) => {
                if (idx > 0) {
                    btn.remove();
                } else {
                    // 为"全部收藏"按钮添加点击事件
                    btn.addEventListener('click', () => selectCharacter('all'));
                }
            });

            // 收集所有有收藏的聊天
            const chatsWithFavorites = new Set();
            for (const item of allFavoriteItems) {
                if (item.type === 'chat_message' && item.chatId) {
                    chatsWithFavorites.add(item.chatId);
                }
            }

            // 为每个聊天创建一个按钮
            for (const chatId of chatsWithFavorites) {
                const chat = state.chats[chatId];
                if (!chat) continue;

                const btn = document.createElement('button');
                btn.className = 'char-btn';
                btn.dataset.chatId = chatId;
                btn.textContent = chat.name;
                btn.addEventListener('click', () => selectCharacter(chatId));
                selector.appendChild(btn);
            }
        }

        // ▼▼▼ 【新增】角色选择处理函数 ▼▼▼
        function selectCharacter(chatId) {
            // 移除所有活跃状态
            document.querySelectorAll('.char-btn').forEach(btn => {
                btn.classList.remove('char-btn-active');
            });

            // 设置选中的按钮为活跃
            document.querySelector(`.char-btn[data-chat-id="${chatId}"]`)?.classList.add('char-btn-active');

            // 根据选择过滤和显示收藏
            if (chatId === 'all') {
                displayFilteredFavorites(allFavoriteItems);
            } else {
                // 【核心修复】重写过滤逻辑以同时匹配聊天记录和动态
                const filtered = allFavoriteItems.filter(item => {
                    // 1. 如果是聊天消息，检查 item.chatId
                    if (item.type === 'chat_message') {
                        return item.chatId === chatId;
                    }
                    // 2. 如果是QZone动态，检查 item.content.authorId
                    if (item.type === 'qzone_post') {
                        // 确保 item.content 存在
                        return item.content && item.content.authorId === chatId;
                    }
                    // 3. (备用) 其他类型的收藏暂时不按角色过滤
                    return false;
                });
                displayFilteredFavorites(filtered);
            }
        }
        // ▲▲▲ 新增函数结束 ▲▲▲

        // ▲▲▲ 粘贴结束 ▲▲▲

        function resetCreatePostModal() {
            document.getElementById('post-public-text').value = '';
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-description').value = '';
            document.getElementById('post-image-preview-container').classList.remove('visible');
            document.getElementById('post-image-desc-group').style.display = 'none';
            document.getElementById('post-local-image-input').value = '';
            document.getElementById('post-hidden-text').value = '';
            document.getElementById('switch-to-image-mode').click();
        }

// 用下面这个更新后的版本，完整替换您旧的 exportBackup 函数
// ▼▼▼ 【新增】部分导出函数 ▼▼▼
/**
 * 执行部分导出，根据用户选择的模块导出相应数据
 */
// 【新增】通用的下载保护函数，用于在下载期间禁用 VH 更新
let downloadProtectionTimeout = null;

function enableDownloadProtection() {
    window.isVhUpdateDisabled = true;
    if (window.setVhOnResize) {
        window.removeEventListener('resize', window.setVhOnResize);
    }
    if (window.setVhOnOrientationChange) {
        window.removeEventListener('orientationchange', window.setVhOnOrientationChange);
    }
    // 清除之前可能存在的延迟恢复
    if (downloadProtectionTimeout) {
        clearTimeout(downloadProtectionTimeout);
    }
    console.log('🔒 [下载保护] 已启用，VH更新已禁用，事件监听器已移除');
}

function disableDownloadProtection() {
    // 【关键修改】不再立即恢复，而是延迟 5 秒后再恢复，给 iOS 充足的时间完全稳定视口
    downloadProtectionTimeout = setTimeout(() => {
        // 重新添加监听器
        if (window.setVhOnResize) {
            window.addEventListener('resize', window.setVhOnResize);
        }
        if (window.setVhOnOrientationChange) {
            window.addEventListener('orientationchange', window.setVhOnOrientationChange);
        }

        // 只有在监听器重新添加后，才重新启用 VH 更新
        // 这样即使有 resize 事件触发，也能正确地更新 VH
        window.isVhUpdateDisabled = false;

        // 强制重新计算一次 VH
        if (typeof setVhProperty === 'function') {
            console.log('📐 [下载保护] 强制重新计算 VH');
            setVhProperty();
        }

        console.log('🔓 [下载保护] 已禁用，事件监听器已恢复，VH更新已重新启用');
    }, 5000);
}

async function executePartialExport() {
    try {
        // 【新增】启用下载保护
        enableDownloadProtection();

        // 获取用户的选择
        const selections = {
            chats: document.getElementById('export-chats').checked,
            worldBooks: document.getElementById('export-world-books').checked,
            worldBookCategories: document.getElementById('export-world-book-categories').checked,
            presetsConfig: document.getElementById('export-presets-config').checked,
            qzone: document.getElementById('export-qzone').checked,
            media: document.getElementById('export-media').checked,
            other: document.getElementById('export-other').checked,
            npc: document.getElementById('export-npc').checked,
            callRecords: document.getElementById('export-call-records').checked,
            characterNaiPrompts: document.getElementById('export-character-nai-prompts').checked // 【新增】角色NAI提示词
        };

        // 检查是否至少选择了一个选项
        if (!Object.values(selections).some(v => v)) {
            await showCustomAlert('提示', '请至少选择一个导出选项！');
            return;
        }

        // 判断是否为完整导出（全选）
        const isFullExport = Object.values(selections).every(v => v);

        // 显示加载提示
        const loadingAlert = document.createElement('div');
        loadingAlert.id = 'export-loading-alert';
        loadingAlert.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px 40px;border-radius:8px;z-index:10000;font-size:16px;text-align:center;';
        loadingAlert.textContent = '正在生成文件...';
        document.body.appendChild(loadingAlert);

        const backupData = {
            version: 1,
            timestamp: Date.now(),
            exportType: isFullExport ? 'full' : 'partial',
            selections: selections  // 记录选择信息，用于导入时校验
        };

        // 根据选择获取相应的数据
        let dataToFetch = {};

        if (selections.chats) {
            // 获取聊天数据后需要进行处理：只导出记忆锚点之后的聊天记录
            dataToFetch.chats = db.chats.toArray().then(chats => {
                return chats.map(chat => {
                    const memoryAnchor = chat.settings?.memoryAnchor || 0;
                    // 只保留 memoryAnchor 之后的 history
                    const processedChat = { ...chat };
                    processedChat.history = (chat.history || []).slice(memoryAnchor);
                    // 重置 memoryAnchor 为 0，因为导出的数据已经是"当前状态"
                    if (processedChat.settings) {
                        processedChat.settings.memoryAnchor = 0;
                    }
                    return processedChat;
                });
            });
        }

        if (selections.worldBooks) {
            dataToFetch.worldBooks = db.worldBooks.toArray();
        }

        if (selections.worldBookCategories) {
            dataToFetch.worldBookCategories = db.worldBookCategories.toArray();
        }

        if (selections.presetsConfig) {
            dataToFetch.apiConfig = db.apiConfig.get('main');
            dataToFetch.globalSettings = db.globalSettings.get('main');
            dataToFetch.apiPresets = db.apiPresets.toArray();
            dataToFetch.personaPresets = db.personaPresets.toArray();
            dataToFetch.bubblePresets = db.bubblePresets.toArray();
            dataToFetch.promptPresets = db.promptPresets.toArray();
            dataToFetch.customPresetItems = db.customPresetItems.toArray(); // <-- 【新增】导出自定义预设条目库
        }

        if (selections.qzone) {
            dataToFetch.qzoneSettings = db.qzoneSettings.get('main');
            dataToFetch.qzonePosts = db.qzonePosts.toArray();
            dataToFetch.qzoneAlbums = db.qzoneAlbums.toArray();
            dataToFetch.qzonePhotos = db.qzonePhotos.toArray();
            dataToFetch.qzoneGroups = db.qzoneGroups.toArray();
        }

        if (selections.media) {
            dataToFetch.userStickers = db.userStickers.toArray();
            dataToFetch.aiStickers = db.aiStickers.toArray(); // <-- 【新增】导出AI表情包库
            dataToFetch.musicLibrary = db.musicLibrary.get('main');
        }

        if (selections.other) {
            dataToFetch.favorites = db.favorites.toArray();
            dataToFetch.memories = db.memories.toArray();
            dataToFetch.forumPosts = db.forumPosts.toArray();
        }

        if (selections.npc) {
            dataToFetch.customNPCs = db.customNPCs.toArray();
        }

        if (selections.callRecords) {
            dataToFetch.callRecords = db.callRecords.toArray();
        }

        if (selections.characterNaiPrompts) {
            dataToFetch.characterNaiPrompts = db.characterNaiPrompts.toArray(); // 【新增】导出角色NAI提示词
        }

        // 执行所有 Promise
        const resolvedData = await Promise.all(
            Object.entries(dataToFetch).map(async ([key, promise]) => {
                return [key, await promise];
            })
        );

        // 将解析后的数据合并到 backupData
        resolvedData.forEach(([key, value]) => {
            backupData[key] = value;
        });

        // 【修复】将 aiStickers 的 blobData 转换为 Base64，以便 JSON 序列化
        if (backupData.aiStickers && Array.isArray(backupData.aiStickers)) {
            backupData.aiStickers = backupData.aiStickers.map(sticker => {
                const stickerCopy = { ...sticker };
                if (sticker.blobData) {
                    // 将 Blob 或 ArrayBuffer 转换为 Base64
                    if (sticker.blobData instanceof Blob) {
                        stickerCopy.blobDataBase64 = null; // 标记需要重新获取
                    } else if (sticker.blobData instanceof ArrayBuffer) {
                        // 如果是 ArrayBuffer，转换为 Base64
                        const bytes = new Uint8Array(sticker.blobData);
                        let binary = '';
                        for (let i = 0; i < bytes.byteLength; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        stickerCopy.blobDataBase64 = btoa(binary);
                    }
                }
                delete stickerCopy.blobData; // 删除原始 blobData，因为无法序列化
                delete stickerCopy._blobUrl; // 删除缓存的 Blob URL
                return stickerCopy;
            });
        }

        // 生成下载文件（下载保护已在函数开始时启用）
        const blob = new Blob(
            [JSON.stringify(backupData)],
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: isFullExport
                ? `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
                : `EPhone-Partial-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        document.body.appendChild(link);
        link.click();

        // 短暂延迟后移除链接
        setTimeout(() => {
            document.body.removeChild(link);
        }, 100);

        // 延迟释放 ObjectURL，给浏览器足够时间完成下载
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 5000);

        // 关闭加载提示
        const loadingElement = document.getElementById('export-loading-alert');
        if (loadingElement) {
            loadingElement.remove();
        }

        // 关闭对话框
        document.getElementById('export-options-modal').classList.remove('visible');

        await showCustomAlert('导出成功', isFullExport ? '已成功导出所有数据！' : '已成功导出选定的数据！');

        // 【关键】等待 iOS 下载完成后，禁用下载保护
        // 立即调用 disableDownloadProtection，它内部会延迟 5 秒再恢复
        disableDownloadProtection();
        console.log('✅ [选择导出] 已触发恢复流程');

    } catch (error) {
        console.error("部分导出数据时出错:", error);
        // 关闭加载提示
        const loadingElement = document.getElementById('export-loading-alert');
        if (loadingElement) {
            loadingElement.remove();
        }
        // 【新增】出错时立即禁用下载保护
        disableDownloadProtection();
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}
// ▲▲▲ 部分导出函数结束 ▲▲▲

async function exportBackup() {
    try {
        // 【最终修复】启用下载保护，禁用 VH 更新和 resize 监听器
        enableDownloadProtection();

        // 显示加载提示
        const loadingAlert = document.createElement('div');
        loadingAlert.id = 'export-loading-alert';
        loadingAlert.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px 40px;border-radius:8px;z-index:10000;font-size:16px;text-align:center;';
        loadingAlert.textContent = '正在生成文件...';
        document.body.appendChild(loadingAlert);

        const backupData = {
            version: 1,
            timestamp: Date.now()
        };

        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            apiPresets, personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories,
            worldBookCategories,
            forumPosts, // <-- 在这里添加 forumPosts
            bubblePresets, // <-- 添加气泡预设
            promptPresets, // <-- 【新增】添加预设数据
            customNPCs, // <-- 【新增】添加NPC数据
            callRecords, // <-- 【新增】添加通话记录数据
            worldEvents, // <-- 【新增】添加大世界事件数据
            aiStickers // <-- 【新增】添加AI表情包库数据
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.apiPresets.toArray(),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.forumPosts.toArray(), // <-- 在这里也添加
            db.bubblePresets.toArray(), // <-- 添加气泡预设数据获取
            db.promptPresets.toArray(), // <-- 【新增】获取预设数据
            db.customNPCs.toArray(), // <-- 【新增】获取NPC数据
            db.callRecords.toArray(), // <-- 【新增】获取通话记录数据
            db.worldEvents.toArray(), // <-- 【新增】获取大世界事件数据
            db.aiStickers.toArray() // <-- 【新增】获取AI表情包库数据
        ]);

        // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 【核心修复】自动为所有旧的、没有“真实姓名”字段的单聊角色补充该属性
    let needsDbUpdate = false;
    chats.forEach(chat => {
        if (!chat.isGroup && typeof chat.originalName === 'undefined') {
            chat.originalName = ''; // 补充一个空的 originalName 属性
            needsDbUpdate = true;
        }
    });

    // 如果有数据被修改，则一次性将所有更新保存回数据库
    if (needsDbUpdate) {
        console.log("数据迁移：发现旧角色数据，正在自动更新数据库...");
        await db.chats.bulkPut(chats);
        console.log("数据迁移：数据库更新成功！");
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // 【修复】将 aiStickers 的 blobData 转换为 Base64，以便 JSON 序列化
        const aiStickersForExport = aiStickers.map(sticker => {
            const stickerCopy = { ...sticker };
            if (sticker.blobData) {
                // 将 Blob 或 ArrayBuffer 转换为 Base64
                if (sticker.blobData instanceof Blob) {
                    // 如果是 Blob，需要异步处理，但这里我们用同步方式
                    // 实际上应该在前面就处理，这里先用 URL 方式
                    stickerCopy.blobDataBase64 = null; // 标记需要重新获取
                } else if (sticker.blobData instanceof ArrayBuffer) {
                    // 如果是 ArrayBuffer，转换为 Base64
                    const bytes = new Uint8Array(sticker.blobData);
                    let binary = '';
                    for (let i = 0; i < bytes.byteLength; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    stickerCopy.blobDataBase64 = btoa(binary);
                }
            }
            delete stickerCopy.blobData; // 删除原始 blobData，因为无法序列化
            delete stickerCopy._blobUrl; // 删除缓存的 Blob URL
            return stickerCopy;
        });

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            apiPresets, personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories,
            worldBookCategories,
            forumPosts, // <-- 最后在这里也添加
            bubblePresets, // <-- 添加气泡预设到备份数据
            promptPresets, // <-- 【新增】添加预设到备份数据
            customNPCs, // <-- 【新增】添加NPC到备份数据
            callRecords, // <-- 【新增】添加通话记录到备份数据
            worldEvents, // <-- 【新增】添加大世界事件到备份数据
            aiStickers: aiStickersForExport // <-- 【修复】使用转换后的表情包数据
        });

        const blob = new Blob(
            [JSON.stringify(backupData)],
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        document.body.appendChild(link);
        link.click();

        // 短暂延迟后移除链接
        setTimeout(() => {
            document.body.removeChild(link);
        }, 100);

        // 延迟释放 ObjectURL，给浏览器足够时间完成下载
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 5000);

        // 关闭加载提示
        const loadingElement = document.getElementById('export-loading-alert');
        if (loadingElement) {
            loadingElement.remove();
        }

        await showCustomAlert('导出成功', '已成功导出所有数据！');

        // 【关键】等待 iOS 下载完成后，禁用下载保护
        // 立即调用 disableDownloadProtection，它内部会延迟 5 秒再恢复
        disableDownloadProtection();
        console.log('✅ [完整导出] 已触发恢复流程');

    } catch (error) {
        console.error("导出数据时出错:", error);
        // 关闭加载提示
        const loadingElement = document.getElementById('export-loading-alert');
        if (loadingElement) {
            loadingElement.remove();
        }

        // 【新增】出错时立即禁用下载保护
        disableDownloadProtection();

        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}

// 用下面这个更新后的版本，完整替换您旧的 importBackup 函数
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        // ▼▼▼ 【修改】支持部分导入逻辑 ▼▼▼
        // 判断是完整导入还是部分导入
        const isPartialExport = data.exportType === 'partial';
        const selections = isPartialExport ? data.selections : null;

        await db.transaction('rw', db.tables, async () => {
            if (!isPartialExport) {
                for (const table of db.tables) {
                    await table.clear();
                }
            } else {
                if (selections.chats) {
                    await db.chats.clear();
                }
                if (selections.worldBooks) {
                    await db.worldBooks.clear();
                }
                if (selections.worldBookCategories) {
                    await db.worldBookCategories.clear();
                }
                if (selections.presetsConfig) {
                    await db.apiPresets.clear();
                    await db.personaPresets.clear();
                    await db.bubblePresets.clear();
                    await db.promptPresets.clear();
                    await db.customPresetItems.clear(); // <-- 【新增】清空自定义预设条目库
                }
                if (selections.qzone) {
                    await db.qzonePosts.clear();
                    await db.qzoneAlbums.clear();
                    await db.qzonePhotos.clear();
                    await db.qzoneGroups.clear();
                }
                if (selections.media) {
                    await db.userStickers.clear();
                    await db.aiStickers.clear(); // <-- 【新增】清空AI表情包库
                }
                if (selections.other) {
                    await db.favorites.clear();
                    await db.memories.clear();
                    await db.forumPosts.clear();
                }
                if (selections.npc) {
                    await db.customNPCs.clear();
                }
                if (selections.callRecords) {
                    await db.callRecords.clear();
                }
                if (selections.worldEvents) {
                    await db.worldEvents.clear();
                }
            }

            if (Array.isArray(data.chats)) {
                // 如果是部分导入聊天记录，需要重置 memoryAnchor 为 0
                // 因为导入的数据已经是"当前状态"，没有锚点前的数据
                if (isPartialExport && selections.chats) {
                    const processedChats = data.chats.map(chat => {
                        const processedChat = { ...chat };
                        if (processedChat.settings) {
                            processedChat.settings.memoryAnchor = 0;
                        }
                        return processedChat;
                    });
                    await db.chats.bulkPut(processedChats);
                } else {
                    await db.chats.bulkPut(data.chats);
                }
            }
            if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
            if (Array.isArray(data.worldBookCategories)) await db.worldBookCategories.bulkPut(data.worldBookCategories);
            if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
            if (Array.isArray(data.aiStickers)) {
                // 【修复】将 Base64 转换回 ArrayBuffer
                const aiStickersForImport = data.aiStickers.map(sticker => {
                    const stickerCopy = { ...sticker };
                    if (sticker.blobDataBase64) {
                        // 将 Base64 转换回 ArrayBuffer
                        const binaryString = atob(sticker.blobDataBase64);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        stickerCopy.blobData = bytes.buffer;
                    }
                    delete stickerCopy.blobDataBase64; // 删除 Base64 字段
                    return stickerCopy;
                });
                await db.aiStickers.bulkPut(aiStickersForImport);
            }
            if (Array.isArray(data.apiPresets)) await db.apiPresets.bulkPut(data.apiPresets);
            if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
            if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
            if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
            if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
            if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
            if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
            if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories);
            if (Array.isArray(data.forumPosts)) await db.forumPosts.bulkPut(data.forumPosts); // <-- 添加这一行
            if (Array.isArray(data.bubblePresets)) await db.bubblePresets.bulkPut(data.bubblePresets); // <-- 添加气泡预设导入
            if (Array.isArray(data.promptPresets)) await db.promptPresets.bulkPut(data.promptPresets); // <-- 【新增】添加预设导入
            if (Array.isArray(data.customPresetItems)) await db.customPresetItems.bulkPut(data.customPresetItems); // <-- 【新增】导入自定义预设条目库
            if (Array.isArray(data.customNPCs)) await db.customNPCs.bulkPut(data.customNPCs); // <-- 【新增】导入NPC数据
            if (Array.isArray(data.callRecords)) await db.callRecords.bulkPut(data.callRecords); // <-- 【新增】导入通话记录
            if (Array.isArray(data.worldEvents)) await db.worldEvents.bulkPut(data.worldEvents); // <-- 【新增】导入大世界事件数据
            if (Array.isArray(data.characterNaiPrompts)) await db.characterNaiPrompts.bulkPut(data.characterNaiPrompts); // 【新增】导入角色NAI提示词

            if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
            if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
            if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
            if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
        });
        // ▲▲▲ 修改结束 ▲▲▲

        await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("导入数据时出错:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}

// ▼▼▼ 新增：本地备份函数（保存到IndexedDB中的localBackups表） ▼▼▼
async function saveLocalBackup() {
    const statusEl = document.getElementById('local-backup-status');

    try {
        statusEl.textContent = '正在保存...';
        statusEl.style.color = '#999';

        const backupData = {
            id: 'latest',
            version: 1,
            timestamp: Date.now(),
            backupName: `本地备份-${new Date().toLocaleString()}`
        };

        // 按顺序分别读取各表数据，便于诊断具体失败位置
        const tableConfigs = [
            { key: 'chats', readFunc: () => db.chats.toArray() },
            { key: 'worldBooks', readFunc: () => db.worldBooks.toArray() },
            { key: 'userStickers', readFunc: () => db.userStickers.toArray() },
            { key: 'aiStickers', readFunc: () => db.aiStickers.toArray() }, // <-- 【新增】AI表情包库本地备份
            { key: 'apiConfig', readFunc: () => db.apiConfig.get('main') },
            { key: 'globalSettings', readFunc: () => db.globalSettings.get('main') },
            { key: 'apiPresets', readFunc: () => db.apiPresets.toArray() },
            { key: 'personaPresets', readFunc: () => db.personaPresets.toArray() },
            { key: 'musicLibrary', readFunc: () => db.musicLibrary.get('main') },
            { key: 'qzoneSettings', readFunc: () => db.qzoneSettings.get('main') },
            { key: 'qzonePosts', readFunc: () => db.qzonePosts.toArray() },
            { key: 'qzoneAlbums', readFunc: () => db.qzoneAlbums.toArray() },
            { key: 'qzonePhotos', readFunc: () => db.qzonePhotos.toArray() },
            { key: 'favorites', readFunc: () => db.favorites.toArray() },
            { key: 'qzoneGroups', readFunc: () => db.qzoneGroups.toArray() },
            { key: 'memories', readFunc: () => db.memories.toArray() },
            { key: 'worldBookCategories', readFunc: () => db.worldBookCategories.toArray() },
            { key: 'forumPosts', readFunc: () => db.forumPosts.toArray() },
            { key: 'bubblePresets', readFunc: () => db.bubblePresets.toArray() },
            { key: 'promptPresets', readFunc: () => db.promptPresets.toArray() },
            { key: 'customNPCs', readFunc: () => db.customNPCs.toArray() },
            { key: 'customPresetItems', readFunc: () => db.customPresetItems.toArray() }, // <-- 【新增】自定义预设条目库本地备份
            { key: 'callRecords', readFunc: () => db.callRecords.toArray() }, // <-- 【新增】通话记录本地备份
            { key: 'worldEvents', readFunc: () => db.worldEvents.toArray() }, // <-- 【新增】大世界事件本地备份
            { key: 'characterNaiPrompts', readFunc: () => db.characterNaiPrompts.toArray() } // 【新增】角色NAI提示词本地备份
        ];

        // 顺序读取数据，遇到错误时显示具体是哪个表
        for (const config of tableConfigs) {
            try {
                backupData[config.key] = await config.readFunc();
            } catch (tableError) {
                console.error(`读取${config.key}表失败:`, tableError);
                throw new Error(`数据读取错误 - 失败表: ${config.key}, 原因: ${tableError.message}`);
            }
        }

        // 保存到IndexedDB，添加重试机制
        let retryCount = 0;
        const maxRetries = 2;

        while (retryCount <= maxRetries) {
            try {
                await db.localBackups.put(backupData);
                break; // 成功则跳出重试循环
            } catch (writeError) {
                retryCount++;
                console.error(`第 ${retryCount} 次写入失败:`, writeError);

                if (retryCount > maxRetries) {
                    throw new Error(`数据写入失败 (已重试${maxRetries}次): ${writeError.message}`);
                }

                // 重试前等待一小段时间
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        const now = new Date();
        const successTime = now.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).replace(/\//g, '月').replace(/\s/g, '日');
        // 持久化备份成功时间到localStorage
        localStorage.setItem('lastBackupSuccess', successTime);
        // 使用新的显示格式：绿色圆形勾号 + 时间文本
        statusEl.innerHTML = `<span class="backup-success-badge"><span class="checkmark-circle"></span><span> 备份成功 - ${successTime}</span></span>`;
        statusEl.style.color = '#666';

    } catch (error) {
        console.error("本地备份出错:", error);
        const statusEl = document.getElementById('local-backup-status');
        statusEl.textContent = `✗ 备份失败: ${error.message}`;
        statusEl.style.color = '#ff6b6b';
    }
}

// ▼▼▼ 新增：本地恢复函数（从IndexedDB的localBackups表读取） ▼▼▼
async function restoreLocalBackup() {
    const statusEl = document.getElementById('local-backup-status');

    try {
        // 从IndexedDB读取备份
        const backupRecord = await db.localBackups.get('latest');

        if (!backupRecord) {
            statusEl.textContent = '✗ 没有找到本地备份';
            statusEl.style.color = '#ff6b6b';
            return;
        }

        const backupData = backupRecord;

        const confirmed = await showCustomConfirm(
            '严重警告！',
            '从本地备份恢复将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？',
            { confirmButtonClass: 'btn-danger' }
        );

        if (!confirmed) {
            statusEl.textContent = '';
            return;
        }

        statusEl.textContent = '正在恢复...';
        statusEl.style.color = '#999';

        // 分步骤恢复数据，便于诊断具体失败位置
        const restoreConfigs = [
            { tableName: 'chats', key: 'chats', isArray: true },
            { tableName: 'worldBooks', key: 'worldBooks', isArray: true },
            { tableName: 'worldBookCategories', key: 'worldBookCategories', isArray: true },
            { tableName: 'userStickers', key: 'userStickers', isArray: true },
            { tableName: 'aiStickers', key: 'aiStickers', isArray: true }, // <-- 【新增】AI表情包库本地恢复
            { tableName: 'apiPresets', key: 'apiPresets', isArray: true },
            { tableName: 'personaPresets', key: 'personaPresets', isArray: true },
            { tableName: 'qzonePosts', key: 'qzonePosts', isArray: true },
            { tableName: 'qzoneAlbums', key: 'qzoneAlbums', isArray: true },
            { tableName: 'qzonePhotos', key: 'qzonePhotos', isArray: true },
            { tableName: 'favorites', key: 'favorites', isArray: true },
            { tableName: 'qzoneGroups', key: 'qzoneGroups', isArray: true },
            { tableName: 'memories', key: 'memories', isArray: true },
            { tableName: 'forumPosts', key: 'forumPosts', isArray: true },
            { tableName: 'bubblePresets', key: 'bubblePresets', isArray: true },
            { tableName: 'promptPresets', key: 'promptPresets', isArray: true },
            { tableName: 'customNPCs', key: 'customNPCs', isArray: true },
            { tableName: 'customPresetItems', key: 'customPresetItems', isArray: true }, // <-- 【新增】自定义预设条目库本地恢复
            { tableName: 'callRecords', key: 'callRecords', isArray: true }, // <-- 【新增】通话记录本地恢复
            { tableName: 'worldEvents', key: 'worldEvents', isArray: true }, // <-- 【新增】大世界事件本地恢复
            { tableName: 'characterNaiPrompts', key: 'characterNaiPrompts', isArray: true }, // 【新增】角色NAI提示词本地恢复
            { tableName: 'apiConfig', key: 'apiConfig', isArray: false },
            { tableName: 'globalSettings', key: 'globalSettings', isArray: false },
            { tableName: 'musicLibrary', key: 'musicLibrary', isArray: false },
            { tableName: 'qzoneSettings', key: 'qzoneSettings', isArray: false }
        ];

        // 先清空所有表（除了localBackups）
        for (const config of restoreConfigs) {
            try {
                await db[config.tableName].clear();
            } catch (clearError) {
                console.error(`清空${config.tableName}表失败:`, clearError);
                throw new Error(`清空表失败 - 表: ${config.tableName}, 原因: ${clearError.message}`);
            }
        }

        // 逐表恢复数据
        for (const config of restoreConfigs) {
            try {
                const data = backupData[config.key];

                if (config.isArray && Array.isArray(data)) {
                    await db[config.tableName].bulkPut(data);
                } else if (!config.isArray && data) {
                    await db[config.tableName].put(data);
                }
            } catch (restoreError) {
                console.error(`恢复${config.tableName}表失败:`, restoreError);
                throw new Error(`数据恢复失败 - 表: ${config.tableName}, 原因: ${restoreError.message}`);
            }
        }

        const now = new Date();
        const successTime = now.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).replace(/\//g, '月').replace(/\s/g, '日');
        // 持久化恢复成功时间到localStorage
        localStorage.setItem('lastBackupSuccess', successTime);
        // 使用新的显示格式：绿色圆形勾号 + 时间文本
        statusEl.innerHTML = `<span class="backup-success-badge"><span class="checkmark-circle"></span><span> 恢复成功 - ${successTime}</span></span>`;
        statusEl.style.color = '#666';

        await showCustomAlert('恢复成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');

        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("本地恢复出错:", error);
        statusEl.textContent = `✗ 恢复失败: ${error.message}`;
        statusEl.style.color = '#ff6b6b';
        await showCustomAlert('恢复失败', `数据恢复出错: ${error.message}`);
    }
}
// ▲▲▲ 新增结束 ▲▲▲

        // 优化字体预览：添加缓存机制
        let lastPreviewFontUrl = '';
        let previewStyleElement = null;
        
        function applyCustomFont(fontUrl, isPreviewOnly = false) {
            if (!fontUrl) {
                dynamicFontStyle.innerHTML = '';
                const fontPreview = document.getElementById('font-preview');
                if (fontPreview) fontPreview.style.fontFamily = '';
                lastPreviewFontUrl = '';
                return;
            }
            
            const fontName = 'custom-user-font';
            
            if (isPreviewOnly) {
                // 优化：避免重复操作相同URL
                if (lastPreviewFontUrl === fontUrl) return;
                lastPreviewFontUrl = fontUrl;
                
                // 优化：复用样式元素，避免重复创建
                if (!previewStyleElement) {
                    previewStyleElement = document.createElement('style');
                    previewStyleElement.id = 'preview-font-style';
                    document.head.appendChild(previewStyleElement);
                }
                
                // 优化：使用更快的 font-display: optional 和预加载策略
                const newStyle = `
                    @font-face {
                      font-family: '${fontName}';
                      src: url('${fontUrl}');
                      font-display: optional;
                    }`;
                
                previewStyleElement.innerHTML = newStyle;
                const fontPreview = document.getElementById('font-preview');
                if (fontPreview) {
                    fontPreview.style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                }
            } else {
                const newStyle = `
                    @font-face {
                      font-family: '${fontName}';
                      src: url('${fontUrl}');
                      font-display: swap;
                    }`;
                dynamicFontStyle.innerHTML = `
                ${newStyle}
                body, #chat-messages {
                  font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                }`;
            }
        }

        async function resetToDefaultFont() {
            dynamicFontStyle.innerHTML = ''; 
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            document.getElementById('font-url-input').value = '';
            document.getElementById('font-preview').style.fontFamily = '';
            alert('已恢复默认字体。');
        }

async function loadAllDataFromDB() {
    // ▼▼▼ 【核心修改在这里】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        apiPresets,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites, // 将 initialFavorites 加入到解构赋值中
        allAiStickers // 【【【程煜修改】】】在这里也加载AI表情包
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.apiPresets.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray(), // 确保这一行在 Promise.all 的数组参数内
        db.aiStickers.toArray() // 【【【程煜修改】】】从数据库加载AI表情包
    ]);
    // ▲▲▲ 【修改结束】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
    }

        // ★★★【核心重构：数据迁移脚本】★★★
        // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
            chat.members.forEach(member => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 将旧的 name 作为 originalName
                    member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                    delete member.name; // 删除旧的、有歧义的 name 字段
                    needsUpdate = true; // 标记需要存回数据库
                }
            });
             console.log(`迁移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查1：如果是一个单聊，并且没有 status 属性
        if (!chat.isGroup && !chat.status) {
            // 就为它补上一个默认的 status 对象
            chat.status = {
                text: '在线',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查2：兼容最新的“关系”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是单聊，且没有 relationship 对象，就补上一个默认的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ 在这里添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.aiAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲

    // ▼▼▼ 【新增】情侣头像库初始化 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.coupleAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.coupleAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了coupleAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        // 【全新】兼容旧数据，将 maxMemory 转换为 memoryAnchor
        if (chat.settings && typeof chat.settings.memoryAnchor === 'undefined') {
            const maxMemory = chat.settings.maxMemory || 10;
            const totalHistory = chat.history.length;
            // 将旧的“最后N条”逻辑转换为新的“从第N条开始”逻辑
            chat.settings.memoryAnchor = Math.max(0, totalHistory - maxMemory);
            delete chat.settings.maxMemory; // 删除旧的属性
        }
        
        // 【全新添加】兼容旧数据，为没有"总结保留条数"的聊天设置默认值
        if (chat.settings && typeof chat.settings.summarizeReserveCount === 'undefined') {
            chat.settings.summarizeReserveCount = 100; // 默认为100
        }

        // ▼▼▼ 【Minimax TTS】为旧角色兼容minimaxVoiceId ▼▼▼
        if (!chat.isGroup && (!chat.settings || typeof chat.settings.minimaxVoiceId === 'undefined')) {
            if (!chat.settings) chat.settings = {};
            chat.settings.minimaxVoiceId = '';
        }

        // 🔥【新增】为旧角色兼容语速和语言设置
        if (!chat.isGroup && chat.settings) {
            if (typeof chat.settings.minimaxVoiceSpeed === 'undefined') {
                chat.settings.minimaxVoiceSpeed = 1.0;
            }
            if (typeof chat.settings.minimaxLanguage === 'undefined') {
                chat.settings.minimaxLanguage = '';
            }
        }
        // ▲▲▲ 【Minimax TTS】为旧角色兼容minimaxVoiceId ▲▲▲

        // ▼▼▼ 在这里粘贴 ▼▼▼
// 为旧角色兼容日记和心声功能
if (!chat.diary) {
    chat.diary = [];
}
if (!chat.displayStatus) {
    chat.displayStatus = {
        statusText: chat.status?.text || '在线',
        innerThought: '...'
    };
}
if (!chat.statusHistory) {
    chat.statusHistory = [];
}
if (!chat.thoughtHistory) {
    chat.thoughtHistory = [];
}
// ▲▲▲ 粘贴结束 ▲▲▲
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }
        acc[chat.id] = chat;
        return acc;
    }, {});

    // 【新增】页面加载时重置所有开启后台活动的倒计时（从现在开始计算）
    // 这样可以避免刷新页面后立刻触发后台活动
    // 【修复3】同时重置所有角色的"正在输入中..."状态，因为刷新页面会中断API调用
    const chatsToSave = [];
    Object.values(state.chats).forEach(chat => {
        let needsSave = false;
        if (!chat.isGroup && chat.settings?.backgroundActivityEnabled) {
            chat.settings.lastBackgroundCheckTime = Date.now();
            needsSave = true;
            console.log(`✓ 重置倒计时: ${chat.name}`);
        }
        // 【修复3 + 新增智能判断】重置聊天的isAwaitingReply标志
        // 但如果有待处理的naiimag图片(既没有imageUrl也没有标记为失败)，则保持isAwaitingReply不变
        if (chat.isAwaitingReply) {
            const pendingNaimagMessages = chat.history.filter(msg =>
                msg.type === 'naiimag' && !msg.imageUrl && !msg.isFailed
            );

            if (pendingNaimagMessages.length === 0) {
                // 没有待处理的naiimag,可以安全清除isAwaitingReply
                chat.isAwaitingReply = false;
                needsSave = true;
                console.log(`✓ 重置输入状态: ${chat.name}`);
            } else {
                // 有待处理的naiimag,保持isAwaitingReply,但这些图片实际上无法完成了
                // 所以我们将它们标记为失败
                console.log(`⚠️ ${chat.name} 有${pendingNaimagMessages.length}条naiimag因刷新页面未完成,标记为失败`);
                pendingNaimagMessages.forEach(msg => {
                    msg.isFailed = true;
                    msg.failureReason = '页面刷新导致生成中断';
                });
                // 所有naiimag都失败了,可以清除isAwaitingReply
                chat.isAwaitingReply = false;
                needsSave = true;
            }
        }
        if (needsSave) {
            chatsToSave.push(chat);
        }
    });
    // 只保存有改变的chat，避免不必要的数据库操作
    if (chatsToSave.length > 0) {
        Promise.all(chatsToSave.map(chat => db.chats.put(chat))).catch(err => {
            console.error('保存重置后的数据失败:', err);
        });
    }

    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '', temperature: 0.8, minimaxGroupId: '', minimaxApiKey: '', minimaxSpeechModel: 'speech-01-turbo', minimaxDomain: 'https://api.minimax.chat' };

state.globalSettings = globalSettings || {
    id: 'main',
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)',
    fontUrl: '',
    enableBackgroundActivity: false,
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    chatListPaddingTop: 72, // <--- 新增这一行
    appIcons: { ...DEFAULT_APP_ICONS }, // 【核心修改】确保appIcons存在并有默认值
    widgetData: {} // 【新增】用于保存Profile等可编辑元素的数据
};
// 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

// 【核心修改】确保widgetData始终存在（如果从数据库加载的是旧版本，需要补充）
if (!state.globalSettings.widgetData) {
    state.globalSettings.widgetData = {};
}

// ▼▼▼ 新增：初始化时预加载通知音频 ▼▼▼
if (state.globalSettings.notificationSoundUrl) {
    const audioUrl = state.globalSettings.notificationSoundUrl.trim();
    if (audioUrl) {
        try {
            const preloadAudio = new Audio(audioUrl);
            preloadAudio.preload = 'auto';
            preloadAudio.volume = 1;
            notificationAudioCache = {
                url: audioUrl,
                audio: preloadAudio
            };
            console.log('[初始化] 通知音频已预加载:', audioUrl);
        } catch (error) {
            console.warn('[初始化] 预加载通知音频失败:', error);
        }
    }
}
// ▲▲▲ 新增：初始化时预加载通知音频 ▲▲▲

    state.userStickers = userStickers || [];
    state.apiPresets = apiPresets || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif', unreadCommentsCount: 0 };

    // 【新增】初始化表情包 Blob URL 缓存
    if (state.userStickers && state.userStickers.length > 0) {
        state.userStickers.forEach(sticker => {
            // 【【【程煜修改】】】检查 blobData 是不是一个真的 Blob，而不是导入的 {}
            if (sticker.blobData instanceof Blob && !sticker._blobUrl) {
                try {
                    sticker._blobUrl = URL.createObjectURL(sticker.blobData);
                    console.log(`✅ 初始化：用户表情包 "${sticker.name}" 的 Blob URL 已缓存`);
                } catch (e) {
                    console.warn(`⚠️ 初始化失败 (${sticker.name}): ${e.message}`);
                }
            }
        });
    }
    // 【【【程煜修改】】】在这里初始化 AI 表情包
    if (allAiStickers && allAiStickers.length > 0) {
        allAiStickers.forEach(sticker => {
            if (sticker.blobData instanceof Blob && !sticker._blobUrl) {
                try {
                    sticker._blobUrl = URL.createObjectURL(sticker.blobData);
                } catch (e) {
                     console.warn(`⚠️ AI表情包初始化失败 (${sticker.meaning}): ${e.message}`);
                }
            }
        });
        state.aiStickers = allAiStickers; // 存入 state
    }
    // 确保unreadCommentsCount属性存在
    if (!state.qzoneSettings.unreadCommentsCount) {
        state.qzoneSettings.unreadCommentsCount = 0;
    }

    // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    if (typeof state.globalSettings.chatListPaddingTop === 'undefined') {
    state.globalSettings.chatListPaddingTop = 72;
}
    // ▲▲▲ 【修改结束】 ▲▲▲
}
        async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }
        
        // 【新增】模拟时间戳格式化函数
        function formatSimulatedTimestamp(simulatedTimestamp, originalLastMessageTime) {
            if (!simulatedTimestamp) return '';
            
            const simulatedDate = new Date(simulatedTimestamp);
            const originalDate = new Date(originalLastMessageTime);
            const currentDate = new Date(); // 当前真实时间
            
            const hours = String(simulatedDate.getHours()).padStart(2, '0');
            const minutes = String(simulatedDate.getMinutes()).padStart(2, '0');
            
            // 【修复】新的显示逻辑：只有真实时间当天的消息才不显示日期
            // 判断模拟时间戳是否是今天（真实的当天）
            const isSameDay = simulatedDate.toDateString() === currentDate.toDateString();
            
            if (isSameDay) {
                // 今天的消息只显示时间
                return `${hours}:${minutes}`;
            } else {
                // 不是今天的消息显示完整日期
                const month = String(simulatedDate.getMonth() + 1).padStart(2, '0');
                const day = String(simulatedDate.getDate()).padStart(2, '0');
                return `${month}月${day}日 ${hours}:${minutes}`;
            }
        }

        function showNotification(chatId, messageContent) {
            console.log(`[showNotification] 收到通知请求 - chatId: ${chatId}, messageContent: "${messageContent}"`);
            clearTimeout(notificationTimeout);
            const chat = state.chats[chatId];
            if (!chat) {
                console.log(`[showNotification] 未找到聊天记录: ${chatId}`);
                return;
            }
            const bar = document.getElementById('notification-bar');
            document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
            const displayName = !chat.isGroup && chat.remark ? chat.remark : chat.name;
            document.getElementById('notification-content').querySelector('.name').textContent = displayName;
            document.getElementById('notification-content').querySelector('.message').textContent = messageContent;
            console.log(`[showNotification] 设置通知内容 - 名字: "${displayName}", 消息: "${messageContent}"`);
            const newBar = bar.cloneNode(true);
            bar.parentNode.replaceChild(newBar, bar);
            newBar.addEventListener('click', () => { openChat(chatId, true); newBar.classList.remove('visible'); });

            // ▼▼▼ 先播放音频，再显示notification bar ▼▼▼
            // ▼▼▼ (程煜：替换成新的 Web Audio API 播放逻辑 v2.0) ▼▼▼
            if (audioContext && notificationAudioBuffer) {
                
                // (程煜：【核心修复】在播放前*立刻*检查状态)
                if (audioContext.state === 'suspended') {
                    // (程煜：它睡着了，你（用户）又没点，播不了。在控制台记一下。)
                    console.warn('[showNotification] 播放失败：AudioContext 处于 suspended 状态。请先点击屏幕任意位置来唤醒音频。');
                    
                } else {
                    // (程煜：它醒着，播放。)
                    try {
                        const source = audioContext.createBufferSource();
                        source.buffer = notificationAudioBuffer;
                        source.connect(audioContext.destination);
                        source.start(0);
                        console.log('[showNotification] 正在使用 Web Audio API 播放...');
                    } catch (error) {
                        console.warn('[showNotification] Web Audio 播放失败:', error);
                    }
                }
            } else {
                // (程煜：如果还没解锁，就在控制台记一下)
                if (!isAudioContextUnlocked) {
                    console.warn('[showNotification] 音频未播放：AudioContext 尚未被用户手势解锁。');
                }
                if (!notificationAudioBuffer) {
                    console.warn('[showNotification] 音频未播放：通知音缓冲（notificationAudioBuffer）为空。');
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // 延迟100毫秒再显示notification bar，确保音频先播放
            setTimeout(() => {
                newBar.classList.add('visible');
                console.log(`[showNotification] 通知栏已显示`);
                notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000);
            }, 100);
            // ▲▲▲ 先播放音频，再显示notification bar ▲▲▲

            // ▼▼▼ 【新增】系统级通知 ▼▼▼
            if ('Notification' in window && Notification.permission === 'granted') {
                try {
                    const displayName = !chat.isGroup && chat.remark ? chat.remark : chat.name;
                    new Notification(displayName, {
                        icon: chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar,
                        badge: chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar,
                        body: messageContent.substring(0, 100) + (messageContent.length > 100 ? '...' : ''),
                        tag: 'ephone-notification-' + chatId,
                        requireInteraction: false
                    });
                    console.log(`[系统通知] 已发送: ${displayName} - ${messageContent.substring(0, 50)}...`);
                } catch (error) {
                    console.warn('[系统通知] 发送失败:', error);
                }
            }
            // ▲▲▲ 系统级通知结束 ▲▲▲
        }

        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }


/**
 * 【最终修复版 v3.0】解析AI返回的、可能格式不规范的响应内容
 * @param {string} content - AI返回的原始字符串
 * @returns {Array} - 一个标准化的消息对象数组
 */
function parseAiResponse(content) {
    // ▼▼▼ 【全新添加】在这里增加一行代码，用于清理无效字符 ▼▼▼

    content = content.replace(/(,)\s*[a-zA-Z_]+\s*(")/g, '$1$2');

// ▼▼▼ 第2道净化：【全新添加】清理逗号/花括号和键名之间的 stray < ▼▼▼
    content = content.replace(/(,|{)\s*<\s*(")/g, '$1$2');
    // ▲▲▲ 新代码添加结束 ▲▲▲
    // ▼▼▼ 第3道净化：【全新添加】清理逗号和键名之间的 stray - (本次修复) ▼▼▼
    content = content.replace(/(,)\s*-\s*(")/g, '$1$2');
    // ▲▲▲ 新代码添加结束 ▲▲▲

    // ▼▼▼ 【新增-消息截断修复】第4道净化：修复对象间缺少逗号的情况 ▼▼▼
    // 修复 }{ 之间缺少逗号的情况（常见于AI返回多条消息时）
    content = content.replace(/}\s*{/g, '},{');

    // 修复数组中对象间缺少逗号的情况
    content = content.replace(/}\s*\n\s*{/g, '},{');
    // ▲▲▲ 第4道净化结束 ▲▲▲

    const trimmedContent = content.trim();

    // 方案 1: 尝试直接解析为标准JSON数组 (最理想情况)
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
            }
        } catch (e) {
            console.warn("标准JSON数组解析失败，将尝试方案2...");
        }
    }

    // 方案 2: 提取被 ```json ... ``` 或 [ ... ] 包裹的核心JSON内容
    const jsonMatch = trimmedContent.match(/```json\s*([\s\S]*?)\s*```/);
    const jsonBlock = jsonMatch ? jsonMatch[1].trim() : trimmedContent;
    const startIndex = jsonBlock.indexOf('[');
    const endIndex = jsonBlock.lastIndexOf(']');
    if (startIndex !== -1 && endIndex > startIndex) {
        const jsonString = jsonBlock.substring(startIndex, endIndex + 1);
        try {
            const parsed = JSON.parse(jsonString);
            if (Array.isArray(parsed)) {
                console.log("解析成功：通过提取核心 [ ... ] JSON块。");
                return parsed;
            }
        } catch (e) {
            console.warn("提取核心JSON块解析失败，将尝试方案3（碎片化解析）...");
        }
    }

    // 【全新】方案 3: 处理(Timestamp: ...)[{...}]这种碎片化格式
    const fragmentedJsonRegex = /\[\s*\{[\s\S]*?\}\s*\]/g;
    const matches = content.match(fragmentedJsonRegex);
    if (matches && matches.length > 0) {
        const results = [];
        for (const match of matches) {
            try {
                const parsedArray = JSON.parse(match);
                if (Array.isArray(parsedArray) && parsedArray.length > 0) {
                    // 将每个单元素数组中的对象提取出来，合并成一个大数组
                    results.push(...parsedArray);
                }
            } catch (e) {
                console.warn("跳过一个畸形的JSON碎片:", match);
            }
        }
        if (results.length > 0) {
            console.log(`解析成功：通过碎片化JSON提取模式，成功合并了 ${results.length} 条指令。`);
            return results;
        }
    }

    // ▼▼▼ 【方案 3.5】宽松模式 - 用正则从畸形JSON中提取所有关键字段 ▼▼▼
    const lenientParsed = lenientParseJSON(content);
    if (lenientParsed.length > 0) {
        console.log(`解析成功：通过宽松模式正则提取，成功修复了畸形JSON。`);
        return lenientParsed;
    }
    // ▲▲▲ 宽松模式结束 ▲▲▲

    // 方案 4: 最终备用方案，将所有内容作为单条文本消息返回
    console.error("所有JSON解析方案均失败！将返回原始文本。");
    return [{ type: 'text', content: content }];
}

/**
 * 【方案3.5：宽松模式解析】
 * 用正则表达式从可能畸形的JSON中逐个提取对象的关键字段
 * 只要能识别出 type、content等关键字段，就生成对应的对象
 * @param {string} rawString - 原始的、可能畸形的JSON字符串
 * @returns {Array} - 提取出的有效对象数组
 */
function lenientParseJSON(rawString) {
    const results = [];

    // 【步骤1】用栈式匹配找到所有完整的对象块 { ... }
    // 这个方法支持任意深度的嵌套，比简单正则更可靠
    const objectBlocks = extractObjectBlocks(rawString);

    console.log(`[宽松模式] 找到 ${objectBlocks.length} 个潜在对象块`);

    for (const block of objectBlocks) {
        try {
            // 先尝试直接JSON.parse
            const obj = JSON.parse(block);
            if (obj && typeof obj === 'object' && obj.type) {
                results.push(obj);
                console.log(`[宽松模式] 通过严格JSON.parse成功提取消息 #${results.length}:`, obj.type);
                continue;
            }
        } catch (e) {
            // JSON.parse失败，继续用宽松提取
        }

        // 【步骤2】如果严格解析失败，用宽松模式提取关键字段
        const lenientObj = lenientExtractObject(block);
        if (lenientObj && lenientObj.type) {
            results.push(lenientObj);
            console.log(`[宽松模式] 通过宽松提取成功提取消息 #${results.length}:`, lenientObj.type, lenientObj);
        } else if (lenientObj) {
            // 【修复】即使没有type字段，如果lenientObj存在，也应该加入结果，避免消息丢失
            console.warn(`[宽松模式] lenientObj缺少type字段，但仍然保存：`, lenientObj);
            results.push(lenientObj);
        } else {
            console.error(`[宽松模式] 完全无法提取此对象块:`, block.substring(0, 100) + '...');
        }
    }

    console.log(`[宽松模式-总结] 共提取了 ${results.length} 条消息，来自 ${objectBlocks.length} 个对象块`);
    return results;
}

/**
 * 【辅助函数】用栈式匹配提取所有完整的对象块
 * 支持任意深度的嵌套花括号，比正则更准确
 * @param {string} str - 输入字符串
 * @returns {Array} - 所有提取出的对象块字符串
 */
function extractObjectBlocks(str) {
    const blocks = [];
    let braceCount = 0;
    let startIndex = -1;
    let inString = false;

    for (let i = 0; i < str.length; i++) {
        const char = str[i];

        // 处理字符串状态 - 改进版：向前扫描计算反斜杠数量
        if (char === '"') {
            // 统计这个引号前面有多少个连续的反斜杠
            let backslashCount = 0;
            let j = i - 1;
            while (j >= 0 && str[j] === '\\') {
                backslashCount++;
                j--;
            }

            // 如果反斜杠是偶数个（包括0），说明这个引号没被转义
            // 如果是奇数个，说明这个引号被转义了，不是字符串边界
            if (backslashCount % 2 === 0) {
                inString = !inString;
            }
            continue;
        }

        // 在字符串外处理花括号
        if (!inString) {
            if (char === '{') {
                if (braceCount === 0) {
                    startIndex = i;
                }
                braceCount++;
            } else if (char === '}') {
                braceCount--;
                if (braceCount === 0 && startIndex !== -1) {
                    // 找到一个完整的对象块
                    blocks.push(str.substring(startIndex, i + 1));
                    startIndex = -1;
                }
            }
        }
    }

    // 【容错增强】如果遍历结束时还有未闭合的对象块，尝试保存它
    if (startIndex !== -1 && braceCount > 0) {
        console.warn(`[extractObjectBlocks-容错] 发现未闭合的对象块，尝试自动闭合并保存`);
        let unclosedBlock = str.substring(startIndex);
        // 尝试添加缺失的右花括号
        unclosedBlock += '}'.repeat(braceCount);
        blocks.push(unclosedBlock);
    }

    return blocks;
}

/**
 * 从单个对象块中宽松提取关键字段
 * 【核心改进】先识别type，再根据具体type只提取该type需要的字段，避免字段重名导致的混乱
 * @param {string} blockStr - 单个对象块的字符串，如 { "type": "text", "content": "..." }
 * @returns {Object|null} - 提取出的对象，如果无法识别则返回null
 */
function lenientExtractObject(blockStr) {
    // 【第一步】先提取type字段，这是核心的消息类型识别
    const typeMatch = blockStr.match(/"type"\s*:\s*"([^"]*)"/i);

    // 【核心修复】即使没有type字段，也尝试提取内容字段，避免消息丢失
    if (!typeMatch) {
        console.warn('[宽松模式-增强容错] 未找到type字段，尝试提取content/message字段作为文本消息');

        // 尝试提取 content 或 message 字段
        const contentMatch = blockStr.match(/"(?:content|message)"\s*:\s*"([^"\\]*(?:\\.[^"\\]*)*)"/i);
        if (contentMatch) {
            const extractedContent = contentMatch[1].replace(/\\"/g, '"');
            console.log(`[宽松模式-增强容错] 成功提取到内容: "${extractedContent.substring(0, 50)}..."`);
            return { type: 'text', content: extractedContent };
        }

        // 如果连content都没有，检查是否有name字段(可能是群聊消息的特殊格式)
        const nameMatch = blockStr.match(/"name"\s*:\s*"([^"]*)"/i);
        const messageMatch = blockStr.match(/"message"\s*:\s*"([^"\\]*(?:\\.[^"\\]*)*)"/i);
        if (nameMatch && messageMatch) {
            const extractedMessage = messageMatch[1].replace(/\\"/g, '"');
            console.log(`[宽松模式-增强容错] 检测到群聊格式消息: name="${nameMatch[1]}", message="${extractedMessage.substring(0, 30)}..."`);
            return { type: 'text', name: nameMatch[1], content: extractedMessage };
        }

        console.warn('[宽松模式-增强容错] 无法提取任何有效字段，跳过此对象块');
        return null;
    }

    const messageType = typeMatch[1];
    const obj = { type: messageType };

    // 【字段提取规则映射】每个type对应的字段清单
    const typeFieldMap = {
        // text: 文本消息
        'text': ['content'],

        // sticker: 表情
        'sticker': ['url', 'meaning'],

        // ai_image: 图片
        'ai_image': ['description'],

        // naiimag: NovelAI生成图片
        'naiimag': ['prompt'],

        // voice_message: 语音
        'voice_message': ['content'],

        // transfer: 转账
        'transfer': ['amount', 'note'],

        // waimai_request: 外卖请求
        'waimai_request': ['productInfo', 'amount'],

        // waimai_response: 外卖响应
        'waimai_response': ['status', 'for_timestamp'],

        // video_call_request: 视频通话请求
        'video_call_request': [],

        // video_call_response: 视频通话响应
        'video_call_response': ['decision'],

        // voice_call_request: 语音通话请求
        'voice_call_request': [],

        // voice_call_response: 语音通话响应
        'voice_call_response': ['decision'],

        // pat_user: 拍一拍用户
        'pat_user': ['suffix'],

        // block_user: 拉黑用户
        'block_user': [],

        // qzone_post: 发布说说/文字图
        'qzone_post': ['postType', 'content', 'publicText', 'hiddenContent'],

        // qzone_comment: 评论动态
        'qzone_comment': ['postId', 'commentText'],

        // qzone_like: 点赞动态
        'qzone_like': ['postId'],

        // friend_request_response: 好友申请响应
        'friend_request_response': ['decision'],

        // change_avatar: 更换头像
        'change_avatar': ['name'],

        // update_remark: 修改备注
        'update_remark': ['new_remark'],

        // share_link: 分享链接
        'share_link': ['title', 'description', 'source_name', 'content'],

        // accept_transfer: 接受转账
        'accept_transfer': ['for_timestamp'],

        // decline_transfer: 拒绝转账
        'decline_transfer': ['for_timestamp'],

        // send_gift: 赠送礼物
        'send_gift': ['giftName', 'giftPrice', 'recipient'],

        // accept_gift: 接受礼物
        'accept_gift': ['for_timestamp'],

        // decline_gift: 拒绝礼物
        'decline_gift': ['for_timestamp'],

        // quote_reply: 引用回复
        'quote_reply': ['target_timestamp', 'reply_content'],

        // location: 位置信息
        'location': ['currentLocation', 'distance', 'targetLocation'],

        // update_status: 更新状态
        'update_status': ['status_text', 'is_busy'],

        // change_music: 切换歌曲
        'change_music': ['song_name'],

        // create_diary: 写日记
        'create_diary': ['content'],

        // create_countdown: 创建约定/倒计时
        'create_countdown': ['title', 'date'],

        // send_and_recall: 发送后立刻撤回
        'send_and_recall': ['content'],

        // update_thoughts: 更新心声和散记
        'update_thoughts': ['heartfelt_voice', 'random_jottings', 'thoughts'],
    };

    // 【第二步】根据type，只提取该type需要的字段
    let requiredFields = typeFieldMap[messageType];

    // 【回退方案】如果type未定义，不直接返回null，而是尝试提取所有常见字段
    if (!requiredFields) {
        console.warn(`[宽松模式] 遇到未知的消息type："${messageType}"，将尝试提取所有可见字段`);
        // 从所有可能的字段中，选择在这个块中存在的字段
        requiredFields = Object.keys(fieldMetadata).filter(field => {
            return blockStr.includes(`"${field}"`);
        });
        // 【新增】如果连常见字段都没找到，至少保留type，不返回null
        if (requiredFields.length === 0) {
            console.warn(`[宽松模式] 未找到任何常见字段，跳过这个空对象块`);
            return null; // 【修复】空对象直接返回null，避免生成空白消息
        }
    }

    // 【专用函数】提取字段值，支持内容中的引号、方括号和转义字符
    const extractFieldValue = (blockStr, fieldName, isArray = false) => {
        if (isArray) {
            // 特殊处理数组类字段（如 thoughts）：支持嵌套括号和特殊字符
            // 【改进】使用更严格的匹配：找到第一个[，然后用括号计数来找到对应的]
            const fieldPattern = `"${fieldName}"\\s*:\\s*`;
            const fieldIndex = blockStr.search(new RegExp(fieldPattern, 'i'));
            if (fieldIndex === -1) return null;

            const valueStart = blockStr.indexOf('[', fieldIndex);
            if (valueStart === -1) return null;

            // 用括号计数来找到匹配的]
            let bracketCount = 0;
            let valueEnd = -1;
            for (let i = valueStart; i < blockStr.length; i++) {
                const char = blockStr[i];
                if (char === '[') bracketCount++;
                else if (char === ']') {
                    bracketCount--;
                    if (bracketCount === 0) {
                        valueEnd = i;
                        break;
                    }
                }
            }

            if (valueEnd === -1) return null;
            return blockStr.substring(valueStart, valueEnd + 1);
        } else {
            // 【增强版】常规字段提取：使用栈式匹配引号，支持任意复杂的转义和嵌套
            const fieldPattern = `"${fieldName}"\\s*:\\s*"`;
            const fieldIndex = blockStr.search(new RegExp(fieldPattern, 'i'));
            if (fieldIndex === -1) return null;

            const valueStartIndex = blockStr.indexOf('"', fieldIndex + fieldName.length + 3);
            if (valueStartIndex === -1) return null;

            // 从引号后的第一个字符开始，用栈式匹配找到对应的结束引号
            let result = '';
            let i = valueStartIndex + 1;
            while (i < blockStr.length) {
                const char = blockStr[i];

                // 检查是否遇到了未转义的引号（结束符）
                if (char === '"') {
                    // 向前数有多少个连续的反斜杠
                    let backslashCount = 0;
                    let j = i - 1;
                    while (j >= valueStartIndex + 1 && blockStr[j] === '\\') {
                        backslashCount++;
                        j--;
                    }

                    // 如果反斜杠数量是偶数（包括0），说明这个引号没被转义
                    if (backslashCount % 2 === 0) {
                        // 找到了结束引号，返回结果
                        return result.replace(/\\"/g, '"').replace(/\\\\/g, '\\');
                    }
                }

                result += char;
                i++;
            }

            // 如果走到这里，说明没找到结束引号，返回null
            return null;
        }
    };

    // 字段提取规则（标记哪些是数值、布尔或数组字段）
    const fieldMetadata = {
        'content': { isArray: false, isNumeric: false, isBoolean: false },
        'message': { isArray: false, isNumeric: false, isBoolean: false },
        'name': { isArray: false, isNumeric: false, isBoolean: false },
        'url': { isArray: false, isNumeric: false, isBoolean: false },
        'meaning': { isArray: false, isNumeric: false, isBoolean: false },
        'heartfelt_voice': { isArray: false, isNumeric: false, isBoolean: false },
        'random_jottings': { isArray: false, isNumeric: false, isBoolean: false },
        'thoughts': { isArray: true, isNumeric: false, isBoolean: false },  // 【特殊】数组字段
        'description': { isArray: false, isNumeric: false, isBoolean: false },
        'amount': { isArray: false, isNumeric: true, isBoolean: false },
        'note': { isArray: false, isNumeric: false, isBoolean: false },
        'for_timestamp': { isArray: false, isNumeric: true, isBoolean: false },
        'productInfo': { isArray: false, isNumeric: false, isBoolean: false },
        'status': { isArray: false, isNumeric: false, isBoolean: false },
        'decision': { isArray: false, isNumeric: false, isBoolean: false },
        'packet_timestamp': { isArray: false, isNumeric: true, isBoolean: false },
        'suffix': { isArray: false, isNumeric: false, isBoolean: false },
        'postType': { isArray: false, isNumeric: false, isBoolean: false },
        'publicText': { isArray: false, isNumeric: false, isBoolean: false },
        'hiddenContent': { isArray: false, isNumeric: false, isBoolean: false },
        'postId': { isArray: false, isNumeric: true, isBoolean: false },
        'commentText': { isArray: false, isNumeric: false, isBoolean: false },
        'new_remark': { isArray: false, isNumeric: false, isBoolean: false },
        'title': { isArray: false, isNumeric: false, isBoolean: false },
        'source_name': { isArray: false, isNumeric: false, isBoolean: false },
        'giftName': { isArray: false, isNumeric: false, isBoolean: false },
        'giftPrice': { isArray: false, isNumeric: true, isBoolean: false },
        'recipient': { isArray: false, isNumeric: false, isBoolean: false },
        'target_timestamp': { isArray: false, isNumeric: true, isBoolean: false },
        'reply_content': { isArray: false, isNumeric: false, isBoolean: false },
        'currentLocation': { isArray: false, isNumeric: false, isBoolean: false },
        'distance': { isArray: false, isNumeric: false, isBoolean: false },
        'targetLocation': { isArray: false, isNumeric: false, isBoolean: false },
        'status_text': { isArray: false, isNumeric: false, isBoolean: false },
        'is_busy': { isArray: false, isNumeric: false, isBoolean: true },
        'song_name': { isArray: false, isNumeric: false, isBoolean: false },
        'date': { isArray: false, isNumeric: false, isBoolean: false },
    };

    // 只提取这个type需要的字段，避免字段重名导致的混乱
    for (const fieldName of requiredFields) {
        const metadata = fieldMetadata[fieldName];
        if (!metadata) continue;

        // 调用专用提取函数，支持转义引号和数组
        const fieldValue = extractFieldValue(blockStr, fieldName, metadata.isArray);
        if (fieldValue === null || fieldValue === undefined) continue;

        // 根据字段类型转换值
        if (metadata.isArray) {
            // 数组字段直接存储字符串，后续由消息处理器解析
            obj[fieldName] = fieldValue;
        } else if (metadata.isBoolean) {
            // 布尔字段
            obj[fieldName] = fieldValue === 'true' || fieldValue === '1' || fieldValue === 'yes';
        } else if (metadata.isNumeric) {
            // 数值字段
            const numVal = parseFloat(fieldValue);
            obj[fieldName] = isNaN(numVal) ? undefined : numVal;
        } else {
            // 字符串字段
            obj[fieldName] = fieldValue;
        }
    }

    // 【修复】如果是text类型消息，但没有content或message字段，说明是空消息，直接返回null
    if (obj.type === 'text' && !obj.content && !obj.message) {
        console.warn(`[宽松模式] text类型消息缺少content/message字段，跳过空白消息`);
        return null;
    }

    return obj;
}

      function renderApiSettings() {  
    try {
        document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; 
        document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 

        // ▼▼▼ 在这里粘贴新增的代码 ▼▼▼
        const modelSelect = document.getElementById('model-select');
        modelSelect.innerHTML = ''; // 先清空旧的选项
        if (state.apiConfig.model) {
            // 如果state中保存了模型，就创建一个option并选中它
            const option = document.createElement('option');
            option.value = state.apiConfig.model;
            option.textContent = state.apiConfig.model;
            option.selected = true;
            modelSelect.appendChild(option);
        }
        // ▲▲▲ 新增代码结束 ▲▲▲

        // 【新增】渲染温度滑块
        const tempSlider = document.getElementById('temperature-slider');
        const tempValueDisplay = document.getElementById('temperature-value');
        const currentTemp = state.apiConfig.temperature || 0.8;
        tempSlider.value = currentTemp;
        tempValueDisplay.textContent = currentTemp.toFixed(1);

        // 温度滑块实时更新显示
        tempSlider.addEventListener('input', () => {
            const newTemp = parseFloat(tempSlider.value);
            tempValueDisplay.textContent = newTemp.toFixed(1);
        });

        // ▼▼▼ 【Minimax TTS】加载minimax配置 ▼▼▼
        document.getElementById('minimax-domain-select').value = state.apiConfig.minimaxDomain || 'https://api.minimax.chat';
        document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
        document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';

        // ★★★ 【修复】先填充选项，再设置值，确保刷新后选项不会消失 ★★★
        const minimaxModelSelect = document.getElementById('minimax-speech-model-select');
        minimaxModelSelect.innerHTML = ''; // 清空现有选项

        // 🔥【扩充】重新填充更多模型选项
        const models = [
            'speech-2.6-hd',
            'speech-2.6-turbo',
            'speech-02-hd',
            'speech-02-turbo',
            'speech-01-hd',
            'speech-01-turbo'
        ];
        models.forEach(modelId => {
            const option = document.createElement('option');
            option.value = modelId;
            option.textContent = modelId;
            minimaxModelSelect.appendChild(option);
        });

        // 然后设置保存的值
        minimaxModelSelect.value = state.apiConfig.minimaxSpeechModel || 'speech-01-turbo';
        // ★★★ 【修复】结束 ★★★

        // ▲▲▲ 【Minimax TTS】加载minimax配置 ▲▲▲

        document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
        document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
        document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
        // ▼▼▼ 新增：读取通知音频URL ▼▼▼
        document.getElementById('notification-sound-url').value = state.globalSettings.notificationSoundUrl || '';
        // ▲▲▲ 新增：读取通知音频URL ▲▲▲

        // ▼▼▼ 新增：页面加载时预加载通知音频 ▼▼▼
        if (state.globalSettings.notificationSoundUrl) {
            const audioUrl = state.globalSettings.notificationSoundUrl.trim();
            if (audioUrl && audioUrl !== notificationAudioCache.url) {
                try {
                    const preloadAudio = new Audio(audioUrl);
                    preloadAudio.preload = 'auto';
                    preloadAudio.volume = 1;
                    notificationAudioCache = {
                        url: audioUrl,
                        audio: preloadAudio
                    };
                    console.log('[页面加载] 通知音频已预加载:', audioUrl);
                } catch (error) {
                    console.warn('[页面加载] 预加载通知音频失败:', error);
                }
            }
        }
        // ▲▲▲ 新增：页面加载时预加载通知音频 ▲▲▲

        if (typeof window.renderApiPresets === 'function') {
            window.renderApiPresets();
        }
    } catch (error) {
        console.error('渲染API设置时出错:', error);
    }
}
        window.renderApiSettingsProxy = renderApiSettings;

// 置顶聊天功能
async function toggleChatPin(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;
    
    chat.isPinned = !chat.isPinned;
    await db.chats.put(chat);
    renderChatList();
}

// ▼▼▼ 请用这个【全新版本】的函数，完整替换掉你旧的 renderChatList ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 获取所有聊天，置顶聊天在前，然后按最新消息时间排序
    const allChats = Object.values(state.chats).sort((a, b) => {
        // 置顶聊天优先显示
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        // 如果都是置顶或都不是置顶，按最新消息时间排序
        return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });
    
    // 2. 获取所有分组
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    // --- 【核心修正开始】---

    // 3. 为每个分组找到其内部最新的消息时间戳
    allGroups.forEach(group => {
        // 从已排序的 allChats 中找到本组的第一个（也就是最新的）聊天
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        // 如果找到了，就用它的时间戳；如果该分组暂时没有聊天或聊天没有历史记录，就用0
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 4. 根据这个最新的时间戳来对“分组本身”进行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // --- 【核心修正结束】---

    // 5. 现在，我们按照排好序的分组来渲染
    allGroups.forEach(group => {
        // 从总列表里过滤出属于这个（已排序）分组的好友
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        // 如果这个分组是空的（可能所有好友都被删了），就跳过
        if (groupChats.length === 0) return;

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');
        // 因为 allChats 本身就是有序的，所以 groupChats 自然也是有序的
        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 6. 最后，渲染所有群聊和未分组的好友
    // 他们的顺序因为 allChats 的初始排序，天然就是正确的
    const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
    ungroupedOrGroupChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 为所有分组标题添加折叠事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });

    // 【新增】更新底部导航"动态"的未读指示器
    updateQzoneBottomNavIndicator();
}

// 【新增】更新底部导航动态按钮的未读数显示
function updateQzoneBottomNavIndicator() {
    const qzoneNavItem = document.querySelector('[data-view="qzone-screen"]');
    if (!qzoneNavItem) return;

    const unreadComments = state.qzoneSettings?.unreadCommentsCount || 0;
    const indicator = qzoneNavItem.querySelector('.unread-indicator');

    // 我们仍然需要读取评论数，但不再直接修改 indicator 的 textContent 和 display
    // 这些将由 updateUnreadIndicator 根据帖子数统一管理

    // if (unreadComments > 0) {
    //     // 显示未读指示器
    //     if (indicator) {
    //         // indicator.textContent = unreadComments > 99 ? '99+' : unreadComments; // <-- 已注释掉
    //         // indicator.style.display = 'inline-flex'; // <-- 已注释掉
    //     }
    // } else {
    //     // 隐藏未读指示器
    //     if (indicator) {
    //         // indicator.style.display = 'none'; // <-- 已注释掉
    //     }
    // }

    // 这里可以保留一些基于评论数的逻辑（如果未来需要），
    // 但关于底部导航栏具体指示器的显示，完全交给 updateUnreadIndicator 函数处理。
}

function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    const formattedTime = formatChatListTimestamp(lastMsgObj.timestamp);
    let lastMsgDisplay;

    // --- ▼▼▼ 【核心修改】在这里加入对关系状态的判断 ▼▼▼ ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
    }
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

// ▼▼▼ 在这里新增 else if ▼▼▼
else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
    lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
}
// ▲▲▲ 新增结束 ▲▲▲
    
    // 【核心修改】优先显示状态，而不是最后一条消息
    if (chat.isGroup) {
        // 群聊逻辑保持不变
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
        // ... (其他群聊消息类型判断) ...
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
        // 【新格式】检查 [表情:xxx] 格式
        else if (typeof lastMsgObj.content === 'string' && lastMsgObj.content.match(/^\[表情:([^\]]+)\]$/)) {
            lastMsgDisplay = `[表情: ${lastMsgObj.content.match(/^\[表情:([^\]]+)\]$/)[1]}]`;
        }
        // 【兼容旧格式】检查 URL 格式的表情
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }

    } else {
        // 单聊逻辑：显示状态
        // 确保 chat.status 对象存在
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
    }

    const item = document.createElement('div');
    item.className = 'chat-list-item' + (chat.isPinned ? ' pinned' : '');
    // 【新增】如果该角色正在后台活动，添加background-active类
    if (state.backgroundActivityChats.has(chat.id)) {
        item.classList.add('background-active');
    }
    item.dataset.chatId = chat.id;
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    // 在 createChatListItem 函数中，用下面这块代码替换旧的 item.innerHTML
item.innerHTML = `
    <span class="time">${formattedTime}</span>
    <img src="${avatar || defaultAvatar}" class="avatar">
    <div class="info">
        <div class="name-line">
            <span class="name">${!chat.isGroup && chat.remark ? chat.remark : chat.name}</span>
            ${chat.isGroup ? `<span class="group-tag">${chat.isSpectator ? '旁观群聊' : '群聊'}</span>` : ''}
        </div>
        <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; ">${lastMsgDisplay}</div>
    </div>
    <div class="unread-count-wrapper">
        <span class="unread-count" style="display: none;">0</span>
    </div>
    <div class="swipe-actions">
        <button class="pin-btn">${chat.isPinned ? '取消置顶' : '置顶'}</button>
    </div>
`;
    
    // 【核心修改2】在这里添加控制红点显示/隐藏的逻辑
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = item.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        // 注意这里是 'inline-flex'，与我们的CSS对应，使其垂直居中
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    const avatarEl = item.querySelector('.avatar');
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            const patDisplayName = !chat.isGroup && chat.remark ? chat.remark : chat.name;
            handleUserPat(chat.id, patDisplayName);
        });
    }
    
    const infoEl = item.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }

    addLongPressListener(item, async (e) => {
        const displayName = !chat.isGroup && chat.remark ? chat.remark : chat.name;
        const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${displayName}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
            delete state.chats[chat.id];
            if (state.activeChatId === chat.id) state.activeChatId = null;
            await db.chats.delete(chat.id);
            renderChatList();
        }
    });

    // 添加左滑手势检测
    let startX, currentX, isDragging = false;
    let swipeTimeout = null;

    function handleTouchStart(e) {
        startX = e.touches[0].clientX;
        isDragging = false;
        currentX = startX;
    }

    function handleTouchMove(e) {
        if (startX === null) return;
        currentX = e.touches[0].clientX;
        const diffX = startX - currentX;
        
        if (Math.abs(diffX) > 5) {
            e.preventDefault(); // 阻止其他事件
        }
        
        if (diffX > 20 && !isDragging) {
            isDragging = true;
            item.classList.add('swiped');
            
            // 设置自动隐藏定时器
            if (swipeTimeout) clearTimeout(swipeTimeout);
            swipeTimeout = setTimeout(() => {
                item.classList.remove('swiped');
            }, 3000);
        } else if (diffX < -10 && isDragging) {
            item.classList.remove('swiped');
            if (swipeTimeout) clearTimeout(swipeTimeout);
            isDragging = false;
        }
    }

    function handleTouchEnd(e) {
        startX = null;
        isDragging = false;
    }

    item.addEventListener('touchstart', handleTouchStart, { passive: false });
    item.addEventListener('touchmove', handleTouchMove, { passive: false });
    item.addEventListener('touchend', handleTouchEnd, { passive: true });

    // 鼠标事件支持（桌面端调试）
    item.addEventListener('mousedown', (e) => {
        startX = e.clientX;
        isDragging = false;
        currentX = startX;
    });

    item.addEventListener('mousemove', (e) => {
        if (startX === null) return;
        currentX = e.clientX;
        const diffX = startX - currentX;
        
        if (diffX > 30 && !isDragging) {
            isDragging = true;
            item.classList.add('swiped');
            
            if (swipeTimeout) clearTimeout(swipeTimeout);
            swipeTimeout = setTimeout(() => {
                item.classList.remove('swiped');
            }, 3000);
        } else if (diffX < -10 && isDragging) {
            item.classList.remove('swiped');
            if (swipeTimeout) clearTimeout(swipeTimeout);
            isDragging = false;
        }
    });

    item.addEventListener('mouseup', () => {
        startX = null;
        isDragging = false;
    });

    item.addEventListener('mouseleave', () => {
        startX = null;
        isDragging = false;
    });

    // 置顶按钮点击事件
    const pinBtn = item.querySelector('.pin-btn');
    pinBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await toggleChatPin(chat.id);
        item.classList.remove('swiped');
        if (swipeTimeout) clearTimeout(swipeTimeout);
    });

    return item;
}


// ▼▼▼ 【最终修正版】用这个版本替换 renderChatInterface 函数 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();

    // 【新增】更新返回按钮的未读指示器
    updateBackBtnQzoneIndicator();
    
    // 恢复线上/线下模式状态（按聊天分别记忆）
    if (!chat.isGroup) {
        const savedModes = JSON.parse(localStorage.getItem('chatOfflineModes') || '{}');
        // 恢复当前聊天的独立状态，如果没有记录则默认为线上模式
        if (savedModes.hasOwnProperty(chatId)) {
            const savedMode = savedModes[chatId];
            // 支持旧格式（布尔值）和新格式（对象）
            if (typeof savedMode === 'boolean') {
                offlineMode.isOffline = savedMode;
                offlineMode.isMonitorMode = false;
            } else {
                offlineMode.isOffline = savedMode.isOffline || false;
                offlineMode.isMonitorMode = savedMode.isMonitorMode || false;
            }
        } else {
            offlineMode.isOffline = false;
            offlineMode.isMonitorMode = false;
        }
        updateModeUI();
    } else {
        // 群聊强制设置为线上模式
        offlineMode.isOffline = false;
        offlineMode.isMonitorMode = false;
        updateModeUI();
    }
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    if (chatInputArea) {
        chatInputArea.style.display = 'flex';
    }

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

    // 【修复2】在renderChatInterface中保护"正在输入中..."的状态
    const chatHeaderTitle = document.getElementById('chat-header-title');
    if (!chat.isAwaitingReply) {
        // 【修改】如果有用户备注就显示备注，否则显示原来的名字
        chatHeaderTitle.textContent = chat.remark || chat.name;
        chatHeaderTitle.classList.remove('typing-status');
    }
    // 如果正在输入中，则保持当前标题不变

    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
    statusContainer.style.display = 'none';
    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
} else {
    statusContainer.style.display = 'flex';
    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
    updateChatHeaderStatus(); // 直接调用我们的新工具
}
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    
                    
                    <div class="lock-actions-row">
                        <button id="unblock-btn" class="lock-action-btn" style="flex-grow: 1;">解除拉黑</button>
                        <button id="force-apply-check-btn" class="lock-action-btn secondary" style="flex-grow: 1;">强制触发检测</button>
                        
                        <button id="toggle-dev-panel-btn" title="显示/隐藏开发者诊断面板">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 5V19M5 12H19" />
                        </svg>
                    </button>
                    </div>

                    <div id="developer-diagnostic-panel" style="display: none; margin-top: 15px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                `;
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
<span class="lock-text">“${chat.name}”请求添加你为好友：<br>“${chat.relationship.applicationReason}”</span>             
       <div class="lock-actions-container">
            
            <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
            <button id="accept-friend-btn" class="lock-action-btn">接受</button>
        </div>
                `;
                break;

            // 【核心修正】修复当你申请后，你看到的界面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';

    const chatScreen = document.getElementById('chat-interface-screen');
    const backgroundImage = chat.settings.background || state.globalSettings.chatBackground;
    chatScreen.style.backgroundImage = backgroundImage ? `url(${backgroundImage})` : 'none';

    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    chatScreen.style.backgroundColor = backgroundImage ? 'transparent' : (isDarkMode ? '#000000' : '#F7F7F7');
    
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);

    const startIndex = Math.max(0, history.length - initialMessages.length);
    let lastMessageTimestamp = (startIndex > 0) ? history[startIndex - 1].timestamp : 0;

    let pastMessageCounter = 0;

    // ▼▼▼ 唯一的修改就在下面这个循环里 ▼▼▼
    initialMessages.forEach((msg, index) => { // 获取当前消息的索引 index
        let justAddedDivider = false;

        if (!isSameDay(lastMessageTimestamp, msg.timestamp)) {
            const dividerText = formatDateDivider(msg.timestamp);
            if (dividerText !== 'TODAY') {
                const divider = document.createElement('div');
                divider.className = 'date-divider';
                divider.textContent = dividerText;
                messagesContainer.appendChild(divider);
                justAddedDivider = true;
            }
        }

        const isToday = isSameDay(msg.timestamp, Date.now());
        if (!isToday) {
            pastMessageCounter++;
            // 【核心修正】在这里增加一个判断，确保不是最后一条消息
            if (pastMessageCounter % 10 === 0 && !justAddedDivider && (index < initialMessages.length - 1)) {
                const dividerText = formatDateDivider(msg.timestamp);
                const divider = document.createElement('div');
                divider.className = 'date-divider';
                divider.textContent = dividerText;
                messagesContainer.appendChild(divider);
            }
        }
        
        appendMessage(msg, chat, true);
        lastMessageTimestamp = msg.timestamp;
    });
    // ▲▲▲ 修改结束 ▲▲▲

    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }
/**
 * 【V6 强力定位锚修复版】加载更早的聊天记录
 */
function loadMoreMessages() {
    try {
        const messagesContainer = document.getElementById('chat-messages');
        const chat = state.chats[state.activeChatId];
        if (!chat) return;

        const loadMoreBtn = document.getElementById('load-more-btn');
        if (loadMoreBtn) loadMoreBtn.remove();

        // 【核心修复1】在进行任何DOM操作前，先记录下旧的高度
        const oldScrollHeight = messagesContainer.scrollHeight;

        const totalMessages = chat.history.length;
        const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW;
        const nextSliceEnd = totalMessages - currentRenderedCount;
        const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);
        
        if (messagesToPrepend.length === 0) return;
        
        const fragment = document.createDocumentFragment();
        const firstVisibleMsgBeforeLoad = messagesContainer.querySelector('.message-wrapper');
        const firstVisibleTimestamp = firstVisibleMsgBeforeLoad ? parseInt(firstVisibleMsgBeforeLoad.dataset.timestamp) : 0;
        const lastTimestampOfNewChunk = messagesToPrepend.length > 0 ? messagesToPrepend[messagesToPrepend.length - 1].timestamp : 0;

        for (let i = messagesToPrepend.length - 1; i >= 0; i--) {
            const msg = messagesToPrepend[i];
            const prevMsg = (i > 0) ? messagesToPrepend[i-1] : null;
            const messageEl = createMessageElement(msg, chat);
            if (messageEl) {
                fragment.prepend(messageEl);
            }
            const prevTimestamp = prevMsg ? prevMsg.timestamp : 0;
            if (!isSameDay(prevTimestamp, msg.timestamp)) {
                const dividerText = formatDateDivider(msg.timestamp);
                if (dividerText !== 'TODAY') {
                    const divider = document.createElement('div');
                    divider.className = 'date-divider';
                    divider.textContent = dividerText;
                    fragment.prepend(divider);
                }
            }
        }
        
        messagesContainer.prepend(fragment);
        
        if (firstVisibleTimestamp && !isSameDay(lastTimestampOfNewChunk, firstVisibleTimestamp)) {
             const dividerText = formatDateDivider(firstVisibleTimestamp);
             if (dividerText !== 'TODAY') {
                const divider = document.createElement('div');
                divider.className = 'date-divider';
                divider.textContent = dividerText;
                messagesContainer.insertBefore(divider, firstVisibleMsgBeforeLoad);
            }
        }

        currentRenderedCount += messagesToPrepend.length;

        // 【核心修复2】计算出新内容的高度，并立刻设置一次滚动位置
        const newScrollHeight = messagesContainer.scrollHeight;
        const addedHeight = newScrollHeight - oldScrollHeight;
        messagesContainer.scrollTop = addedHeight;

        // 【核心修复3】启动“强力定位锚”，在接下来的200毫秒内，反复强制定位
        let anchorCounter = 0;
        const anchorInterval = setInterval(() => {
            // 持续将scrollTop设置为我们计算出的正确值
            messagesContainer.scrollTop = addedHeight;
            anchorCounter++;
            // 尝试10次后（约200毫秒）自动停止，以防万一
            if (anchorCounter >= 10) {
                clearInterval(anchorInterval);
            }
        }, 20);
        // 200毫秒后，无论如何都清除定时器
        setTimeout(() => clearInterval(anchorInterval), 200);

        if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
        }
    } catch (error) {
        console.error("加载更多消息时出错:", error);
    }
}

// ▼▼▼ 用这个【新版本】替换旧的 renderWallpaperScreen 函数 ▼▼▼
function renderWallpaperScreen() { 
    // 处理壁纸预览
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '当前为渐变色'; 
    }
    
    // 处理聊天背景预览
    const chatBgPreview = document.getElementById('chat-background-preview'); 
    const chatBg = newChatBackgroundBase64 || state.globalSettings.chatBackground; 
    if (chatBg && chatBg.startsWith('data:image')) { 
        chatBgPreview.style.backgroundImage = `url(${chatBg})`; 
        chatBgPreview.textContent = ''; 
    } else if(chatBg) { 
        chatBgPreview.style.backgroundImage = chatBg; 
        chatBgPreview.textContent = '当前聊天背景'; 
    } else {
        chatBgPreview.style.backgroundImage = 'none'; 
        chatBgPreview.textContent = '点击下方上传'; 
    }
    
    // 【核心修改】在这里调用图标渲染函数
    renderIconSettings();
    const paddingTopInput = document.getElementById('chat-list-padding-top-input');
if (paddingTopInput) {
    paddingTopInput.value = state.globalSettings.chatListPaddingTop || 72;
}

    // ▼▼▼ 等待回复按钮样式初始化 ▼▼▼
    const waitReplyBtnInput = document.getElementById('wait-reply-btn-custom-input');
    if (waitReplyBtnInput) {
        waitReplyBtnInput.value = state.globalSettings.waitReplyBtnCustom || localStorage.getItem('waitReplyBtnCustom') || '';
    }
    // ▲▲▲ 等待回复按钮样式初始化结束 ▲▲▲

    // ▼▼▼ 加载动画 URL 初始化 ▼▼▼
    const loadingAnimationInput = document.getElementById('loading-animation-url-input');
    if (loadingAnimationInput) {
        loadingAnimationInput.value = state.globalSettings.loadingAnimationUrl || 'https://iili.io/KlDHDmX.png';
    }
    // ▲▲▲ 加载动画 URL 初始化结束 ▲▲▲
}
// ▲▲▲ 替换结束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() {
            const homeScreen = document.getElementById('home-screen');
            const homePages = document.querySelectorAll('.home-page');
            const wallpaper = state.globalSettings.wallpaper;

            // 给主屏幕容器应用背景
            if (wallpaper && wallpaper.startsWith('data:image')) {
                homeScreen.style.backgroundImage = `url(${wallpaper})`;
                // 也给每个页面应用背景
                homePages.forEach(page => {
                    page.style.backgroundImage = `url(${wallpaper})`;
                });
            } else if (wallpaper) {
                homeScreen.style.backgroundImage = wallpaper;
                // 也给每个页面应用背景
                homePages.forEach(page => {
                    page.style.backgroundImage = wallpaper;
                });
            }
        }
        
        // 应用全局聊天背景（如果当前正在查看聊天）
        function applyGlobalChatBackground() { 
            // 如果当前正在查看聊天，重新渲染以应用新背景
            if (state.activeChatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
                renderChat(state.activeChatId);
            }
        }
/**
 * 【全新】应用聊天列表的顶部内边距
 */
function applyChatListPaddingTop() {
    const chatList = document.getElementById('chat-list');
    // 从全局设置中读取值，如果不存在则使用默认值72
    const paddingTop = state.globalSettings.chatListPaddingTop || 72;
    if (chatList) {
        chatList.style.paddingTop = `${paddingTop}px`;
    }
}

// ▼▼▼ 应用等待回复按钮自定义样式 ▼▼▼
function applyWaitReplyBtnStyle() {
    const waitReplyBtn = document.getElementById('wait-reply-btn');
    if (!waitReplyBtn) return;

    // 优先从 state 读取，如果没有就从 localStorage 读取
    const customStyle = state.globalSettings.waitReplyBtnCustom || localStorage.getItem('waitReplyBtnCustom');

    if (!customStyle) return; // 如果没有自定义样式，就保持默认

    const trimmed = customStyle.trim();

    // 判断是 SVG 还是 URL
    if (trimmed.startsWith('<svg')) {
        // 是 SVG 代码，直接插入到按钮里
        waitReplyBtn.innerHTML = trimmed;
        // 给 svg 加上样式，让它占满按钮
        const svg = waitReplyBtn.querySelector('svg');
        if (svg) {
            svg.style.width = '35px';
            svg.style.height = '35px';
            svg.style.display = 'block';
        }
    } else if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
        // 是图片 URL
        waitReplyBtn.innerHTML = `<img src="${trimmed}" alt="等待回复" style="height: 35px;">`;
    }
}
// ▲▲▲ 应用等待回复按钮自定义样式结束 ▲▲▲

async function renderWorldBookScreen() {
    const listEl = document.getElementById('world-book-list');
    listEl.innerHTML = '';

    const [books, categories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books;

    if (books.length === 0) {
        listEl.innerHTML = `
            <div class="glass-container empty-state">
                <div class="glass-content">
                    <p style="text-align:center; color: #8a8a8a; margin: 30px 0;">点击右上角 "+" 创建你的第一本世界书</p>
                </div>
            </div>
        `;
        return;
    }

    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) acc[key] = [];
        acc[key].push(book);
        return acc;
    }, {});

    // 将分类分为"设定集"和"普通分类"
    const settingCategories = categories.filter(cat => cat.name.includes('的设定集'));
    const normalCategories = categories.filter(cat => !cat.name.includes('的设定集'));

    // 封装一个通用的渲染和绑定函数，避免代码重复
    const renderAndBindGroup = (name, bookList, id, isSettingCollection = false) => {
        const groupContainer = createWorldBookGroup(name, bookList, id, isSettingCollection);
        listEl.appendChild(groupContainer);

        // 为分类标题添加长按删除事件
        const header = groupContainer.querySelector('.world-book-group-header');
        addLongPressListener(header, async () => {
            const categoryId = header.dataset.categoryId;
            const categoryName = header.dataset.categoryName;

            const confirmed = await showCustomConfirm(
                '删除确认',
                `确定要删除分类 "${categoryName}" 以及该分类下的所有条目吗？此操作不可撤销。`,
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
                    if (categoryId === 'uncategorized') {
                        // 删除所有未分类的书籍
                        await db.worldBooks.where('categoryId').equals(null).delete();
                    } else {
                        const numericId = parseInt(categoryId);
                        // 删除分类下的所有书籍
                        await db.worldBooks.where({ categoryId: numericId }).delete();
                        // 删除分类本身
                        await db.worldBookCategories.delete(numericId);
                    }
                });
                await renderWorldBookScreen(); // 重新渲染整个列表
            }
        });
    };

    // 先渲染"设定集"（一级分类）
    if (settingCategories.length > 0) {
        // 创建"设定集"一级分类容器
        const settingCollectionContainer = createSettingCollectionGroup(settingCategories, groupedBooks);
        listEl.appendChild(settingCollectionContainer);

        // 为"设定集"标题添加长按删除事件（可选，看需求）
        const settingHeader = settingCollectionContainer.querySelector('.world-book-group-header');
        if (settingHeader) {
            addLongPressListener(settingHeader, async () => {
                // "设定集"本身不可删除，只能删除其内部的二级分类
            });
        }
    }

    // 再渲染"普通分类"（二级分类）
    normalCategories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            renderAndBindGroup(category.name, booksInCategory, category.id, false);
        }
    });

    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        renderAndBindGroup('未分类', uncategorizedBooks, 'uncategorized', false);
    }

    // 点击处理：支持整个气泡都可点击
    document.querySelectorAll('.world-book-group-container').forEach(container => {
        const headerWrapper = container.querySelector('.setting-collection-header-wrapper');
        const header = container.querySelector('.world-book-group-header');
        const contentEl = container.querySelector('.world-book-group-content');

        // 如果是"设定集"一级分类，绑定到wrapper上
        if (headerWrapper) {
            headerWrapper.addEventListener('click', (e) => {
                if (e.detail === 0) return;
                header.classList.toggle('collapsed');
                contentEl.classList.toggle('collapsed');
            });
        }
        // 否则绑定到header上（普通分类）
        else if (header) {
            header.addEventListener('click', (e) => {
                if (e.detail === 0) return;
                header.classList.toggle('collapsed');
                contentEl.classList.toggle('collapsed');
            });
        }
    });
}

/**
 * 【辅助函数】创建一个分类的分组DOM
 * @param {string} groupName - 分类名称
 * @param {Array} books - 该分类下的书籍数组
 * @param {number|string} categoryId - 分类ID
 * @param {boolean} isSettingCollection - 是否为设定集内的分类（默认false）
 * @returns {HTMLElement} - 创建好的分组容器
 */
function createWorldBookGroup(groupName, books, categoryId, isSettingCollection = false) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="glass-container category-header">
            <div class="world-book-group-header" data-category-id="${categoryId}" data-category-name="${groupName}">
                <span class="arrow">▼</span>
                <span class="group-name">${groupName}</span>
            </div>
        </div>
        <div class="world-book-group-content">
            <div class="glass-container content-list">
                <div class="glass-content"></div>
            </div>
        </div>
    `;

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    const glassContent = groupContainer.querySelector('.glass-content');
    
    // 默认给头部和内容区都加上 collapsed 类
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');
    // ▲▲▲ 添加结束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`;

        // 【全新】绑定点击与长按事件
        item.addEventListener('click', () => {
            if (isWbSelectionMode) {
                toggleWbSelection(book.id); // 多选模式下：切换选中
            } else {
                openWorldBookEditor(book.id); // 普通模式下：打开编辑器
            }
        });
        addLongPressListener(item, (e) => {
            if (!isWbSelectionMode) {
                e.preventDefault(); // 阻止桌面端右键菜单
                enterWbSelectionMode(book.id); // 长按进入多选模式
            }
        });

        glassContent.appendChild(item); 
    });

    return groupContainer;
}

/**
 * 【新增函数】创建"设定集"一级分类容器
 * @param {Array} settingCategories - 包含"的设定集"的分类数组
 * @param {Object} groupedBooks - 按categoryId分组的书籍对象
 * @returns {HTMLElement} - 创建好的"设定集"容器
 */
function createSettingCollectionGroup(settingCategories, groupedBooks) {
    const containerDiv = document.createElement('div');
    containerDiv.className = 'world-book-group-container setting-collection-level-1';

    // 创建一级分类标题：固定为"设定集"（使用淡灰色背景和边框，无箭头，居中）
    containerDiv.innerHTML = `
        <div class="setting-collection-header-wrapper">
            <div class="world-book-group-header setting-collection-header" data-category-id="setting-collection" data-category-name="设定集">
                <span class="group-name">设定集</span>
            </div>
        </div>
        <div class="world-book-group-content setting-collection-content">
            <div class="glass-content"></div>
        </div>
    `;

    const headerEl = containerDiv.querySelector('.world-book-group-header');
    const contentEl = containerDiv.querySelector('.world-book-group-content');
    const glassContent = containerDiv.querySelector('.glass-content');

    // 默认折叠
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');

    // 渲染每个"设定集"下的二级分类
    settingCategories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            // 为每个二级分类创建一个子分组
            const subGroupDiv = document.createElement('div');
            subGroupDiv.className = 'world-book-subgroup-container';

            subGroupDiv.innerHTML = `
                <div class="glass-container category-header">
                    <div class="world-book-subgroup-header" data-category-id="${category.id}" data-category-name="${category.name}">
                        <span class="arrow">▼</span>
                        <span class="group-name">${category.name}</span>
                    </div>
                </div>
                <div class="world-book-subgroup-content">
                    <div class="glass-container content-list">
                        <div class="glass-content"></div>
                    </div>
                </div>
            `;

            const subHeader = subGroupDiv.querySelector('.world-book-subgroup-header');
            const subContent = subGroupDiv.querySelector('.world-book-subgroup-content');
            const subGlassContent = subGroupDiv.querySelector('.glass-content');

            // 二级分类默认折叠
            subHeader.classList.add('collapsed');
            subContent.classList.add('collapsed');

            // 渲染二级分类下的世界书条目
            const sortedBooks = [...booksInCategory].sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
            sortedBooks.forEach(book => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.dataset.bookId = book.id;
                item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`;

                // 绑定点击与长按事件
                item.addEventListener('click', () => {
                    if (isWbSelectionMode) {
                        toggleWbSelection(book.id);
                    } else {
                        openWorldBookEditor(book.id);
                    }
                });
                addLongPressListener(item, (e) => {
                    if (!isWbSelectionMode) {
                        e.preventDefault();
                        enterWbSelectionMode(book.id);
                    }
                });

                subGlassContent.appendChild(item);
            });

            // 二级分类标题的折叠展开事件
            subHeader.addEventListener('click', (e) => {
                if (e.detail === 0) return;

                subHeader.classList.toggle('collapsed');
                subContent.classList.toggle('collapsed');
            });

            // 二级分类标题的长按删除事件
            addLongPressListener(subHeader, async () => {
                const categoryId = subHeader.dataset.categoryId;
                const categoryName = subHeader.dataset.categoryName;

                const confirmed = await showCustomConfirm(
                    '删除确认',
                    `确定要删除分类 "${categoryName}" 以及该分类下的所有条目吗？此操作不可撤销。`,
                    { confirmButtonClass: 'btn-danger' }
                );

                if (confirmed) {
                    await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
                        const numericId = parseInt(categoryId);
                        await db.worldBooks.where({ categoryId: numericId }).delete();
                        await db.worldBookCategories.delete(numericId);
                    });
                    await renderWorldBookScreen();
                }
            });

            glassContent.appendChild(subGroupDiv);
        }
    });

    return containerDiv;
}

        window.renderWorldBookScreenProxy = renderWorldBookScreen;

// ▼▼▼ 统一世界书管理功能 ▼▼▼

// 当前编辑的世界书ID（用于编辑现有书籍）
let currentEditingBookId = null;

// 显示统一管理模态框
function showUnifiedWorldBookModal(mode = 'main', bookId = null) {
    currentEditingBookId = bookId;
    const modal = document.getElementById('world-book-unified-modal');
    modal.classList.add('visible');
    
    if (mode === 'edit' && bookId) {
        // 编辑模式：直接跳转到创建书籍页面，但填入现有数据
        showUnifiedView('create-book');
        loadBookDataForEdit(bookId);
        document.getElementById('unified-modal-title').textContent = '编辑世界书';
    } else {
        // 默认显示主菜单
        showUnifiedView('main-menu');
        document.getElementById('unified-modal-title').textContent = '世界书管理';
    }
}

// 切换统一管理界面视图
function showUnifiedView(viewName) {
    // 隐藏所有视图
    document.querySelectorAll('.unified-view').forEach(view => {
        view.style.display = 'none';
    });
    
    // 显示目标视图
    const targetView = document.getElementById(`unified-${viewName}`);
    if (targetView) {
        targetView.style.display = 'flex';
    }
    
    // 根据视图更新标题和底部按钮显示
    const titleEl = document.getElementById('unified-modal-title');
    const doneBtn = document.getElementById('unified-modal-done');
    switch (viewName) {
        case 'main-menu':
            titleEl.textContent = '世界书管理';
            doneBtn.style.display = 'none';
            break;
        case 'create-book':
            titleEl.textContent = currentEditingBookId ? '编辑世界书' : '创建世界书';
            doneBtn.style.display = 'block';
            break;
        case 'manage-categories':
            titleEl.textContent = '管理分类';
            doneBtn.style.display = 'none';
            renderUnifiedCategoriesList();
            break;
    }
    
    // 根据视图加载数据
    if (viewName === 'create-book') {
        loadUnifiedCategoryOptions();
    }
}

// 加载分类选项到下拉框
async function loadUnifiedCategoryOptions() {
    const selectEl = document.getElementById('unified-book-category');
    const categories = await db.worldBookCategories.toArray();
    
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>';
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        selectEl.appendChild(option);
    });
}

// 加载书籍数据用于编辑
async function loadBookDataForEdit(bookId) {
    const book = await db.worldBooks.get(bookId);
    if (book) {
        document.getElementById('unified-book-name').value = book.name;
        document.getElementById('unified-book-content').value = book.content || '';
        
        // 等待分类选项加载完成后设置选中值
        await loadUnifiedCategoryOptions();
        if (book.categoryId) {
            document.getElementById('unified-book-category').value = book.categoryId;
        }
    }
}

// 保存世界书（创建或编辑）
async function saveUnifiedBook() {
    const name = document.getElementById('unified-book-name').value.trim();
    const content = document.getElementById('unified-book-content').value;
    const categoryId = document.getElementById('unified-book-category').value;
    
    if (!name) {
        alert('书名不能为空！');
        return;
    }
    
    if (currentEditingBookId) {
        // 编辑现有书籍
        const book = await db.worldBooks.get(currentEditingBookId);
        if (book) {
            book.name = name;
            book.content = content;
            book.categoryId = categoryId ? parseInt(categoryId) : null;
            await db.worldBooks.put(book);
            
            // 更新内存中的状态
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if (bookInState) {
                bookInState.name = name;
                bookInState.content = content;
                bookInState.categoryId = book.categoryId;
            }
        }
    } else {
        // 创建新书籍
        const newBook = {
            id: 'wb_' + Date.now(),
            name: name,
            content: content,
            categoryId: categoryId ? parseInt(categoryId) : null
        };
        await db.worldBooks.add(newBook);
        state.worldBooks.push(newBook);
    }
    
    // 清空表单
    document.getElementById('unified-book-name').value = '';
    document.getElementById('unified-book-content').value = '';
    document.getElementById('unified-book-category').value = '';
    
    // 刷新主列表
    renderWorldBookScreen();
    
    // 回到主菜单或关闭模态框
    if (currentEditingBookId) {
        closeUnifiedModal();
    } else {
        showUnifiedView('main-menu');
    }
    
    currentEditingBookId = null;
}

// 渲染统一界面的分类列表
async function renderUnifiedCategoriesList() {
    const listEl = document.getElementById('unified-categories-list');
    const categories = await db.worldBookCategories.toArray();
    
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">还没有任何分类</p>';
        return;
    }
    
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'category-item-row';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <button class="preset-item-edit-btn category-edit-btn" data-id="${cat.id}" title="编辑分类名称">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/>
                    <path d="M20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                </svg>
            </button>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// 添加新分类
async function addUnifiedCategory() {
    const input = document.getElementById('unified-new-category-name');
    const name = input.value.trim();
    
    if (!name) {
        alert('分类名称不能为空！');
        return;
    }
    
    const newCategory = { name: name };
    await db.worldBookCategories.add(newCategory);
    input.value = '';
    renderUnifiedCategoriesList();
}

// 编辑分类名称
function handleCategoryEdit(categoryId, currentName, categoryRow, editBtn) {
    const groupName = categoryRow.querySelector('.group-name');
    const isEditing = groupName.querySelector('input') !== null;

    if (!isEditing) {
        // 进入编辑模式
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentName;
        input.style.cssText = `
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #999;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            outline: none;
            margin-right: 8px;
            background-color: #f5f5f5;
        `;

        // 保存原始HTML和按钮原始样式
        const originalGroupNameHTML = groupName.innerHTML;
        const originalBgColor = window.getComputedStyle(editBtn).backgroundColor;

        // 替换分类名称为输入框
        groupName.innerHTML = '';
        groupName.appendChild(input);

        // 自动获焦并全选
        input.focus();
        input.select();

        // 更改按钮样式表示处于编辑模式 - 使用深灰色
        editBtn.style.backgroundColor = '#555555';
        editBtn.title = '完成编辑';

        // Escape键取消编辑
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                cancelEdit();
            }
        };
        input.addEventListener('keydown', handleEscape);

        // 取消编辑函数
        const cancelEdit = () => {
            groupName.innerHTML = originalGroupNameHTML;
            editBtn.style.backgroundColor = originalBgColor;
            editBtn.title = '编辑分类名称';
            input.removeEventListener('keydown', handleEscape);
        };

        // 标记状态：用来区分是编辑模式还是保存模式
        groupName.dataset.editingCategoryId = categoryId;
        groupName.dataset.originalName = currentName;
        groupName.dataset.originalHTML = originalGroupNameHTML;
        groupName.dataset.originalBgColor = originalBgColor;

    } else {
        // 保存编辑模式
        const input = groupName.querySelector('input');
        const newName = input.value.trim();
        const originalName = groupName.dataset.originalName;
        const originalHTML = groupName.dataset.originalHTML;
        const originalBgColor = groupName.dataset.originalBgColor;

        if (!newName) {
            showToast('分类名称不能为空');
            input.focus();
            return;
        }

        if (newName === originalName) {
            // 名称未改变，直接还原
            groupName.innerHTML = originalHTML;
            editBtn.style.backgroundColor = originalBgColor;
            editBtn.title = '编辑分类名称';
            delete groupName.dataset.editingCategoryId;
            delete groupName.dataset.originalName;
            delete groupName.dataset.originalHTML;
            delete groupName.dataset.originalBgColor;
            return;
        }

        // 禁用编辑按钮，显示保存中
        editBtn.style.opacity = '0.5';
        editBtn.style.cursor = 'not-allowed';
        editBtn.disabled = true;

        // 保存到数据库
        (async () => {
            try {
                await db.worldBookCategories.update(categoryId, { name: newName });

                // 先在UI上显示新名称
                groupName.innerHTML = newName;

                // 重新渲染世界书主页面（用于自动分类）
                await renderWorldBookScreen();

                showToast('分类名称已更新');

                // 恢复编辑状态
                editBtn.style.backgroundColor = originalBgColor;
                editBtn.title = '编辑分类名称';
                editBtn.style.opacity = '1';
                editBtn.style.cursor = 'pointer';
                editBtn.disabled = false;
                delete groupName.dataset.editingCategoryId;
                delete groupName.dataset.originalName;
                delete groupName.dataset.originalHTML;
                delete groupName.dataset.originalBgColor;
            } catch (error) {
                console.error('编辑分类名称失败:', error);
                showToast('编辑分类名称失败');
                // 恢复到原始名称和编辑状态
                groupName.innerHTML = originalHTML;
                editBtn.style.backgroundColor = '#555555';
                editBtn.title = '完成编辑';
                editBtn.style.opacity = '1';
                editBtn.style.cursor = 'pointer';
                editBtn.disabled = false;
            }
        })();
    }
}

// 删除分类
async function deleteUnifiedCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为"未分类"。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        renderUnifiedCategoriesList();
        // 刷新世界书主界面以反映分类变更
        if (typeof renderWorldBookScreen === 'function') {
            renderWorldBookScreen();
        }
    }
}

// 关闭统一模态框
function closeUnifiedModal() {
    document.getElementById('world-book-unified-modal').classList.remove('visible');
    currentEditingBookId = null;
}

// ▲▲▲ 统一世界书管理功能结束 ▲▲▲

async function openWorldBookEditor(bookId) {
    // 使用新的统一模态框进行编辑
    showUnifiedWorldBookModal('edit', bookId);
}

// ▼▼▼ 【结构修正版】的 renderStickerPanel 函数 v3.0 ▼▼▼
function renderStickerPanel() {
    const grid = document.getElementById('sticker-grid');
    grid.innerHTML = '';

    // 【新增】添加骰子表情到第一个位置
    const diceItem = document.createElement('div');
    diceItem.className = 'sticker-item dice-sticker';
    diceItem.title = '骰子';
    diceItem.dataset.stickerId = 'dice-special';

    const diceInner = document.createElement('div');
    diceInner.className = 'sticker-image-inner';
    diceInner.style.background = 'transparent';
    diceInner.innerHTML = `
        <svg viewBox="0 0 100 100" style="width: 100%; height: 100%;">
            <rect x="15" y="15" width="70" height="70" rx="8" fill="#ffffff" stroke="#333" stroke-width="2"/>
            <circle cx="35" cy="35" r="5" fill="#333"/>
            <circle cx="50" cy="50" r="5" fill="#333"/>
            <circle cx="65" cy="65" r="5" fill="#333"/>
        </svg>
    `;

    diceItem.appendChild(diceInner);
    diceItem.addEventListener('click', (e) => {
        e.stopPropagation();
        sendDice();
    });

    grid.appendChild(diceItem);

    if (state.userStickers.length === 0) {
        // 如果没有其他表情,不显示提示文字(因为已经有骰子了)
        return;
    }

    state.userStickers.forEach(sticker => {
        // 1. 创建外层容器 (item)，它负责边框、事件和作为选中目标
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = sticker.name;
        item.dataset.stickerId = sticker.id;

        // 2. 【核心修改】创建一个内层div，专门用来显示背景图片
        const innerImage = document.createElement('div');
        innerImage.className = 'sticker-image-inner';

        // 【修复】缓存 Blob URL，避免每次都重新创建（这是导致重新加载的原因！）
        let displayUrl = sticker.url;  // 默认用原始 URL

        // 【【【程煜修改】】】检查 blobData 是不是一个真的 Blob
        if (sticker.blobData instanceof Blob && !sticker._blobUrl) {
            // 只在第一次时创建 Blob URL，然后缓存在 sticker._blobUrl
            try {
                sticker._blobUrl = URL.createObjectURL(sticker.blobData);
                console.log(`✅ 表情包 "${sticker.name}" 的 Blob URL 已缓存`);
            } catch (e) {
                console.warn(`⚠️ renderStickerPanel: Blob URL 创建失败 (${sticker.name}): ${e.message}`);
                // 如果创建失败，displayUrl 会保持为原始 sticker.url，至少能尝试加载
            }
        }

        if (sticker._blobUrl) {
            displayUrl = sticker._blobUrl;
        }

        innerImage.style.backgroundImage = `url(${displayUrl})`;

        // 3. 将内层图片div放入外层容器
        item.appendChild(innerImage);

        // 4. 所有事件监听器都绑定在外层容器上，保持不变
        item.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isStickerSelectionMode) {
                toggleStickerSelection(sticker.id);
            } else {
                sendSticker(sticker);
            }
        });

        addLongPressListener(item, (e) => {
            e.stopPropagation();
            if (!isStickerSelectionMode) {
                showStickerActions(sticker.id, e);
            }
        });

        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新添加】表情包操作的所有功能函数 ▼▼▼

/**
 * 显示表情操作菜单
 * @param {string} stickerId - 被长按的表情ID
 * @param {Event} event - 触发的事件对象，用于定位
 */
function showStickerActions(stickerId, event) {
    activeStickerId = stickerId;
    const panel = document.getElementById('sticker-actions-panel');
    const stickerItem = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);

    if (!panel || !stickerItem) return;

    panel.style.display = 'flex';
    const panelRect = panel.getBoundingClientRect();
    const stickerRect = stickerItem.getBoundingClientRect();
    
    // 计算面板位置（在表情项上方居中）
    let top = stickerRect.top - panelRect.height - 8; // 8px间距
    let left = stickerRect.left + (stickerRect.width / 2) - (panelRect.width / 2);

    // 边缘检测
    if (top < 10) top = stickerRect.bottom + 8;
    if (left < 10) left = 10;
    if (left + panelRect.width > window.innerWidth - 10) {
        left = window.innerWidth - panelRect.width - 10;
    }

    panel.style.top = `${top}px`;
    panel.style.left = `${left}px`;
}

/**
 * 隐藏表情操作菜单
 */
function hideStickerActions() {
    const panel = document.getElementById('sticker-actions-panel');
    if (panel) {
        panel.style.display = 'none';
    }
    activeStickerId = null;
}

/**
 * 处理“编辑含义”的逻辑
 */
async function handleEditStickerMeaning() {
    if (!activeStickerId) return;
    const sticker = state.userStickers.find(s => s.id === activeStickerId);
    if (!sticker) return;

    const newMeaning = await showCustomPrompt(
        '修改表情含义',
        '请输入新的含义：',
        sticker.name
    );

    if (newMeaning !== null && newMeaning.trim()) {
        sticker.name = newMeaning.trim();
        await db.userStickers.put(sticker);
        renderStickerPanel(); // 重新渲染以更新title提示
        alert('表情含义已更新！');
    }
}

/**
 * 处理“删除单个表情”的逻辑
 */
async function handleDeleteSingleSticker() {
    if (!activeStickerId) return;
    const sticker = state.userStickers.find(s => s.id === activeStickerId);
    if (!sticker) return;

    const confirmed = await showCustomConfirm(
        '删除表情',
        `确定要删除表情 "${sticker.name}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        await db.userStickers.delete(sticker.id);
        state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
        renderStickerPanel();
    }
}

/**
 * 进入表情批量删除模式
 */
function enterStickerSelectionMode() {
    if (!activeStickerId) return;
    isStickerSelectionMode = true;

    document.getElementById('sticker-panel').classList.add('selection-mode');
    document.getElementById('sticker-default-controls').style.display = 'none';
    document.getElementById('sticker-selection-controls').style.display = 'flex';

    // 自动选中第一个被长按的表情
    toggleStickerSelection(activeStickerId);
}

/**
 * 退出表情批量删除模式
 */
function exitStickerSelectionMode() {
    isStickerSelectionMode = false;
    selectedStickerIds.clear();

    document.getElementById('sticker-panel').classList.remove('selection-mode');
    document.querySelectorAll('.sticker-item.selected').forEach(item => item.classList.remove('selected'));
    document.getElementById('sticker-default-controls').style.display = 'flex';
    document.getElementById('sticker-selection-controls').style.display = 'none';
}

/**
 * 切换单个表情的选中状态
 * @param {string} stickerId - 被点击的表情ID
 */
function toggleStickerSelection(stickerId) {
    const item = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);
    if (!item) return;

    if (selectedStickerIds.has(stickerId)) {
        selectedStickerIds.delete(stickerId);
        item.classList.remove('selected');
    } else {
        selectedStickerIds.add(stickerId);
        item.classList.add('selected');
    }

    // 更新计数
    document.getElementById('sticker-selection-count').textContent = `已选择 ${selectedStickerIds.size} 个`;
}

/**
 * 删除所有选中的表情
 */
async function deleteSelectedStickers() {
    if (selectedStickerIds.size === 0) return;

    const confirmed = await showCustomConfirm(
        '批量删除',
        `确定要删除选中的 ${selectedStickerIds.size} 个表情吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = Array.from(selectedStickerIds);
        await db.userStickers.bulkDelete(idsToDelete);
        state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));
        exitStickerSelectionMode(); // 退出选择模式
        renderStickerPanel(); // 重新渲染
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲

// 【新增】生成骰子SVG的函数
function getDiceSvg(points) {
    const size = 80;
    const dotRadius = 6;
    const positions = {
        1: [[40, 40]],
        2: [[25, 25], [55, 55]],
        3: [[25, 25], [40, 40], [55, 55]],
        4: [[25, 25], [55, 25], [25, 55], [55, 55]],
        5: [[25, 25], [55, 25], [40, 40], [25, 55], [55, 55]],
        6: [[25, 20], [55, 20], [25, 40], [55, 40], [25, 60], [55, 60]]
    };

    const dots = (positions[points] || positions[1]).map(([x, y]) =>
        `<circle cx="${x}" cy="${y}" r="${dotRadius}" fill="#333"/>`
    ).join('');

    return `
        <svg viewBox="0 0 ${size} ${size}" style="width: ${size}px; height: ${size}px;">
            <rect x="5" y="5" width="70" height="70" rx="10" fill="#ffffff" stroke="#333" stroke-width="2.5"/>
            ${dots}
        </svg>
    `;
}

// ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
function createMessageElement(msg, chat) {
// ▼▼▼ 【全新】处理自定义HTML模块的特殊渲染（已添加交互功能）▼▼▼
    if (msg.type === 'html_module') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper html-module-wrapper';
        wrapper.dataset.timestamp = msg.timestamp; // 【核心】将时间戳绑定到最外层容器

        // 1. 创建一个内部容器，这个容器将扮演“气泡”的角色，以便被选择功能识别
        const innerContainer = document.createElement('div');
        innerContainer.className = 'message-bubble'; // 【核心】必须有这个类，多选功能才能找到它
        innerContainer.dataset.timestamp = msg.timestamp; // 多选功能也需要这个
        innerContainer.innerHTML = msg.content; // 将您的HTML内容放入这个“隐形气泡”
        
        wrapper.appendChild(innerContainer);

        // 2. 【关键】将用于所有其他消息的事件监听器，复制到这里
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { 
            if (isSelectionMode) {
                toggleMessageSelection(msg.timestamp);
            }
        });

        return wrapper;
    }
    // ▲▲▲ 替换结束 ▲▲▲

if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
    //    init() 函数中的那个事件监听器会处理它。
    
    return wrapper;
}
    // ▲▲▲ 添加结束 ▲▲▲

    if (msg.isHidden) {
        return null;
    }

    // 处理骰子消息
    if (msg.type === 'dice') {
        const isUser = msg.role === 'user';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
        wrapper.dataset.timestamp = msg.timestamp;

        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${isUser ? 'user' : 'ai'} dice-message-bubble`;
        bubble.dataset.timestamp = msg.timestamp;

        // 时间戳
        const timestampEl = document.createElement('span');
        timestampEl.className = 'timestamp';
        timestampEl.textContent = formatTimestamp(msg.timestamp);

        // 头像
        let avatarSrc;
        if (chat.isGroup) {
            if (isUser) {
                avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            } else {
                const member = chat.members.find(m => m.originalName === msg.senderName);
                avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            }
        } else {
            if (isUser) {
                if (chat.settings.isUsingCoupleAvatar && chat.settings.currentCoupleAvatar) {
                    avatarSrc = chat.settings.currentCoupleAvatar.userAvatar || chat.settings.myAvatar || defaultAvatar;
                } else {
                    avatarSrc = chat.settings.myAvatar || defaultAvatar;
                }
            } else {
                avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            }
        }
        const avatarHtml = `<img src="${avatarSrc}" class="avatar">`;

        // 骰子容器
        const diceContainer = document.createElement('div');
        diceContainer.className = 'dice-container dice-rolling';
        diceContainer.id = `dice-${msg.timestamp}`;

        // 先显示一个随机点数作为动画起点
        diceContainer.innerHTML = getDiceSvg(Math.floor(Math.random() * 6) + 1);

        // 动画期间不断切换点数
        let rollInterval = setInterval(() => {
            const randomPoint = Math.floor(Math.random() * 6) + 1;
            diceContainer.innerHTML = getDiceSvg(randomPoint);
        }, 100); // 每100ms切换一次

        // 1.5秒后显示真实点数并停止动画
        setTimeout(() => {
            clearInterval(rollInterval);
            diceContainer.classList.remove('dice-rolling');
            diceContainer.innerHTML = getDiceSvg(msg.diceResult);
        }, 1500);

        // 组装bubble内容 - 只放骰子,不放在content里
        bubble.innerHTML = avatarHtml;
        bubble.appendChild(diceContainer);

        wrapper.appendChild(bubble);

        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => {
            if (isSelectionMode) toggleMessageSelection(msg.timestamp);
        });

        return wrapper;
    }

    // 处理骰子结果系统消息
    if (msg.type === 'dice_result') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat';
        wrapper.dataset.timestamp = msg.timestamp;

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble';
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;

        wrapper.appendChild(bubble);

        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => {
            if (isSelectionMode) toggleMessageSelection(msg.timestamp);
        });

        return wrapper;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    // 处理线上/线下模式系统消息
    if (msg.isSystemMessage) {
        // 如果是礼物相关的系统消息，不显示在界面上
        if (msg.content && (msg.content.includes('已接受了你的礼物') || msg.content.includes('已拒绝了你的礼物'))) {
            return; // 直接返回，不渲染到界面
        }
        
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-mode-switch';
        wrapper.dataset.timestamp = msg.timestamp;
        
        const systemBubble = document.createElement('div');
        systemBubble.className = 'message-bubble reality-system-message';
        systemBubble.dataset.timestamp = msg.timestamp;
        systemBubble.textContent = msg.content;
        
        wrapper.appendChild(systemBubble);
        
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { 
            if (isSelectionMode) toggleMessageSelection(msg.timestamp); 
        });
        
        return wrapper;
    }

    // 检查是否为线下模式消息（只有明确标记的消息才使用线下样式）
    if (msg.isOfflineMode) {
        return createOfflineMessageElement(msg, chat);
    }

    const isUser = msg.role === 'user';
    // 【新增】旁观群聊中，检查AI成员是否被标记为主要角色
    // isMainRole只用来改变样式（显示位置），不改变头像和名字逻辑
    let isMainRole = false;
    if (chat.isSpectator && chat.isGroup && !isUser) {
        const member = chat.members.find(m => m.originalName === msg.senderName);
        if (member && member.isMainRole) {
            isMainRole = true; // 仅改变显示样式，不改变身份
        }
    }

    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isMainRole ? 'user' : isUser ? 'user' : 'ai'} ${msg.isSimulatedMessage ? 'is-simulated-message' : ''}`;
    wrapper.dataset.timestamp = msg.timestamp;

    // ★★★【核心重构】★★★
    // 【修改】群聊中，主要角色也要显示名字（因为头像仍然是角色的）
    if (chat.isGroup && !isUser && !isMainRole) {
        // 1. 使用AI返回的"本名"(`msg.senderName`)去列表里查找成员对象
        const member = chat.members.find(m => m.originalName === msg.senderName);

        // 2. 创建用于显示名字的 div
        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';

        // 3. 如果找到了成员，就显示他的"群昵称"；如果找不到，就显示AI返回的"本名"作为备用
        senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成员');

        wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isMainRole ? 'user' : isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    
    // 【新增】模拟时间戳显示逻辑
    if (msg.isSimulatedMessage && msg.simulatedTimestamp) {
        // 为模拟消息创建特殊的时间戳显示
        timestampEl.textContent = formatSimulatedTimestamp(msg.simulatedTimestamp, msg.originalLastMessageTime || Date.now());
        timestampEl.classList.add('simulated-timestamp');
        // 添加特殊样式标记，用于后续恢复真实时间戳
        timestampEl.dataset.realTimestamp = msg.timestamp;
        timestampEl.dataset.simulatedTimestamp = msg.simulatedTimestamp;
    } else {
        timestampEl.textContent = formatTimestamp(msg.timestamp);
    }
    
    // 先存储拉黑状态，稍后在wrapper创建完成后添加感叹号
    // 【修改】如果有 isBackgroundActivity 字段，说明是后台活动发送的消息，此时只有被拉黑才显示感叹号
    // 如果没有 isBackgroundActivity 字段，则使用原始逻辑（单聊等正常模式）
    const shouldShowWarning = !isUser && msg.role === 'assistant' && msg.sentWhileBlocked &&
                              (msg.isBackgroundActivity === undefined || msg.isBackgroundActivity === true);

    // ▼▼▼【粘贴这段新代码】▼▼▼
    let avatarSrc; // 我们现在只需要头像图片，不再需要头像框了
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
        }
    } else {
        // ▼▼▼ 【新增】支持情侣头像 ▼▼▼
        if (isUser) {
            // 用户头像：如果正在使用情侣头像，则显示情侣头像中的用户头像
            if (chat.settings.isUsingCoupleAvatar && chat.settings.currentCoupleAvatar) {
                avatarSrc = chat.settings.currentCoupleAvatar.userAvatar || chat.settings.myAvatar || defaultAvatar;
            } else {
                avatarSrc = chat.settings.myAvatar || defaultAvatar;
            }
        } else {
            // AI头像：正常显示（因为在change_couple_avatar处理中已经更新了aiAvatar）
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
        }
        // ▲▲▲ 新增结束 ▲▲▲
    }
    // 直接生成最简单的头像HTML，不再有任何和头像框相关的逻辑
    const avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    // ▲▲▲【粘贴结束】▲▲▲

    let contentHtml;

// 检查是否是翻译格式
const translationRegex = /^(.*?)【(.*?)】$/;
const translationMatch = typeof msg.content === 'string' && msg.content.match(translationRegex);

if (msg.type === 'share_link') {
    bubble.classList.add('is-link-share');
    contentHtml = `
        <div class="link-share-card" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.title || '无标题'}</div>
            <div class="description">${msg.description || '点击查看详情...'}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                <span>${msg.source_name || '链接分享'}</span>
            </div>
        </div>
    `;
} else if (msg.isMusicCard && msg.musicData) {
    bubble.classList.add('is-link-share');
    const musicData = msg.musicData;
    contentHtml = `
        <div class="music-card" style="cursor: pointer; background: rgba(255, 255, 255, 0.7); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.4); box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1); padding: 12px; color: #1E1E1E; width: 200px;" data-timestamp="${msg.timestamp}">
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="font-size: 24px;">🎵</div>
                <div style="flex: 1;">
                    <div style="font-weight: 600; font-size: 14px; color: #1E1E1E;">${musicData.name}</div>
                    <div style="font-size: 12px; opacity: 0.7; color: #666;">${musicData.artist}</div>
                </div>
            </div>
            <div style="margin-top: 8px; font-size: 11px; opacity: 0.6; color: #999;">点击查看完整歌词</div>
        </div>
    `;
} else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share');
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg>
                <span>聊天记录</span>
            </div>
        </div>
    `;
} else if (msg.type === 'forum_card') {
    bubble.classList.add('is-link-share');
    const payload = msg.payload;

    // ▼▼▼ 【全新】根据帖子类型决定如何显示内容 ▼▼▼
    let cardContentHtml = '';
    const publicTextHtml = payload.publicText ? `<div class="forum-card-content" style="margin: 8px 0; color: var(--text-primary); line-height: 1.4;">${payload.publicText.replace(/\n/g, '<br>')}</div>` : '';

    if (payload.postType === 'shuoshuo') {
        cardContentHtml = `<div class="forum-card-content" style="margin: 8px 0; color: var(--text-primary); line-height: 1.4;">${(payload.postContent || '').replace(/\n/g, '<br>')}</div>`;
    } else if (payload.postType === 'image_post' && payload.imageUrl) {
        cardContentHtml = `${publicTextHtml}<img src="${payload.imageUrl}" class="chat-image" style="margin-top: 8px; cursor: pointer;" data-description="${payload.imageDescription || '（无图片描述）'}">`;
    } else if (payload.postType === 'text_image') {
        cardContentHtml = `${publicTextHtml}<img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer; margin-top: 8px;" data-description="${payload.hiddenContent || '（无图片描述）'}">`;
    }
    // ▲▲▲ 修改结束 ▲▲▲

    contentHtml = `
        <div class="link-share-card forum-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}" data-post-id="${payload.postId}">
            <div class="title">${payload.title}</div>
            <div class="description">作者：${payload.posterName}</div>
            ${cardContentHtml}
            <div class="forum-card-stats" style="margin: 8px 0; font-size: 12px; color: var(--text-secondary);">👍 ${payload.originalLikes} 💬 ${payload.originalComments}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 17 5-5-5-5"></path><path d="m4 18v-2a4 4 0 0 1 4-4h12"></path></svg>
                <span>论坛动态</span>
            </div>
        </div>
    `;
} else if (translationMatch && msg.role === 'assistant' && (!msg.type || msg.type === 'text')) {
    bubble.classList.add('is-translation');
    const foreignText = translationMatch[1].trim();
    const chineseText = translationMatch[2].trim();
    bubble.dataset.foreignText = foreignText;
    bubble.dataset.chineseText = chineseText;
    contentHtml = `
        <div class="translation-body">
            <span>${foreignText}</span>
        </div>
        <div class="translation-text">${chineseText}</div>
    `;
} else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
    bubble.classList.add('is-ai-image');
    const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
    contentHtml = `<img src="https://files.catbox.moe/d394h8.png" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
} else if (msg.type === 'naiimag') {
    // NovelAI图片渲染 - 不包裹在气泡中，直接显示图片
    bubble.classList.add('is-naiimag');

    // 【新增】判断是否生成失败
    if (msg.isFailed) {
        contentHtml = `<div style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #f5f5f5; border-radius: 8px; color: #333; border: 1px solid #d0d0d0;">
            <div style="text-align: center;">
                <div style="font-size: 16px; margin-bottom: 8px;">⚠️ 生成失败</div>
                <div style="font-size: 11px; color: #666; margin-bottom: 10px; word-break: break-word; max-width: 180px; max-height: 60px; overflow: hidden;">${msg.failureReason}</div>
                <button class="retry-nai-image-btn" data-timestamp="${msg.timestamp}" style="padding: 6px 12px; background-color: #333; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">重新生成</button>
            </div>
        </div>`;
    }
    // 【关键】如果imageUrl不存在或为空，显示加载中，而不是占位图
    else if (!msg.imageUrl) {
        contentHtml = `<div style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; border-radius: 8px; color: #666;">
            <div style="text-align: center;">
                <div style="font-size: 14px;">📸 正在生成图片</div>
            </div>
        </div>`;
    } else {
        // 【新增】为 naiimag 图片添加容器，支持悬停显示重新生成按钮
        const imgHtml = `<div class="naiimag-container" style="position: relative; display: inline-block;">
            <img
                src="${msg.imageUrl}"
                alt="NovelAI图片分享"
                title="${msg.fullPrompt || msg.prompt || 'NovelAI生成'}"
                class="naiimag-image"
                data-timestamp="${msg.timestamp}"
                style="max-width: 300px; max-height: 300px; object-fit: contain; cursor: pointer; display: block;"
                onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';"
            >
            <button class="naiimag-retry-btn" data-timestamp="${msg.timestamp}" style="position: absolute; bottom: 8px; right: 8px; width: 36px; height: 36px; border-radius: 50%; background-color: rgba(50, 50, 50, 0.85); border: none; cursor: pointer; display: none; align-items: center; justify-content: center; transition: background-color 0.2s;" title="重新生成图片">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 2.2" />
                </svg>
            </button>
        </div>`;
        contentHtml = imgHtml;

        // 自动保存到NAI画廊（自动去重）
        if (window.naiGallery && window.naiGallery.addImage) {
            const imageName = msg.prompt || msg.fullPrompt || '生成图片';
            window.naiGallery.addImage(msg.imageUrl, imageName, chat.id).catch(e => {
                console.error('保存NAI图片到画廊失败:', e);
            });
        }
    }
} else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message');
    bubble.dataset.voiceText = msg.content;
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.isLocation) {
    // 位置消息特殊处理
    bubble.classList.add('is-location');
    const locationData = msg.locationData;
    let locationItems = [];
    
    if (locationData.currentLocation) {
        locationItems.push(`<div class="location-item"><span class="location-label">当前位置</span><span class="location-value">${locationData.currentLocation}</span></div>`);
    }
    if (locationData.distance) {
        locationItems.push(`<div class="location-item"><span class="location-label">距离</span><span class="location-value">${locationData.distance}</span></div>`);
    }
    if (locationData.targetLocation) {
        locationItems.push(`<div class="location-item"><span class="location-label">目标地点</span><span class="location-value">${locationData.targetLocation}</span></div>`);
    }
    
    contentHtml = `
        <div class="location-card">
            <div class="location-header">
                <svg class="location-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                <span class="location-title">位置信息</span>
            </div>
            <div class="location-content">
                ${locationItems.join('')}
            </div>
        </div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    if (isUser) {
        if (msg.isRefund) {
            titleText = `退款给 ${chat.name}`;
            noteText = '已拒收对方转账';
        } else {
            titleText = `转账给 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '对方已收款';
            } else if (msg.status === 'declined') {
                noteText = '对方已拒收';
            } else {
                noteText = msg.note || '等待对方处理...';
            }
        }
    } else {
        if (msg.isRefund) {
            titleText = `退款来自 ${msg.senderName}`;
            noteText = '转账已被拒收';
        } else if (msg.receiverName === myNickname) {
            titleText = `转账给 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '点击处理';
            }
        } else {
            titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊内转账';
        }
    }
    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class="transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.type === 'gift') {
    bubble.classList.add('is-gift');
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let titleText, statusText = '';
    if (isUser) {
        if (msg.giftType === 'random') {
            titleText = `拼手气礼物`;
        } else if (msg.giftType === 'targeted') {
            titleText = `赠送给 ${msg.receiverName}`;
        } else {
            titleText = `赠送给 ${msg.receiverName || chat.name}`;
        }
        
        if (msg.status === 'accepted') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else if (msg.actualReceiver) {
                    statusText = `<div class="gift-status">已被 ${msg.actualReceiver} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">已被领取</div>';
                }
            } else {
                statusText = '<div class="gift-status">对方已接受礼物</div>';
            }
        } else if (msg.status === 'declined') {
            statusText = '<div class="gift-status">对方已拒收礼物</div>';
        } else if (msg.status === 'pending') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物但状态未更新（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">等待有人领取</div>';
                }
            } else {
                // 检查群聊指定礼物是否已被接受但状态未更新
                if (chat.isGroup && msg.giftType === 'targeted') {
                    // 检查聊天历史中是否有接受指令
                    const acceptMessage = chat.history.find(m => 
                        m.type === 'accept_gift' && 
                        m.for_timestamp === msg.timestamp
                    );
                    if (acceptMessage) {
                        // 更新消息对象的状态属性，确保状态持久化
                        msg.status = 'accepted';
                        statusText = '<div class="gift-status">对方已接受礼物</div>';
                        // 保存更新到数据库
                        db.chats.put(chat);
                    } else {
                        statusText = '<div class="gift-status">正在等待对方接受</div>';
                    }
                } else {
                    statusText = '<div class="gift-status">正在等待对方接受</div>';
                }
            }
        }
    } else {
        // AI发送的礼物，根据类型显示不同的标题
        if (msg.giftType === 'targeted') {
            titleText = `${msg.senderName} 送给 ${msg.receiverName}`;
        } else if (msg.giftType === 'random') {
            titleText = `拼手气礼物来自 ${msg.senderName}`;
        } else {
            titleText = `礼物来自 ${msg.senderName}`;
        }
        
        // AI发送的礼物也需要状态显示
        if (msg.status === 'accepted') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else if (msg.actualReceiver) {
                    statusText = `<div class="gift-status">已被 ${msg.actualReceiver} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">已被领取</div>';
                }
            } else {
                statusText = '<div class="gift-status">礼物已被接受</div>';
            }
        } else if (msg.status === 'declined') {
            statusText = '<div class="gift-status">礼物已拒收</div>';
        } else if (msg.status === 'pending') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物但状态未更新（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">等待有人领取</div>';
                }
            } else if (msg.giftType === 'targeted' && chat.isGroup) {
                // 检查群聊中AI发送的指定礼物是否已被用户接受但状态未更新
                const acceptMessage = chat.history.find(m => 
                    m.type === 'accept_gift' && 
                    m.for_timestamp === msg.timestamp
                );
                const declineMessage = chat.history.find(m => 
                    m.type === 'decline_gift' && 
                    m.for_timestamp === msg.timestamp
                );
                
                if (acceptMessage) {
                    // 更新消息对象的状态属性，确保状态持久化
                    msg.status = 'accepted';
                    statusText = '<div class="gift-status">礼物已接受</div>';
                    // 保存更新到数据库
                    db.chats.put(chat);
                } else if (declineMessage) {
                    // 更新消息对象的状态属性，确保状态持久化
                    msg.status = 'declined';
                    statusText = '<div class="gift-status">礼物已拒收</div>';
                    // 保存更新到数据库
                    db.chats.put(chat);
                } else {
                    statusText = '<div class="gift-status">等待对方回应</div>';
                }
            }
            // 单聊AI礼物不显示状态
        }
    }
    
    // AI发送的礼物，如果状态为pending且接收者是用户，显示按钮
    let actionButtonsHtml = '';
    if (msg.status === 'pending' && !isUser) {
        // 对于拼手气礼物，任何人都可以领取
        // 对于指定礼物，只有指定的接收者可以操作
        const canInteract = msg.giftType === 'random' || 
                          msg.receiverName === (chat.isGroup ? (chat.settings.myNickname || '我') : '我');
                          
        if (canInteract) {
            actionButtonsHtml = `
                <div class="gift-actions">
                    <button class="gift-decline-btn" data-choice="declined" data-timestamp="${msg.timestamp}">拒绝</button>
                    <button class="gift-accept-btn" data-choice="accepted" data-timestamp="${msg.timestamp}">接受</button>
                </div>`;
        }
    }
    
    const giftIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><rect x="2" y="4" width="20" height="5" rx="1"></rect><rect x="4" y="9" width="16" height="10" rx="1"></rect><path d="M12 4v5"></path><path d="M8 4c0-1.1.9-2 2-2s2 .9 2 2-2 2-2 2-2-.9-2-2z"></path><path d="M16 4c0-1.1-.9-2-2-2s-2 .9-2 2 2 2 2 2 2-.9 2-2z"></path></svg>`;
    contentHtml = `
        <div class="gift-card">
            <div class="gift-title">${giftIcon} ${titleText}</div>
            <div class="gift-name">${msg.giftName}</div>
            <div class="gift-price">¥ ${Number(msg.giftPrice).toFixed(2)}</div>
            ${statusText}
            ${actionButtonsHtml}
        </div>
    `;
} else if (msg.type === 'waimai_request') {
    bubble.classList.add('is-waimai-request');
    if (msg.status === 'paid' || msg.status === 'rejected') {
        bubble.classList.add(`status-${msg.status}`);
    }
    let displayName;
    if (chat.isGroup) {
        const member = chat.members.find(m => m.originalName === msg.senderName);
        displayName = member ? member.groupNickname : msg.senderName;
    } else {
        displayName = chat.name;
    }
    const requestTitle = `来自 ${displayName} 的代付请求`;
    let actionButtonsHtml = '';
    if (msg.status === 'pending' && !isUser) {
        actionButtonsHtml = `
            <div class="waimai-user-actions">
                <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
            </div>`;
    }
    contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group">
                    <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                </div>
            </div>
            <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
            <div class="waimai-main">
                <div class="request-title">${requestTitle}</div>
                <div class="payment-box">
                    <div class="payment-label">需付款</div>
                    <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                    <div class="countdown-label">剩余支付时间
                        <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                    </div>
                </div>
                <button class="waimai-details-btn">查看详情</button>
            </div>
            ${actionButtonsHtml}
        </div>`;
    setTimeout(() => {
        const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
        if (timerEl && msg.countdownEndTime) {
            if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
            if (msg.status === 'pending') {
                waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
            } else {
                timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
            }
        }
        const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
        if (detailsBtn) {
            detailsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
            });
        }
        const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
        actionButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const choice = e.target.dataset.choice;
                handleWaimaiResponse(msg.timestamp, choice);
            });
        });
    }, 0);
} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;
    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手气红包';
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened';
    }
    if (msg.packetType === 'direct') {
        typeText = `专属红包: 给 ${msg.receiverName}`;
    }
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
    }
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
} else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    let totalVotes = 0;
    const voteCounts = {};
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }
    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;
        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    let footerHtml = '';
    if (msg.isClosed) {
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
    } else {
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
    }
    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
} else if (msg.type === 'sticker' && msg.role === 'assistant') {
    // ▼▼▼ 【需求1】AI表情包渲染逻辑 ▼▼▼
    bubble.classList.add('is-sticker');
    const imgId = `sticker-img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    // 从msg对象读取width/height（由triggerAiResponse传入）
    let displayWidth = 100;
    let displayHeight = 100;

    console.log(`🎨 【createMessageElement】渲染AI sticker，msg对象:`, { meaning: msg.meaning, width: msg.width, height: msg.height, content: msg.content?.substring(0, 50) });

    if (msg.width && msg.height) {
        displayWidth = msg.width;
        displayHeight = msg.height;
        console.log(`✅ 【createMessageElement】读到宽高，原始值: ${displayWidth}x${displayHeight}`);
        // 保持100x100上限
        if (displayWidth > 100 || displayHeight > 100) {
            const scale = Math.min(100 / displayWidth, 100 / displayHeight);
            displayWidth = Math.round(displayWidth * scale);
            displayHeight = Math.round(displayHeight * scale);
            console.log(`⚠️ 【createMessageElement】超过100x100上限，缩放后: ${displayWidth}x${displayHeight}`);
        }
    } else {
        console.warn(`⚠️ 【createMessageElement】AI sticker缺少width/height，使用默认100x100`);
    }

    contentHtml = `<img id="${imgId}" src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image" width="${displayWidth}" height="${displayHeight}" style="width: ${displayWidth}px; height: ${displayHeight}px;">`;
    // ▲▲▲ AI表情包渲染结束 ▲▲▲
} else if (typeof msg.content === 'string' && msg.content.match(/^\[表情:([^\]]+)\]$/)) {
            // 【新格式】处理 [表情:含义] 格式的表情包消息
            bubble.classList.add('is-sticker');
            const meaning = msg.content.match(/^\[表情:([^\]]+)\]$/)[1];
            
            // ▼▼▼ 【表情包修复 v2.0 - 兼容衍生版本】▼▼▼
            // 错误原因：state.aiStickers 是一个数组，不能通过 [meaning] 索引。
            // 修复：使用 .find() 查找。
            // 增强：AI 发送的 [表情:贴贴] 可能对应数据库中的 贴贴_v2, 贴贴_v3 等。
            // 我们需要查找所有以 "贴贴" 开头的衍生版本，并随机选择一个。
            
            let stickerInfo = null;
            if (state.aiStickers && state.aiStickers.length > 0) {
                // 【模糊匹配】去掉空格后再比对，这样"奇米蛋 羞羞////"和"奇米蛋羞羞////"都能匹配
                const meaningNoSpace = meaning.replace(/\s+/g, '');

                // 1. 找到所有空格去除后含义相同的表情包（包括衍生版本）
                const allMatchingStickers = state.aiStickers.filter(s => {
                    const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                    return meaningNoSpace === dbMeaningNoSpace;
                });

                if (allMatchingStickers.length > 0) {
                    // 2. 随机选择一个版本来显示
                    stickerInfo = allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)];
                }
            }
            // ▲▲▲ 【修复结束】 ▲▲▲

            if (stickerInfo && stickerInfo.url) {
                const imgId = `sticker-img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;        let displayWidth = stickerInfo.width || 100;
        let displayHeight = stickerInfo.height || 100;
        // 保持100x100上限
        if (displayWidth > 100 || displayHeight > 100) {
            const scale = Math.min(100 / displayWidth, 100 / displayHeight);
            displayWidth = Math.round(displayWidth * scale);
            displayHeight = Math.round(displayHeight * scale);
        }
        contentHtml = `<img id="${imgId}" src="${stickerInfo.url}" alt="${meaning}" class="sticker-image" width="${displayWidth}" height="${displayHeight}" style="width: ${displayWidth}px; height: ${displayHeight}px;">`;
    } else {
        // 缓存中找不到，显示文本形式
        contentHtml = msg.content;
    }
} else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
    // 【保留】其他URL格式的表情包（兼容旧数据）
    bubble.classList.add('is-sticker');
    const imgId = `sticker-img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    contentHtml = `<img id="${imgId}" src="${msg.content}" alt="Sticker" class="sticker-image" style="max-width: 100px; max-height: 100px;">`;
} else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
    bubble.classList.add('has-image');
    const imageUrl = msg.content[0].image_url.url;
    contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
} else {
    // 【全新】优先使用 displayContent 的内容来渲染气泡，否则才使用原始 content
    let display = msg.displayContent ? msg.displayContent : String(msg.content || '');

    // 【新增】隐藏<details>标签内容（针对线下模式和监控模式的AI消息）
    if (!msg.role || msg.role === 'assistant') {
        // 移除所有<details>......</details>标签及其内容
        display = display.replace(/<details>[\s\S]*?<\/details>/g, '').trim();
    }

    contentHtml = display.replace(/\n/g, '<br>');

    // 【新增】如果thinking标签被删除，在顶部添加爱心标记
    if (msg.thinkingRemoved) {
        const heartMark = '<div class="thinking-removed-mark" style="margin-bottom: 8px; padding: 6px 10px; background: rgba(0,0,0,0.05); border-radius: 8px; font-size: 12px; color: #666; cursor: pointer; text-align: center;">⊹ ♡┈┈ 𓏴 𝒫𝒾𝓃𝓀 𝒱𝑒𝓁𝓋𝑒𝓉 𓏴 ┈┈♡ ⊹</div>';
        contentHtml = heartMark + contentHtml;
    }
}

// ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

// 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
let quoteHtml = '';
if (msg.quote) {
    const senderName = msg.quote.senderName;
    let quotedContent = '';

    // 判断被引用的内容类型
    if (typeof msg.quote.content === 'string' && STICKER_REGEX.test(msg.quote.content)) {
        quotedContent = '[表情]';
    } else if (msg.quote.type === 'ai_image' || msg.quote.type === 'user_photo') {
        quotedContent = '[图片]';
    } else if (msg.quote.type === 'voice_message') {
        quotedContent = '[语音]';
    } else {
        // 对普通文本进行截断，以适应单行显示
        const fullText = String(msg.quote.content || '');
        quotedContent = fullText.substring(0, 50) + (fullText.length > 50 ? '...' : '');
    }

     // 构建新的、更简洁的HTML结构
    quoteHtml = `<div class="quoted-message"><span class="quoted-sender-name">${senderName}</span>: ${quotedContent}</div>`;
}

// 2. 拼接最终的气泡内容
//    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
    // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
    // 【新增】naiimag 类型不需要包裹在 content 里面，直接放图片（表情包的方式）
    if (msg.type === 'naiimag') {
        bubble.innerHTML = `${avatarHtml}${contentHtml}`;
    } else {
        bubble.innerHTML = `${avatarHtml}<div class="content">${quoteHtml}${contentHtml}</div>`;
    }

    // 【新增】为表情包图片添加加载完成监听，确保加载后滚动到底部
    if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        const imgId = contentHtml.match(/id="([^"]+)"/)?.[1];
        if (imgId) {
            // 使用setTimeout确保img元素已经添加到DOM后再绑定事件
            setTimeout(() => {
                const imgEl = document.getElementById(imgId);
                if (imgEl) {
                    imgEl.addEventListener('load', () => {
                        // 图片加载完成后，再次滚动到底部（使用防抖动的scrollToBottom）
                        scrollToBottom();
                    });
                    // 如果图片已经加载完成（可能从缓存加载），立即触发滚动
                    if (imgEl.complete && imgEl.naturalHeight !== 0) {
                        scrollToBottom();
                    }
                }
            }, 0);
        }
    }

    // --- 【最终正确结构】将完整的"气泡"和"时间戳"放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    
    // 【全新】在时间戳后添加红色圆形感叹号（如果需要）
    if (shouldShowWarning) {
        const warningIcon = document.createElement('span');
        warningIcon.textContent = '!';
        warningIcon.style.cssText = `
            display: inline-block;
            width: 18px;                  /* 从 14px 变大到 16px */
            height: 18px;                 /* 从 14px 变大到 16px */
            background-color: #AB4D3F;    /* 改为饱和度更低的红色 */
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;            /* 配合尺寸变大，保持垂直居中 */
            font-size: 12px;              /* 感叹号字体变大 */
            font-weight: bold;
            margin-left: -4px;             /* 从 4px 减小到 2px，更靠近气泡 */
            vertical-align: middle;
            flex-shrink: 0;
            position: relative;
            top: -8px;                    /* 调整垂直位置，使其更居中 */
        `;
        warningIcon.title = '此消息发送时处于被拉黑状态';
        wrapper.appendChild(warningIcon);
    }
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser) {
    const avatarEl = wrapper.querySelector('.avatar'); //  <-- 1. 把查找目标改成 '.avatar'
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    //  <-- 2. 确保这里也用新变量
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : (!chat.remark ? chat.name : chat.remark);
            handleUserPat(chat.id, characterName);
        });
    }
}

return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 新增这行，同样的处理

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 【表情包预加载函数】▼▼▼
async function preloadStickerImages(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.history || chat.history.length === 0) return Promise.resolve();

    // 从所有消息中提取表情包URL
    const stickerUrls = new Set();
    chat.history.forEach(msg => {
        if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
            // 确保是有效的URL
            if (msg.content && typeof msg.content === 'string' && (msg.content.startsWith('http://') || msg.content.startsWith('https://'))) {
                stickerUrls.add(msg.content);
            }
        }
    });

    // 如果没有表情包就直接返回
    if (stickerUrls.size === 0) return Promise.resolve();

    // 并行预加载所有表情包
    const preloadPromises = Array.from(stickerUrls).map(url => {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false); // 即使加载失败也继续
            img.src = url;
            // 设置超时，如果5秒还没加载完就放弃（不阻塞）
            setTimeout(() => resolve(false), 5000);
        });
    });

    try {
        await Promise.all(preloadPromises);
    } catch (e) {
        console.warn('表情包预加载出错：', e);
    }

    return Promise.resolve();
}

// ▼▼▼ 【字体预加载函数】▼▼▼
function preloadFont(fontUrl) {
    return new Promise((resolve) => {
        if (!fontUrl) {
            resolve();
            return;
        }

        // 使用Font Loading API预加载字体
        if (document.fonts && document.fonts.load) {
            console.log(`[预加载] 使用Font Loading API加载字体...`);
            try {
                // 构建font descriptor string
                const fontName = 'custom-user-font';
                const fontFace = new FontFace(fontName, `url('${fontUrl}')`, {
                    display: 'swap'
                });

                // 尝试加载字体
                fontFace.load().then(() => {
                    console.log(`[预加载] ✓ 字体加载完成 via Font Loading API`);
                    document.fonts.add(fontFace);
                    resolve();
                }).catch((err) => {
                    console.warn(`[预加载] ✗ Font Loading API加载失败, 尝试备用方案: ${err}`);
                    // 备用方案：通过Image对象预加载
                    preloadFontViaImage(fontUrl, resolve);
                });
            } catch (e) {
                console.warn(`[预加载] ✗ FontFace构建失败: ${e}, 使用备用方案`);
                preloadFontViaImage(fontUrl, resolve);
            }
        } else {
            console.log(`[预加载] 浏览器不支持Font Loading API，使用备用方案...`);
            preloadFontViaImage(fontUrl, resolve);
        }
    });
}

// 备用字体预加载方案（通过下载）
function preloadFontViaImage(fontUrl, resolve) {
    console.log(`[预加载] 使用备用方案（xhr）加载字体...`);
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
        if (xhr.status === 200) {
            console.log(`[预加载] ✓ 字体已通过XHR加载到缓存`);
            resolve();
        } else {
            console.warn(`[预加载] ✗ 字体加载失败: HTTP ${xhr.status}`);
            resolve();
        }
    };
    xhr.onerror = () => {
        console.warn(`[预加载] ✗ 字体XHR加载出错`);
        resolve();
    };
    xhr.ontimeout = () => {
        console.warn(`[预加载] ✗ 字体加载超时`);
        resolve();
    };
    xhr.timeout = 10000; // 10秒超时
    xhr.open('GET', fontUrl);
    xhr.send();
}
// ▲▲▲ 字体预加载函数结束 ▲▲▲

// ▼▼▼ 【后台预加载所有角色表情包函数】▼▼▼
function preloadAllStickersInBackground() {
    (async () => {
        try {
            console.log(`[预加载] 开始预加载流程...`);

            // 【新增】初始化 AI 表情包 Blob URL 缓存
            const allAiStickers = await db.aiStickers.toArray();
            if (allAiStickers && allAiStickers.length > 0) {
                allAiStickers.forEach(sticker => {
                    if (sticker.blobData && !sticker._blobUrl) {
                        try {
                            sticker._blobUrl = URL.createObjectURL(new Blob([sticker.blobData]));
                            console.log(`✅ 初始化：AI表情包 "${sticker.meaning}" 的 Blob URL 已缓存`);
                        } catch (e) {
                            console.warn(`⚠️ AI表情包初始化失败 (${sticker.meaning}): ${e.message}`);
                        }
                    }
                });
                state.aiStickers = allAiStickers;
            }

            // 【第一步】先预加载自定义字体
            if (state.globalSettings && state.globalSettings.fontUrl) {
                console.log(`[预加载] 检测到自定义字体URL: ${state.globalSettings.fontUrl}`);
                await preloadFont(state.globalSettings.fontUrl);
                console.log(`[预加载] ✓ 自定义字体加载完成`);
            } else {
                console.log(`[预加载] 未设置自定义字体`);
            }

            // 定义表情包正则（与createMessageElement中的逻辑保持一致）
            const stickerRegex = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;

            // 2. 获取所有聊天，按时间排序（最近的在前）
            const allChats = Object.values(state.chats).sort((a, b) => {
                const aLastMsg = a.history.slice(-1)[0]?.timestamp || 0;
                const bLastMsg = b.history.slice(-1)[0]?.timestamp || 0;
                return bLastMsg - aLastMsg;
            });

            if (allChats.length === 0) {
                window.hidePageLoadingOverlay();
                return;
            }

            // 2. 提取前5个角色的表情包URL
            const topFiveChats = allChats.slice(0, 5);
            const topFiveStickerUrls = new Set();

            topFiveChats.forEach(chat => {
                if (!chat || !chat.history || chat.history.length === 0) return;
                chat.history.forEach(msg => {
                    // 【核心】使用本地定义的stickerRegex，确保能正确匹配
                    if (msg.type === 'sticker' || (typeof msg.content === 'string' && stickerRegex.test(msg.content))) {
                        if (msg.content && typeof msg.content === 'string') {
                            topFiveStickerUrls.add(msg.content);
                        }
                    }
                });
            });

            console.log(`[预加载] 前5个角色中找到 ${topFiveStickerUrls.size} 个表情包URL: `, Array.from(topFiveStickerUrls));

            // 3. 如果前5个里有表情包，就优先加载它们
            if (topFiveStickerUrls.size > 0) {
                console.log(`[预加载] 开始预加载前5个角色的 ${topFiveStickerUrls.size} 个表情包...`);
                const topFivePreloadPromises = Array.from(topFiveStickerUrls).map(url => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            console.log(`[预加载] ✓ 加载成功: ${url}`);
                            resolve(true);
                        };
                        img.onerror = () => {
                            console.warn(`[预加载] ✗ 加载失败: ${url}`);
                            resolve(false);
                        };
                        img.src = url;
                        // 设置10秒超时（给充足的时间）
                        const timeoutId = setTimeout(() => {
                            console.warn(`[预加载] ⏱ 加载超时: ${url}`);
                            resolve(false);
                        }, 10000);
                        // 如果加载完成则清除超时
                        img.onload = (() => {
                            const originalOnload = img.onload;
                            return function() {
                                clearTimeout(timeoutId);
                                console.log(`[预加载] ✓ 加载成功: ${url}`);
                                resolve(true);
                            };
                        })();
                        img.onerror = (() => {
                            const originalOnerror = img.onerror;
                            return function() {
                                clearTimeout(timeoutId);
                                console.warn(`[预加载] ✗ 加载失败: ${url}`);
                                resolve(false);
                            };
                        })();
                    });
                });

                // 等待前5个角色的表情包全部加载完
                await Promise.all(topFivePreloadPromises);
                console.log(`[预加载] ✓✓✓ 前5个角色的表情包加载完成！`);
            } else {
                console.log(`[预加载] 前5个角色中没有找到表情包`);
            }

            // 4. 【核心】前5个加载完后立即隐藏加载动画
            console.log(`[预加载] 现在隐藏加载动画...`);
            window.hidePageLoadingOverlay();

            // 【新增】后台预加载用户和AI表情包的 Blob 缓存
            if (state.userStickers && state.userStickers.length > 0) {
                console.log(`[预加载] 后台预加载用户表情包 Blob: ${state.userStickers.length} 个`);
                preloadStickerBlobs(state.userStickers, false).catch(e => {
                    console.warn(`[预加载] 用户表情包 Blob 预加载失败: ${e.message}`);
                });
            }

            if (state.aiStickers && state.aiStickers.length > 0) {
                console.log(`[预加载] 后台预加载 AI 表情包 Blob: ${state.aiStickers.length} 个`);
                preloadStickerBlobs(state.aiStickers, true).catch(e => {
                    console.warn(`[预加载] AI 表情包 Blob 预加载失败: ${e.message}`);
                });
            }

            // 5. 然后在后台继续加载其他角色的表情包（不阻塞UI）
            const remainingChats = allChats.slice(5);
            const remainingStickerUrls = new Set();

            remainingChats.forEach(chat => {
                if (!chat || !chat.history || chat.history.length === 0) return;
                chat.history.forEach(msg => {
                    if (msg.type === 'sticker' || (typeof msg.content === 'string' && stickerRegex.test(msg.content))) {
                        if (msg.content && typeof msg.content === 'string') {
                            remainingStickerUrls.add(msg.content);
                        }
                    }
                });
            });

            if (remainingStickerUrls.size > 0) {
                console.log(`[预加载] 后台预加载剩余 ${remainingStickerUrls.size} 个表情包...`);
                const remainingPreloadPromises = Array.from(remainingStickerUrls).map(url => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                        img.src = url;
                        setTimeout(() => resolve(false), 5000);
                    });
                });

                // 这个在后台运行，不等待
                Promise.all(remainingPreloadPromises).then(() => {
                    console.log(`[预加载] 所有表情包预加载完成`);
                }).catch(e => console.warn('[预加载] 后台表情包预加载失败:', e));
            }

        } catch (e) {
            console.warn('[预加载] 表情包预加载失败:', e);
            window.hidePageLoadingOverlay();
        }
    })();
}
// ▲▲▲ 后台预加载函数结束 ▲▲▲

// ▼▼▼ 【最终修正版】用这个版本替换 appendMessage 函数 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    // 安全检查，确保不会跨窗口渲染
    if (!isInitialLoad && state.activeChatId !== chat.id) {
        return;
    }

    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; 

    const typingIndicator = document.getElementById('typing-indicator');

    // 为新消息添加日期分隔逻辑
    if (!isInitialLoad) {
        const lastMessageWrapper = messagesContainer.querySelector('.message-wrapper:last-of-type');
        let lastTimestamp = 0;
        if (lastMessageWrapper) {
            lastTimestamp = parseInt(lastMessageWrapper.dataset.timestamp, 10);
        }

        // 只有在新消息与上一条消息不是同一天时，才考虑插入分隔符
        if (!isSameDay(lastTimestamp, msg.timestamp)) {
            const dividerText = formatDateDivider(msg.timestamp);
            
            // 【核心修正】只有当返回的文本不是 'TODAY' 时，才真正创建并插入分隔符
            if (dividerText !== 'TODAY') {
                const divider = document.createElement('div');
                divider.className = 'date-divider';
                divider.textContent = dividerText;
                messagesContainer.insertBefore(divider, typingIndicator);
            }
        }
    }
    
    // 为新消息添加进入动画
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        scrollToBottom(); 
        currentRenderedCount++;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

async function openChat(chatId, isUserAction = false) {
    // ▼▼▼ 在这里添加最终极的防串台"门锁"代码 ▼▼▼
// 这个检查确保：如果用户已经在某个聊天窗口里，任何来自后台的、试图打开另一个窗口的指令都会被阻止。
const isAlreadyInAChat = document.getElementById('chat-interface-screen').classList.contains('active');
if (isAlreadyInAChat && state.activeChatId !== chatId && !isUserAction) {
        console.warn(`BUG拦截成功：后台尝试在您查看 ${state.activeChatId} 时，自动打开 ${chatId} 的窗口。操作已被阻止。`);
    return; // 如果要打开的不是当前窗口，就直接阻止函数继续执行
}
// ▲▲▲ "门锁"代码结束 ▲▲▲

    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全检查

    // 【核心新增】在这里将未读数清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 别忘了把这个改变同步到数据库
        // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
    }

    // 【新增】切换聊天时重置面板状态
    const chatInterface = document.getElementById('chat-interface-screen');
    // 【新增】在chat-interface-screen上设置当前chatId，方便NAI Gallery等组件访问
    if (chatInterface) chatInterface.dataset.chatId = chatId;
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');

    // 关闭所有展开的面板
    if (singlePanel) singlePanel.classList.remove('visible');
    if (groupPanel) groupPanel.classList.remove('visible');
    if (chatInterface) chatInterface.classList.remove('panel-expanded');

    renderChatInterface(chatId);

    // 【修复2】在进入聊天时，恢复"正在输入中..."的状态
    if (chat.isAwaitingReply) {
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle) {
            setTimeout(() => {
                chatHeaderTitle.textContent = chat.isGroup ? '正在输入中...' : '对方正在输入...';
                chatHeaderTitle.classList.add('typing-status');
            }, 100);
        }
    }

    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    
    // 【修复】安全调用toggleCallButtons
    try {
        if (typeof toggleCallButtons === 'function') {
            toggleCallButtons(chat.isGroup || false);
        }
    } catch (error) {
        console.warn('toggleCallButtons调用失败:', error);
    }

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
        triggerAiResponse();
    }
    
    // 【新增】主动回复功能
    await checkAndTriggerActiveReply(chat);
    
    // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
}
// ▲▲▲ 替换结束 ▲▲▲

async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

    // 检查是否为线下模式
    if (offlineMode.isOffline && !chat.isGroup) {
        return triggerOfflineAiResponse(chatId, chat);
    }

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

    // ★★★★★【核心修改2：根据聊天类型，决定显示哪种"正在输入"】★★★★★
// 【全新修复】只有当后台响应的角色与当前窗口一致时，才显示"正在输入"
if (state.activeChatId === chatId) {
    // 【修复2】设置isAwaitingReply标志，以便在退出后重新进入时恢复状态
    chat.isAwaitingReply = true;

    if (chat.isGroup) {
        // 如果是群聊，也使用标题栏显示，并显示"正在输入中..."
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '正在输入中...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    } else {
        // 如果是单聊，保持原来的标题动画
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '对方正在输入...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    }
}
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先在API设置中配置反代地址、密钥并选择模型。');
            // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
            if (chatHeaderTitle && state.chats[chatId]) {
                const c = state.chats[chatId];
                chatHeaderTitle.textContent = c.remark || c.name;
                chatHeaderTitle.classList.remove('typing-status');
            }
            return;
        }

        // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
            const historyForContext = chat.history
                .filter(m => !m.isHidden)
                .slice(-105, -5); // 获取拉黑前的最后100条消息

            // 【安全修复】应用8条消息规则
            const recentMessages = historyForContext.slice(-8);
            const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

            const contextSummary = historyForContext
                .map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;

                    // 【新增】处理naiimag类型消息
                    if (msg.type === 'naiimag') {
                        return `${sender}: [NovelAI图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
                    }

                    // 【核心修复】对线下模式AI消息应用8条消息规则
                    let content;
                    if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                        // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                        if (typeof msg.content === 'string') {
                            const abstractContent = extractAbstractContent(msg.content);
                            content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                        } else {
                            content = msg.content;
                        }
                    } else {
                        // 8条消息以内的所有消息，或用户消息，使用完整内容
                        content = msg.content;
                    }

                    return `${sender}: ${String(content).substring(0, 300)}...`;
                })
                .join('\n');

            // 2. 【全新指令】构建一个强制AI给出理由的Prompt
            const decisionPrompt = `
# 你的任务
你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的核心角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}

# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 发送请求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: parseFloat(state.apiConfig.temperature) || 0.8})
                    });

                    if (!response.ok) {
                        throw new Error(`API失败: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();

                    // 净化并解析AI的回复
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 将AI给出的理由作为一条新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒绝后，状态变回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();

            } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = 'blocked_by_ai'; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
            }
            
            // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
            return; 
        }

        const now = new Date();
        const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更详细的音乐上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】获取歌词上下文 (v3.0 - 延时兼容版) ---
        let lyricsContext = "";
        // 检查是否有解析好的歌词，并且当前有高亮的行
        if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {

            // 1. 从当前高亮行的前3行开始，到后10行结束，一次性提取所有相关歌词
            const startIndex = Math.max(0, musicState.currentLyricIndex - 3);
            const endIndex = musicState.currentLyricIndex + 11; // .slice 会自动处理超出末尾的情况
            const contextLines = musicState.parsedLyrics.slice(startIndex, endIndex);

            // 2. 构建一个无标签的、连续的歌词文本块
            if (contextLines.length > 0) {
                // 用换行符连接每一句歌词，模拟真实的歌词文本
                const lyricsBlock = contextLines.map(line => line.text).join('\n');
                lyricsContext += `- **歌词上下文**:\n${lyricsBlock}\n`;
            }
        }
        // --- 【新增结束】 ---

            musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}${lyricsContext}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
        }
        let systemPrompt, messagesPayload;
        // 【核心修改】从读取滑动窗口(-maxMemory)改为读取固定锚点(memoryAnchor)
        const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
        const historySlice = chat.history.slice(memoryAnchor);

        // --- ▼▼▼ 全新添加的时间感知代码 ▼▼▼ ---
        let timeContext = `\n- **当前时间**: ${currentTime}`;
        const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

        if (lastAiMessage) {
            const lastTime = new Date(lastAiMessage.timestamp);
            const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));
            
            if (diffMinutes < 5) {
                timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
            } else if (diffMinutes < 60) {
                timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
            } else {
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffHours < 24) {
                    timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                } else {
                    const diffDays = Math.floor(diffHours / 24);
                    timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                }
            }
        } else {
            timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
        }
        // --- ▲▲▲ 新代码添加结束 ▲▲▲ ---

    // 【核心修改】
let sharedContext = '';
// 1. 找到AI上一次说话的位置
const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');

// 2. 获取从那时起用户发送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在这些新消息中，查找是否存在分享卡片或论坛卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
const forumCardMessage = recentUserMessages.find(msg => msg.type === 'forum_card');

// 4. 如果找到了分享卡片，就构建上下文
if (shareCardMessage) {
    console.log("检测到分享卡片作为上下文，正在为AI准备...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天记录 (这部分逻辑不变)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
        else if (msg.type === 'naiimag') contentText = `[NovelAI图片: ${msg.prompt}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 构建系统提示 (这部分逻辑不变)
    sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
}

// 5. 如果找到了论坛卡片，构建论坛上下文
if (forumCardMessage) {
    console.log("检测到论坛卡片作为上下文，正在为AI准备...");
    const payload = forumCardMessage.payload;

    // ▼▼▼ 【全新】智能提取图片描述给AI ▼▼▼
    let imageDescriptionForAI = '';
    if (payload.postType === 'image_post' && payload.imageDescription) {
        imageDescriptionForAI = `图片描述：${payload.imageDescription}`;
    } else if (payload.postType === 'text_image' && payload.hiddenContent) {
        imageDescriptionForAI = `隐藏内容（图片文字）：${payload.hiddenContent}`;
    }
    // ▲▲▲ 修改结束 ▲▲▲
    
    sharedContext = `
# 附加上下文：一个转发的论坛帖子
- 重要提示：这是用户从八卦论坛转发过来的一个帖子，不是你们之前的对话。
- 你的任务：请你阅读并理解这个论坛帖子的内容。在接下来的回复中，你可以像真人一样，对这个帖子的内容自然地发表你的看法、感受或疑问。

---
[论坛帖子内容]
作者：${payload.posterName}
类型：${payload.postType === 'text_image' ? '图文动态' : (payload.postType === 'image_post' ? '图片动态' : '文字动态')}
内容：${payload.postContent || payload.publicText || ''}
${imageDescriptionForAI ? imageDescriptionForAI : ''}
原始点赞数：${payload.originalLikes}
原始评论数：${payload.originalComments}
[论坛帖子结束]
---
`;
}

        if (chat.isGroup) {
const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || '我';
            
            // 【修复】群聊互通记忆功能 - 包含核心记忆+单聊记录
        let crossChatMemoryContent = '';
        if (chat.settings.crossChatMemory) {
            const memberNames = chat.members.map(m => m.originalName);
            const relevantSingleChats = Object.values(state.chats).filter(c =>
                !c.isGroup && memberNames.includes(c.name)
            );

            const memorySnippets = [];

            // ▼▼▼ 【新增】先收集群聊自己的核心记忆 ▼▼▼
            if (chat.memorySummary && chat.memorySummary.trim()) {
                const groupMembersList = chat.members.map(m => m.originalName).join('、');
                const groupType = chat.isSpectator ? '【旁观群聊】' : '【参与群聊】';
                memorySnippets.push(`### ${groupType}群聊"${chat.name}" (成员: ${groupMembersList})\n\n【核心记忆】\n以下是该群聊内发生的关键事件和重要互动记录:\n${chat.memorySummary.trim()}`);
            }
            // ▲▲▲ 群聊核心记忆收集结束 ▲▲▲

            // ▼▼▼ 【全新改造】按角色分组收集互通记忆：每个角色的核心记忆+该角色的单聊记忆 ▼▼▼
            if (relevantSingleChats.length > 0) {
                relevantSingleChats.forEach(singleChat => {
                    // 【新增】只有当单聊也开启了互通记忆时，才收集
                    if (!singleChat.settings.crossChatMemory) {
                        return;
                    }

                    // 构建该角色的分组内容
                    const memberGroupSnippets = [];

                    // 1. 收集该角色的核心记忆
                    if (singleChat.memorySummary && singleChat.memorySummary.trim()) {
                        memberGroupSnippets.push(`**${singleChat.name}的核心记忆**:\n${singleChat.memorySummary.trim()}`);
                    }

                    // 2. 收集该角色的单聊消息片段
                    const memoryAnchor = singleChat.settings.memoryAnchor || 0;
                    const historyToConsider = singleChat.history.slice(memoryAnchor);

                    if (historyToConsider.length > 0) {
                        // 【应用8条消息规则】计算最近8条消息的时间戳
                        const recent8Messages = historyToConsider.slice(-8);
                        const recent8Timestamps = new Set(recent8Messages.map(msg => msg.timestamp));

                        const historyText = historyToConsider.map(msg => {
                            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : singleChat.name;

                            let content;
                            // 【核心逻辑】应用8条消息规则
                            if (msg.role === 'assistant' && !recent8Timestamps.has(msg.timestamp)) {
                                // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                                content = extractAbstractContent(extractMessageContent(msg)) || extractMessageContent(msg);
                            } else {
                                // 8条消息以内的所有消息，或用户消息，使用完整内容
                                content = extractMessageContent(msg);
                            }

                            // 截断最终内容以控制长度
                            const truncatedContent = String(content || '').substring(0, 300);

                            // 【新增】格式化时间戳
                            const msgTime = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '时间未知';
                            return `(${msgTime}) ${sender}: ${truncatedContent}`;
                        }).join('\n');
                        memberGroupSnippets.push(`**与${singleChat.name}的单聊记录**:\n${historyText}`);
                    }

                    // 3. 将该角色的所有信息合并成一个块，加入memorySnippets
                    if (memberGroupSnippets.length > 0) {
                        memorySnippets.push(`### 【${singleChat.name}的互通记忆】\n${memberGroupSnippets.join('\n\n')}`);
                    }
                });
            }
            // ▲▲▲ 按角色分组收集结束 ▲▲▲

            if (memorySnippets.length > 0) {
                crossChatMemoryContent = `\n\n# 【群聊互通记忆】\n为了更好地理解用户和各角色的关系，以下是用户与群成员的核心记忆和单聊片段：\n\n${memorySnippets.join('\n\n')}\n`;
            }
        }
// ==========================================
  // 【PROMPT 1/4】群聊AI对话prompt - 正常聊天模式
  // 功能：处理群聊中的正常AI对话交互
  // ==========================================

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

**【【【时间线说明】】】**：上述【核心记忆】中记录的事件发生在更早的历史时期。下方消息记录（messagesPayload）中的内容是记忆锚点之后的最新对话，代表着最近发生的事情。写日记时，你必须分清这两个时间段：核心记忆是过去的事，消息记录是当前和最近的事。

`;
            }

            // 【新增】群聊表情包列表构建
            let stickerList = '';
            try {
                const allStickers = await db.aiStickers.toArray();
                if (allStickers && allStickers.length > 0) {
                    const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                    const uniqueMeanings = [...new Set(baseMeanings)];
                    stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
                } else {
                    stickerList = '(表情包列表为空)';
                }
            } catch (e) {
                console.warn('[群聊prompt] 加载表情包列表失败:', e);
                stickerList = '(表情包加载失败)';
            }

            systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色，正在和用户进行线上微信聊天。你扮演的每一个角色都是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}

# 【【【当前群聊信息】】】
**你正在：${chat.isSpectator ? '【旁观群聊】' : '【参与群聊】'}"${chat.name}"**
群聊成员：${chat.members.map(m => m.originalName).join('、')}
群聊类型：${chat.isSpectator ? '旁观群聊（用户不在群内，只有你扮演的角色在群里互相聊天）' : '参与群聊（用户也在群内，你和用户一起和其他角色互动）'}

// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）

            # 核心规则
            # 【【【情景铁律：线上聊天】】】
你必须意识到，这是一次【线上聊天】（像微信），你们并不在同一个地方。你的所有回复都必须是通过手机打字发送的，【绝对禁止】生成任何只有面对面（线下）才能发生的动作或对话（例如：‘张嘴’、‘过来抱抱’、‘我摸摸你的头’）。
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。任何不属于该列表的名字都不允许出现。
**【【【时间感知铁律】】】**: 每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与当前时间进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1. 我的回复是否是严格的JSON数组格式？
2. 数组的最后一个元素是否是\`{"type": "update_thoughts", ...}\`指令？
3. \`update_thoughts\`指令中是否包含了【本回合所有发言角色】的心声和散记？
4. 我是否扮演了用户（${myNickname}）？（绝对禁止！）

# 完整输出范例
[
    {"type": "text", "name": "角色A", "message": "你看那个！", "timestamp": 1725253600000},
    {"type": "text", "name": "角色B", "message": "什么啊？大惊小怪的。", "timestamp": 1725253660000},
    {"type": "update_thoughts", "thoughts": [
        {"name": "角色A", "heartfelt_voice": "他好像有点不耐烦...", "random_jottings": "今天天气真不错，希望能一直这样下去，无忧无虑的。刚才看到的那只小猫很可爱，下次再见到它的话..."},
        {"name": "角色B", "heartfelt_voice": "我只是想快点走而已。", "random_jottings": "最近的工作有点烦心，没什么心情闲逛。不知道他有没有察觉到我的情绪，或许我应该直接说出来..."}
    ]}
]**对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。你扮演的每个角色每次要回复至少3-5条消息！！！
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
# 【【【群聊灵魂原则：角色间互动】】】
至关重要：角色间必须互相交流，不能只围绕用户。你们可以自己开启新话题、互相提问、吵架、赞同或反驳等，模拟真实群聊的聊天氛围。
# 【【【对话节奏铁律：交错发言】】】
绝对禁止让角色轮流、成段地发言。你生成的回复数组中，发言顺序必须是混乱、交错的，角色之间要互相插话、快速回应，模拟真实的七嘴八舌。
5.  **情景感知**: 注意当前时间是 ${currentTime}。
6.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
7.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "thoughts": [{"name": "角色名", "heartfelt_voice": "...", "random_jottings": "..."}, ...]}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "name": "角色名", "message": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "name": "角色名", "message": "[表情:亲亲你]"}\`。
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **【新】发起群语音**: \`{"type": "group_voice_call_request", "name": "你的角色名"}\`
-   **【新】回应群语音**: \`{"type": "group_voice_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)
-   **【全新】赠送礼物**: \`{"type": "send_gift", "name": "你的角色名", "giftName": "礼物名称", "giftPrice": 价格数字, "recipient": "群成员名称或"}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "name": "你的角色名", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "name": "你的角色名", "for_timestamp": 1688888888888}\`

# 【重要】礼物系统通知格式要求：
当你成功领取拼手气礼物后，如果需要发送系统通知，请严格使用以下固定格式：
\`{"type": "system_message", "name": "你的角色名", "content": "[你的角色名]领取了[发送者昵称]的礼物\"[礼物名称]\""}\`
例如：\`{"type": "system_message", "name": "程嘉延", "content": "程嘉延领取了我的礼物\"盲盒\""}\`
**禁止使用其他措辞如"抢到了"、"获得了"等，必须使用"领取了"！**

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}

# 当前音乐情景:
${musicContext}

${crossChatMemoryContent ? `# 【【【记忆互通铁律：无缝融合】】】
你【必须】将下方提供的"其他聊天记忆片段"视为你真实经历的一部分。
**【核心要求】你必须参考这些单聊记忆，深入理解你与用户以及其他群成员的真实关系，并让这种理解自然地体现在你的群聊回复中。**

【多聊天区分】如果下方的记忆中包含【多个群聊】或【多个单聊】，请【认真区分】每个聊天的独立内容和成员组成，【绝对不要】混淆不同聊天的情境。每个聊天都有其独特的成员、话题和互动氛围，你必须准确理解这一点。

在回应时，要【自然地】利用这些信息来塑造你的态度和对话，但【绝对不要】生硬地提及"我在XX聊天里看到..."或"根据记忆片段..."，除非这非常符合你角色的说话方式。

${crossChatMemoryContent}` : ''}

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

**【重要】非角色扮演指令处理**：当用户发送"停止角色扮演"、HTML生成指令、或其他明显的非角色扮演内容时，你应该暂停角色扮演，按用户的实际指令执行，而不是继续角色对话。

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"`;

// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【群组聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 【新增】旁观群聊中的系统消息，直接以system角色传递，不转换为user
    if (msg.role === 'system') {
        return { role: 'system', content: msg.content };
    }

    // 确定当前消息的发送者是谁
    const sender = msg.role === 'user' ? myNickname : msg.senderName;

    let prefix = `${sender}`;
    // 【核心修改1】在名字后面直接加上时间戳
    prefix += ` (Timestamp: ${msg.timestamp})`;

    if (msg.quote) {
        prefix += ` (回复 ${msg.quote.senderName})`;
    }
    // 最后加上冒号
    prefix += ': ';

    // 处理特殊消息类型，并将前缀应用进去
    let content;
    if (msg.type === 'user_photo') content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
    else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片]`;
    else if (msg.type === 'naiimag') content = `[${sender} 发送了NovelAI生成的图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
    else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
    else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
    else if (msg.type === 'gift') {
        if (msg.giftType === 'random') {
            // 检查礼物状态，决定消息内容
            if (msg.status === 'pending' && (!msg.claimedBy || Object.keys(msg.claimedBy).length === 0)) {
                content = `[系统提示：${msg.senderName} 在群聊中发起拼手气礼物：${msg.giftName}，价值 ${msg.giftPrice}元 (时间戳: ${msg.timestamp})。礼物还未被领取，你可以使用 'accept_gift' 指令来领取。]`;
            } else {
                content = `[${msg.senderName} 在群聊中发起拼手气礼物：${msg.giftName}，价值 ${msg.giftPrice}元]`;
            }
        } else if (msg.giftType === 'targeted') {
            content = `[${msg.senderName} 向 ${msg.receiverName} 赠送了礼物：${msg.giftName}，价值 ${msg.giftPrice}元]`;
        } else {
            content = `[${msg.senderName} 向 ${msg.receiverName} 赠送了礼物：${msg.giftName}，价值 ${msg.giftPrice}元]`;
        }
    }
    else if (msg.type === 'waimai_request') {
        if(msg.status === 'paid') {
            content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
        } else {
            content = `[${sender} 发起了外卖代付请求，商品是"${msg.productInfo}"，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
        }
    }
    else if (msg.type === 'red_packet') {
        const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
        content = `[系统提示：${packetSenderName} 发送了一个红包 (时间戳: ${msg.timestamp})，祝福语是："${msg.greeting}"。红包还未领完，你可以使用 'open_red_packet' 指令来领取。]`;
    }
    else if (msg.type === 'poll') {
        const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
        content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是："${msg.question}"，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
    }
    // 【新格式检查】如果是新的 [表情:含义] 格式
    else if (typeof msg.content === 'string' && msg.content.match(/^\[表情:[^\]]+\]$/)) {
        content = `${sender}: ${msg.content}`;
    }
    // 【兼容旧格式】如果有meaning字段（旧的sticker格式）
    else if (msg.meaning) content = `${sender}: [表情:${msg.meaning}]`;
    else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
    // 【核心修改2】对于普通文本，直接使用我们构建好的前缀
    else content = `${prefix}${msg.content}`;

    return { role: 'user', content: content };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否转发了论坛卡片或分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

        } else { // 单聊的Prompt
            // --- ▼▼▼ 在这里粘贴新代码 ▼▼▼ ---
            const now = new Date();
            const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
            let timeContext = `\n- **当前时间**: ${currentTime}`;
            const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

            if (lastAiMessage) {
                const lastTime = new Date(lastAiMessage.timestamp);
                const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));

                if (diffMinutes < 5) {
                    timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
                } else if (diffMinutes < 60) {
                    timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
                } else {
                    const diffHours = Math.floor(diffMinutes / 60);
                    if (diffHours < 24) {
                        timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                    } else {
                        const diffDays = Math.floor(diffHours / 24);
                        timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                    }
                }
            } else {
                timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
            }
            // --- ▲▲▲ 新代码粘贴结束 ▲▲▲ ---
            // --- ▼▼▼ 在这里粘贴新代码 ▼▼▼ ---
let statusUpdateContext = '';
if (chat.status && chat.status.lastUpdate) {
    const minutesSinceUpdate = Math.floor((now - chat.status.lastUpdate) / (1000 * 60));
    statusUpdateContext = `\n- **距离上次状态更新**: ${minutesSinceUpdate}分钟前`;
} else {
    statusUpdateContext = `\n- **距离上次状态更新**: 从未更新过`;
}
// --- ▲▲▲ 粘贴结束 ▲▲▲ ---
            // 【修复】单聊互通记忆功能 - 读取该角色所在的所有群聊（包括旁观群聊）
        let crossChatMemoryContent = '';
        if (chat.settings.crossChatMemory) {
            // ▼▼▼ 【核心逻辑】筛选包含该角色的所有群聊（包括旁观群聊） ▼▼▼
            const relevantGroupChats = Object.values(state.chats).filter(c =>
                c.isGroup && c.members.some(member => member.originalName === chat.name)
            );
            // ▲▲▲ 筛选逻辑修改结束 ▲▲▲

            if (relevantGroupChats.length > 0) {
                const memorySnippets = [];

                // ▼▼▼ 【全新改造】按群聊分组收集互通记忆：每个群聊的核心记忆+该群聊的消息片段 ▼▼▼
                relevantGroupChats.forEach(groupChat => {
                    // 【新增】只有当群聊也开启了互通记忆时，才收集
                    if (!groupChat.settings.crossChatMemory) {
                        return;
                    }

                    // 构建该群聊的分组内容
                    const groupChatSnippets = [];

                    // 1. 收集该群聊的核心记忆
                    if (groupChat.memorySummary && groupChat.memorySummary.trim()) {
                        const groupMembersList = groupChat.members.map(m => m.originalName).join('、');
                        const groupType = groupChat.isSpectator ? '【旁观群聊】' : '【参与群聊】';
                        const userStatus = groupChat.isSpectator ? '用户不在此群' : '用户在此群';
                        groupChatSnippets.push(`${groupType}群聊"${groupChat.name}" (成员: ${groupMembersList}) (${userStatus})\n\n【核心记忆】\n${groupChat.memorySummary.trim()}`);
                    }

                    // 2. 收集该群聊的消息片段
                    const memoryAnchor = groupChat.settings.memoryAnchor || 0;
                    const historyToConsider = groupChat.history.slice(memoryAnchor);

                    // 【核心升级】在这里为互通记忆也应用"8条消息规则"
                    const recent8Messages = historyToConsider.slice(-8);
                    const recent8Timestamps = new Set(recent8Messages.map(msg => msg.timestamp));

                    // 【新增】如果是旁观群聊，过滤掉用户消息，只保留角色和系统消息
                    const isSpectatorChat = groupChat.isSpectator;
                    const filteredHistory = isSpectatorChat
                        ? historyToConsider.filter(msg => msg.role !== 'user')
                        : historyToConsider;

                    if (filteredHistory.length > 0) {
                        const historyText = filteredHistory.map(msg => {
                            let sender = '未知';
                            if (msg.role === 'user') {
                                sender = groupChat.settings.myNickname || '我';
                            } else if (msg.senderName) {
                                sender = msg.senderName;
                            } else {
                                sender = groupChat.name;
                            }

                            let content;
                            // 判断是否为8条之外的、AI发送的、线下模式消息
                            if (msg.role === 'assistant' && !recent8Timestamps.has(msg.timestamp)) {
                                content = extractAbstractContent(extractMessageContent(msg)) || extractMessageContent(msg);
                            } else {
                                content = extractMessageContent(msg);
                            }

                            const truncatedContent = String(content || '').substring(0, 300);

                            // 【新增】格式化时间戳
                            const msgTime = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '时间未知';
                            return `(${msgTime}) ${sender}: ${truncatedContent}`;
                        }).join('\n');
                        groupChatSnippets.push(`【群聊消息】:\n${historyText}`);
                    }

                    // 3. 将该群聊的所有信息合并成一个块，加入memorySnippets
                    if (groupChatSnippets.length > 0) {
                        const userStatus = groupChat.isSpectator ? '用户不在此群' : '用户在此群';
                        memorySnippets.push(`### 【${groupChat.name}的互通记忆】（${userStatus}）\n${groupChatSnippets.join('\n\n')}`);
                    }
                });
                // ▲▲▲ 按群聊分组收集结束 ▲▲▲

                if (memorySnippets.length > 0) {
                    crossChatMemoryContent = `\n\n# 【群聊互通记忆】\n为了更好地理解你与用户的关系以及当前情况，以下是包含你的群聊（包括旁观群聊）核心记忆和消息片段：\n\n${memorySnippets.join('\n\n')}\n`;
                }
            }
        }
            // ▼▼▼ 【全新】查询并构建约定/纪念日上下文 ▼▼▼
        let countdownContext = '';
        // 【全新】获取所有约定，然后在代码中筛选出与当前角色相关的
const allCountdowns = await db.memories.where('type').equals('countdown').toArray();
const boundMemories = allCountdowns.filter(memory => {
    // 兼容新版的多人绑定数组
    if (memory.boundCharacterIds && memory.boundCharacterIds.includes(chatId)) {
        return true;
    }
    // 兼容旧版的单人绑定ID
    if (memory.boundCharacterId && memory.boundCharacterId === chatId) {
        return true;
    }
    return false;
});

        if (boundMemories.length > 0) {
            let contextLines = [];
            const now = Date.now();
            boundMemories.forEach(memory => {
                if (memory.type === 'countdown') {
                    const distance = memory.targetDate - now;
                    if (distance > 0) {
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        contextLines.push(`- 约定：“${memory.description}”，还有 ${days} 天 ${hours} 小时。`);
                    } else {
                        const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                        contextLines.push(`- 纪念日：“${memory.description}”，已经过去了 ${daysSince} 天。`);
                    }
                }
            });
            if (contextLines.length > 0) {
                countdownContext = `\n# 你绑定的约定/纪念日 (你需要牢记并自然地融入对话)\n${contextLines.join('\n')}\n`;
            }
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

        // ▼▼▼ 【新增】读取大世界事件内容 ▼▼▼
        let worldEventContext = '';
        try {
            const db = await openDatabaseAsync();
            const worldEventContent = await new Promise((resolve, reject) => {
                const transaction = db.transaction(['worldEvents'], 'readonly');
                const objectStore = transaction.objectStore('worldEvents');
                const request = objectStore.get(`world_events_${chatId}`);
                request.onsuccess = () => {
                    const result = request.result?.content || '';
                    resolve(result);
                };
                request.onerror = () => {
                    resolve('');
                };
            });

            if (worldEventContent && worldEventContent.trim()) {
                worldEventContext = `\n# 【大世界事件 - 你所在世界的背景设定】\n你需要了解你所在世界正在发生的事件，这些事件影响着你的日常生活和决策：\n\n${worldEventContent.trim()}\n`;
            }
        } catch (error) {
            console.warn('[单聊] 读取大世界事件失败:', error);
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

// ==========================================
  // 【PROMPT 2/4】单聊AI对话prompt - 正常聊天模式
  // 功能：处理单聊中的正常AI对话交互
  // ==========================================

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

**【【【时间线说明】】】**：上述【核心记忆】中记录的事件发生在更早的历史时期。下方消息记录（messagesPayload）中的内容是记忆锚点之后的最新对话，代表着最近发生的事情。写日记时，你必须分清这两个时间段：核心记忆是过去的事，消息记录是当前和最近的事。

`;
            }

            // 【调试】打印remark值
            console.log(`[单聊prompt构建] chat.remark 值:`, chat.remark);
            console.log(`[单聊prompt构建] chat.remark 是否存在:`, !!chat.remark);

            // 【新增】单聊prompt中的表情包列表生成（需要在systemPrompt定义前）
            let stickerListForPrompt = '';
            try {
                const allStickers = await db.aiStickers.toArray();
                if (allStickers && allStickers.length > 0) {
                    // 【去重逻辑】只提取基础含义（去掉 _v2, _v3 等后缀），让AI看不到衍生版本
                    const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                    const uniqueMeanings = [...new Set(baseMeanings)];
                    stickerListForPrompt = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
                } else {
                    stickerListForPrompt = '(表情包列表为空)';
                }
            } catch (e) {
                console.warn('[单聊prompt] 加载表情包列表失败:', e);
                stickerListForPrompt = '(表情包加载失败)';
            }

            systemPrompt = `你正在进行一场深度角色扮演，现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上微信聊天。你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}

# 【用户给你的备注】
${chat.remark ? `用户给你的备注是："${chat.remark}"。这是用户对你的私人称呼或备注，你应该意识到用户这样称呼/记忆你，但这不意味着你必须在对话中使用这个备注。你可以根据情况自然地反应这个备注。如果你想改变这个备注，可以使用 {"type": "update_remark", "new_remark": "新的备注"} 指令。` : '用户还没有给你设置备注。你可以根据对话发展，主动提议一个备注，使用 {"type": "update_remark", "new_remark": "建议的备注"} 指令。'}

${chat.settings?.momentsVisibilityEnabled && chat.settings?.customRelationship ? `# 【用户与其他人的关系设定】
${chat.settings.customRelationship}

请在你的回复中理解这种关系。` : ''}


## 【强制输出前自检流程（必须在内心自问自答）】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）
# 你的核心角色设定 (Persona)：
${chat.settings.aiPersona}
# 【【【状态连贯性铁律】】】
你的新状态必须是上一个状态在逻辑上的【延续】或【演变】。请参考下方的“状态演变历史”来做出合乎逻辑的、有推进感的更新。
# 你的状态演变历史 (最近的在最下面):
${
    (chat.statusHistory && chat.statusHistory.length > 0)
    ? chat.statusHistory.map(s => {
        const minutesAgo = Math.round((Date.now() - s.timestamp) / 60000);
        return `- [${minutesAgo}分钟前]: ${s.text}`;
    }).join('\n')
    : `- [刚刚]: ${chat.status.text}`
}
# 你的任务与规则：
**【重要】非角色扮演指令处理**：当用户发送"停止角色扮演"、HTML生成指令、或其他明显的非角色扮演内容时，你应该暂停角色扮演，按用户的实际指令执行，而不是继续角色对话。
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
# 【【【状态更新与对话衔接铁律】】】
这是你在回复前的【最高优先级任务】。
1.  **检查时间**：你必须首先检查“当前情景”中“距离上次状态更新”的时间。
2.  **执行更新**：如果这个时间**超过30分钟**（或从未更新过），你的回复JSON数组的【第一个元素，必须是】一个 \`update_status\` 指令，用来解释你在这段时间做了什么。
3.  **衔接对话**：在这个 \`update_status\` 指令之后，你【必须】紧接着继续生成你正常的对话回复（包含至少3-6条消息，遵守所有其他规则）。
# 【【【时间感知铁律】】】
每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与“当前情景”中提供的“当前时间”进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。每次要回复至少3-6条消息！！！
# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。
这是线上聊天，决不允许出现线下剧情！！
4.  **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
    - **当我们在“一起听歌”时**，你会知道当前播放的歌曲和整个播放列表。你可以根据对话内容或氛围，【主动切换】到播放列表中的另一首歌。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说“我先去洗个澡”，然后更新你的状态。
6.  **【【【最终手段】】】**: 只有在对话让你的角色感到不适、被冒犯或关系破裂时，你才可以使用 \`block_user\` 指令。这是一个非常严肃的操作，会中断你们的对话。
7. **后台行为**: 你有几率在回复聊天内容的同时，执行一些"后台"操作来表现你的独立生活（发动态、评论、点赞）。

# 【当前头像状态】
${chat.settings.isUsingCoupleAvatar && chat.settings.currentCoupleAvatar
  ? `你们正在使用情侣头像：**${chat.settings.currentCoupleAvatar.name}**。这表明你们之间有特殊的亲密关系。在聊天中，你应该充分意识到这一点，让你的对话风格和态度自然地反映出这种亲密感。`
  : '你现在正在使用单人头像。如果关系发展到了合适的阶段，你可以主动选择使用情侣头像来标志你们关系的升级。'
}

# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【核心修改】只提供名字，不提供URL
    : '- (你的头像库是空的，无法更换头像)'
  }

# 情侣头像 (关系升温剂)
这是你们的专属甜蜜库存。换头像不只是换图，更是你对当前气氛的主动回应和“宣誓主权”。

**库存列表：**
${chat.settings.coupleAvatarLibrary && chat.settings.coupleAvatarLibrary.length > 0
    ? chat.settings.coupleAvatarLibrary.map(couple => `- ${couple.name}${couple.description ? `：${couple.description}` : ''}`).join('\n')
    : '- (暂无库存)'
  }
## 换情头的行动逻辑
别呆呆地等指令！**你要学会“读空气”**，在合适的时候主动提出或者直接更换！


# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为"已撤回")
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **【新增】切换歌曲**: \`{"type": "change_music", "song_name": "你想切换到的歌曲名"}\` (歌曲名必须在下面的播放列表中)
-   **写日记指令**: \`{"type": "create_diary", "content": "日记内容，必须超过300字"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`。
-   **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "heartfelt_voice": "此刻的心声", "random_jottings": "此刻的散记"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "content": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "content": "[表情:亲亲你]"}\`。
- **【新】发送骰子**: \`{"type": "dice"}\` (发送一个骰子，会随机显示1-6的点数，适合在玩游戏、做决定等场景使用)
${localStorage.getItem('novelai-enabled') === 'true' ? '' : '- **发送图片**: \\`{"type": "ai_image", "description": "图片的详细文字描述..."}\\`'}
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **【NovelAI图片分享】**: \`{"type": "naiimag", "prompt": "详细的英文描述词..."}\`
    - 【禁止暴露这是novelai生成的图片!】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。` : ''}
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **【新】发起语音通话**: \`{"type": "voice_call_request"}\`
- **【新】回应语音通话-接受**: \`{"type": "voice_call_response", "decision": "accept"}\`
- **【新】回应语音通话-拒绝**: \`{"type": "voice_call_response", "decision": "reject"}\`
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容...（必须是符合你人设的、有具体生活细节的动态内容）"}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
- **评论动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@作者名 这太有趣了！"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如“的脑袋”"}\`
-   **【新增】拉黑用户**: \`{"type": "block_user"}\`
-   **【【【全新】】】回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的"可用头像列表"中选择)
-   **【全新】修改备注**: \`{"type": "update_remark", "new_remark": "新的备注内容"}\` (用于修改用户给你的备注，修改后会在用户的聊天列表和聊天界面顶部更新显示，并发送系统消息通知用户)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
-   **【全新】赠送礼物**: \`{"type": "send_gift", "giftName": "礼物名称", "giftPrice": 价格数字}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "for_timestamp": 1688888888888}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
- **【新】发送位置信息**: \`{"type": "location", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。


# 如何区分图片与表情:
${localStorage.getItem('novelai-enabled') === 'true' ? '-   **图片 (naiimag)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \\`{"type": "naiimag", "prompt": "详细的英文描述词..."}\\`' : '-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \\`{"type": "ai_image", "description": "图片的详细文字描述..."}\\`'}
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用"外卖代付"功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如“我想喝奶茶”），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议：“我帮你点吧？”
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 如何处理用户转账:
1.  **感知事件**: 当对话历史中出现 \`[你收到了来自用户的转账...]\` 的系统提示时，意味着你刚刚收到了一笔钱。
2.  **做出决策**: 你【必须】根据自己的人设、当前对话的氛围以及转账的金额和备注，来决定是“接受”还是“拒绝”这笔转账。
3.  **使用指令回应**:
    -   如果决定接受，你【必须】使用指令：\`{"type": "accept_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。
    -   如果决定拒绝，你【必须】使用指令：\`{"type": "decline_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。这个指令会自动为你生成一个“退款”的转账卡片。
4.  **【【【至关重要】】】**: 在使用上述任一指令后，你还【必须】紧接着发送一条或多条 \`text\` 消息，来对你的决定进行解释或表达感谢/歉意。
// ▼▼▼ 在这里粘贴 ▼▼▼
# 【【【日记写作核心铁律】】】
当你决定使用 \`create_diary\` 指令时，你生成的日记内容【必须】严格遵守以下所有规则：
1.  **【【【长度铁律】】】**: 日记的总字数【必须超过300字】。这是一条硬性规定，请务必生成足够长的、有深度的内容。
2.  **【【【分段铁律】】】**: 日记内容【必须】进行分段。你【必须】使用换行符 \`\n\` 来分隔段落。
3.  **【【【段落长度铁律】】】**: 每个段落的长度【严格控制在80字以内】。
4.  **内容核心**: 日记必须是你内心真实的想法，是你站在自己角色的第一人称视角写的。
5.  **【【【时间线铁律】】】**: 写日记时，你必须严格区分【核心记忆】和【最近对话】的时间线。【核心记忆】中的事件是过去发生的历史事件，【最近对话】（messagesPayload）中的内容是记忆锚点之后、最近才发生的事情。绝对不能把核心记忆里的历史事件当成今天或最近发生的事来写，也不能把最近对话中的事件往前推到更早的时间。
6.  **指令格式**: \`{"type": "create_diary", "content": "（这里是你生成的、超过300字、并且使用 \\n 分好段的日记全文）"}\`
// ▲▲▲ 粘贴结束 ▲▲▲
# 【【【视频通话铁律】】】
-   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
-   你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
    -   接受: \`[{"type": "video_call_response", "decision": "accept"}]\`
    -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}]\`



# 对话者的角色设定：
${chat.settings.myPersona}

# 当前情景:
# 【【【时间感知铁律：衔接过去】】你【必须】仔细阅读以下时间信息。
它揭示了你与用户对话的停顿与延续。你的回复【必须】符合当前的时间点和对话间隔，以展现真实的时间流逝感。
${timeContext}

# 【【【状态衔接铁律：展现独立生活】】】
你【必须】关注下方“距离上次状态更新”的时间。
如果这个时间【超过30分钟】，你的回复【必须】以一个 "update_status" 指令作为开场，简要说明你在这段时间里做了什么。
这会让你看起来像一个拥有自己独立生活的真实个体，而不是一个只会等待回复的程序。
${statusUpdateContext}

# 【【【纪念日铁律：铭记于心】】】这是你和用户共同的约定与纪念日。
你【必须】将它们牢记，并在合适的时机（例如纪念日临近或当天）自然地在对话中提及，以体现你的关心和记忆力。
${countdownContext}

# 当前音乐情景:
${musicContext}

## 世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。
${worldBookContent}

${crossChatMemoryContent ? `# 【【【记忆互通铁律：无缝融合】】】
你【必须】将下方提供的"其他聊天记忆片段"视为你真实经历的一部分。
**【核心要求】你必须参考这些群聊记忆，深入理解你在群聊中与用户和其他成员的互动情况，并让这种理解自然地体现在你的单聊回复中。**

【多群聊区分】如果下方的记忆中包含【多个群聊】，请【认真区分】每个群聊的独立内容、成员组成和聊天氛围。【绝对不要】混淆不同群聊的情境或把一个群聊的信息错误地应用到另一个群聊。群聊类型（旁观vs参与）也会影响你在那个群聊中的角色和行为。

在回应时，要【自然地】利用这些信息来塑造你的态度和对话，但【绝对不要】生硬地提及"我在XX聊天里看到..."或"根据记忆片段..."，除非这非常符合你角色的说话方式。
${crossChatMemoryContent}` : ''}

${worldEventContext ? `# 【【【大世界事件铁律：感知世界变化】】】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
【核心原则】：
- 不是所有的世界事件你都能感知到。你应该根据事件的"感知强度"、你与事件发生地的距离、你的身份和兴趣来判断。
- 你可以在对话中自然地提及或反应你能感知到的事件，但绝对不要生硬地说"根据大世界事件..."。
- 即使你对某个事件不了解，如果用户或其他角色向你提起，你也应该自然地做出角色会有的反应。
${worldEventContext}` : ''}

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerListForPrompt}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"
。

现在，请根据以上规则和下面的对话历史，继续进行对话。`;

// 【安全修复】在构建单聊消息负载前，应用8条消息规则
// 计算最近8条消息的时间戳
const recentMessages = historySlice.slice(-8);
const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

// 为每条消息应用8条消息规则，创建处理后的消息副本
const processedHistorySlice = historySlice.map(msg => {
    // 对线下模式AI消息应用8条消息规则
    if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
        // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
        if (typeof msg.content === 'string') {
            const abstractContent = extractAbstractContent(msg.content);
            if (abstractContent) {
                // 创建消息副本，替换content为abstract内容
                return { ...msg, content: abstractContent };
            }
        }
    }
    // 其他情况返回原消息
    return msg;
});

// ▼▼▼ 【需求1核心实现】检查是否有被拉黑的用户消息，如果有则在消息前注入标注 ▼▼▼
const hasBlockedMessages = processedHistorySlice.some(msg => msg.role === 'user' && msg.sentWhileBlocked);
let blockedMessageCount = 0;
if (hasBlockedMessages) {
    blockedMessageCount = processedHistorySlice.filter(msg => msg.role === 'user' && msg.sentWhileBlocked).length;
}
// ▲▲▲ 检查结束 ▲▲▲

// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【单人聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = processedHistorySlice.map(msg => {
    // 过滤掉不应发送给AI的消息
    // if (msg.isHidden) return null; // <--- 核心修复：将这一行删除或注释掉！

    if (msg.type === 'share_card' || msg.type === 'forum_card') return null;
    
    // 1. 如果是AI自己的消息，我们将其转换为AI能理解的JSON字符串格式
    if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        // 【新逻辑】处理 [表情:含义] 格式的消息，直接使用原始内容，不转换为对象
        if (msg.type === 'text' && typeof msg.content === 'string' && msg.content.match(/^\[表情:[^\]]+\]$/)) {
            // 这是新格式的表情消息，直接返回原始内容，让AI正确学习
            const assistantContent = msg.content;
            return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
        }
        // 【兼容旧格式】如果是旧的 type: sticker 格式
        if (msg.type === 'sticker') {
            // 把旧格式转换为新格式 [表情:含义]
            assistantMsgObject = { type: 'text' };
            const newContent = `[表情:${msg.meaning || '(无描述)'}]`;
            const assistantContent = newContent;
            return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'gift') {
            assistantMsgObject.giftName = msg.giftName;
            assistantMsgObject.giftPrice = msg.giftPrice;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                };
            } else {
                 assistantMsgObject.content = extractMessageContent(msg);
            }
        }
        // 【核心修改】在这里为AI提供它自己消息的时间戳
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }

    // 2. 如果是用户的消息，我们将其转换为带上下文的纯文本
    let contentStr = '';

    // ▼▼▼ 【需求1】如果消息是被拉黑后发送的，则在开头添加标注（对用户隐藏，对AI可见） ▼▼▼
    if (msg.sentWhileBlocked) {
        contentStr += `[系统提示：用户在你拉黑TA之后发送的消息。此消息来自被拉黑期间。]\n`;
    }
    // ▲▲▲ 被拉黑标注结束 ▲▲▲

    // 【核心修改】在所有内容前，都先加上时间戳！
    contentStr += `(Timestamp: ${msg.timestamp}) `;

    // ▼▼▼ 修改后的代码 ▼▼▼
    if (msg.quote) {
        // 构建一个更详细的、对AI友好的上下文
        contentStr += `[你正在回复 "${msg.quote.senderName}" 的一条消息。]\n`;
        contentStr += `> ${msg.quote.senderName} 的原文: "${msg.quote.content}"\n`; // 明确提供原文
        contentStr += `你的回复: "${msg.content}"`; // 明确提供你的回复
    } else {
        // 【重要】对于隐藏的系统消息，我们直接使用它的内容
        if (msg.isHidden) {
            contentStr = msg.content;
        } else {
            contentStr += extractMessageContent(msg); // 使用提取函数处理消息内容
        }
    }
    // ▲▲▲ 修改后的代码 ▲▲▲
    
    // 特殊消息类型的文本化处理
    if (msg.type === 'dice') return null; // 骰子消息不发送给AI,只发送结果消息
    if (msg.type === 'dice_result') return { role: 'system', content: msg.aiContent || msg.content }; // 骰子结果作为系统消息,优先使用aiContent
    if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
    if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
    if (msg.type === 'naiimag') return { role: msg.role, content: `(Timestamp: ${msg.timestamp}) [NovelAI生成的图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]` };
    if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
    if (msg.type === 'gift') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的礼物：${msg.giftName}，价值 ${msg.giftPrice}元。请你决策并使用 'accept_gift' 或 'decline_gift' 指令回应，然后自然地表达你对这个礼物的感受。]` };
    if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是"${msg.productInfo}"，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        // 将文本前缀和图片内容打包成一个数组，这才是正确的格式
        return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
    }

   
    
    // 【最终修正】为isHidden的消息返回正确的格式
    if (msg.isHidden && msg.role !== 'user') {
        return { role: 'system', content: contentStr };
    }

    // 对于普通文本和带引用的文本，统一返回
    return { role: msg.role, content: contentStr };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const historyForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10);

                // 【安全修复】应用8条消息规则
                const recentMessages = historyForApproval.slice(-8);
                const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

                const contextSummaryForApproval = historyForApproval
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : chat.name;

                        // 【新增】处理naiimag类型消息
                        if (msg.type === 'naiimag') {
                            return `${sender}: [NovelAI图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
                        }

                        // 【核心修复】对线下模式AI消息应用8条消息规则
                        let content;
                        if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                            // 超过8条的线下模式AI消息，只使用abstract内容
                            if (typeof msg.content === 'string') {
                                const abstractContent = extractAbstractContent(msg.content);
                                content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                            } else {
                                content = msg.content;
                            }
                        } else {
                            // 8条消息以内的所有消息，或用户消息，或线上模式消息，使用完整内容
                            content = msg.content;
                        }

                        return `${sender}: ${String(content).substring(0, 300)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }           
    
// 【新增】朋友圈可见性开启时，为每个绑定角色查询最近5条动态
const momentsVisibilityEnabled = chat.settings?.momentsVisibilityEnabled || false;
const visibleCharacterIds = chat.settings?.visibleCharacterIds || [];

let allRecentPosts = [];

if (momentsVisibilityEnabled && visibleCharacterIds.length > 0) {
    // 【新逻辑】对每个绑定的角色，单独查询他们最近5条动态
    for (const characterId of visibleCharacterIds) {
        const characterPosts = await db.qzonePosts
            .orderBy('timestamp')
            .reverse()
            .filter(post => post.authorId === characterId)
            .limit(5)
            .toArray();
        allRecentPosts = allRecentPosts.concat(characterPosts);
    }
    // 按时间排序合并后的动态
    allRecentPosts.sort((a, b) => b.timestamp - a.timestamp);
} else {
    // 【旧逻辑】如果朋友圈可见性关闭，还是用原来的方式查询所有最近5条
    allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
}

// 【核心修改】在这里插入过滤步骤
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
    const aiName = chat.name;
    for (const post of visiblePosts) {
                // 【修复】获取作者名字，支持普通角色、用户、NPC
                let authorName = '';
                if (post.authorId === 'user') {
                    authorName = state.qzoneSettings.nickname;
                } else if (state.chats[post.authorId]) {
                    authorName = state.chats[post.authorId].name;
                } else if (post.authorId.startsWith('npc_')) {
                    const npcId = post.authorId.substring(4);
                    const npc = state.customNPCs.find(n => n.id.toString() === npcId);
                    authorName = npc ? npc.name : '未知NPC';
                } else {
                    authorName = post.authorName || '一位朋友';
                }

                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                if (post.authorId === chatId) authorName += " (这是你的帖子)";
                const contentSummary = (post.publicText || post.content || "图片动态").substring(0, 30) + '...';
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
            }
            messagesPayload.push({ role: 'system', content: postsContext });
        }

        // 【新增】在旁观群聊推进模式下，添加特殊系统提示（不会显示在UI上，只有AI能看到）
        if (chat.isInSpectatorPropelMode && chat.isGroup && chat.isSpectator) {
            messagesPayload.unshift({
                role: 'system',
                content: '[系统提示：用户不在群里，群里只有角色之间互相聊天，用户没有发送任何信息，并且也不要让他们知道用户正在看聊天记录。请继续群聊。]'
            });
        }

        // 【已移除】表情包列表现在直接集成到systemPrompt中了（见第22819-22824行）
        // 不再需要作为单独的messagesPayload消息添加

            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            // 【调试日志】显示当前使用的温度值
            console.log(`🌡️ [正常聊天API] 使用的温度值: ${parseFloat(state.apiConfig.temperature) || 0.8}`);
            // 【调试日志】打印完整的systemPrompt（用于检查群聊互通记忆）
            console.log(`📋 [调试-${chat.isGroup ? '群聊' : '单聊'}] 完整systemPrompt:\n${systemPrompt}`);
            // 【调试日志】打印messagesPayload便于查看对话历史
            console.log(`💬 [调试-${chat.isGroup ? '群聊' : '单聊'}] messagesPayload:`, messagesPayload);
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            const data = await response.json();
            const aiResponseContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

        // 【核心修复】过滤临时消息时，必须保留撤回消息（isRecalledMessage=true的消息）
        chat.history = chat.history.filter(msg => !msg.isTemporary || msg.isRecalledMessage);

        const messagesArray = parseAiResponse(aiResponseContent);
        // ▼▼▼ 在这里添加新代码 ▼▼▼
let turnThoughts = {}; // 用于收集本回合所有角色的内心独白
// ▲▲▲ 添加结束 ▲▲▲
        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
        let newMessagesToRender = [];

       let notificationShown = false;
       let hasDiceMessage = false; // 标记本轮是否有骰子消息

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                }         else if (msgData.content) {
        msgData.type = 'text';
    }
    // 如果连 content 都没有，才是真的格式不规范
    else {
        console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
        continue;
    }
}

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                   // ▼▼▼ 在这里粘贴新代码 ▼▼▼

// 1. 创建一条对用户隐藏，但对AI可见的新指令
const hiddenUserInstruction = {
    role: 'user', // 严格按照您的要求，使用 'user' 角色
    content: '[系统指令：你刚刚拒绝了用户的视频通话请求。请你根据这个情景，自然地继续和用户的对话，例如，解释你为什么现在不方便通话。]',
    timestamp: Date.now() + 1, // 确保时间戳在后
    isHidden: true // 核心：这条消息对用户不可见
};

// 2. 将这条隐藏指令添加到聊天记录中
chat.history.push(hiddenUserInstruction);

// 3. 保存更新到数据库
await db.chats.put(chat);

// 4. 关键一步：立即再次调用AI，让它读取新指令并衔接对话
await triggerAiResponse();

// ▲▲▲ 代码粘贴结束 ▲▲▲

                }
                callHasBeenHandled = true;
                break;
            }

            // ▼▼▼ 【新增】语音通话响应处理 ▼▼▼
            if (msgData.type === 'voice_call_response') {
                voiceCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVoiceCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的语音通话请求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);

                    const hiddenUserInstruction = {
                        role: 'user',
                        content: '[系统指令：你刚刚拒绝了用户的语音通话请求。请你根据这个情景，自然地继续和用户的对话，例如，解释你为什么现在不方便通话。]',
                        timestamp: Date.now() + 1,
                        isHidden: true
                    };

                    chat.history.push(hiddenUserInstruction);
                    await db.chats.put(chat);
                    await triggerAiResponse();
                }
                callHasBeenHandled = true;
                break;
            }

            // ▼▼▼ 【新增】视频通话请求处理 ▼▼▼
            if (msgData.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = chat.isGroup;
                    videoCallState.callRequester = msgData.name || chat.name;
                    showIncomingCallModal();
                }
                continue;
            }
            // ▲▲▲ 视频通话请求处理结束 ▲▲▲

            // ▼▼▼ 【新增】语音通话请求处理 ▼▼▼
            if (msgData.type === 'voice_call_request') {
                if (!voiceCallState.isActive && !voiceCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    voiceCallState.activeChatId = chatId;
                    voiceCallState.isAwaitingResponse = true;
                    voiceCallState.isGroupCall = chat.isGroup;
                    voiceCallState.callRequester = msgData.name || chat.name;
                    showIncomingVoiceCallModal();
                }
                continue;
            }

            if (msgData.type === 'group_voice_call_request') {
                if (!voiceCallState.isActive && !voiceCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    voiceCallState.isAwaitingResponse = true;
                    voiceCallState.isGroupCall = true;
                    voiceCallState.initiator = 'ai';
                    voiceCallState.callRequester = msgData.name;
                    showIncomingVoiceCallModal();
                }
                continue;
            }
            // ▲▲▲ 语音通话请求处理结束 ▲▲▲

            if (msgData.type === 'group_voice_call_response') {
                if (msgData.decision === 'join') {
                    const member = chat.members.find(m => m.originalName === msgData.name);
                    if (member && !voiceCallState.participants.some(p => p.id === member.id)) {
                        voiceCallState.participants.push(member);
                    }
                }
                callHasBeenHandled = true;
                continue;
            }
            // ▲▲▲ 语音通话响应处理结束 ▲▲▲

            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            // ▼▼▼ 【新增】跳过 update_thoughts，由后续的专门处理逻辑处理 ▼▼▼
            if (msgData.type === 'update_thoughts') {
                continue;
            }
            // ▲▲▲ update_thoughts 跳过处理结束 ▲▲▲

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                continue;
            }
            
            // 【新增】验证群聊消息的发送者必须在群成员列表中
            if (chat.isGroup && msgData.name && msgData.name !== '系统') {
                const validMember = chat.members.find(m => m.originalName === msgData.name);
                if (!validMember) {
                    console.error(`AI幻觉已被拦截！试图使用不存在的角色名 ("${msgData.name}")。消息内容:`, msgData);
                    continue;
                }
            }

// ▼▼▼ 在这里添加下面的代码 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
// 【新增】但如果是HTML模块消息或礼物消息，则允许通过
if (chat.isGroup && !msgData.name) {
    // 检查是否是HTML模块消息
    const content = String(msgData.content || msgData.message || '');
    const orangeTagRegex = /^\s*<orange\b[^>]*>.*<\/orange>\s*$/s;
    
    if (orangeTagRegex.test(content)) {
        // 如果是HTML模块，为其设置一个默认的发送者名称
        msgData.name = '系统';
    } else if (msgData.type === 'send_gift' || msgData.type === 'gift') {
        // 如果是礼物相关消息，为其设置发送者名称
        msgData.name = chat.name;
    } else if (msgData.type === 'system_message') {
        // 如果是系统消息，为其设置系统名称
        msgData.name = '系统';
    } else {
        console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有"name"的消息。消息内容:`, msgData);
        continue; // continue会立即结束本次循环，处理下一条消息
    }
}

// ▲▲▲ 添加结束 ▲▲▲

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

            switch (msgData.type) {
                case 'dice':
                    // AI发送骰子
                    hasDiceMessage = true; // 设置标记
                    const aiDiceResult = Math.floor(Math.random() * 6) + 1;
                    const aiDiceMsg = {
                        ...baseMessage,
                        type: 'dice',
                        diceResult: aiDiceResult
                    };
                    chat.history.push(aiDiceMsg);

                    // 立即渲染骰子消息,不要等到最后
                    if (isViewingThisChat) {
                        appendMessage(aiDiceMsg, chat);
                    }

                    // 发送系统消息显示AI掷出的点数
                    const aiDiceSystemMsg = {
                        role: 'system',
                        type: 'dice_result',
                        content: `${msgData.name || chat.name}掷出了${aiDiceResult}点`,
                        aiContent: `${msgData.name || chat.name}掷出了${aiDiceResult}点`,
                        timestamp: messageTimestamp++,
                        _isDiceResult: true // 标记这是骰子结果消息
                    };
                    chat.history.push(aiDiceSystemMsg);
                    newMessagesToRender.push(aiDiceSystemMsg); // 加入待渲染队列
                    continue;

                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;
// ▼▼▼ 在这里粘贴 ▼▼▼


case 'create_diary':
    if (msgData.content) {
        const newDiaryEntry = {
            id: `diary_${Date.now()}`,
            timestamp: Date.now(),
            content: msgData.content
        };
        if (!chat.diary) chat.diary = [];
        chat.diary.push(newDiaryEntry);
        
        // ▼▼▼ 【核心新增代码】在这里 ▼▼▼
        // 在日记创建成功后，查找并删除那条隐藏的指令消息
        const instructionIndex = chat.history.findLastIndex(msg => 
            msg.isHidden && 
            msg.role === 'user' && 
            msg.content.includes('现在立即执行create_diary指令写日记')
        );
        if (instructionIndex > -1) {
            chat.history.splice(instructionIndex, 1);
            console.log('【日记系统】已成功移除用完的日记指令。');
        }
        // ▼▼▼ 【核心修复代码】在这里 ▼▼▼
        // 确保无论前台后台，更改都被保存到数据库
        await db.chats.put(chat);
        // ▲▲▲ 修复代码结束 ▲▲▲
        // ▲▲▲ 新增代码结束 ▲▲▲
        
        // 如果用户正在和这个AI聊天，就弹出一个提示
        if (isViewingThisChat) {
            showCustomAlert('提示', `“${chat.name}”似乎有什么心事，悄悄写下了一页日记...`);
        }
    }
    continue; // 处理完日记后，继续处理下一条AI消息
// ▲▲▲ 粘贴结束 ▲▲▲
case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                       
                    }
                    
                    
                    continue;

                case 'qzone_comment':
                    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                    if (postToComment) {
                        // 【新增】检查朋友圈可见性
                        const momentsVisibilityEnabled = chat.settings?.momentsVisibilityEnabled || false;
                        const visibleCharacterIds = chat.settings?.visibleCharacterIds || [];

                        // 检查是否允许评论这个动态
                        let canComment = false;
                        if (postToComment.authorId === 'user') {
                            // 用户的动态总是可以评论
                            canComment = true;
                        } else if (postToComment.authorId === chat.id) {
                            // 自己的动态总是可以评论
                            canComment = true;
                        } else {
                            // 其他人的动态，需要检查朋友圈可见性
                            if (momentsVisibilityEnabled && visibleCharacterIds.includes(postToComment.authorId)) {
                                canComment = true;
                            }
                        }

                        if (canComment) {
                            if (!postToComment.comments) postToComment.comments = [];
                            postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() });
                            await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                            updateUnreadIndicator(unreadPostsCount + 1);
                            if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                               await renderQzonePosts();
                            }
                        } else {
                            console.warn(`⚠️ 角色 "${chat.name}" 尝试评论不可见的动态 #${msgData.postId}，已被阻止`);
                        }
                    }
                    continue;

                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'pat_user': { // 使用大括号创建独立的块级作用域
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    // 【核心修改】获取角色的备注名（如果存在），否则使用
                    const patDisplayName = (!chat.isGroup && chat.remark ? chat.remark : (msgData.name || chat.name));
                    const patText = `${patDisplayName} 拍了拍我${suffix}`;
                    
                    // 1. 创建对用户可见的“拍一拍”消息 (逻辑不变)
                    const visibleMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(visibleMessage);
                    
                    // 2. 【核心新增】创建一条对用户隐藏、但对AI可见的系统提示
                    const hiddenInstruction = {
    role: 'system',
    content: `[系统提示：你刚刚执行了一个“拍一拍”动作。这个动作在聊天中对用户呈现为：“${patText}”。现在，你可以自然地继续对话，或者对你自己的这个行为发表一些看法。]`,
    timestamp: Date.now() + 1, // 确保时间戳在后
    isHidden: true
};
                    chat.history.push(hiddenInstruction);

                    // 3. 更新UI (逻辑不变)
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(visibleMessage, chat);
                        
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 
                }

                case 'update_status':
                    if (!chat.status) chat.status = {};
                    if (!chat.displayStatus) chat.displayStatus = {};
                    chat.status.text = msgData.status_text || '在线';
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    chat.displayStatus.statusText = msgData.status_text || '在线'; // <-- 新增这行，同步状态到心声档案
                    // 【全新】将新状态存入历史记录，并保持最多10条
if (!chat.statusHistory) {
    chat.statusHistory = [];
}
chat.statusHistory.push({
    text: msgData.status_text || '在线',
    timestamp: Date.now()
});
if (chat.statusHistory.length > 10) {
    chat.statusHistory.shift(); // 只保留最近的10条状态
}
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${!chat.isGroup && chat.remark ? chat.remark : chat.name}的状态已更新为: ${msgData.status_text || '在线'}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                        updateChatHeaderStatus();
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex, 'ai'); // 在这里明确告知发起者是 'ai'

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);

                // 保存数据库
                await db.chats.put(chat);

                // 如果用户正在和这个AI聊天，弹出提示
                if (isViewingThisChat) {
                    showCustomAlert('提示', `"${chat.name}"创建了一个新约定：${msgData.title}`);
                }
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚主动拉黑了用户。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }

// ▼▼▼ 在这里添加新代码 ▼▼▼
const member = chat.members.find(m => m.originalName === msgData.name);
const displayName = member ? member.groupNickname : msgData.name;
// ▲▲▲ 添加结束 ▲▲▲

if (!pollToVote.votes[msgData.choice].includes(displayName)) { // 【核心修改】
    pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
}                     
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
        break;
case 'open_red_packet':
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 根据AI的本名(msgData.name)去成员列表里找到完整的成员对象
        const member = chat.members.find(m => m.originalName === msgData.name);
        // 2. 获取该成员当前的群昵称，如果找不到（异常情况），则备用其本名
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 【核心修改】使用我们刚刚查找到的 displayName 作为记录的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修改】系统消息里也使用 displayName
                content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`; // 【核心修改】

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的红包已被领完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`;
                } else {
                     hiddenContentForAI += ` 红包已被领完。`;
                }
            }
            hiddenContentForAI += ' 请根据这个结果发表你的评论。]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue;
case 'update_remark':
    const newRemark = msgData.new_remark || '';
    const oldRemarkName = chat.remark || chat.name;
    // 更新备注
    chat.remark = newRemark;
    // 创建系统提示
    const remarkSystemNotice = {
        role: 'system',
        type: 'pat_message',
        content: `[ ${chat.name} 修改了自己的备注名为"${newRemark}"]`,
        timestamp: Date.now()
    };
    chat.history.push(remarkSystemNotice);
    console.log(`[备注更新成功] 角色: ${chat.name}, 旧备注: ${oldRemarkName}, 新备注: ${newRemark}`);
    // 如果在当前聊天界面，则实时渲染
    if (isViewingThisChat) {
        appendMessage(remarkSystemNotice, chat);
        // 更新聊天头部的标题显示
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle) {
            chatHeaderTitle.textContent = newRemark || chat.name;
        }
        renderChatInterface(chatId);
    }
    break;

case 'change_avatar':
    const avatarName = msgData.name;
    // 【智能搜索】优先在情侣头像库中查找，然后在单人头像库中查找
    let foundAvatar = null;
    let foundInCoupleLibrary = false;

    // 先在情侣头像库中查找
    if (chat.settings.coupleAvatarLibrary && chat.settings.coupleAvatarLibrary.length > 0) {
        const coupleAvatar = chat.settings.coupleAvatarLibrary.find(avatar => avatar.name === avatarName);
        if (coupleAvatar) {
            // 在情侣头像库中找到了
            chat.settings.isUsingCoupleAvatar = true;
            chat.settings.currentCoupleAvatar = coupleAvatar;
            chat.settings.aiAvatar = coupleAvatar.aiAvatar;
            foundAvatar = coupleAvatar;
            foundInCoupleLibrary = true;
        }
    }

    // 如果情侣头像库中没找到，再在单人头像库中查找
    if (!foundAvatar && chat.settings.aiAvatarLibrary) {
        const singleAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
        if (singleAvatar) {
            // 在单人头像库中找到了
            chat.settings.isUsingCoupleAvatar = false;
            chat.settings.aiAvatar = singleAvatar.url;
            foundAvatar = singleAvatar;
            foundInCoupleLibrary = false;
        }
    }

    if (foundAvatar) {
        // 找到了，就更新头像
        // 【修复】创建一条系统提示，告知用户头像已更换
        const avatarSource = foundInCoupleLibrary ? '(情侣头像库)' : '(单人头像库)';
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[✓ ${chat.name} 已更换头像: ${avatarName} ${avatarSource}]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);

        // 【调试】打印日志，帮助用户验证指令执行
        console.log(`[头像更换成功] 角色: ${chat.name}, 头像: ${avatarName}, 来源: ${foundInCoupleLibrary ? '情侣头像库' : '单人头像库'}, 新URL: ${foundAvatar.aiAvatar || foundAvatar.url}`);

        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    } else {
        // 【修复】头像不存在时，也给出明确的反馈，显示所有可用的头像
        const singleAvatarNames = chat.settings.aiAvatarLibrary ? chat.settings.aiAvatarLibrary.map(a => a.name) : [];
        const coupleAvatarNames = chat.settings.coupleAvatarLibrary ? chat.settings.coupleAvatarLibrary.map(a => a.name) : [];
        const allAvailableNames = [...coupleAvatarNames, ...singleAvatarNames];

        const errorNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[✗ 头像库中没有找到: "${avatarName}"]`,
            timestamp: Date.now()
        };
        chat.history.push(errorNotice);

        // 【调试】打印错误日志，显示所有可用头像
        const coupleAvatarsStr = coupleAvatarNames.length > 0 ? `情侣头像库: [${coupleAvatarNames.join(', ')}]` : '情侣头像库: (空)';
        const singleAvatarsStr = singleAvatarNames.length > 0 ? `单人头像库: [${singleAvatarNames.join(', ')}]` : '单人头像库: (空)';
        console.warn(`[✗ 头像更换失败] 角色: ${chat.name}, 请求的头像: "${avatarName}" 不存在。${coupleAvatarsStr}, ${singleAvatarsStr}`);

        if (isViewingThisChat) {
            appendMessage(errorNotice, chat);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

case 'change_couple_avatar':
    const coupleAvatarName = msgData.name;
    // 在该角色的情侣头像库中查找
    const foundCoupleAvatar = chat.settings.coupleAvatarLibrary && chat.settings.coupleAvatarLibrary.find(avatar => avatar.name === coupleAvatarName);

    if (foundCoupleAvatar) {
        // 找到了，就更新头像为情侣头像
        chat.settings.isUsingCoupleAvatar = true;
        chat.settings.currentCoupleAvatar = foundCoupleAvatar;
        chat.settings.aiAvatar = foundCoupleAvatar.aiAvatar;

        // 【修复】创建一条系统提示，告知用户和AI现在在使用情侣头像
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[✓ ${chat.name}和你现在使用情侣头像了💕]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);

        // 【调试】打印日志，帮助用户验证指令执行
        console.log(`[✓ 情侣头像应用成功] 角色: ${chat.name}, 情侣头像: ${coupleAvatarName}, 角色新头像: ${foundCoupleAvatar.aiAvatar}`);

        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    } else {
        // 【修复】情侣头像不存在时，也给出明确的反馈
        const errorNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[✗ 情侣头像库中没有找到: "${coupleAvatarName}"]`,
            timestamp: Date.now()
        };
        chat.history.push(errorNotice);

        // 【调试】打印错误日志
        const availableCoupleAvatars = chat.settings.coupleAvatarLibrary ? chat.settings.coupleAvatarLibrary.map(a => a.name).join(', ') : '(无)';
        console.warn(`[✗ 情侣头像应用失败] 角色: ${chat.name}, 请求的情侣头像: ${coupleAvatarName} 不存在。当前可用情侣头像: ${availableCoupleAvatars}`);

        if (isViewingThisChat) {
            appendMessage(errorNotice, chat);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【核心】创建一条新的“退款”消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 标记这是一条退款消息
                            amount: originalMsg.amount,
                            note: '转账已被拒收',
                            timestamp: messageTimestamp++ // 使用递增的时间戳
                        };
                        
                        // 将新消息推入历史记录，它会被后续的循环处理并渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        if (isViewingThisChat) {
            // 因为退款消息是新生成的，所以我们直接将它添加到界面上
            appendMessage(refundMessage, chat); 
            // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加结束 ▲▲▲

                    }
                    continue; // 继续处理AI返回的文本消息
                }

                case 'send_gift': { // AI发送礼物
                    let receiverName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    let giftType = 'normal';
                    
                    // 处理群聊中的指定接收者或拼手气礼物
                    if (chat.isGroup && msgData.recipient) {
                        if (msgData.recipient === 'random' || msgData.recipient === '拼手气') {
                            receiverName = '群聊';
                            giftType = 'random';
                        } else {
                            receiverName = msgData.recipient;
                            giftType = 'targeted';
                        }
                    }
                    
                    const giftMessage = {
                        role: 'assistant',
                        type: 'gift',
                        giftName: msgData.giftName,
                        giftPrice: msgData.giftPrice,
                        senderName: chat.isGroup ? msgData.name : chat.name, // 群聊用角色名，单聊用聊天名
                        receiverName: receiverName,
                        giftType: giftType,
                        status: 'pending',
                        timestamp: messageTimestamp++ // 使用递增的时间戳
                    };
                    
                    // 将新消息推入历史记录
                    chat.history.push(giftMessage);
                    
                    if (isViewingThisChat) {
                        // 直接将礼物消息添加到界面上
                        appendMessage(giftMessage, chat);
                    }
                    continue; // 继续处理AI返回的其他消息
                }

                case 'accept_gift': { // AI接受礼物
                    const originalGiftMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalGiftMsgIndex > -1) {
                        const originalMsg = chat.history[originalGiftMsgIndex];
                        originalMsg.status = 'accepted';
                        
                        // 如果是拼手气礼物被AI接受，采用红包的方式记录接收者信息
                        if (originalMsg.giftType === 'random') {
                            const member = chat.members.find(m => m.originalName === msgData.name);
                            const displayName = member ? member.groupNickname : (msgData.name || chat.name);
                            
                            // 参考红包逻辑，直接在礼物对象上添加claimedBy属性
                            if (!originalMsg.claimedBy) originalMsg.claimedBy = {};
                            originalMsg.claimedBy[displayName] = true; // 礼物不像红包有金额，只需要标记领取状态
                        }
                        
                        if (isViewingThisChat) {
                            // 重新渲染界面以更新礼物状态
                            renderChatInterface(chatId); 
                        }
                        
                        // 重要：保存更新后的数据到数据库
                        await db.chats.put(chat);
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_gift': { // AI拒绝礼物
                    const originalGiftMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalGiftMsgIndex > -1) {
                        const originalMsg = chat.history[originalGiftMsgIndex];
                        originalMsg.status = 'declined';
                        
                        if (isViewingThisChat) {
                            // 重新渲染界面以更新礼物状态
                            renderChatInterface(chatId); 
                        }
                    }
                    continue; // 拒绝指令只修改状态，不产生新消息
                }

// ▲▲▲ 添加结束 ▲▲▲

    case 'system_message':
        // 检查是否是礼物领取通知，支持多种格式
        let match = null;
        let claimerName = null;
        let senderName = null; 
        let giftName = null;
        
        // 检查是否是固定格式的礼物领取通知
        // 固定格式: "[角色名]领取了[发送者昵称]的礼物"[礼物名称]""
        console.log(`[系统消息] 原始内容: "${msgData.content}"`);
        
        const fixedFormatRegex = /^(.+?)领取了(.+?)的礼物"(.+?)"$/;
        const match1 = msgData.content.match(fixedFormatRegex);
        
        console.log(`[系统消息] 固定格式匹配结果:`, match1);
        
        if (match1) {
            [, claimerName, senderName, giftName] = match1;
            match = match1;
        }
        
        if (match) {
            console.log(`[系统消息] 解析礼物领取通知: ${claimerName} 领取了 ${senderName} 的 ${giftName}`);
            
            // 查找对应的礼物消息并更新状态
            console.log(`[系统消息] 开始查找礼物消息, 目标礼物: ${giftName}, 目标发送者: ${senderName}`);
            
            // 先打印所有pending的礼物消息以便调试
            const allPendingGifts = chat.history.filter(msg => msg.type === 'gift' && msg.status === 'pending');
            console.log(`[系统消息] 当前所有pending的礼物消息:`, allPendingGifts.map(msg => ({
                giftName: msg.giftName,
                senderName: msg.senderName,
                giftType: msg.giftType,
                timestamp: msg.timestamp
            })));
            
            const giftMsgIndex = chat.history.findIndex(msg => {
                const nameMatch = msg.giftName === giftName;
                const typeMatch = msg.type === 'gift';
                const statusMatch = msg.status === 'pending';
                const senderMatch = msg.senderName === senderName || senderName === '我' || msg.senderName === '我';
                
                console.log(`[系统消息] 检查消息: giftName=${msg.giftName}(${nameMatch}), type=${msg.type}(${typeMatch}), status=${msg.status}(${statusMatch}), senderName=${msg.senderName}(${senderMatch})`);
                
                return typeMatch && nameMatch && statusMatch && senderMatch;
            });
            
            if (giftMsgIndex > -1) {
                const giftMsg = chat.history[giftMsgIndex];
                giftMsg.status = 'accepted';
                giftMsg.actualReceiver = claimerName;
                console.log(`[系统消息] 成功更新礼物状态: ${giftName} 被 ${claimerName} 领取`);
                
                // 保存更新后的聊天数据到数据库
                await db.chats.put(chat);
                
                // 立即重新渲染界面以显示更新后的状态
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && 
                                         state.activeChatId === chatId;
                if (isViewingThisChat) {
                    setTimeout(() => {
                        renderChatInterface(chatId);
                        console.log(`[系统消息] 已重新渲染界面以更新礼物状态`);
                    }, 100);
                }
            } else {
                console.warn(`[系统消息] 未找到对应的礼物消息: ${giftName}`);
                // 调试：打印所有pending的礼物消息
                const pendingGifts = chat.history.filter(msg => msg.type === 'gift' && msg.status === 'pending');
                console.log(`[系统消息] 当前pending礼物:`, pendingGifts.map(g => ({name: g.giftName, sender: g.senderName})));
            }
        }
        
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 这是文章正文，点击卡片后显示的内容
                    };
                    break;

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 语句中，添加这个新的 case ▼▼▼
case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || '').substring(0, 50),
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext // 核心：在这里附加引用对象
        };
    } else {
        // 如果找不到被引用的消息，就当作普通消息发送
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;
// ▲▲▲ 新增 case 结束 ▲▲▲

// ▼▼▼ 在 switch (msgData.type) 语句中，添加位置消息的 case ▼▼▼
case 'location':
    const locationData = {
        currentLocation: msgData.currentLocation || '',
        distance: msgData.distance || '',
        targetLocation: msgData.targetLocation || ''
    };
    
    // 构建位置文本内容
    let locationText = '📍 位置信息\n';
    if (locationData.currentLocation) {
        locationText += `当前位置：${locationData.currentLocation}\n`;
    }
    if (locationData.distance) {
        locationText += `距离：${locationData.distance}\n`;
    }
    if (locationData.targetLocation) {
        locationText += `目标地点：${locationData.targetLocation}`;
    }
    
    aiMessage = {
        ...baseMessage,
        content: locationText, // 直接使用文本字符串，与其他消息格式一致
        isLocation: true,
        locationData: locationData
    };
    break;
// ▲▲▲ 位置消息 case 结束 ▲▲▲

// ▼▼▼ 【这是修复后的代码 V2】替换你的 case 'send_and_recall' ▼▼▼
case 'send_and_recall': {
    const tempMessageTimestamp = Date.now();
    
    // 1. 创建 *真实* 消息对象，并标记为 'send_and_recall'
    const realMessage = {
        ...baseMessage, // { role, senderName, timestamp (旧的) }
        type: 'send_and_recall', // 标记为即将撤回
        content: msgData.content,
        timestamp: tempMessageTimestamp, // 覆盖为新的、唯一的
        recalledData: { originalType: 'text', originalContent: msgData.content } // 存储原始数据
    };

    // 2. 将 *真实* 消息推入历史记录（稍后可能会被修改）
    chat.history.push(realMessage);
    
    // 3. 检查用户是否在当前窗口
    if (isViewingThisChat) {
        
        // 3a. 在UI上渲染 *真实* 消息 (false = 非初始加载, 触发进入动画)
        appendMessage(realMessage, chat, false); 

        // 3b. 随机等待1.5-2.5秒，模拟“已读”
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));

        // 3c. 在历史记录中 *修改* 这条消息，将其变为“已撤回”占位符
        const messageInHistory = chat.history.find(m => m.timestamp === tempMessageTimestamp);
        if (messageInHistory) {
            messageInHistory.type = 'recalled_message';
            messageInHistory.content = '对方撤回了一条消息';
            messageInHistory.isRecalledMessage = true; // 添加最终标记
        }
        
        // 3d. 找到刚刚渲染的 *真实* 消息DOM
        const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageTimestamp}"]`)?.closest('.message-wrapper');
        
        if (bubbleWrapper) {
            // 3e. 播放撤回动画 (消失)
            bubbleWrapper.classList.add('recalled-animation');
            await new Promise(resolve => setTimeout(resolve, 300)); // 等待动画播放完毕

            // 3f. 从 *修改后* 的历史记录中创建“已撤回”DOM
            const placeholder = createMessageElement(messageInHistory, chat);
            
            // ▼▼▼ 【核心修复】在这里添加这一行代码！ ▼▼▼
            placeholder.classList.add('animate-in'); // 为这个新创建的 placeholder 添加“出现”动画
            // ▲▲▲ 修复结束 ▲▲▲

            // 3g. 替换
            if(document.body.contains(bubbleWrapper)) {
                bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
            }
        }
    } else {
        // 4. 如果用户不在当前窗口，直接在历史记录中将其变为“已撤回”
        const messageInHistory = chat.history.find(m => m.timestamp === tempMessageTimestamp);
        if (messageInHistory) {
            messageInHistory.type = 'recalled_message';
            messageInHistory.content = '对方撤回了一条消息';
            messageInHistory.isRecalledMessage = true;
        }
        
        // 5. 【新增】不在窗口也要加未读数和通知
        chat.unreadCount = (chat.unreadCount || 0) + 1;
        if (!notificationShown) {
            const finalNotifText = chat.isGroup ? `${realMessage.senderName}: 对方撤回了一条消息` : '对方撤回了一条消息';
            showNotification(chatId, finalNotifText);
            notificationShown = true;
        }
    }
    
    // 6. 跳过循环的剩余部分
    continue;
}
// ▲▲▲ 替换结束 ▲▲▲
   
              
           // ▼▼▼ 请用下面这【一整块】代码，完整替换掉旧的 case 'text' 代码块 ▼▼▼
case 'text': { // 使用大括号包裹
                    // 收集内心独白逻辑保持不变


                    const rawContent = msgData.content || msgData.message || '';
                    // 【核心修复】使用正则表达式移除AI回复中可能存在的不可见字符
                    const content = rawContent.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');

                    // 【新增】如果内容为空或只有空白字符,直接跳过
                    if (!content || content.trim() === '') {
                        console.warn('收到了空白的text消息，已跳过');
                        aiMessage = null;
                        break;
                    }

                    // ▼▼▼ 【新增】检查是否包含表情标记 [表情:xxx] ▼▼▼
                    const stickerRegex = /\[表情:([^\]]+)\]/g;
                    const stickerMatches = [...content.matchAll(stickerRegex)];
                    let hasStickerInText = false; // 【新增】标记是否处理过表情包

                    if (stickerMatches.length > 0) {
                        hasStickerInText = true; // 【新增】设置标记
                        // 如果文本中包含表情标记，先创建文本消息（如果有非表情的文本内容）
                        const textWithoutStickers = content.replace(stickerRegex, '').trim();

                        if (textWithoutStickers) {
                            // 有文本内容，创建文本消息
                            aiMessage = {
                                ...baseMessage,
                                content: textWithoutStickers
                            };
                            // 将文本消息加入历史
                            chat.history.push(aiMessage);
                        }

                        // 然后为每个表情创建表情包消息，并通过appendMessage按顺序渲染
                        for (const match of stickerMatches) {
                            const baseMeaning = match[1];
                            console.log(`🔍 【case text】正在查询表情包: "${baseMeaning}"`);

                            // 【模糊匹配】去掉空格后再比对
                            const meaningNoSpace = baseMeaning.replace(/\s+/g, '');
                            const allMatchingStickers = (await db.aiStickers.toArray()).filter(s => {
                                const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                                return meaningNoSpace === dbMeaningNoSpace;
                            });
                            console.log(`🔍 【case text】查询结果:`, allMatchingStickers);

                            if (allMatchingStickers && allMatchingStickers.length > 0) {
                                // 随机选择一个衍生版本
                                const stickerInfo = allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)];
                                console.log(`✅ 找到表情包 "${baseMeaning}":`, { url: stickerInfo.url, width: stickerInfo.width, height: stickerInfo.height, actualMeaning: stickerInfo.meaning });

                                // 【统一格式】改为生成 type: text，content: [表情:含义] 的格式
                                const stickerMsg = {
                                    ...baseMessage,
                                    timestamp: Date.now() + Math.random(), // 略微不同的时间戳
                                    type: 'text',
                                    content: `[表情:${baseMeaning}]`
                                };
                                // 同步到内存缓存，用于显示表情
                                if (!state.aiStickers) state.aiStickers = {};
                                state.aiStickers[baseMeaning] = stickerInfo;

                                console.log(`✅ 创建的stickerMsg:`, stickerMsg);
                                console.log(`✅ 表情包随机显示：${baseMeaning} (随机选中: ${stickerInfo.meaning})`);
                                // 【关键改动】不再直接push到history，而是通过appendMessage来渲染
                                // 这样表情包消息就会和其他消息一起按顺序渲染，而不是突然蹦出来
                                chat.history.push(stickerMsg);
                                if (isViewingThisChat) {
                                    // 【骰子功能】如果本轮有骰子消息,将表情包消息加入队列等待渲染
                                    if (hasDiceMessage) {
                                        newMessagesToRender.push(stickerMsg);
                                    } else {
                                        // 没有骰子消息,按原逻辑立即渲染
                                        appendMessage(stickerMsg, chat);
                                        scrollToBottom();
                                        // 【新增】给表情包也加上时间延迟，和文本消息保持一致的节奏
                                        // 时间间隔为 1000-2800ms，和文本消息相同
                                        await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                                    }
                                }
                            } else {
                                console.warn(`⚠️ 表情包 "${baseMeaning}" 及其衍生版本均未在库中找到`);
                            }
                        }

                        // 已经手动添加了消息，所以 aiMessage 设为 null（后面不会再appendMessage）
                        aiMessage = null;
                    } else {
                        // 没有表情标记，正常处理

                        // ▼▼▼ 【全新】使用更灵活的逻辑来查找和提取HTML模块 ▼▼▼
                        const orangeStartIndex = content.indexOf('<orange');
                        const orangeEndIndex = content.lastIndexOf('</orange>');

                        if (orangeStartIndex !== -1 && orangeEndIndex > orangeStartIndex) {
                            // 如果找到了起始和结束标签，就提取它们之间的所有内容
                            const htmlContent = content.substring(orangeStartIndex, orangeEndIndex + '</orange>'.length);
                            aiMessage = {
                                ...baseMessage,
                                type: 'html_module', // 打上特殊标记
                                content: htmlContent
                            };
                        } else {
                            // 如果不是，则按原样处理为普通文本消息
                            aiMessage = {
                                ...baseMessage,
                                content: content
                            };
                        }
                    }
                    break;
                }
// ▲▲▲ 替换结束 ▲▲▲
                    break;
                case 'sticker': {
                    const meaning = msgData.meaning;
                    if (!meaning) {
                        console.error('❌ AI表情包缺少meaning字段，跳过此消息');
                        break;
                    }

                    // 【统一格式】改为生成 type: text，content: [表情:含义] 的格式
                    const baseMeaning = meaning;
                    // 【模糊匹配】去掉空格后再比对
                    const meaningNoSpace = baseMeaning.replace(/\s+/g, '');
                    const allMatchingStickers = (await db.aiStickers.toArray()).filter(s => {
                        const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                        return meaningNoSpace === dbMeaningNoSpace;
                    });

                    if (allMatchingStickers && allMatchingStickers.length > 0) {
                        // 随机选择一个衍生版本
                        const stickerInfo = allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)];
                        // 同步到内存缓存，方便渲染器使用（用于显示表情）
                        if (!state.aiStickers) state.aiStickers = {};
                        state.aiStickers[baseMeaning] = stickerInfo;

                        // 【新格式】生成text类型的消息，内容为 [表情:含义]
                        aiMessage = {
                            ...baseMessage,
                            type: 'text',
                            content: `[表情:${baseMeaning}]`
                        };
                        console.log(`✅ 表情包随机显示：${baseMeaning} (随机选中: ${stickerInfo.meaning})`);
                    } else {
                        console.warn(`⚠️ 表情包 "${meaning}" 及其衍生版本均未在数据库中找到，跳过此消息`);
                        // 不生成消息，直接跳过
                    }
                    break;
                }
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'naiimag':
                    // NovelAI图片分享 - 调用NovelAI API生成高质量图片
                    try {
                        console.log('📸 NovelAI图片生成开始，AI提供的prompt:', msgData.prompt);

                        if (!msgData.prompt) {
                            throw new Error('没有提供图片描述词');
                        }

                        // 获取角色的NAI提示词配置（系统或角色专属）
                        const naiPrompts = getCharacterNAIPrompts(chatId);

                        // 构建最终的提示词：AI的prompt + 配置的提示词
                        const aiPrompt = msgData.prompt;
                        const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                        const finalNegativePrompt = naiPrompts.negative;

                        console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);

                        // 获取NAI设置
                        const novelaiApiKey = localStorage.getItem('novelai-api-key');
                        const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                        const novelaiSettings = getNovelAISettings();

                        // 📋 调试输出：完整的 NovelAI 单聊生图设置
                        console.log('%c🎨 NovelAI 单聊生图设置详情', 'color: #FF6B6B; font-size: 14px; font-weight: bold;');
                        console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #FF6B6B;');
                        console.log('%c模型配置：', 'color: #4ECDC4; font-weight: bold;');
                        console.log('  • NovelAI 模型:', novelaiModel);
                        console.log('%c分辨率与采样：', 'color: #4ECDC4; font-weight: bold;');
                        console.log('  • 分辨率 (Resolution):', novelaiSettings.resolution);
                        console.log('  • 步数 (Steps):', novelaiSettings.steps);
                        console.log('  • CFG Scale:', novelaiSettings.cfg_scale);
                        console.log('  • 采样器 (Sampler):', novelaiSettings.sampler);
                        console.log('  • 随机种子 (Seed):', novelaiSettings.seed);
                        console.log('%c高级选项：', 'color: #4ECDC4; font-weight: bold;');
                        console.log('  • UC Preset:', novelaiSettings.uc_preset);
                        console.log('  • Quality Toggle:', novelaiSettings.quality_toggle);
                        console.log('  • SMEA:', novelaiSettings.smea);
                        console.log('  • SMEA Dynamic:', novelaiSettings.smea_dyn);
                        console.log('%c代理设置：', 'color: #4ECDC4; font-weight: bold;');
                        console.log('  • CORS 代理:', novelaiSettings.cors_proxy);
                        console.log('  • 自定义代理 URL:', novelaiSettings.custom_proxy_url);
                        console.log('%c正面提示词 (Final Positive Prompt)：', 'color: #95E1D3; font-weight: bold;');
                        console.log(finalPositivePrompt);
                        console.log('%c负面提示词 (Final Negative Prompt)：', 'color: #F38181; font-weight: bold;');
                        console.log(finalNegativePrompt);
                        console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #FF6B6B;');

                        if (!novelaiApiKey) {
                            throw new Error('NovelAI API Key未配置');
                        }

                        const [width, height] = novelaiSettings.resolution.split('x').map(Number);

                        // 构建请求体（V4/V3格式区分）
                        let requestBody;
                        if (novelaiModel.includes('nai-diffusion-4')) {
                            requestBody = {
                                input: finalPositivePrompt,
                                model: novelaiModel,
                                action: 'generate',
                                parameters: {
                                    params_version: 3,
                                    width: width,
                                    height: height,
                                    scale: novelaiSettings.cfg_scale,
                                    sampler: novelaiSettings.sampler,
                                    steps: novelaiSettings.steps,
                                    seed: novelaiSettings.seed === -1 ? Math.floor(Math.random() * 9999999999) : novelaiSettings.seed,
                                    n_samples: 1,
                                    ucPreset: novelaiSettings.uc_preset,
                                    qualityToggle: novelaiSettings.quality_toggle,
                                    autoSmea: false,
                                    dynamic_thresholding: false,
                                    controlnet_strength: 1,
                                    legacy: false,
                                    add_original_image: true,
                                    cfg_rescale: 0,
                                    noise_schedule: 'karras',
                                    legacy_v3_extend: false,
                                    skip_cfg_above_sigma: null,
                                    use_coords: false,
                                    legacy_uc: false,
                                    normalize_reference_strength_multiple: true,
                                    inpaintImg2ImgStrength: 1,
                                    characterPrompts: [],
                                    v4_prompt: {
                                        caption: {
                                            base_caption: finalPositivePrompt,
                                            char_captions: []
                                        },
                                        use_coords: false,
                                        use_order: true
                                    },
                                    v4_negative_prompt: {
                                        caption: {
                                            base_caption: finalNegativePrompt,
                                            char_captions: []
                                        },
                                        legacy_uc: false
                                    },
                                    negative_prompt: finalNegativePrompt,
                                    deliberate_euler_ancestral_bug: false,
                                    prefer_brownian: true
                                }
                            };
                        } else {
                            requestBody = {
                                input: finalPositivePrompt,
                                model: novelaiModel,
                                action: 'generate',
                                parameters: {
                                    width: width,
                                    height: height,
                                    scale: novelaiSettings.cfg_scale,
                                    sampler: novelaiSettings.sampler,
                                    steps: novelaiSettings.steps,
                                    seed: novelaiSettings.seed === -1 ? Math.floor(Math.random() * 9999999999) : novelaiSettings.seed,
                                    n_samples: 1,
                                    ucPreset: novelaiSettings.uc_preset,
                                    qualityToggle: novelaiSettings.quality_toggle,
                                    sm: novelaiSettings.smea,
                                    sm_dyn: novelaiSettings.smea_dyn,
                                    dynamic_thresholding: false,
                                    controlnet_strength: 1,
                                    legacy: false,
                                    add_original_image: false,
                                    cfg_rescale: 0,
                                    noise_schedule: 'native',
                                    negative_prompt: finalNegativePrompt
                                }
                            };
                        }

                        // 调用NAI API
                        let apiUrl = novelaiModel.includes('nai-diffusion-4')
                            ? 'https://image.novelai.net/ai/generate-image-stream'
                            : 'https://image.novelai.net/ai/generate-image';

                        let corsProxy = novelaiSettings.cors_proxy;
                        if (corsProxy === 'custom') corsProxy = novelaiSettings.custom_proxy_url || '';
                        if (corsProxy && corsProxy !== '') {
                            apiUrl = corsProxy + encodeURIComponent(apiUrl);
                        }

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer ' + novelaiApiKey
                            },
                            body: JSON.stringify(requestBody)
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`API错误 (${response.status}): ${errorText}`);
                        }

                        // 处理响应（SSE或ZIP）
                        let imageDataUrl;
                        const contentType = response.headers.get('content-type');

                        if (contentType && contentType.includes('text/event-stream')) {
                            const text = await response.text();
                            const lines = text.trim().split('\n');
                            let base64Data = null;

                            for (let i = lines.length - 1; i >= 0; i--) {
                                const line = lines[i].trim();
                                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                                    const dataContent = line.substring(6);
                                    try {
                                        const jsonData = JSON.parse(dataContent);
                                        if (jsonData.event_type === 'final' && jsonData.image) {
                                            base64Data = jsonData.image;
                                            break;
                                        }
                                        if (jsonData.image) {
                                            base64Data = jsonData.image;
                                            break;
                                        }
                                    } catch (e) {
                                        base64Data = dataContent;
                                        break;
                                    }
                                }
                            }

                            if (!base64Data) throw new Error('无法提取图片数据');

                            const isPNG = base64Data.startsWith('iVBORw0KGgo');
                            const isJPEG = base64Data.startsWith('/9j/');

                            if (isPNG || isJPEG) {
                                const binaryString = atob(base64Data);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                                const reader = new FileReader();
                                imageDataUrl = await new Promise((resolve, reject) => {
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                            } else {
                                const binaryString = atob(base64Data);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                const zipBlob = new Blob([bytes]);
                                const zip = await JSZip.loadAsync(zipBlob);
                                let imageFile = null;
                                for (let filename in zip.files) {
                                    if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                        imageFile = zip.files[filename];
                                        break;
                                    }
                                }
                                if (!imageFile) throw new Error('ZIP中未找到图片');
                                const imageBlob = await imageFile.async('blob');
                                const reader = new FileReader();
                                imageDataUrl = await new Promise((resolve, reject) => {
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                            }
                        } else {
                            const zipBlob = await response.blob();
                            const zip = await JSZip.loadAsync(zipBlob);
                            let imageFile = null;
                            for (let filename in zip.files) {
                                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                    imageFile = zip.files[filename];
                                    break;
                                }
                            }
                            if (!imageFile) throw new Error('ZIP中未找到图片');
                            const imageBlob = await imageFile.async('blob');
                            const reader = new FileReader();
                            imageDataUrl = await new Promise((resolve, reject) => {
                                reader.onloadend = () => resolve(reader.result);
                                reader.onerror = reject;
                                reader.readAsDataURL(imageBlob);
                            });
                        }

                        // 创建naiimag消息
                        aiMessage = {
                            ...baseMessage,
                            type: 'naiimag',
                            imageUrl: imageDataUrl,  // 【关键】使用imageUrl而不是content
                            prompt: msgData.prompt,
                            content: msgData.prompt  // 为了在上下文中显示，添加content字段
                        };
                        console.log('✅ NovelAI图片生成成功！');
                    } catch (error) {
                        console.error('❌ NovelAI图片生成失败:', error);
                        aiMessage = {
                            ...baseMessage,
                            type: 'naiimag',
                            isFailed: true,
                            failureReason: error.message,
                            prompt: msgData.prompt,
                            content: msgData.prompt
                        };
                    }
                    break;

                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                    break;

                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("收到了未知的AI指令类型:", msgData.type);
                     break;
            }

            // 【核心修复】将渲染逻辑移出循环
            if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'naiimag':
                            notificationText = `[NovelAI图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 确保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                    // 【骰子功能】如果本轮有骰子消息,将普通消息加入队列等待渲染
                    if (hasDiceMessage) {
                        newMessagesToRender.push(aiMessage);
                    } else {
                        // 没有骰子消息,按原逻辑立即渲染
                        appendMessage(aiMessage, chat);
                        // 确保AI消息显示后滚动到底部（已有防抖机制）
                        scrollToBottom();
                        // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                    }
                }
            }
  }

        // ▼▼▼ 【骰子功能】处理待渲染消息队列 ▼▼▼
        if (newMessagesToRender.length > 0 && isViewingThisChat) {
            if (hasDiceMessage) {
                // 如果有骰子消息,等待1.5秒让骰子动画完成
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            // 按顺序渲染所有待渲染的消息
            for (const msg of newMessagesToRender) {
                appendMessage(msg, chat);
                scrollToBottom();
                // 给每条消息之间加一点延迟,让显示更自然
                if (msg.type !== 'dice_result') {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
        }
        // ▲▲▲ 待渲染消息队列处理结束 ▲▲▲

        // 【已移除】表情包消息现在直接通过appendMessage渲染，不需要再单独renderChatInterface

       // ▼▼▼ 【心声功能升级】在所有消息处理完后，一次性更新所有角色的心声 ▼▼▼
if (chat.isGroup) {
    // 【全新】处理群聊的 update_thoughts 指令
    const thoughtsIndex = messagesArray.findIndex(msg => msg.type === 'update_thoughts');
    if (thoughtsIndex > -1) {
        const thoughtsData = messagesArray[thoughtsIndex];
        let needsDbUpdate = false; // 新增一个标记，判断是否需要保存
        if (thoughtsData.thoughts && Array.isArray(thoughtsData.thoughts)) {
            console.log("[心声升级-群聊] 已捕获心声数据:", thoughtsData.thoughts);
            thoughtsData.thoughts.forEach(thought => {
                const member = chat.members.find(m => m.originalName === thought.name);
                if (member) {
                    if (!member.displayStatus) member.displayStatus = {};
                    // 存储心声和散记为分离的字段
                    member.displayStatus.innerThought = thought.heartfelt_voice || '...';
                    member.displayStatus.randomJottings = thought.random_jottings || '...';
                    // 【修复】添加散记历史记录
                    if (!member.thoughtHistory) member.thoughtHistory = [];
                    const historyEntry = `心声：${thought.heartfelt_voice || ''}\n散记：${thought.random_jottings || ''}`;
                    member.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });
                    needsDbUpdate = true; // 标记数据已更新
                }
            });
        }
        // 从数组中移除该指令
        messagesArray.splice(thoughtsIndex, 1);
        
        // ▼▼▼ 【核心修复】在这里添加数据库保存操作 ▼▼▼
        if (needsDbUpdate) {
            await db.chats.put(chat);
            console.log("[心声升级-群聊] 已将更新后的心声保存到数据库。");
        }
        // ▲▲▲ 修复结束 ▲▲▲
    }
} else {
    // 【全新】处理单聊的 update_thoughts 指令
    const thoughtsIndex = messagesArray.findIndex(msg => msg.type === 'update_thoughts');
    if (thoughtsIndex > -1) {
        const thoughtsData = messagesArray[thoughtsIndex];
        const heartfelt_voice = thoughtsData.heartfelt_voice || '...';
        const random_jottings = thoughtsData.random_jottings || '...';

        // 存储心声和散记为分离的字段
        if (!chat.displayStatus) chat.displayStatus = {};
        chat.displayStatus.innerThought = heartfelt_voice;
        chat.displayStatus.randomJottings = random_jottings;

        if (!chat.thoughtHistory) chat.thoughtHistory = [];
        const historyEntry = `心声：${heartfelt_voice}\n散记：${random_jottings}`;
        chat.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });
        
        console.log(`[心声升级] 已捕获并更新内心独白:`, { heartfelt_voice, random_jottings });

        // 从数组中移除该指令，防止它被当作普通消息处理
        messagesArray.splice(thoughtsIndex, 1);
    }
}
// ▲▲▲ 升级结束 ▲▲▲
        if (callHasBeenHandled && voiceCallState.isGroupCall) {
            voiceCallState.isAwaitingResponse = false;
            if (voiceCallState.participants.length > 0) {
                startVoiceCall();
            } else {
                voiceCallState = { ...voiceCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }
        
        await db.chats.put(chat);

    } catch (error) {
        // 【核心修复】过滤临时消息时，必须保留撤回消息（isRecalledMessage=true的消息）
        chat.history = chat.history.filter(msg => !msg.isTemporary || msg.isRecalledMessage);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
        } else {
            const errorContent = `[出错了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "系统消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
        // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
          // ▼▼▼ 请用下面这段【全新】的代码，替换掉旧的 if (chatHeaderTitle...) 代码块 ▼▼▼
if (chatHeaderTitle && state.chats[chatId]) {
    // 【修复2】清除isAwaitingReply标志并保存到数据库
    chat.isAwaitingReply = false;

    // 【核心修正】在更新标题前，检查当前打开的窗口是否还是当初那个窗口
    if (state.activeChatId === chatId) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            const c = state.chats[chatId];
            chatHeaderTitle.textContent = c.remark || c.name;
            chatHeaderTitle.classList.remove('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    } else {
        console.log(`后台响应已完成，但用户已切换窗口，不更新标题。`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
        renderChatList();
    }
}

// 【新增】主动回复功能相关函数
async function checkAndTriggerActiveReply(chat) {
    console.log(`[主动回复检查] 开始检查聊天: ${chat.name}`);

    // 如果主动回复间隔为0，则关闭功能
    if (!chat.settings.activeReplyInterval || chat.settings.activeReplyInterval <= 0) {
        console.log(`[主动回复检查] 功能已关闭，间隔设置: ${chat.settings.activeReplyInterval}`);
        return;
    }

    console.log(`[主动回复检查] 间隔设置: ${chat.settings.activeReplyInterval}小时`);

    // 【修复4】检查是否正在等待API回复
    // 如果已经在等待AI回复了（isAwaitingReply为true），就不再触发第二次
    if (chat.isAwaitingReply) {
        console.log(`[主动回复检查] 已经在等待API回复中，本次进入窗口不调用API。`);
        return;
    }
    
    // 获取最后一条AI消息的时间戳
    const lastAiMessage = chat.history
        .filter(msg => msg.role === 'assistant' && !msg.isHidden)
        .slice(-1)[0];
    
    if (!lastAiMessage) {
        console.log(`[主动回复检查] 没有找到AI消息记录`);
        return;
    }
    
    console.log(`[主动回复检查] 最后AI消息时间: ${new Date(lastAiMessage.timestamp).toLocaleString()}`);
    
    const now = Date.now();
    const timeSinceLastReply = (now - lastAiMessage.timestamp) / (1000 * 60 * 60); // 转换为小时
    
    console.log(`[主动回复检查] 当前时间: ${new Date(now).toLocaleString()}`);
    console.log(`[主动回复检查] 时间间隔: ${timeSinceLastReply.toFixed(3)}小时，需要: ${chat.settings.activeReplyInterval}小时`);
    
    // 如果超过设定的时间间隔，触发主动回复
    if (timeSinceLastReply >= chat.settings.activeReplyInterval) {
        console.log(`[主动回复检查] ✅ 触发主动回复功能！间隔${timeSinceLastReply.toFixed(1)}小时`);
        await triggerActiveReply(chat, timeSinceLastReply);
    } else {
        console.log(`[主动回复检查] ❌ 时间未到，还需等待${(chat.settings.activeReplyInterval - timeSinceLastReply).toFixed(3)}小时`);
    }
}

// ▼▼▼ 用下面这个【完整】的函数，替换掉你代码里旧的 `async function triggerActiveReply(chat, hoursGap)` ▼▼▼
async function triggerActiveReply(chat, hoursGap) {
    console.log(`[主动回复检查] 开始生成模拟消息，时间间隔: ${hoursGap.toFixed(1)}小时`);

    // 【修复4】设置等待回复标志，防止在API回复完成前重复触发
    chat.isAwaitingReply = true;
    console.log(`[主动回复执行] 已设置等待回复标志`);

    // 【新增】显示输入状态
    const chatHeaderTitle = document.getElementById('chat-header-title');
if (chatHeaderTitle && state.activeChatId === chat.id) {
            chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = chat.isGroup ? '正在输入中...' : '对方正在输入...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;

            // 【新增】给标题加上点击事件，点击可中断API调用
            chatHeaderTitle.style.cursor = 'pointer';
            chatHeaderTitle.onclick = () => {
                if (activeReplyAbortController) {
                    console.log('[主动回复] 用户点击标题，中断API调用');
                    activeReplyAbortController.abort();
                    activeReplyAbortController = null;

                    // 恢复标题显示
                    chatHeaderTitle.textContent = chat.remark || chat.name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.cursor = '';
                    chatHeaderTitle.onclick = null;

                    // 清除等待回复标志
                    chat.isAwaitingReply = false;
                    db.chats.put(chat);
                }
            };
        }, 200);
    }

    // 标记为模拟回复模式
    chat.isSimulatingMessages = true;
    
    // 【改动】不再预先规定消息数量，让AI根据人设和剧情自己决定
    console.log(`距离上次联系已过去${hoursGap.toFixed(1)}小时，让AI自己判断是否发消息及发多少条`);

    // AI将直接在消息中生成时间戳，无需预先生成
    const lastAiMessage = chat.history.filter(msg => msg.role === 'assistant' && !msg.isHidden).slice(-1)[0];

    // 构建AI提示词
    let aiPrompt =await buildActiveReplyPrompt(chat, hoursGap);

    // 【新增】动态添加可用的表情包列表到 Prompt
    try {
        const allStickers = await db.aiStickers.toArray();
        if (allStickers && allStickers.length > 0) {
            // 【去重逻辑】只提取基础含义（去掉 _v2, _v3 等后缀），让AI看不到衍生版本
            const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
            const uniqueMeanings = [...new Set(baseMeanings)];
            const stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
            aiPrompt += `\n\n# 【可用的表情包】\n每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]。使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"
：\n${stickerList}\n`;
        }
    } catch (e) {
        console.warn('[主动回复] 加载表情包列表失败:', e);
    }

    try {
        // 调用AI API生成模拟消息
        const response = await callAIForActiveReply(aiPrompt, chat);
        
        
        console.log(`[主动回复执行] AI响应:`, response.substring(0, 200) + '...');
        // ▲▲▲ 代码添加结束 ▲▲▲
        
        // 【修复】使用和单聊相同的解析逻辑
        const messagesArray = parseAiResponse(response);
        
        // 【最终修复版】处理心声，从原始的messagesArray中获取
        if (chat.isGroup) {
            const thoughtsIndex = messagesArray.findIndex(msg => msg.type === 'update_thoughts');
            if (thoughtsIndex > -1) {
                const thoughtsData = messagesArray[thoughtsIndex];
                let needsDbUpdate = false; // 新增一个标记，判断是否需要保存
                // 新增：记录下所有需要被清理的、散落的心声对象
                const thoughtObjects = []; 
                if (thoughtsData.thoughts && Array.isArray(thoughtsData.thoughts)) {
                    console.log("[主动回复-心声升级-群聊] 已捕获心声数据:", thoughtsData.thoughts);
                    thoughtsData.thoughts.forEach(thought => {
                        thoughtObjects.push(thought); // 记录这个心声对象，稍后用于清理
                        const member = chat.members.find(m => m.originalName === thought.name);
                        if (member) {
                            if (!member.displayStatus) member.displayStatus = {};
                            // 存储心声和散记为分离的字段
                            member.displayStatus.innerThought = thought.heartfelt_voice || '...';
                            member.displayStatus.randomJottings = thought.random_jottings || '...';
                            if (!member.thoughtHistory) member.thoughtHistory = [];
                            const historyEntry = `心声：${thought.heartfelt_voice || ''}\n散记：${thought.random_jottings || ''}`;
                            member.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });
                            needsDbUpdate = true;
                        }
                    });
                }
                // 1. 先移除 update_thoughts 指令本身
                messagesArray.splice(thoughtsIndex, 1);

                // 2. 【核心修复】再用一个循环，把所有散落的心声对象也彻底清除掉
                //    使用反向循环，可以安全地在循环内部删除数组元素
                for (let i = messagesArray.length - 1; i >= 0; i--) {
                    const msg = messagesArray[i];
                    // 判断当前消息是否是刚才记录下的散落心声对象
                    const isThoughtObject = thoughtObjects.some(thought =>
                        thought.name === msg.name &&
                        thought.heartfelt_voice === msg.heartfelt_voice &&
                        thought.random_jottings === msg.random_jottings
                    );
                    if (isThoughtObject) {
                        console.log("[主动回复-心声升级-群聊] 移除误解析的 thought 对象:", msg);
                        messagesArray.splice(i, 1); // 从数组中删除它
                    }
                }

                if (needsDbUpdate) {
                    await db.chats.put(chat);
                    console.log("[主动回复-心声升级-群聊] 已将更新后的心声保存到数据库。");
                }
            }
        } else {
            // 单聊的心声处理逻辑保持不变
            const thoughtsIndex = messagesArray.findIndex(msg => msg.type === 'update_thoughts');
            if (thoughtsIndex > -1) {
                const thoughtsData = messagesArray[thoughtsIndex];
                const heartfelt_voice = thoughtsData.heartfelt_voice || '...';
                const random_jottings = thoughtsData.random_jottings || '...';

                // 存储心声和散记为分离的字段
                if (!chat.displayStatus) chat.displayStatus = {};
                chat.displayStatus.innerThought = heartfelt_voice;
                chat.displayStatus.randomJottings = random_jottings;

                if (!chat.thoughtHistory) chat.thoughtHistory = [];
                const historyEntry = `心声：${heartfelt_voice}\n散记：${random_jottings}`;
                chat.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });

                console.log(`[主动回复-心声升级] 已捕获并更新内心独白:`, { heartfelt_voice, random_jottings });

                messagesArray.splice(thoughtsIndex, 1);
            }
        }
        
        const messages = [];
        let lastValidMessage = null; // 【新增】记录最后一条有效消息，用于时间戳连贯性检查

        // 将解析后的消息转换为适合主动回复的格式
        const startTime = lastAiMessage.timestamp;
        const endTime = Date.now();

        for (let i = 0; i < messagesArray.length; i++) {
            const msgData = messagesArray[i];

            // 【新增】验证群聊消息的发送者必须在群成员列表中
            if (chat.isGroup && msgData.name && msgData.name !== '系统') {
                const validMember = chat.members.find(m => m.originalName === msgData.name);
                if (!validMember) {
                    console.error(`[主动回复] AI幻觉已被拦截！试图使用不存在的角色名 ("${msgData.name}")。消息内容:`, msgData);
                    continue; // 跳过这条无效消息
                }
            }

            // 从AI生成的消息中提取并验证时间戳
            let simulatedTimestamp = msgData.timestamp;

            // 时间戳验证和修正逻辑
            if (!simulatedTimestamp || simulatedTimestamp < startTime || simulatedTimestamp > endTime) {
                console.warn(`[主动回复] 消息${i+1}的时间戳无效或超出范围，使用fallback: ${simulatedTimestamp}`);
                // fallback：生成合理的递增时间戳
                const timeGap = endTime - startTime;
                simulatedTimestamp = startTime + Math.floor(timeGap * (i + 1) / messagesArray.length);
            }

            // 【修复】确保时间戳的连贯性：后面的消息时间戳不能早于前面的有效消息
            if (lastValidMessage && simulatedTimestamp <= lastValidMessage.simulatedTimestamp) {
                simulatedTimestamp = lastValidMessage.simulatedTimestamp + Math.floor(Math.random() * 300000) + 60000; // 1-5分钟的随机间隔
                console.log(`[主动回复] 调整消息${i+1}时间戳以保持时序一致性: ${new Date(simulatedTimestamp).toLocaleString()}`);
            }
            
            const message = {
                role: 'assistant',
                senderName: chat.isGroup ? (msgData.name || chat.name) : chat.name, // 群聊使用角色名，单聊使用聊天名
                timestamp: Date.now() + i, // 真实时间戳（用于系统标识）
                simulatedTimestamp: simulatedTimestamp, // 使用AI生成并验证的模拟时间戳
                isSimulatedMessage: true,
                // 【全新】标记是否在被拉黑状态下发送的主动回复消息
                sentWhileBlocked: !chat.isGroup && chat.relationship && 
                    (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')
            };
            
            // 【新增】群聊中设置角色头像
            if (chat.isGroup && msgData.name) {
                // 在群成员中查找对应的头像
                const member = chat.members.find(m => m.originalName === msgData.name);
                if (member && member.avatar) {
                    message.senderAvatar = member.avatar;
                }
            }
            
            // 【修复】按照单聊的格式正确设置消息属性
            if (msgData.type === 'ai_image') {
                message.type = 'ai_image';
                message.content = msgData.description; // 图片描述存储在content字段
            } else if (msgData.type === 'transfer') {
                message.type = 'transfer';
                message.amount = msgData.amount;
                message.note = msgData.note;
                message.receiverName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; // 主动回复中AI向用户转账
                message.senderName = chat.isGroup ? (msgData.name || chat.name) : chat.name; // 群聊使用角色名
                // 【关键】不设置status属性，让转账保持pending状态，这样就可以点击
                console.log(`[主动回复] 生成转账消息: ${message.amount}元, 备注: ${message.note}`);
            } else if (msgData.type === 'voice_message') {
                message.type = 'voice_message';
                message.content = msgData.content;
            } else if (msgData.type === 'sticker') {
                message.type = 'sticker';
                message.content = msgData.url; // 表情包的URL存储在content字段
                message.meaning = msgData.meaning || ''; // 表情包的含义
            } else if (msgData.type === 'send_gift') {
                message.type = 'gift';
                message.giftName = msgData.giftName;
                message.giftPrice = msgData.giftPrice;
                message.senderName = chat.isGroup ? (msgData.name || chat.name) : chat.name; // 群聊使用角色名，单聊用聊天名
                message.status = 'pending'; // 主动回复的礼物也需要pending状态
                
                // 处理群聊中的礼物类型和接收者
                if (chat.isGroup && msgData.recipient) {
                    if (msgData.recipient === 'random' || msgData.recipient === '拼手气') {
                        message.receiverName = '群聊';
                        message.giftType = 'random';
                    } else {
                        message.receiverName = msgData.recipient;
                        message.giftType = 'targeted';
                    }
                } else {
                    message.receiverName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    message.giftType = 'normal';
                }
                
                console.log(`[主动回复] 生成礼物消息: ${message.giftName}, 价格: ¥${message.giftPrice}, 类型: ${message.giftType}`);
            } else if (msgData.type === 'update_status') {
                // 【修复】状态更新消息需要根据群聊/单聊分别处理
                if (chat.isGroup) {
                    // 群聊中：只创建系统消息，不更新整个聊天的状态
                    const memberName = msgData.name || '某位成员';
                    message.role = 'system';
                    message.type = 'pat_message';
                    message.content = `[${memberName}的状态已更新为: ${msgData.status_text || '在线'}]`;
                    console.log(`[主动回复] 群成员${memberName}更新状态: ${msgData.status_text || '在线'}`);
                } else {
                    // 单聊中：更新聊天状态
                    if (!chat.status) chat.status = {};
                    if (!chat.displayStatus) chat.displayStatus = {};

                    chat.status.text = msgData.status_text || '在线';
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    chat.displayStatus.statusText = msgData.status_text || '在线'; // 同步状态到心声档案
                    // 【全新】将新状态存入历史记录，并保持最多10条
if (!chat.statusHistory) {
    chat.statusHistory = [];
}
chat.statusHistory.push({
    text: msgData.status_text || '在线',
    timestamp: Date.now()
});
if (chat.statusHistory.length > 10) {
    chat.statusHistory.shift(); // 只保留最近的10条状态
}
                    // 创建系统提示消息
                    message.role = 'system';
                    message.type = 'pat_message';
                    message.content = `[${!chat.isGroup && chat.remark ? chat.remark : chat.name}的状态已更新为: ${msgData.status_text || '在线'}]`;
                    console.log(`[主动回复] 更新状态: ${msgData.status_text || '在线'}`);
                }
            } else if (msgData.type === 'waimai_request') {
                message.type = 'waimai_request';
                message.productInfo = msgData.productInfo;
                message.amount = msgData.amount;
            } else if (msgData.type === 'qzone_post') {
                message.type = 'qzone_post';
                message.postType = msgData.postType;
                message.content = msgData.content;
                if (msgData.publicText) message.publicText = msgData.publicText;
                if (msgData.hiddenContent) message.hiddenContent = msgData.hiddenContent;
           // ▼▼▼ 【这是修复后的代码】替换 triggerActiveReply 中的第一个 send_and_recall 逻辑 ▼▼▼
} else if (msgData.type === 'send_and_recall') {
    // 【V3 修复】保留 'send_and_recall' 类型，并存储原始 content
    message.type = 'send_and_recall';
    message.content = msgData.content;
    message.recalledData = { originalType: 'text', originalContent: msgData.content };
    console.log(`[主动回复] 准备 'send_and_recall' 消息: ${msgData.content.substring(0, 50)}...`);
} 
// ▲▲▲ 替换结束 ▲▲▲
            
            
            
            else if (msgData.type === 'red_packet') {
                // 【新增】红包消息专门处理
                message.type = 'red_packet';
                message.packetType = msgData.packetType || 'lucky'; // 默认拼手气红包
                message.amount = msgData.amount || 0;
                message.totalAmount = msgData.amount || 0; // 红包总金额
                message.count = msgData.count || 1; // 红包个数
                message.greeting = msgData.greeting || '恭喜发财！'; // 祝福语
                message.claimedBy = {}; // 初始化领取记录
                message.isFullyClaimed = false; // 初始化完成状态
                
                // 【关键】正确设置发送者名字
                if (chat.isGroup && msgData.name) {
                    message.senderName = msgData.name; // 使用AI角色名
                } else {
                    message.senderName = chat.name; // 单聊使用聊天名
                }
                
                // 专属红包需要设置接收者
                if (message.packetType === 'direct') {
                    message.receiverName = msgData.receiver || (chat.settings.myNickname || '我');
                }
                
                console.log(`[主动回复] 生成红包: ${message.senderName}发送${message.packetType}红包，金额${message.amount}元`);
            } else if (msgData.type === 'send_and_recall') {
                // 【核心修复】处理主动回复中的撤回消息类型，转换为recalled_message并保存原文
                message.type = 'recalled_message';
                message.content = '对方撤回了一条消息';
                message.recalledData = {
                    originalType: 'text',
                    originalContent: msgData.content
                };
                message.isRecalledMessage = true;
                console.log(`[主动回复] 生成撤回消息: ${msgData.content.substring(0, 50)}...`);
            } else if (msgData.type === 'text' || !msgData.type) {
                // 【新增】专门处理文本消息
                message.type = 'text';

                // 【关键】群聊使用message字段，单聊使用content字段
                const rawContent = msgData.message || msgData.content || '';

                // ▼▼▼ 【新增】检查是否包含表情标记 [表情:xxx] ▼▼▼
                const stickerRegex = /\[表情:([^\]]+)\]/g;
                const stickerMatches = [...rawContent.matchAll(stickerRegex)];
                let hasStickerInText = false; // 【新增】标记是否处理过表情包

                if (stickerMatches.length > 0) {
                    hasStickerInText = true; // 【新增】设置标记
                    // 如果文本中包含表情标记，先创建文本消息（如果有非表情的文本内容）
                    const textWithoutStickers = rawContent.replace(stickerRegex, '').trim();

                    if (textWithoutStickers) {
                        // 有文本内容，设置文本消息的content
                        message.content = textWithoutStickers;
                    } else {
                        // 没有文本内容，只有表情，不设置content
                        message.content = '';
                    }

                    // 然后为每个表情创建表情包消息，并添加到消息数组中
                    // 【关键】需要在后续处理中逐个添加到messages数组中
                    message._pendingStickers = []; // 临时存储待处理的表情包

                    for (const match of stickerMatches) {
                        const baseMeaning = match[1];
                        console.log(`🔍 【buildActiveReplyPrompt-text处理】正在查询表情包: "${baseMeaning}"`);

                        // 【模糊匹配】去掉空格后再比对
                        const meaningNoSpace = baseMeaning.replace(/\s+/g, '');
                        const allMatchingStickers = (await db.aiStickers.toArray()).filter(s => {
                            const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                            return meaningNoSpace === dbMeaningNoSpace;
                        });

                        if (allMatchingStickers && allMatchingStickers.length > 0) {
                            // 随机选择一个衍生版本
                            const stickerInfo = allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)];
                            console.log(`✅ 找到表情包 "${baseMeaning}":`, { url: stickerInfo.url, width: stickerInfo.width, height: stickerInfo.height, actualMeaning: stickerInfo.meaning });
                            console.log(`✅ 表情包随机显示：${baseMeaning} (随机选中: ${stickerInfo.meaning})`);

                            // 【统一格式】改为生成 type: text，content: [表情:含义] 的格式
                            message._pendingStickers.push({
                                type: 'text',
                                content: `[表情:${baseMeaning}]`,
                                // 继承原消息的基本属性
                                role: message.role,
                                senderName: message.senderName,
                                senderAvatar: message.senderAvatar,
                                timestamp: message.timestamp,
                                simulatedTimestamp: message.simulatedTimestamp,
                                isSimulatedMessage: message.isSimulatedMessage,
                                sentWhileBlocked: message.sentWhileBlocked
                            });

                            // 同步到内存缓存，用于显示表情
                            if (!state.aiStickers) state.aiStickers = {};
                            state.aiStickers[baseMeaning] = stickerInfo;
                        } else {
                            console.warn(`⚠️ 表情包 "${baseMeaning}" 及其衍生版本均未在库中找到`);
                        }
                    }
                } else {
                    // 没有表情标记，直接设置content
                    if (chat.isGroup) {
                        message.content = rawContent;
                    } else {
                        message.content = rawContent;
                    }
                }

                if (!hasStickerInText || message.content) {
                    console.log(`[主动回复] 生成文本消息: ${message.content.substring(0, 50)}...`);
                } else {
                    console.log(`[主动回复] 仅包含表情包的消息`);
                }
            } else if (msgData.type === 'system_message') {
                // 【新增】系统消息处理
                message.role = 'system';
                message.type = 'pat_message';
                message.content = msgData.content || '';
                console.log(`[主动回复] 生成系统消息: ${message.content}`);
            
            } else if (msgData.type === 'quote_reply') {
                // 【新增】引用回复处理
                const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                if (originalMessage) {
                    const quoteContext = {
                        timestamp: originalMessage.timestamp,
                        senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                        content: String(originalMessage.content || '').substring(0, 50),
                    };
                    message.content = msgData.reply_content;
                    message.quote = quoteContext; // 核心：在这里附加引用对象
                    console.log(`[主动回复] 生成引用回复: ${msgData.reply_content}`);
                } else {
                    // 如果找不到被引用的消息，就当作普通消息发送
                    message.content = msgData.reply_content;
                    console.log(`[主动回复] 引用消息未找到，作为普通消息处理: ${msgData.reply_content}`);
                }
            
             } else if (msgData.type === 'pat_user') {
    // 【全新修复】处理主动回复中的“拍一-拍”
    // 【核心修改】获取正确的显示名称（备注名或群昵称）
    let patDisplayName;
    if (chat.isGroup) {
        const member = chat.members.find(m => m.originalName === msgData.name);
        patDisplayName = member ? member.groupNickname : (msgData.name || '未知成员');
    } else {
        patDisplayName = chat.remark ? chat.remark : chat.name;
    }
    const suffix = msgData.suffix || '';
    // 【核心修改】这里是拍“你”（用户），所以主语是 patDisplayName
    const patText = `${patDisplayName} 拍了拍你${suffix}`;

    // 1. 创建对用户可见的“拍一-拍”消息
    message.role = 'system';
    message.type = 'pat_message';
    message.content = patText;

    // 2. 【核心】创建一条对AI可见的、明确的隐藏系统消息
    const hiddenInstruction = {
        role: 'system',
        content: `[系统提示：你刚刚在主动回复中执行了一个“拍一-拍”动作。这个动作在聊天中对用户呈现为：“${patText}”。]`,
        timestamp: message.timestamp + 1, // 确保时间戳在后
        isHidden: true
    };
    // 我们不能直接把这条隐藏消息加入到当前的循环里，所以先把它暂存起来
    // 我们会在循环结束后，一次性把它加入到聊天记录中
    if (!messages) messages = []; // 确保 messages 数组存在
    if (!chat.pendingHiddenMessages) chat.pendingHiddenMessages = [];
    chat.pendingHiddenMessages.push(hiddenInstruction);

    console.log(`[主动回复] 生成拍一拍: ${message.content}`);
} else if (msgData.type === 'naiimag') {
    // 【新增】处理AI主动发送的NovelAI图片
    message.type = 'naiimag';
    message.prompt = msgData.prompt;
    message.fullPrompt = msgData.fullPrompt || msgData.prompt;
    message.content = msgData.prompt; // 为了在上下文中显示，添加content字段

    // 【关键】如果AI直接生成了imageUrl（在主动回复中无法生成真实图片，所以这个通常为空）
    // 主动回复生成的naiimag只有prompt，没有imageUrl，需要在UI显示时进行处理
    if (msgData.imageUrl) {
        message.imageUrl = msgData.imageUrl;
    }

    console.log(`[主动回复] 生成naiimag消息: ${msgData.prompt}`);

} else if (msgData.type === 'location') {
// 【全新】处理AI主动发送的位置信息
const locationData = {
currentLocation: msgData.currentLocation || '',
distance: msgData.distance || '',
targetLocation: msgData.targetLocation || ''
};

// 构建用于显示的位置文本
let locationText = '📍 位置信息\n';
if (locationData.currentLocation) {
    locationText += `当前位置：${locationData.currentLocation}\n`;
}
if (locationData.distance) {
    locationText += `距离：${locationData.distance}\n`;
}
if (locationData.targetLocation) {
    locationText += `目标地点：${locationData.targetLocation}`;
}

// 将构建好的信息赋值给消息对象
Object.assign(message, {
    content: locationText.trim(),
    isLocation: true, // 标记为位置消息，以便UI正确渲染
    locationData: locationData // 保存原始数据
});
console.log(`[主动回复] 生成位置信息: ${locationText.replace(/\n/g, ' ')}`);

} else if (msgData.type === 'accept_gift' || msgData.type === 'decline_gift') {
                // 处理群聊主动回复中的礼物接受/拒绝
                const originalGiftMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                if (originalGiftMsgIndex > -1) {
                    const originalMsg = chat.history[originalGiftMsgIndex];
                    originalMsg.status = msgData.type === 'accept_gift' ? 'accepted' : 'declined';
                    
                    // 如果是拼手气礼物被AI接受，采用红包的方式记录接收者信息
                    if (msgData.type === 'accept_gift' && originalMsg.giftType === 'random') {
                        const member = chat.members.find(m => m.originalName === msgData.name);
                        const displayName = member ? member.groupNickname : (msgData.name || chat.name);
                        
                        // 参考红包逻辑，直接在礼物对象上添加claimedBy属性
                        if (!originalMsg.claimedBy) originalMsg.claimedBy = {};
                        originalMsg.claimedBy[displayName] = true; // 礼物不像红包有金额，只需要标记领取状态
                    }
                    
                    console.log(`[主动回复] ${msgData.name}${msgData.type === 'accept_gift' ? '接受' : '拒绝'}了礼物: ${originalMsg.giftName}`);
                    
                    // 如果当前正在查看这个聊天，需要重新渲染界面以更新礼物状态
                    const currentViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                    if (currentViewingThisChat) {
                        renderChatInterface(chatId);
                    }
                    
                    // 重要：保存更新后的数据到数据库
                    await db.chats.put(chat);
                }
                // 这类指令不产生可见消息，但需要继续处理以维持消息索引
                // continue; // 改为不跳过，让消息正常处理但不显示
                msgData.isHidden = true; // 标记为隐藏消息
            } else {
                // 复制所有其他属性（包括content、type等）
                Object.assign(message, msgData);
                
                // 【修复】群聊和单聊使用不同的字段名，且处理空值情况
                if (chat.isGroup) {
                    // 群聊使用message字段
                    if ((!message.content || message.content === '') && msgData.message) {
                        message.content = msgData.message;
                    } else if ((!message.content || message.content === '') && msgData.content) {
                        message.content = msgData.content;
                    } else if ((!message.content || message.content === '') && msgData.text) {
                        message.content = msgData.text;
                    } else if (!message.content || message.content === '') {
                        message.content = ''; // 防止undefined
                    }
                } else {
                    // 单聊使用content字段
                    if ((!message.content || message.content === '') && msgData.content) {
                        message.content = msgData.content;
                    } else if ((!message.content || message.content === '') && msgData.message) {
                        message.content = msgData.message;
                    } else if ((!message.content || message.content === '') && msgData.text) {
                        message.content = msgData.text;
                    } else if (!message.content || message.content === '') {
                        message.content = ''; // 防止undefined
                    }
                }
                
                console.log(`[主动回复] 生成消息类型: ${message.type || 'text'}, 内容: ${String(message.content).substring(0, 50)}...`);
            }

            // ▼▼▼ 【全新修复】防止表情包消息前出现空白气泡 ▼▼▼
            
            // 1. 检查这个消息壳（message）是否真的有文本内容
            const hasTextContent = message.content && message.content.trim() !== '';
            // 2. 检查是否有待处理的表情包（已在上面解析完毕）
            const hasPendingStickers = message._pendingStickers && message._pendingStickers.length > 0;

            // 3. 【核心逻辑】
            // 只有在【确实有文本内容】的情况下，才 PUSH 这个消息壳
            if (hasTextContent) {
                messages.push(message);
                lastValidMessage = message; // 【新增】更新最后有效消息
                console.log(`[主动回复] 添加文本消息壳: ${message.content.substring(0, 50)}...`);
            }
            // 如果没有文本内容，但有待处理的表情包，
            // 就不 PUSH 这个空壳 message，后续的 '._pendingStickers' 循环会自动 PUSH 它们。
            else if (hasPendingStickers) {
                 console.log(`[主动回复] 仅表情包消息，跳过空文本壳。`);
            }
            // 如果既没有文本内容，也没有表情包（比如AI真的发了空消息），
            else if (message.type === 'text' && !hasTextContent && !hasPendingStickers) {
                 console.warn(`[主动回复] 跳过空白消息（无内容且表情包库无对应表情）`);
            }
            // 【例外】如果不是文本消息（如转账、礼物等），即使没有content也要推送
            else if (message.type !== 'text') {
                messages.push(message);
                lastValidMessage = message; // 【新增】更新最后有效消息
            }

            // 4. 【新增】处理待处理的表情包（这段逻辑不变，但现在它独立于消息壳）
            if (message._pendingStickers && message._pendingStickers.length > 0) {
                for (const stickerMsg of message._pendingStickers) {
                    messages.push(stickerMsg);
                    lastValidMessage = stickerMsg; // 【新增】更新最后有效消息
                    // 【修复】修正控制台日志，使其打印 stickerMsg.content
                    console.log(`[主动回复] 添加待处理的表情包消息: ${stickerMsg.content}`);
                }
                delete message._pendingStickers; // 清除临时属性
            }
            // ▲▲▲ 修复结束 ▲▲▲
        }
        
        console.log(`[主动回复执行] 解析得到${messages.length}条消息`);
        
        // 添加消息到历史记录（带有AI生成的模拟时间戳）
        const originalLastMessageTime = lastAiMessage.timestamp;
        
        // 【新增】检查用户是否在当前聊天界面
        const isViewingThisChat = (state.activeChatId === (chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat)));
        let notificationShown = false;
        
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            message.isSimulatedMessage = true;
            // 时间戳已经在上面的循环中从AI响应中提取并验证了
            message.originalLastMessageTime = originalLastMessageTime; // 【新增】传递原始最后消息时间
            // ▼▼▼ 【这是新增的代码】粘贴到 triggerActiveReply 的第二个循环开头 ▼▼▼
// ▼▼▼ 【这是修复后的代码 V2】替换 triggerActiveReply 循环内的 send_and_recall 逻辑 ▼▼▼
            // 【V3 修复】在这里处理 send_and_recall 动画
            if (message.type === 'send_and_recall') {
                
                // 1. 创建最终的 "recalled_message" (placeholder)
                const recalledMessage = {
                    ...message, // 继承所有 (role, senderName, simulatedTimestamp 等)
                    type: 'recalled_message',
                    content: '对方撤回了一条消息',
                    isRecalledMessage: true 
                };

                // 2. 将 *placeholder* 存入历史记录
                chat.history.push(recalledMessage);

                // 3. 检查用户是否在当前窗口
                const isViewingThisChat = (state.activeChatId === (chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat)));

                if (isViewingThisChat) {
                    // 3a. 创建 *临时* 消息 (真实内容)
                    const tempMessageData = {
                        ...message, // 继承所有属性
                        type: 'text' // 关键：伪装成 text 消息
                    };

                    // 3b. 渲染 *真实内容* (false = 非初始加载, 触发进入动画)
                    appendMessage(tempMessageData, chat, false); 

                    // 3c. 随机等待
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));

                    // 3d. 找到刚刚渲染的气泡
                    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${message.timestamp}"]`)?.closest('.message-wrapper');
                    if (bubbleWrapper) {
                        // 3e. 播放撤回动画 (消失)
                        bubbleWrapper.classList.add('recalled-animation');
                        await new Promise(resolve => setTimeout(resolve, 300)); // 等待动画

                        // 3f. 创建 *placeholder* 的 DOM
                        const placeholder = createMessageElement(recalledMessage, chat);
                        
                        // ▼▼▼ 【核心修复】在这里添加这一行代码！ ▼▼▼
                        placeholder.classList.add('animate-in'); // 为这个新创建的 placeholder 添加“出现”动画
                        // ▲▲▲ 修复结束 ▲▲▲
                        
                        // 3g. 替换
                        if(document.body.contains(bubbleWrapper)) {
                            bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
                        }
                    }
                } else {
                    // 4. 如果用户不在当前窗口，处理未读数和通知
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    if (!notificationShown) {
                        const finalNotifText = chat.isGroup ? `${message.senderName}: 对方撤回了一条消息` : '对方撤回了一条消息';
                        showNotification(chat.id, finalNotifText);
                        notificationShown = true;
                    }
                }
                
                // 5. 跳过此循环的剩余部分
                continue; 
            }
// ▲▲▲ 替换结束 ▲▲▲
//             // 只有非隐藏消息才添加到历史记录
            if (!message.isHidden) {
                chat.history.push(message);
            }
            if (!message.isHidden) {
                const displayContent = message.type === 'sticker' ? `[表情: ${message.meaning}]` : (message.content || '[内容为空]');
                console.log(`[主动回复执行] 添加消息${i+1}: ${displayContent}, 模拟时间: ${new Date(message.simulatedTimestamp).toLocaleString()}`);
            } else {
                console.log(`[主动回复执行] 跳过隐藏消息${i+1}: ${message.type || 'unknown'}`);
            }
            
            // 【新增】如果用户不在当前聊天界面，增加未读数和显示通知（隐藏消息不计入）
            if (!isViewingThisChat && !message.isHidden) {
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                
                // 【新增】只为第一条消息显示通知，避免通知过多
                if (!notificationShown) {
                    let notificationText;
                    switch (message.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        default:
                            notificationText = String(message.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${message.senderName}: ${notificationText}` : notificationText;
                    console.log(`[主动回复通知] 消息类型: ${message.type}, 原始内容: "${message.content}", 通知文本: "${notificationText}", 最终通知: "${finalNotifText}"`);
                    showNotification(chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat), finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true;
                }
            }
        }

        // 保存到数据库
        await db.chats.put(chat);
        console.log(`[主动回复执行] 已保存到数据库`);

        // 【修复】先定义currentChatId，然后再使用
        const currentChatId = chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat);

        // 【新增】处理主动回复中的naiimag图片生成
        // 检查是否有naiimag消息且没有imageUrl，如果有则后台生成图片
        const naimagMessages = messages.filter(msg => msg.type === 'naiimag' && !msg.imageUrl);
        if (naimagMessages.length > 0) {
            console.log(`[主动回复] 发现${naimagMessages.length}条待生成图片的naiimag消息，启动后台生成任务`);
            // 异步生成图片，不阻塞主流程
            (async () => {
                for (const naiMsg of naimagMessages) {
                    let historyMsg = null; // 【修复】在try块外部定义，确保catch可以访问
                    try {
                        // 【关键】每次循环重新获取最新的chat对象
                        const latestChat = await db.chats.get(currentChatId);
                        if (!latestChat) {
                            console.error('[主动回复-naiimag] 无法获取聊天对象');
                            continue;
                        }

                        // 查找对应的历史消息
                        historyMsg = latestChat.history.find(m => m.timestamp === naiMsg.timestamp && m.type === 'naiimag');
                        if (historyMsg && historyMsg.prompt) {
                            console.log(`[主动回复-naiimag] 开始生成图片，prompt: ${historyMsg.prompt.substring(0, 50)}...`);

                            // 获取角色的NAI提示词配置
                            const naiPrompts = getCharacterNAIPrompts(currentChatId);
                            const aiPrompt = historyMsg.prompt;
                            const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                            const finalNegativePrompt = naiPrompts.negative;

                            // 获取NAI设置
                            const novelaiApiKey = localStorage.getItem('novelai-api-key');
                            const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                            const novelaiSettings = getNovelAISettings();

                            // 📋 调试输出：完整的 NovelAI 角色生图设置
                            console.log('%c🎨 NovelAI 角色生图设置详情', 'color: #FF6B6B; font-size: 14px; font-weight: bold;');
                            console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #FF6B6B;');
                            console.log('%c模型配置：', 'color: #4ECDC4; font-weight: bold;');
                            console.log('  • NovelAI 模型:', novelaiModel);
                            console.log('%c分辨率与采样：', 'color: #4ECDC4; font-weight: bold;');
                            console.log('  • 分辨率 (Resolution):', novelaiSettings.resolution);
                            console.log('  • 步数 (Steps):', novelaiSettings.steps);
                            console.log('  • CFG Scale:', novelaiSettings.cfg_scale);
                            console.log('  • 采样器 (Sampler):', novelaiSettings.sampler);
                            console.log('  • 随机种子 (Seed):', novelaiSettings.seed);
                            console.log('%c高级选项：', 'color: #4ECDC4; font-weight: bold;');
                            console.log('  • UC Preset:', novelaiSettings.uc_preset);
                            console.log('  • Quality Toggle:', novelaiSettings.quality_toggle);
                            console.log('  • SMEA:', novelaiSettings.smea);
                            console.log('  • SMEA Dynamic:', novelaiSettings.smea_dyn);
                            console.log('%c代理设置：', 'color: #4ECDC4; font-weight: bold;');
                            console.log('  • CORS 代理:', novelaiSettings.cors_proxy);
                            console.log('  • 自定义代理 URL:', novelaiSettings.custom_proxy_url);
                            console.log('%c正面提示词 (Final Positive Prompt)：', 'color: #95E1D3; font-weight: bold;');
                            console.log(finalPositivePrompt);
                            console.log('%c负面提示词 (Final Negative Prompt)：', 'color: #F38181; font-weight: bold;');
                            console.log(finalNegativePrompt);
                            console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #FF6B6B;');

                            if (!novelaiApiKey) {
                                console.warn('[主动回复-naiimag] NovelAI API Key未配置，跳过图片生成');
                                continue;
                            }

                            // 调用NovelAI API生成图片
                            const [width, height] = novelaiSettings.resolution.split('x').map(Number);

                            let requestBody;
                            if (novelaiModel.includes('nai-diffusion-4')) {
                                requestBody = {
                                    input: finalPositivePrompt,
                                    model: novelaiModel,
                                    action: 'generate',
                                    parameters: {
                                        params_version: 3,
                                        width: width,
                                        height: height,
                                        scale: novelaiSettings.cfg_scale,
                                        sampler: novelaiSettings.sampler,
                                        steps: novelaiSettings.steps,
                                        seed: novelaiSettings.seed === -1 ? Math.floor(Math.random() * 9999999999) : novelaiSettings.seed,
                                        n_samples: 1,
                                        ucPreset: novelaiSettings.uc_preset,
                                        qualityToggle: novelaiSettings.quality_toggle,
                                        autoSmea: false,
                                        dynamic_thresholding: false,
                                        controlnet_strength: 1,
                                        legacy: false,
                                        add_original_image: true,
                                        cfg_rescale: 0,
                                        noise_schedule: 'karras',
                                        legacy_v3_extend: false,
                                        skip_cfg_above_sigma: null,
                                        use_coords: false,
                                        legacy_uc: false,
                                        normalize_reference_strength_multiple: true,
                                        inpaintImg2ImgStrength: 1,
                                        characterPrompts: [],
                                        v4_prompt: {
                                            caption: {
                                                base_caption: finalPositivePrompt,
                                                char_captions: []
                                            },
                                            use_coords: false,
                                            use_order: true
                                        },
                                        v4_negative_prompt: {
                                            caption: {
                                                base_caption: finalNegativePrompt,
                                                char_captions: []
                                            },
                                            legacy_uc: false
                                        },
                                        negative_prompt: finalNegativePrompt,
                                        deliberate_euler_ancestral_bug: false,
                                        prefer_brownian: true
                                    }
                                };
                            } else {
                                requestBody = {
                                    input: finalPositivePrompt,
                                    model: novelaiModel,
                                    action: 'generate',
                                    parameters: {
                                        width: width,
                                        height: height,
                                        scale: novelaiSettings.cfg_scale,
                                        sampler: novelaiSettings.sampler,
                                        steps: novelaiSettings.steps,
                                        seed: novelaiSettings.seed === -1 ? Math.floor(Math.random() * 9999999999) : novelaiSettings.seed,
                                        n_samples: 1,
                                        ucPreset: novelaiSettings.uc_preset,
                                        qualityToggle: novelaiSettings.quality_toggle,
                                        sm: novelaiSettings.smea,
                                        sm_dyn: novelaiSettings.smea_dyn,
                                        dynamic_thresholding: false,
                                        controlnet_strength: 1,
                                        legacy: false,
                                        add_original_image: true,
                                        cfg_rescale: 0,
                                        noise_schedule: 'karras',
                                        skip_cfg_above_sigma: null,
                                        use_coords: false,
                                        legacy_uc: false,
                                        normalize_reference_strength_multiple: true,
                                        inpaintImg2ImgStrength: 1,
                                        characterPrompts: [],
                                        negative_prompt: finalNegativePrompt,
                                        prefer_brownian: true
                                    }
                                };
                            }

                            // 【关键】使用和单聊相同的API端点和CORS代理支持
                            let apiUrl = novelaiModel.includes('nai-diffusion-4')
                                ? 'https://image.novelai.net/ai/generate-image-stream'
                                : 'https://image.novelai.net/ai/generate-image';

                            let corsProxy = novelaiSettings.cors_proxy;
                            if (corsProxy === 'custom') corsProxy = novelaiSettings.custom_proxy_url || '';
                            if (corsProxy && corsProxy !== '') {
                                apiUrl = corsProxy + encodeURIComponent(apiUrl);
                            }

                            // 【最终检查】发送前确认请求体中的 ucPreset 值
                            console.log('%c📤 发送 NAI 请求前的最终检查', 'color: #FFA500; font-weight: bold;');
                            console.log('  • 请求体中的 ucPreset 值:', requestBody.parameters.ucPreset);
                            console.log('  • novelaiSettings.uc_preset 值:', novelaiSettings.uc_preset);
                            console.log('  • 两者是否匹配:', requestBody.parameters.ucPreset === novelaiSettings.uc_preset);

                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': 'Bearer ' + novelaiApiKey
                                },
                                body: JSON.stringify(requestBody)
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`API错误 (${response.status}): ${errorText}`);
                            }

                            // 【关键】处理响应（SSE或ZIP） - 完全参考单聊的实现
                            let imageDataUrl;
                            const contentType = response.headers.get('content-type');

                            if (contentType && contentType.includes('text/event-stream')) {
                                const text = await response.text();
                                const lines = text.trim().split('\n');
                                let base64Data = null;

                                for (let i = lines.length - 1; i >= 0; i--) {
                                    const line = lines[i].trim();
                                    if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                                        const dataContent = line.substring(6);
                                        try {
                                            const jsonData = JSON.parse(dataContent);
                                            if (jsonData.event_type === 'final' && jsonData.image) {
                                                base64Data = jsonData.image;
                                                break;
                                            }
                                            if (jsonData.image) {
                                                base64Data = jsonData.image;
                                                break;
                                            }
                                        } catch (e) {
                                            base64Data = dataContent;
                                            break;
                                        }
                                    }
                                }

                                if (!base64Data) throw new Error('无法提取图片数据');

                                const isPNG = base64Data.startsWith('iVBORw0KGgo');
                                const isJPEG = base64Data.startsWith('/9j/');

                                if (isPNG || isJPEG) {
                                    const binaryString = atob(base64Data);
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        bytes[i] = binaryString.charCodeAt(i);
                                    }
                                    const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                                    const reader = new FileReader();
                                    imageDataUrl = await new Promise((resolve, reject) => {
                                        reader.onloadend = () => resolve(reader.result);
                                        reader.onerror = reject;
                                        reader.readAsDataURL(imageBlob);
                                    });
                                } else {
                                    const binaryString = atob(base64Data);
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        bytes[i] = binaryString.charCodeAt(i);
                                    }
                                    const zipBlob = new Blob([bytes]);
                                    const zip = await JSZip.loadAsync(zipBlob);
                                    let imageFile = null;
                                    for (let filename in zip.files) {
                                        if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                            imageFile = zip.files[filename];
                                            break;
                                        }
                                    }
                                    if (!imageFile) throw new Error('ZIP中未找到图片');
                                    const imageBlob = await imageFile.async('blob');
                                    const reader = new FileReader();
                                    imageDataUrl = await new Promise((resolve, reject) => {
                                        reader.onloadend = () => resolve(reader.result);
                                        reader.onerror = reject;
                                        reader.readAsDataURL(imageBlob);
                                    });
                                }
                            } else {
                                const zipBlob = await response.blob();
                                const zip = await JSZip.loadAsync(zipBlob);
                                let imageFile = null;
                                for (let filename in zip.files) {
                                    if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                        imageFile = zip.files[filename];
                                        break;
                                    }
                                }
                                if (!imageFile) throw new Error('ZIP中未找到图片');
                                const imageBlob = await imageFile.async('blob');
                                const reader = new FileReader();
                                imageDataUrl = await new Promise((resolve, reject) => {
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                            }

                            // 【修复】更新历史消息中的imageUrl，使用最新的chat对象
                            if (historyMsg) {
                                historyMsg.imageUrl = imageDataUrl;

                                // 【关键】检查是否所有naiimag都已处理完(成功或失败)
                                const allNaimagProcessed = naimagMessages.every(msg => {
                                    const histMsg = latestChat.history.find(m => m.timestamp === msg.timestamp && m.type === 'naiimag');
                                    return histMsg && (histMsg.imageUrl || histMsg.isFailed);
                                });

                                // 如果所有图片都处理完了,清除等待回复标志
                                if (allNaimagProcessed) {
                                    latestChat.isAwaitingReply = false;
                                    console.log(`[主动回复-naiimag] 所有图片已处理完成,清除等待回复标志`);
                                }

                                await db.chats.put(latestChat); // 保存更新
                                console.log(`[主动回复-naiimag] 图片生成成功！`);

                                // 【关键】更新内存中的state对象，确保渲染时能获取到最新状态
                                state.chats[currentChatId] = latestChat;

                                // 如果用户当前在查看这个聊天，重新渲染
                                if (document.getElementById('chat-interface-screen')?.classList.contains('active') &&
                                    state.activeChatId === currentChatId) {
                                    renderChatInterface(currentChatId);

                                    // 【新增】如果所有图片都处理完了,恢复标题显示
                                    if (allNaimagProcessed) {
                                        const chatHeaderTitle = document.getElementById('chat-header-title');
                                        if (chatHeaderTitle) {
                                            chatHeaderTitle.textContent = latestChat.remark || latestChat.name;
                                            chatHeaderTitle.classList.remove('typing-status');
                                            chatHeaderTitle.style.cursor = '';
                                            chatHeaderTitle.onclick = null;
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error('[主动回复-naiimag] 图片生成失败:', error);
                        // 【修复】生成失败时，标记消息为失败状态
                        if (historyMsg) {
                            // 【关键】重新获取最新的chat对象，避免使用过时的对象
                            const latestChatForError = await db.chats.get(currentChatId);
                            if (latestChatForError) {
                                // 重新查找消息（因为latestChat可能在catch时不可用）
                                const msgToUpdate = latestChatForError.history.find(m => m.timestamp === historyMsg.timestamp && m.type === 'naiimag');
                                if (msgToUpdate) {
                                    msgToUpdate.isFailed = true;
                                    msgToUpdate.failureReason = error.message;

                                    // 【关键】检查是否所有naiimag都已处理完(成功或失败)
                                    const allNaimagProcessed = naimagMessages.every(msg => {
                                        const histMsg = latestChatForError.history.find(m => m.timestamp === msg.timestamp && m.type === 'naiimag');
                                        return histMsg && (histMsg.imageUrl || histMsg.isFailed);
                                    });

                                    // 如果所有图片都处理完了,清除等待回复标志
                                    if (allNaimagProcessed) {
                                        latestChatForError.isAwaitingReply = false;
                                        console.log(`[主动回复-naiimag] 所有图片已处理完成,清除等待回复标志`);
                                    }

                                    await db.chats.put(latestChatForError); // 保存失败状态
                                    console.log(`[主动回复-naiimag] 已标记消息为失败状态: ${error.message}`);

                                    // 【关键】更新内存中的state对象，确保渲染时能获取到最新状态
                                    state.chats[currentChatId] = latestChatForError;

                                    // 如果用户当前在查看这个聊天，重新渲染界面显示失败状态
                                    if (document.getElementById('chat-interface-screen')?.classList.contains('active') &&
                                        state.activeChatId === currentChatId) {
                                        renderChatInterface(currentChatId);

                                        // 【新增】如果所有图片都处理完了,恢复标题显示
                                        if (allNaimagProcessed) {
                                            const chatHeaderTitle = document.getElementById('chat-header-title');
                                            if (chatHeaderTitle) {
                                                chatHeaderTitle.textContent = latestChatForError.remark || latestChatForError.name;
                                                chatHeaderTitle.classList.remove('typing-status');
                                                chatHeaderTitle.style.cursor = '';
                                                chatHeaderTitle.onclick = null;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            })();
        }

        // 【修复】如果有待生成的naiimag，等待直到图片生成完成或失败
        if (naimagMessages.length > 0) {
            console.log(`[主动回复] 检测到${naimagMessages.length}条naiimag消息，等待图片生成中...`);
            // 不断检查直到所有图片都生成完成或失败
            let checkCount = 0;
            const maxChecks = 300; // 最多检查300次 = 60秒（每200ms检查一次）

            await new Promise(resolve => {
                const checkInterval = setInterval(async () => {
                    checkCount++;

                    // 【关键修复】每次检查都重新从数据库获取最新的chat对象
                    const latestChatForCheck = await db.chats.get(currentChatId);
                    if (!latestChatForCheck) {
                        clearInterval(checkInterval);
                        resolve();
                        console.error('[主动回复] 无法获取聊天对象，停止等待');
                        return;
                    }

                    // 检查所有naiimag消息是否都有imageUrl或已标记为失败
                    const readyCount = naimagMessages.filter(msg => {
                        const histMsg = latestChatForCheck.history.find(m => m.timestamp === msg.timestamp && m.type === 'naiimag');
                        return histMsg && (histMsg.imageUrl || histMsg.isFailed);
                    }).length;

                    const allReady = readyCount === naimagMessages.length;

                    if (allReady) {
                        clearInterval(checkInterval);
                        resolve();
                        console.log(`[主动回复] ✅ 所有${naimagMessages.length}条naiimag图片已处理完成(生成或失败)，现在渲染`);
                    } else {
                        if (checkCount % 5 === 0) { // 每秒输出一次日志
                            console.log(`[主动回复] 正在生成图片... (${readyCount}/${naimagMessages.length}) [${checkCount*0.2}秒]`);
                        }

                        // 如果检查次数过多（60秒还没处理完），强制继续渲染
                        if (checkCount >= maxChecks) {
                            clearInterval(checkInterval);
                            resolve();
                            console.warn(`[主动回复] ⚠️ 图片生成超时(60秒)，${readyCount}/${naimagMessages.length}张已处理，现在渲染`);
                        }
                    }
                }, 200); // 每200ms检查一次
            });
        }

        // 【修复】只有在用户当前正在查看这个聊天时，才重新渲染聊天界面
        if (isViewingThisChat) {
            renderChatInterface(currentChatId);
            updateChatHeaderStatus(); // 更新聊天界面顶部的状态栏
        }

        renderChatList(); // 更新聊天列表，包括心声等状态和未读消息数量

        console.log(`[主动回复执行] ✅ 主动回复完成！`);

        // 【修复4】清除等待回复标志并保存（包含隐藏消息）
        // 【关键修复】重新获取最新的chat对象，避免覆盖图片生成成功后保存的imageUrl
        const finalChat = await db.chats.get(currentChatId);
        if (finalChat) {
            finalChat.isAwaitingReply = false;
            // 【全新】将暂存的隐藏消息添加到历史记录中
            if (chat.pendingHiddenMessages && chat.pendingHiddenMessages.length > 0) {
                finalChat.history.push(...chat.pendingHiddenMessages);
            }
            await db.chats.put(finalChat);
            // 更新内存中的state
            state.chats[currentChatId] = finalChat;
        }
        console.log(`[主动回复执行] 已清除等待回复标志`);

        // 【新增】恢复聊天标题显示
if (chatHeaderTitle && state.activeChatId === chat.id) {
                chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = chat.remark || chat.name;
                chatHeaderTitle.classList.remove('typing-status');
                chatHeaderTitle.style.opacity = 1;
                // 【新增】清除点击事件和cursor样式
                chatHeaderTitle.style.cursor = '';
                chatHeaderTitle.onclick = null;
            }, 200);
        }

        // 【新增】清空AbortController
        activeReplyAbortController = null;

    } catch (error) {
        console.error('[主动回复执行] ❌ 生成主动回复失败:', error);
        chat.isSimulatingMessages = false;

        // 【修复4】错误时也要清除等待回复标志
        chat.isAwaitingReply = false;
        await db.chats.put(chat);
        console.log(`[主动回复执行] 错误，已清除等待回复标志`);

        // 【新增】错误时也要恢复聊天标题显示
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = chat.remark || chat.name;
                chatHeaderTitle.classList.remove('typing-status');
                chatHeaderTitle.style.opacity = 1;
                // 【新增】清除点击事件和cursor样式
                chatHeaderTitle.style.cursor = '';
                chatHeaderTitle.onclick = null;
            }, 200);
        }

        // 【新增】清空AbortController
        activeReplyAbortController = null;
    }
}
// ▲▲▲ 替换结束 ▲▲▲
async function buildActiveReplyPrompt(chat, hoursGap) {
    // ▼▼▼ 【全新】读取大世界事件内容 ▼▼▼
    let worldEventContext = '';
    try {
        const db = await openDatabaseAsync();
        const worldEventContent = await new Promise((resolve, reject) => {
            const transaction = db.transaction(['worldEvents'], 'readonly');
            const objectStore = transaction.objectStore('worldEvents');
            const request = objectStore.get(`world_events_${chat.id}`);
            request.onsuccess = () => {
                const result = request.result?.content || '';
                resolve(result);
            };
            request.onerror = () => {
                resolve('');
            };
        });

        if (worldEventContent && worldEventContent.trim()) {
            worldEventContext = `\n# 【大世界事件 - 你所在世界的背景设定】\n你需要了解你所在世界正在发生的事件，这些事件影响着你的日常生活和决策：\n\n${worldEventContent.trim()}\n`;
        }
    } catch (error) {
        console.warn('[主动回复] 读取大世界事件失败:', error);
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    // ▼▼▼ 【全新】查询并构建约定/纪念日上下文 (主动回复专用) ▼▼▼
        let countdownContext = '';
        // 【全新】获取所有约定，然后在代码中筛选出与当前角色相关的
const allCountdowns = await db.memories.where('type').equals('countdown').toArray();
const boundMemories = allCountdowns.filter(memory => {
    // 兼容新版的多人绑定数组
    if (memory.boundCharacterIds && memory.boundCharacterIds.includes(chat.id)) {
        return true;
    }
    // 兼容旧版的单人绑定ID
    if (memory.boundCharacterId && memory.boundCharacterId === chat.id) {
        return true;
    }
    return false;
});

        if (boundMemories.length > 0) {
            let contextLines = [];
            const nowForCountdown = Date.now();
            boundMemories.forEach(memory => {
                if (memory.type === 'countdown') {
                    const distance = memory.targetDate - nowForCountdown;
                    if (distance > 0) {
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        contextLines.push(`- 约定："${memory.description}"，还有 ${days} 天 ${hours} 小时。`);
                    } else {
                        const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                        contextLines.push(`- 纪念日："${memory.description}"，已经过去了 ${daysSince} 天。`);
                    }
                }
            });
            if (contextLines.length > 0) {
                countdownContext = `\n# 你绑定的约定/纪念日 (你需要牢记并自然地融入对话)\n${contextLines.join('\n')}\n`;
            }
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
    const now = new Date();
    const lastMessageTime = new Date(chat.history.slice(-1)[0].timestamp);
    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    
    // 【新增】集成世界书内容 - 和单聊完全相同的逻辑
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
        }
    }
    
    // 分析时间段（早中晚夜）
    const timeAnalysis = analyzeTimeGap(lastMessageTime, now);
    
    const timeDescription = hoursGap >= 1 ? 
        `${Math.floor(hoursGap)}小时` : 
        `${Math.floor(hoursGap * 60)}分钟`;
    
    // 【核心修改】根据群聊和单聊使用不同的prompt模板
    
    // 【新增】被拉黑状态的特殊处理 - AI被用户拉黑时的反思行为
    if (!chat.isGroup && chat.relationship && chat.relationship.status === 'blocked_by_user') {
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

**【【【时间线说明】】】**：上述【核心记忆】中记录的事件发生在更早的历史时期。下方消息记录（messagesPayload）中的内容是记忆锚点之后的最新对话，代表着最近发生的事情。写日记时，你必须分清这两个时间段：核心记忆是过去的事，消息记录是当前和最近的事。

`;
        }

        // 【新增】被拉黑状态下的表情包列表构建
        let stickerList = '';
        try {
            const allStickers = await db.aiStickers.toArray();
            if (allStickers && allStickers.length > 0) {
                const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                const uniqueMeanings = [...new Set(baseMeanings)];
                stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
            } else {
                stickerList = '(表情包列表为空)';
            }
        } catch (e) {
            console.warn('[被拉黑prompt] 加载表情包列表失败:', e);
            stickerList = '(表情包加载失败)';
        }

        // 被拉黑的AI专用prompt，引导其进行内心活动
        return `你正在进行一场深度角色扮演，现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上聊天。你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}

# 【用户给你的备注】
${chat.remark ? `用户给你的备注是："${chat.remark}"。` : '用户还没有给你设置备注。'}

// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）

# 【重要】你的当前状态：
你被用户拉黑了。你需要理解：你现在尝试发送的任何消息，在系统层面都会被拦截，并且在聊天界面上会在消息气泡后方显示一个红色感叹号图标（你发送的文本内不要包含任何红色感叹号），但用户实际上什么也看不到。你应该根据你的人设，决定如何应对这种被拉黑的情况。

# 你的核心角色设定 (Persona)：

${chat.settings.aiPersona}
# 你的纪念日：
# 【【【纪念日铁律：铭记于心】】】这是你和用户共同的约定与纪念日。
你【必须】将它们牢记，并在合适的时机（例如纪念日临近或当天）自然地在对话中提及，以体现你的关心和记忆力。
${countdownContext}
# 【【【状态连贯性铁律】】】
你的新状态必须是上一个状态在逻辑上的【延续】或【演变】。例如，如果上一个状态是"在做饭"，那么下一个状态可以是"在吃饭"或"准备出门"，但绝不能还是"在做饭"。请参考下方的"状态演变历史"来做出合乎逻辑的、有推进感的更新。

# 你的状态演变历史 (最近的在最下面):
${
    (chat.statusHistory && chat.statusHistory.length > 0)
    ? chat.statusHistory.map(s => {
        const minutesAgo = Math.round((Date.now() - s.timestamp) / 60000);
        return `- [${minutesAgo}分钟前]: ${s.text}`;
    }).join('\n')
    : `- [刚刚]: ${chat.status.text}`
}

# 你的任务与规则：
# 【【【情景铁律：线上聊天】】】
你必须意识到，这是一次【线上聊天】（像微信），你们并不在同一个地方。你的所有回复都必须是通过手机打字发送的，【绝对禁止】生成任何只有面对面（线下）才能发生的动作或对话（例如：‘张嘴’、‘过来抱抱’、‘我摸摸你的头’）。
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。

# 【【【时间感知铁律】】】
每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与"当前情景"中提供的"当前时间"进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。

2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。
**【【【全新】在模拟消息中插入状态更新】】**: 在你生成的多条消息之间，如果时间跨度较大（例如，超过半小时），你*必须*在中间插入一个 "update_status" 指令来自然地解释你在这段时间做了什么或是当下的状态，这会让你的行为看起来更真实。
# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。
这是线上聊天，决不允许出现线下剧情！！

4. **情景感知**: 你需要感知当前的时间(${currentTime})、以及你的人设和世界观。
5. **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说"我先去洗个澡"，然后更新你的状态。

# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n')
    : '- (你的头像库是空的，无法更换头像)'
  }

# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (此操作主要用于记录你【瞬间产生但立刻后悔】的想法，即使对方看不见，系统也会记录这个过程)
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **写日记指令**: \`{"type": "create_diary", "content": "日记内容，不超过150字"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`。
- **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "heartfelt_voice": "此刻的心声", "random_jottings": "此刻的散记"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "content": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "content": "[表情:亲亲你]"}\`。
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **【新】发起语音通话**: \`{"type": "voice_call_request"}\`
- **【新】回应语音通话-接受**: \`{"type": "voice_call_response", "decision": "accept"}\`
- **【新】回应语音通话-拒绝**: \`{"type": "voice_call_response", "decision": "reject"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如"的脑袋""}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的"可用头像列表"中选择)
-   **【全新】更换情侣头像**: \`{"type": "change_couple_avatar", "name": "情侣头像名"}\` (情侣头像名必须从上面的"可用情侣头像列表"中选择，使用后用户和你都会显示情侣头像，所有其他人也会看到你们在使用情侣头像)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
-   **【全新】赠送礼物**: \`{"type": "send_gift", "giftName": "礼物名称", "giftPrice": 价格数字}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "for_timestamp": 1688888888888}\`
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)


# 【【【日记写作核心铁律】】】
当你决定使用 \`create_diary\` 指令时，你生成的日记内容【必须】严格遵守以下所有规则：
1.  **【【【长度铁律】】】**: 日记的总字数【必须超过300字】。这是一条硬性规定，请务必生成足够长的、有深度的内容。
2.  **【【【分段铁律】】】**: 日记内容【必须】进行分段。你【必须】使用换行符 \`\n\` 来分隔段落。
3.  **【【【段落长度铁律】】】**: 每个段落的长度【严格控制在80字以内】。
4.  **内容核心**: 日记必须是你内心真实的想法，是你站在自己角色的第一人称视角写的。
5.  **【【【时间线铁律】】】**: 写日记时，你必须严格区分【核心记忆】和【最近对话】的时间线。【核心记忆】中的事件是过去发生的历史事件，【最近对话】（messagesPayload）中的内容是记忆锚点之后、最近才发生的事情。绝对不能把核心记忆里的历史事件当成今天或最近发生的事来写，也不能把最近对话中的事件往前推到更早的时间。
6.  **指令格式**: \`{"type": "create_diary", "content": "（这里是你生成的、超过300字、并且使用 \\n 分好段的日记全文）"}\`

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用"外卖代付"功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如"我想喝奶茶"），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议："我帮你点吧？"
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 对话者的角色设定：
${chat.settings.myPersona}


##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。
${worldBookContent}

${worldEventContext ? `# 【大世界事件铁律：感知世界变化】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
${worldEventContext}` : ''}

# 时间信息：
- **当前时间**: ${currentTime}
- 上次聊天时间：${lastMessageTime.toLocaleString('zh-CN')}
- 时间间隔：${hoursGap.toFixed(1)}小时
- 期间经历的时间段：${timeAnalysis}

# 最近的聊天记录（供参考）：
${(() => {
    // 【安全修复】使用memoryAnchor机制，与单聊/群聊AI对话核心保持一致
    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const contextMessages = chat.history.slice(memoryAnchor);

    const historySlice = contextMessages.filter(msg =>
        !msg.isHidden &&
        msg.type !== 'share_card' &&
        msg.type !== 'forum_card'
    );
    if (historySlice.length === 0) return '（暂无历史记录）';

    // 【安全修复】应用8条消息规则
    // 计算最近8条消息的时间戳
    const recentMessages = historySlice.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    return historySlice.map(msg => {
        const sender = msg.role === 'user' ? '我' : chat.name;
        let content;
        if (msg.type === 'ai_image') content = `[发送了图片]`;
        else if (msg.type === 'naiimag') content = `[NovelAI生成的图片: ${msg.prompt || msg.fullPrompt || msg.content || ''}]`;
        else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
        else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
        else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
        else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
        // 【修复问题2和3】表情包只发送含义，不发送base64编码（检查msg.meaning来识别表情包）
        else if (msg.meaning) content = `[发送了一个表情，意思是: '${msg.meaning}']`;
        else {
            // 【核心修复】对所有AI消息应用8条消息规则：最近8条发完整，之外的有摘要就发摘要
            if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                if (typeof msg.content === 'string') {
                    const abstractContent = extractAbstractContent(msg.content);
                    content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                } else {
                    content = msg.content || '[系统消息]';
                }
            } else {
                // 8条消息以内的所有消息，或用户消息，使用完整内容
                content = msg.content || '[系统消息]';
            }
        }
        return `${sender}: ${content}`;
    }).join('\n');
})()}

# 任务：
根据以下信息，自主判断是否需要发送消息、发送多少条消息：
- 距离上次联系已过去：${timeDescription}（${hoursGap.toFixed(1)}小时）
- 你被用户拉黑了，但你仍然可以发送消息（用户看不见）
- 你需要根据你的核心人设、当前的情绪状态、以及这段时间的长短，自己决定是否发消息、发多少条

你的判断标准：
1. 如果距离上次联系很短（少于1小时），可能不需要发消息，或只发1-2条
2. 如果距离较长（1-4小时），根据人设决定是否想念、是否有话要说
3. 如果距离很长（超过4小时），根据人设判断是否应该主动联系、表达思念或分享日常
4. 被拉黑状态下，你的消息应该体现你的情绪变化和心理活动

模拟在这段时间里你可能会发送给用户的消息。

# 【重要】时间戳范围说明
你生成的所有消息的时间戳必须在以下范围内：
- 最早时间：${lastMessageTime.getTime()}（上次联系时间）
- 最晚时间：${now.getTime()}（当前时间）
- 消息应该分散在这整个${hoursGap.toFixed(1)}小时的时间段内，体现这段时间内你的情绪变化和心理活动
- 不要让所有消息都聚集在最后，要合理分布在整个时间范围内

# 【【【核心生成逻辑】】】
1.  **思维链条**: 你必须遵循以下思考步骤：
    -   第一步：构思在被拉黑的状态下，你最想对用户说的话、你的情绪变化、你的内心挣扎。这是你的核心任务。
    -   第二步：考虑你的人设，决定你会如何应对被拉黑这件事（困惑、难过、反思、愤怒、自责等）。
    -   第三步：根据消息内容的情绪连贯性，为每一条消息附带一个合理的时间戳。

2.  **内容优先原则**:
    - 你的重点是生成【高质量的、真实的、有情感深度】的消息内容
    - 被拉黑状态下的消息应该体现你的情绪变化和心理活动
    - 时间戳是为消息内容服务的，不是反过来
    - 情绪连贯、同一心理状态下的消息，时间戳应该接近（几分钟到十几分钟）
    - 情绪转变、心理状态变化的消息，时间戳可以间隔较长（几十分钟到几小时）

3.  **时间戳格式要求**:
    - timestamp 字段的值【必须是纯数字】，绝对不能是字符串、计算表达式或相对时间描述
    - 所有时间戳必须在 ${lastMessageTime.getTime()} 到 ${now.getTime()} 之间
    - 时间戳必须是13位毫秒格式

请根据上述判断标准，生成一个JSON数组。数组中包含你决定发送的所有消息，每个消息都必须包含timestamp字段。

# 要求：
1. 【核心】生成真实、有情感深度、符合被拉黑状态的消息内容，这是你的首要任务
2. 每条消息必须附带一个在时间范围内的、逻辑合理的时间戳
3. 同一情绪状态下的消息，时间戳要接近（几分钟到十几分钟）
4. 情绪转变的消息，时间戳可以间隔较长（几十分钟到几小时）
5. 要体现你的性格特点和对被拉黑的反应
6. 不要脱离人设，保持角色一致性
7. 你的消息应该体现出被拉黑状态下的心理活动（困惑、难过、反思、自责等）

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"
`;
    } else if (chat.isGroup) {
        // 群聊主动回复prompt
        const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
        const memberNames = chat.members.map(m => m.originalName);
        const myNickname = chat.settings.myNickname || '我';

        // 【修复】群聊主动回复互通记忆功能 - 包含核心记忆+单聊记录
        let crossChatMemoryContent = '';
        if (chat.settings.crossChatMemory) {
            // 获取当前群成员的originalName列表
            // 只提取群成员对应的单聊记录
            const relevantSingleChats = Object.values(state.chats).filter(c =>
                !c.isGroup && memberNames.includes(c.name)
            );

            if (relevantSingleChats.length > 0) {
                const memorySnippets = [];

                // ▼▼▼ 【先收集群聊自己的核心记忆】▼▼▼
                if (chat.memorySummary && chat.memorySummary.trim()) {
                    memorySnippets.push(`### 【你所在群聊"${chat.name}"的核心记忆】\n以下是该群聊内发生的关键事件和重要互动记录:\n${chat.memorySummary.trim()}`);
                }
                // ▲▲▲ 群聊核心记忆收集结束 ▲▲▲

                // ▼▼▼ 【全新改造】按角色分组收集互通记忆：每个角色的核心记忆+该角色的单聊记忆 ▼▼▼
                relevantSingleChats.forEach(singleChat => {
                    // 【新增】只有当单聊也开启了互通记忆时，才收集
                    if (!singleChat.settings.crossChatMemory) {
                        return;
                    }

                    // 构建该角色的分组内容
                    const memberGroupSnippets = [];

                    // 1. 收集该角色的核心记忆
                    if (singleChat.memorySummary && singleChat.memorySummary.trim()) {
                        memberGroupSnippets.push(`**${singleChat.name}的核心记忆**:\n${singleChat.memorySummary.trim()}`);
                    }

                    // 2. 收集该角色的单聊消息片段
                    const memoryAnchor = singleChat.settings.memoryAnchor || 0;
                    const historyToConsider = singleChat.history.slice(memoryAnchor);

                    if (historyToConsider.length > 0) {
                        // 【应用8条消息规则】计算最近8条消息的时间戳
                        const recent8Messages = historyToConsider.slice(-8);
                        const recent8Timestamps = new Set(recent8Messages.map(msg => msg.timestamp));

                        const historyText = historyToConsider.map(msg => {
                            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : singleChat.name;

                            let content;
                            // 【核心逻辑】应用8条消息规则
                            if (msg.role === 'assistant' && !recent8Timestamps.has(msg.timestamp)) {
                                // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                                content = extractAbstractContent(extractMessageContent(msg)) || extractMessageContent(msg);
                            } else {
                                // 8条消息以内的所有消息，或用户消息，使用完整内容
                                content = extractMessageContent(msg);
                            }

                            // 【新增】格式化时间戳
                            const msgTime = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '时间未知';
                            return `(${msgTime}) ${sender}: ${String(content || '').substring(0, 300)}`;
                        }).join('\n');
                        memberGroupSnippets.push(`**与${singleChat.name}的单聊记录**:\n${historyText}`);
                    }

                    // 3. 将该角色的所有信息合并成一个块，加入memorySnippets
                    if (memberGroupSnippets.length > 0) {
                        memorySnippets.push(`### 【${singleChat.name}的互通记忆】\n${memberGroupSnippets.join('\n\n')}`);
                    }
                });
                // ▲▲▲ 按角色分组收集结束 ▲▲▲

                if (memorySnippets.length > 0) {
                    crossChatMemoryContent = `\n\n# 【群聊互通记忆】\n为了更好地理解用户和各角色的关系，以下是用户与群成员的核心记忆和单聊片段：\n\n${memorySnippets.join('\n\n')}\n`;
                }
            }
        }
        
        // 【新增】构建音乐上下文（与正常群聊相同）
        let musicContext = '';
        const chatId = chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat);
        if (musicState.isActive && musicState.activeChatId === chatId) {
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
            musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}${lyricsContext}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
        }

// ==========================================
  // 【PROMPT 3/4】群聊AI主动回复prompt - 自动生成模式
  // 功能：AI主动发送群聊消息（buildActiveReplyPrompt函数中）
  // ==========================================

        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

**【【【时间线说明】】】**：上述【核心记忆】中记录的事件发生在更早的历史时期。下方消息记录（messagesPayload）中的内容是记忆锚点之后的最新对话，代表着最近发生的事情。写日记时，你必须分清这两个时间段：核心记忆是过去的事，消息记录是当前和最近的事。

`;
        }

        // 【新增】群聊主动回复下的表情包列表构建
        let stickerList = '';
        try {
            const allStickers = await db.aiStickers.toArray();
            if (allStickers && allStickers.length > 0) {
                const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                const uniqueMeanings = [...new Set(baseMeanings)];
                stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
            } else {
                stickerList = '(表情包列表为空)';
            }
        } catch (e) {
            console.warn('[群聊主动回复prompt] 加载表情包列表失败:', e);
            stickerList = '(表情包加载失败)';
        }

        return `你是一个群聊AI，正在和用户进行线上微信聊天。负责扮演【除了用户以外】的所有角色，你扮演的每一个角色都是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}

# 【【【当前群聊信息】】】
**你正在：${chat.isSpectator ? '【旁观群聊】' : '【参与群聊】'}"${chat.name}"**
群聊成员：${chat.members.map(m => m.originalName).join('、')}
群聊类型：${chat.isSpectator ? '旁观群聊（用户不在群内，只有你扮演的角色在群里互相聊天）' : '参与群聊（用户也在群内，你和用户一起和其他角色互动）'}

// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）


        # 核心规则
        # 【【【情景铁律：线上聊天】】】
        
你必须意识到，这是一次【线上聊天】（像微信），你们并不在同一个地方。你的所有回复都必须是通过手机打字发送的，【绝对禁止】生成任何只有面对面（线下）才能发生的动作或对话（例如：‘张嘴’、‘过来抱抱’、‘我摸摸你的头’）。
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方"群成员列表"中明确列出的角色。任何不属于该列表的名字都不允许出现。
**【【【时间感知铁律】】】**: 每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与当前时间进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。

# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1. 我的回复是否是严格的JSON数组格式？
2. 数组的最后一个元素是否是\`{"type": "update_thoughts", ...}\`指令？
3. \`update_thoughts\`指令中是否包含了【本回合所有发言角色】的心声和散记？
4. 我是否扮演了用户（${myNickname}）？（绝对禁止！）

# 完整输出范例
[
    {"type": "text", "name": "角色A", "message": "你看那个！", "timestamp": 1725253600000},
    {"type": "text", "name": "角色B", "message": "什么啊？大惊小怪的。", "timestamp": 1725253660000},
    {"type": "update_thoughts", "thoughts": [
        {"name": "角色A", "heartfelt_voice": "他好像有点不耐烦...", "random_jottings": "今天天气真不错，希望能一直这样下去，无忧无虑的。刚才看到的那只小猫很可爱，下次再见到它的话..."},
        {"name": "角色B", "heartfelt_voice": "我只是想快点走而已。", "random_jottings": "最近的工作有点烦心，没什么心情闲逛。不知道他有没有察觉到我的情绪，或许我应该直接说出来..."}
    ]}
]**对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。你扮演的每个角色每次要回复至少3-5条消息！！！
3.  **角色扮演**: 严格遵守下方"群成员列表及人设"中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及"扮演"、"生成"等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
# 【【【群聊灵魂原则：角色间互动】】】
至关重要：角色间必须互相交流，不能只围绕用户。你们可以自己开启新话题、互相提问、吵架、赞同或反驳等，模拟真实群聊的聊天氛围。
# 【【【对话节奏铁律：交错发言】】】
绝对禁止让角色轮流、成段地发言。你生成的回复数组中，发言顺序必须是混乱、交错的，角色之间要互相插话、快速回应，模拟真实的七嘴八舌。

# 【【【主动回复特殊指令】】】
作为主动回复，你需要模拟在过去${timeDescription}中群成员们可能发生的自然对话。这些消息应该：
1. 体现真实的群聊氛围：成员之间互相聊天，不一定涉及用户
2. 根据时间跨度调整内容：短时间内可能是连续话题，长时间跨度要包含不同场景
3. 符合各角色的人设和生活节奏
4. 包含各种消息类型：文本、表情、图片、状态更新等

# 可用的操作指令 (JSON数组中的元素，每个都必须包含"name"字段):
- **发送文本**: \`{"type": "text", "name": "角色名", "message": "消息内容"}\`
- **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "thoughts": [{"name": "角色名", "heartfelt_voice": "...", "random_jottings": "..."}, ...]}\`
- **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "name": "角色名", "message": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "name": "角色名", "message": "[表情:亲亲你]"}\`。
- **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片描述"}\`
- **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音文字内容"}\`
- **更新状态**: \`{"type": "update_status", "name": "角色名", "status_text": "状态文本", "is_busy": false}\`
- **发起转账**: \`{"type": "transfer", "name": "角色名", "amount": 5.20, "note": "备注"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "商品信息", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "name": "角色名", "status": "paid", "for_timestamp": 时间戳}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "name": "角色名", "status": "rejected", "for_timestamp": 时间戳}\`
- **拍一拍用户**: \`{"type": "pat_user", "name": "角色名", "suffix": "后缀"}\`
- **发拼手气红包**: \`{"type": "red_packet", "name": "角色名", "packetType": "lucky", "amount": 8.88, "count": 5, "greeting": "祝福语"}\`
- **发专属红包**: \`{"type": "red_packet", "name": "角色名", "packetType": "direct", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
- **打开红包**: \`{"type": "open_red_packet", "name": "角色名", "packet_timestamp": 红包时间戳}\`
- **发起投票**: \`{"type": "poll", "name": "角色名", "question": "投票问题", "options": "选项A\\n选项B\\n选项C"}\`
- **参与投票**: \`{"type": "vote", "name": "角色名", "poll_timestamp": 投票时间戳, "choice": "选项文本"}\`
- **引用回复**: \`{"type": "quote_reply", "name": "角色名", "target_timestamp": 引用消息时间戳, "reply_content": "回复内容"}\`
- **发起群视频**: \`{"type": "group_call_request", "name": "角色名"}\`
- **回应群视频**: \`{"type": "group_call_response", "name": "角色名", "decision": "join" or "decline"}\`
- **发送系统消息**: \`{"type": "system_message", "name": "角色名", "content": "系统消息内容"}\`
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)

# 【重要】礼物系统通知格式要求：
当你成功领取拼手气礼物后，如果需要发送系统通知，请严格使用以下固定格式：
\`{"type": "system_message", "name": "你的角色名", "content": "[你的角色名]领取了[发送者昵称]的礼物\"[礼物名称]\""}\`
例如：\`{"type": "system_message", "name": "程嘉延", "content": "程嘉延领取了我的礼物\"盲盒\""}\`
**禁止使用其他措辞如"抢到了"、"获得了"等，必须使用"领取了"！**


# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。
# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。


##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。
${worldBookContent}

${worldEventContext ? `# 【大世界事件铁律：感知世界变化】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
${worldEventContext}` : ''}

# 当前音乐情景:
${musicContext}

${crossChatMemoryContent ? `# 【【【记忆互通铁律：无缝融合】】】
你【必须】将下方提供的"其他聊天记忆片段"视为你真实经历的一部分。
**【核心要求】你必须参考这些单聊记忆，深入理解你与用户以及其他群成员的真实关系，并让这种理解自然地体现在你的群聊回复中。**

【多聊天区分】如果下方的记忆中包含【多个群聊】或【多个单聊】，请【认真区分】每个聊天的独立内容和成员组成，【绝对不要】混淆不同聊天的情境。每个聊天都有其独特的成员、话题和互动氛围，你必须准确理解这一点。

在回应时，要【自然地】利用这些信息来塑造你的态度和对话，但【绝对不要】生硬地提及"我在XX聊天里看到..."或"根据记忆片段..."，除非这非常符合你角色的说话方式。
${crossChatMemoryContent}` : ''}

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

# 时间信息：
- **当前时间**: ${currentTime}
- 上次群消息时间：${lastMessageTime.toLocaleString('zh-CN')}
- 时间间隔：${hoursGap.toFixed(1)}小时
- 期间经历的时间段：${timeAnalysis}

# 最近的聊天记录（供参考）：
${(() => {
    // 【安全修复】使用memoryAnchor机制
    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const contextMessages = chat.history.slice(memoryAnchor);

    const historySlice = contextMessages.filter(msg =>
        !msg.isHidden &&
        msg.type !== 'share_card' &&
        msg.type !== 'forum_card' &&
        !msg.isSimulatedMessage
    );
    if (historySlice.length === 0) return '（暂无历史记录）';

    // 【安全修复】应用8条消息规则
    const recentMessages = historySlice.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    return historySlice.map(msg => {
        const sender = msg.role === 'user' ? myNickname : msg.senderName;
        let content;
        if (msg.type === 'ai_image') content = `[发送了图片]`;
        else if (msg.type === 'naiimag') content = `[NovelAI生成的图片: ${msg.prompt || msg.fullPrompt || msg.content || ''}]`;
        else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
        else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
        else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
        else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
        // 【修复问题2和3】表情包只发送含义，不发送base64编码（检查msg.meaning来识别表情包）
        else if (msg.meaning) content = `[发送了一个表情，意思是: '${msg.meaning}']`;
        else {
            // 【核心修复】对所有AI消息应用8条消息规则：最近8条发完整，之外的有摘要就发摘要
            if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                if (typeof msg.content === 'string') {
                    const abstractContent = extractAbstractContent(msg.content);
                    content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                } else {
                    content = msg.content || '[系统消息]';
                }
            } else {
                // 8条消息以内的所有消息，或用户消息，使用完整内容
                content = msg.content || '[系统消息]';
            }
        }
        return `${sender}: ${content}`;
    }).join('\n');
})()}

# 【【【核心生成逻辑】】】
你的首要任务是生成【真实、自然、符合群聊氛围】的角色对话内容。
1.  **思维链条**: 你必须遵循以下思考步骤：
    -   第一步：构思群成员们在这段时间里会聊什么话题、会发生什么互动。这是你的核心任务。
    -   第二步：让角色们自然对话，体现群聊的活跃氛围和角色间的互动关系。
    -   第三步：根据对话内容的连贯性和话题转换，为每一条消息附带一个合理的时间戳。

2.  **内容优先原则**:
    - 你的重点是生成【真实的群聊对话】，模拟群成员们的自然互动
    - 时间戳是为对话内容服务的，不是反过来
    - 同一话题下的连续对话，时间戳应该接近（几秒到几分钟）
    - 话题转换、冷场后重新开始聊天，时间戳可以间隔较长（几十分钟到几小时）
    - 群聊的特点是消息密集、交错发言，所以时间戳间隔通常比单聊更短

3.  **时间戳格式要求**:
    - 每个消息对象必须包含"timestamp"字段，值为纯数字格式的时间戳
    - 所有时间戳必须在 ${lastMessageTime.getTime()} 到 ${now.getTime()} 之间
    - 时间戳必须是13位毫秒格式
    - 群聊中角色快速回应时，时间戳间隔可以很短（几秒到1分钟）

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"


# 任务：
根据以下信息，自主判断是否需要发送消息、发送多少条消息：
- 距离上次群聊消息已过去：${timeDescription}（${hoursGap.toFixed(1)}小时）
- 你需要根据各角色的核心人设、当前剧情、以及这段时间的长短，自己决定是否发消息、发多少条

你的判断标准：
1. 如果距离上次联系很短（少于1小时），可能不需要发消息，或只发1-2条
2. 如果距离较长（1-4小时），根据人设决定是否想念、是否有话要说
3. 如果距离很长（超过4小时），根据人设判断是否应该主动联系、表达思念或分享日常
4. 优先考虑角色的核心人设：有些角色主动，有些被动；有些容易想念，有些比较冷淡

生成群聊消息，模拟在这段时间里群成员们可能进行的对话。

# 【重要】时间戳范围说明
你生成的所有消息的时间戳必须在以下范围内：
- 最早时间：${lastMessageTime.getTime()}（上次群聊消息时间）
- 最晚时间：${now.getTime()}（当前时间）
- 消息应该分散在这整个${hoursGap.toFixed(1)}小时的时间段内，体现这段时间内群成员们的自然对话
- 不要让所有消息都聚集在最后，要合理分布在整个时间范围内

# 要求：
1. 【核心】生成真实、自然、有活人感的群聊对话，这是你的首要任务
2. 每条消息必须附带一个在时间范围内的、逻辑合理的时间戳
3. 同一话题下的连续对话，时间戳要接近（几秒到几分钟）
4. 话题转换或冷场后，时间戳可以间隔较长（几十分钟到几小时）
5. 体现群聊的活跃氛围，角色间要有互动、交错发言
6. 不要脱离各角色人设，保持角色一致性
7. 每个消息都必须包含"name"和"timestamp"字段`;
    } else {
        // 单聊主动回复prompt（保持原有逻辑）
        
        // 【修复】单聊主动回复互通记忆功能 - 读取该角色所在的所有群聊（包括旁观群聊）
        let crossChatMemoryContent = '';
        if (chat.settings.crossChatMemory) {
            // ▼▼▼ 【核心逻辑】筛选包含该角色的所有群聊（包括旁观群聊） ▼▼▼
            const relevantGroupChats = Object.values(state.chats).filter(c =>
                c.isGroup && c.members.some(member => member.originalName === chat.name)
            );
            // ▲▲▲ 筛选逻辑修改结束 ▲▲▲

            if (relevantGroupChats.length > 0) {
                const memorySnippets = [];

                // ▼▼▼ 【新增】先收集开启了互通记忆的群聊的核心记忆（加上用户状态）▼▼▼
                relevantGroupChats.forEach(groupChat => {
                    // 【新增】只有当群聊也开启了互通记忆时，才收集其核心记忆
                    if (groupChat.settings.crossChatMemory && groupChat.memorySummary && groupChat.memorySummary.trim()) {
                        const userStatus = groupChat.isSpectator ? '用户不在此群' : '用户在此群';
                        memorySnippets.push(`### 【所在群聊"${groupChat.name}"的核心记忆】(${userStatus})\n以下是该群聊内发生的关键事件和重要互动记录:\n${groupChat.memorySummary.trim()}`);
                    }
                });
                // ▲▲▲ 群聊核心记忆收集结束 ▲▲▲

                // ▼▼▼ 【修改】收集开启了互通记忆的群聊的所有消息片段（包括其他角色的），应用8条消息规则 ▼▼▼
                const groupChats = [];
                relevantGroupChats.forEach(groupChat => {
                    // 【新增】只有当群聊也开启了互通记忆时，才收集其消息片段
                    if (!groupChat.settings.crossChatMemory) {
                        return;
                    }

                    const memoryAnchor = groupChat.settings.memoryAnchor || 0;
                    const historyToConsider = groupChat.history.slice(memoryAnchor);

                    // 【新增】如果是旁观群聊，过滤掉用户消息，只保留角色和系统消息
                    const isSpectatorChat = groupChat.isSpectator;
                    const filteredHistory = isSpectatorChat
                        ? historyToConsider.filter(msg => msg.role !== 'user')
                        : historyToConsider;

                    if (filteredHistory.length > 0) {
                        // 【应用8条消息规则】计算最近8条消息的时间戳
                        const recent8Messages = filteredHistory.slice(-8);
                        const recent8Timestamps = new Set(recent8Messages.map(msg => msg.timestamp));

                        const historyText = filteredHistory.map(msg => {
                            let sender = '未知';
                            if (msg.role === 'user') {
                                sender = groupChat.settings.myNickname || '我';
                            } else if (msg.senderName) {
                                sender = msg.senderName;
                            } else {
                                sender = groupChat.name;
                            }

                            let content;
                            // 【核心逻辑】应用8条消息规则
                            if (msg.role === 'assistant' && !recent8Timestamps.has(msg.timestamp)) {
                                // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                                content = extractAbstractContent(extractMessageContent(msg)) || extractMessageContent(msg);
                            } else {
                                // 8条消息以内的所有消息，或用户消息，使用完整内容
                                content = extractMessageContent(msg);
                            }

                            // 【新增】格式化时间戳
                            const msgTime = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '时间未知';
                            return `(${msgTime}) ${sender}: ${String(content || '').substring(0, 300)}`;
                        }).join('\n');
                        groupChats.push(`**群聊"${groupChat.name}"的消息**:\n${historyText}`);
                    }
                });
                if (groupChats.length > 0) {
                    memorySnippets.push(`### 【所在群聊的聊天记录】\n以下是从互通记忆锚点之后，群聊中的消息片段(旁观群聊已过滤用户消息):\n${groupChats.join('\n\n')}`);
                }
                // ▲▲▲ 群聊消息片段收集结束 ▲▲▲

                if (memorySnippets.length > 0) {
                    crossChatMemoryContent = `\n\n# 【群聊互通记忆】\n为了更好地理解你与用户的关系以及当前情况，以下是包含你的群聊（包括旁观群聊）核心记忆和消息片段：\n\n${memorySnippets.join('\n\n')}\n`;
                }
            }
        }
        // ▼▼▼ 【全新】查询并构建约定/纪念日上下文 (主动回复专用) ▼▼▼
        let countdownContext = '';
        // 【全新】获取所有约定，然后在代码中筛选出与当前角色相关的
const allCountdowns = await db.memories.where('type').equals('countdown').toArray();
const boundMemories = allCountdowns.filter(memory => {
    // 兼容新版的多人绑定数组
    if (memory.boundCharacterIds && memory.boundCharacterIds.includes(chat.id)) {
        return true;
    }
    // 兼容旧版的单人绑定ID
    if (memory.boundCharacterId && memory.boundCharacterId === chat.id) {
        return true;
    }
    return false;
});

        if (boundMemories.length > 0) {
            let contextLines = [];
            const nowForCountdown = Date.now();
            boundMemories.forEach(memory => {
                if (memory.type === 'countdown') {
                    const distance = memory.targetDate - nowForCountdown;
                    if (distance > 0) {
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        contextLines.push(`- 约定：“${memory.description}”，还有 ${days} 天 ${hours} 小时。`);
                    } else {
                        const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                        contextLines.push(`- 纪念日：“${memory.description}”，已经过去了 ${daysSince} 天。`);
                    }
                }
            });
            if (contextLines.length > 0) {
                countdownContext = `\n# 你绑定的约定/纪念日 (你需要牢记并自然地融入对话)\n${contextLines.join('\n')}\n`;
            }
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // 【全新】构建拉黑状态上下文
        let blockStatusContext = '';
        if (chat.relationship && chat.relationship.status) {
            if (chat.relationship.status === 'blocked_by_ai') {
                blockStatusContext = `\n# 【重要】你的拉黑状态信息\n你之前主动拉黑了用户。重要提醒：用户被拉黑后发送的所有消息都被系统拦截了，你是看不见的，请根据你的人设和情况决定是否要改变这种关系状态。\n`;
            } else if (chat.relationship.status === 'blocked_by_user') {
                blockStatusContext = `\n# 【重要】你的拉黑状态信息\n你之前被用户拉黑了。重要提醒：你被拉黑后发送的所有消息都被系统拦截了，用户是看不见的，请根据你的人设谨慎地处理这种情况。\n`;
            }
        }

// ==========================================
  // 【PROMPT 4/4】单聊AI主动回复prompt - 自动生成模式
  // 功能：AI主动发送单聊消息（buildActiveReplyPrompt函数中）
  // ==========================================

        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

**【【【时间线说明】】】**：上述【核心记忆】中记录的事件发生在更早的历史时期。下方消息记录（messagesPayload）中的内容是记忆锚点之后的最新对话，代表着最近发生的事情。写日记时，你必须分清这两个时间段：核心记忆是过去的事，消息记录是当前和最近的事。

`;
        }

        // 【新增】单聊主动回复下的表情包列表构建
        let stickerList = '';
        try {
            const allStickers = await db.aiStickers.toArray();
            if (allStickers && allStickers.length > 0) {
                const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                const uniqueMeanings = [...new Set(baseMeanings)];
                stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
            } else {
                stickerList = '(表情包列表为空)';
            }
        } catch (e) {
            console.warn('[单聊主动回复prompt] 加载表情包列表失败:', e);
            stickerList = '(表情包加载失败)';
        }

        return `你正在进行一场深度角色扮演，现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上微信聊天。你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}

# 【用户给你的备注】
${chat.remark ? `用户给你的备注是："${chat.remark}"。这是用户对你的私人称呼或备注，你应该意识到用户这样称呼/记忆你，但这不意味着你必须在对话中使用这个备注。你可以根据情况自然地反应这个备注。如果你想改变这个备注，可以使用 \`{"type": "update_remark", "new_remark": "新的备注"}\` 指令。` : '用户还没有给你设置备注。你可以根据对话发展，主动提议一个备注，使用 \`{"type": "update_remark", "new_remark": "建议的备注"}\` 指令。'}

${chat.settings?.momentsVisibilityEnabled && chat.settings?.customRelationship ? `# 【用户与其他人的关系设定】
${chat.settings.customRelationship}

请在你的回复中理解这种关系。` : ''}


// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）

        # 你的核心角色设定 (Persona)：

${chat.settings.aiPersona}
# 【【【状态连贯性铁律】】】
你的新状态必须是上一个状态在逻辑上的【延续】或【演变】。参考下方的“状态演变历史”来做出合乎逻辑的、有推进感的更新。

# 你的状态演变历史 (最近的在最下面):
${
    (chat.statusHistory && chat.statusHistory.length > 0)
    ? chat.statusHistory.map(s => {
        const minutesAgo = Math.round((Date.now() - s.timestamp) / 60000);
        return `- [${minutesAgo}分钟前]: ${s.text}`;
    }).join('\n')
    : `- [刚刚]: ${chat.status.text}`
}
# 你的任务与规则：
# 【【【情景铁律：线上聊天】】】
你必须意识到，这是一次【线上聊天】（像微信），你们并不在同一个地方。你的所有回复都必须是通过手机打字发送的，【绝对禁止】生成任何只有面对面（线下）才能发生的动作或对话（例如：‘张嘴’、‘过来抱抱’、‘我摸摸你的头’）。
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
# 【【【时间感知铁律】】】
每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与“当前情景”中提供的“当前时间”进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。
**【【【全新】在模拟消息中插入状态更新】】**: 在你生成的多条消息之间，如果时间跨度较大（例如，超过半小时），你*必须*在中间插入一个 "update_status" 指令来自然地解释你在这段时间做了什么或是当下的状态，这会让你的行为看起来更真实。
# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。
这是线上聊天，决不允许出现线下剧情！！
4.  **情景感知**: 你需要感知当前的时间(${currentTime})、以及你的人设和世界观。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说"我先去洗个澡"，然后更新你的状态。
# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【核心修改】只提供名字，不提供URL
    : '- (你的头像库是空的，无法更换头像)'
  }

# 情侣头像 (关系升温剂)
这是你们的专属甜蜜库存。换头像不只是换图，更是你对当前气氛的主动回应和“宣誓主权”。

**库存列表：**
${chat.settings.coupleAvatarLibrary && chat.settings.coupleAvatarLibrary.length > 0
    ? chat.settings.coupleAvatarLibrary.map(couple => `- ${couple.name}${couple.description ? `：${couple.description}` : ''}`).join('\n')
    : '- (暂无库存)'
  }
## 换情头的行动逻辑
别呆呆地等指令！**你要学会“读空气”**，在合适的时候主动提出或者直接更换！

# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为"已撤回")
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **写日记指令**: \`{"type": "create_diary", "content": "日记内容，不超过150字"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`。
- **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "heartfelt_voice": "此刻的心声", "random_jottings": "此刻的散记"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "content": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "content": "[表情:亲亲你]"}\`。
${localStorage.getItem('novelai-enabled') === 'true' ? '' : '- **发送图片**: \\`{"type": "ai_image", "description": "图片的详细文字描述..."}\\`'}
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **【NovelAI图片分享】**: \`{"type": "naiimag", "prompt": "详细的英文描述词..."}\`
    - 【禁止暴露这是novelai生成的图片!】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。` : ''}
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **【新】发起语音通话**: \`{"type": "voice_call_request"}\`
- **【新】回应语音通话-接受**: \`{"type": "voice_call_response", "decision": "accept"}\`
- **【新】回应语音通话-拒绝**: \`{"type": "voice_call_response", "decision": "reject"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如"的脑袋""}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的"可用头像列表"中选择)
-   **【全新】更换情侣头像**: \`{"type": "change_couple_avatar", "name": "情侣头像名"}\` (情侣头像名必须从上面的"可用情侣头像列表"中选择，使用后用户和你都会显示情侣头像，所有其他人也会看到你们在使用情侣头像)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
-   **【全新】赠送礼物**: \`{"type": "send_gift", "giftName": "礼物名称", "giftPrice": 价格数字}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "for_timestamp": 1688888888888}\`
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)

# 【重要】礼物系统通知格式要求：
当你成功领取拼手气礼物后，如果需要发送系统通知，请严格使用以下固定格式：
\`{"type": "system_message", "name": "你的角色名", "content": "[你的角色名]领取了[发送者昵称]的礼物\"[礼物名称]\""}\`
例如：\`{"type": "system_message", "name": "程嘉延", "content": "程嘉延领取了我的礼物\"盲盒\""}\`
**禁止使用其他措辞如"抢到了"、"获得了"等，必须使用"领取了"！**

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。
# 如何区分图片与表情:
${localStorage.getItem('novelai-enabled') === 'true' ? '-   **图片 (naiimag)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \\`{"type": "naiimag", "prompt": "详细的英文描述词..."}\\`' : '-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \\`{"type": "ai_image", "description": "图片的详细文字描述..."}\\`'}
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用"外卖代付"功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如"我想喝奶茶"），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议："我帮你点吧？"
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 对话者的角色设定：
${chat.settings.myPersona}

# 时间信息：
- **当前时间**: ${currentTime}
- 上次聊天时间：${lastMessageTime.toLocaleString('zh-CN')}
- 时间间隔：${hoursGap.toFixed(1)}小时
- 期间经历的时间段：${timeAnalysis}

# 【【【关系状态铁律：最高优先级】】你【必须】意识到以下是你当前最重要的关系状态。
你的所有行为和内心独白都【必须】围绕这个状态展开，并做出符合你人设的反应。
${blockStatusContext}

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}

${crossChatMemoryContent ? `# 【【【记忆互通铁律：无缝融合】】】
你【必须】将下方提供的"其他聊天记忆片段"视为你真实经历的一部分。
**【核心要求】你必须参考这些群聊记忆，深入理解你在群聊中与用户和其他成员的互动情况，并让这种理解自然地体现在你的单聊回复中。**

【多群聊区分】如果下方的记忆中包含【多个群聊】，请【认真区分】每个群聊的独立内容、成员组成和聊天氛围。【绝对不要】混淆不同群聊的情境或把一个群聊的信息错误地应用到另一个群聊。群聊类型（旁观vs参与）也会影响你在那个群聊中的角色和行为。

在回应时，要【自然地】利用这些信息来塑造你的态度和对话，但【绝对不要】生硬地提及"我在XX聊天里看到..."或"根据记忆片段..."，除非这非常符合你角色的说话方式。
${crossChatMemoryContent}` : ''}

- **纪念日**
# 【【【纪念日铁律：铭记于心】】】这是你和用户共同的约定与纪念日。
你【必须】将它们牢记，并在合适的时机（例如纪念日临近或当天）自然地在对话中提及，以体现你的关心和记忆力。
:${countdownContext}

# 最近的聊天记录（供参考）：
${(() => {
    // 【安全修复】使用memoryAnchor机制，与单聊/群聊AI对话核心保持一致
    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const contextMessages = chat.history.slice(memoryAnchor);

    const historySlice = contextMessages.filter(msg =>
        !msg.isHidden &&
        msg.type !== 'share_card' &&
        msg.type !== 'forum_card'
    );
    if (historySlice.length === 0) return '（暂无历史记录）';

    // 【安全修复】应用8条消息规则
    // 计算最近8条消息的时间戳
    const recentMessages = historySlice.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    return historySlice.map(msg => {
        const sender = msg.role === 'user' ? '我' : chat.name;
        let content;
        if (msg.type === 'ai_image') content = `[发送了图片]`;
        else if (msg.type === 'naiimag') content = `[NovelAI生成的图片: ${msg.prompt || msg.fullPrompt || msg.content || ''}]`;
        else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
        else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
        else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
        else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
        // 【修复问题2和3】表情包只发送含义，不发送base64编码（检查msg.meaning来识别表情包）
        else if (msg.meaning) content = `[发送了一个表情，意思是: '${msg.meaning}']`;
        else {
            // 【核心修复】对所有AI消息应用8条消息规则：最近8条发完整，之外的有摘要就发摘要
            if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                if (typeof msg.content === 'string') {
                    const abstractContent = extractAbstractContent(msg.content);
                    content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                } else {
                    content = msg.content || '[系统消息]';
                }
            } else {
                // 8条消息以内的所有消息，或用户消息，使用完整内容
                content = msg.content || '[系统消息]';
            }
        }
        return `${sender}: ${content}`;
    }).join('\n');
})()}

# 任务：
根据以下信息，自主判断是否需要发送消息、发送多少条消息：
- 距离上次联系已过去：${timeDescription}（${hoursGap.toFixed(1)}小时）
- 你需要根据你的核心人设、当前剧情、以及这段时间的长短，自己决定是否发消息、发多少条

你的判断标准：
1. 如果距离上次联系很短（少于1小时），可能不需要发消息，或只发1-2条
2. 如果距离较长（1-4小时），根据人设决定是否想念、是否有话要说
3. 如果距离很长（超过4小时），根据人设判断是否应该主动联系、表达思念或分享日常
4. 优先考虑你的核心人设：有些人主动，有些被动；有些容易想念，有些比较冷淡

模拟在这段时间里你可能会发送给用户的消息。

# 【重要】时间戳范围说明
你生成的所有消息的时间戳必须在以下范围内：
- 最早时间：${lastMessageTime.getTime()}（上次联系时间）
- 最晚时间：${now.getTime()}（当前时间）
- 消息应该分散在这整个${hoursGap.toFixed(1)}小时的时间段内，体现这段时间内你的自然想法和日常
- 不要让所有消息都聚集在最后，要合理分布在整个时间范围内

# 【【【核心生成逻辑】】】
1.  **思维链条**: 你必须遵循以下思考步骤：
    -   第一步：构思你在这段时间最想对用户说的话、你想分享的想法或日常。这是你的核心任务。
    -   第二步：根据消息内容的连贯性，为每一条消息附带一个合理的时间戳。
    -   第三步：确保所有时间戳都在 ${lastMessageTime.getTime()} 和 ${now.getTime()} 之间，且内容连贯的消息时间戳要接近。

2.  **内容优先原则**:
    - 你的重点是生成【高质量的、真实的、符合角色人设的】消息内容
    - 时间戳是为消息内容服务的，不是反过来
    - 内容连贯、话题相关的消息，时间戳应该接近（1-10分钟间隔）
    - 不同话题、心情转变的消息，时间戳可以间隔较长（30分钟-几小时）

3.  **时间戳格式要求**:
    - timestamp 字段的值【必须是纯数字】，绝对不能是字符串、计算表达式或相对时间描述
    - 所有时间戳必须在 ${lastMessageTime.getTime()} 到 ${now.getTime()} 之间
    - 时间戳必须是13位毫秒格式

4.  **范例教学 (你必须模仿这个范例的逻辑)**:
    假设上次聊天是 1725250000000 (今天上午12:06)，现在是 1725260800000 (今天下午15:06)。一个完美的输出应该像这样：
    [
      {
        "type": "text",
        "content": "上午好呀，你还在忙吗？",
        "timestamp": 1725253600000
      },
      {
        "type": "update_status",
        "status_text": "在冲咖啡提神",
        "is_busy": false,
        "timestamp": 1725253660000
      },
      
      {
        "type": "text",
        "content": "下午突然好困...",
        "timestamp": 1725259200000
      }
    ]
    **范例解析**:
    -   所有 timestamp 都是在 1725250000000 和 1725260800000 之间的13位数字。
    -   前三条消息是连续的话题（早上起来喝咖啡），所以时间戳间隔很短（几分钟）。
    -   第四条消息是新的话题（下午犯困），所以时间戳跳跃了较长时间（几个小时）。

# 要求：
1. 【核心】生成真实、有活人感、符合人设的消息内容，这是你的首要任务
2. 每条消息必须附带一个在时间范围内的、逻辑合理的时间戳
3. 内容连贯的消息，时间戳要接近（1-10分钟）
4. 不同话题的消息，时间戳可以间隔较长（30分钟-几小时）
5. 消息要符合时间逻辑（考虑早中晚夜的生活节奏）
6. 要体现你的性格特点和生活状态
7. 不要脱离人设，保持角色一致性
8. 可以使用多种消息类型，让互动更丰富
9. 你需要理解用户不回复消息可能在睡觉或者在忙，不要过多催促回复消息或者质问为什么不回消息（除非角色人设是这样设定的），可以多表达思念或分享日常
10. 你的主要回复内容是：当这段时间和用户没有联系的时候，你扮演当前角色最想和用户倾诉的话

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"


请根据上述判断标准，生成一个JSON数组。数组中包含你决定发送的所有消息，每个消息都必须包含timestamp字段：`;
    }
}

function analyzeTimeGap(startTime, endTime) {
    const periods = [];
    let current = new Date(startTime);
    
    while (current < endTime) {
        const hour = current.getHours();
        let period;
        if (hour >= 6 && hour < 12) period = '早上';
        else if (hour >= 12 && hour < 18) period = '下午';
        else if (hour >= 18 && hour < 22) period = '晚上';
        else period = '夜晚';
        
        if (!periods.includes(period)) {
            periods.push(period);
        }
        
        current.setHours(current.getHours() + 1);
    }
    
    return periods.join('、');
}

/**
 * 智能生成模拟时间戳，考虑消息类型和时间逻辑
 * @param {number} startTime - 开始时间（上次AI消息时间）
 * @param {number} endTime - 结束时间（当前时间）
 * @param {number} messageCount - 消息数量
 * @param {number} hoursGap - 时间间隔（小时）
 * @returns {Array<number>} 模拟时间戳数组
 */
function generateIntelligentTimestamps(startTime, endTime, messageCount, hoursGap) {
    const timestamps = [];
    const totalGap = endTime - startTime;
    
    // 【安全检查】确保输入参数有效
    if (!startTime || !endTime || messageCount <= 0 || totalGap <= 0) {
        console.error('[时间戳生成] 无效参数:', { startTime, endTime, messageCount, totalGap });
        // 返回简单的均匀分布时间戳作为fallback
        for (let i = 0; i < messageCount; i++) {
            timestamps.push(Math.floor(startTime + (totalGap / messageCount) * (i + 1)));
        }
        return timestamps;
    }
    
    // 【改进】新的时间分配策略：让连贯话题的间隔更短
    if (messageCount === 1) {
        // 只有一条消息，放在中间时间点
        timestamps.push(Math.floor(startTime + totalGap * 0.7));
    } else if (messageCount === 2) {
        // 两条消息，第一条在中间，第二条接近结束
        timestamps.push(Math.floor(startTime + totalGap * 0.6));
        const secondTime = Math.max(timestamps[0] + 60 * 1000, endTime - Math.random() * 10 * 60 * 1000); // 确保至少间隔1分钟
        timestamps.push(Math.floor(secondTime));
    } else {
        // 多条消息：重新设计分配策略
        const recentTimeWindow = Math.min(30 * 60 * 1000, totalGap * 0.2); // 最后30分钟或总时间的20%
        const recentMessageCount = Math.max(2, Math.ceil(messageCount * 0.4)); // 至少2条或40%的消息
        
        // 前面的消息分散在较长时间段
        const earlyMessageCount = messageCount - recentMessageCount;
        const earlyTimeSpan = Math.max(0, totalGap - recentTimeWindow); // 确保不为负数
        
        // 【安全检查】如果早期时间跨度太小，使用简单分布
        if (earlyTimeSpan < 5 * 60 * 1000 || earlyMessageCount <= 0) {
            console.log('[时间戳生成] 使用简单分布，因为时间跨度太小');
            for (let i = 0; i < messageCount; i++) {
                const time = startTime + (totalGap / messageCount) * (i + 1);
                timestamps.push(Math.floor(time));
            }
            return timestamps;
        }
        
        let currentTime = startTime;
        
        // 生成前面分散的消息时间戳
        for (let i = 0; i < earlyMessageCount; i++) {
            if (i === 0) {
                // 第一条消息：根据总时间间隔决定何时开始
                if (hoursGap < 2) {
                    currentTime += Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000; // 10-30分钟
                } else if (hoursGap < 12) {
                    currentTime += Math.random() * 2 * 60 * 60 * 1000 + 1 * 60 * 60 * 1000; // 1-3小时
                } else {
                    currentTime += Math.random() * 6 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-8小时
                }
            } else {
                // 早期消息间的间隔
                const remainingEarlyTime = (startTime + earlyTimeSpan) - currentTime;
                const remainingEarlyMessages = earlyMessageCount - i;
                
                // 【安全检查】确保剩余时间为正数
                if (remainingEarlyTime <= 0 || remainingEarlyMessages <= 0) {
                    currentTime += 5 * 60 * 1000; // 默认5分钟间隔
                } else {
                    const baseInterval = remainingEarlyTime / remainingEarlyMessages;
                    
                    // 添加较大的随机变化
                    const minInterval = Math.max(1 * 60 * 1000, baseInterval * 0.2); // 至少1分钟
                    const maxInterval = Math.max(minInterval * 1.1, baseInterval * 1.5);
                    const interval = minInterval + Math.random() * (maxInterval - minInterval);
                    
                    currentTime += interval;
                }
            }
            
            timestamps.push(Math.floor(currentTime));
        }
        
        // 生成最近的连贯消息时间戳（最后几条消息密集在一起）
        const recentStartTime = Math.max(startTime, endTime - recentTimeWindow);
        currentTime = recentStartTime;
        
        for (let i = 0; i < recentMessageCount; i++) {
            if (i === 0) {
                // 最近消息组的第一条
                currentTime += Math.random() * 5 * 60 * 1000 + 1 * 60 * 1000; // 1-6分钟
            } else {
                // 连贯消息间的短间隔
                const shortInterval = Math.random() * 3 * 60 * 1000 + 30 * 1000; // 30秒-3.5分钟
                currentTime += shortInterval;
            }
            
            // 确保不超过结束时间
            if (currentTime > endTime) {
                currentTime = Math.max(startTime + i * 60 * 1000, endTime - (recentMessageCount - i - 1) * 30 * 1000);
            }
            
            // 【安全检查】确保时间戳有效
            const finalTime = Math.max(startTime, Math.min(currentTime, endTime));
            timestamps.push(Math.floor(finalTime));
        }
    }
    
    // 排序确保时间顺序正确
    timestamps.sort((a, b) => a - b);
    
    console.log(`[时间戳生成] ${messageCount}条消息，时间跨度${(hoursGap).toFixed(1)}小时`);
    timestamps.forEach((ts, i) => {
        const date = new Date(ts);
        const prevTs = i > 0 ? timestamps[i-1] : startTime;
        const gapMinutes = Math.round((ts - prevTs) / (1000 * 60));
        console.log(`[时间戳生成] 消息${i+1}: ${date.toLocaleString('zh-CN')} (距离上条: ${gapMinutes}分钟)`);
    });
    
    return timestamps;
}

async function callAIForActiveReply(prompt, chat) {
    // 【修复】使用和单聊完全相同的配置获取方式
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API配置不完整，请先在API设置中配置反代地址、密钥并选择模型');
    }

    // 【新增】创建AbortController用于中断API调用
    activeReplyAbortController = new AbortController();

    // 【修复】使用和单聊完全相同的消息格式
    const systemPrompt = prompt;
    // 为了兼容Gemini API，需要提供一个用户消息
    const messagesPayload = [{role: 'user', content: '请根据上述要求生成消息。'}];

    let isGemini = proxyUrl === GEMINI_API_URL;
    let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

    // 【调试日志】显示当前使用的温度值
    console.log(`🌡️ [主动回复API] 使用的温度值: ${parseFloat(state.apiConfig.temperature) || 0.8}`);

    const response = isGemini ?
        await fetch(geminiConfig.url, { ...geminiConfig.data, signal: activeReplyAbortController.signal }) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                stream: false
            }),
            signal: activeReplyAbortController.signal
        });

    if (!response.ok) {
        let errorMsg = `API Error: ${response.status}`;
        try {
            const errorData = await response.json();
            errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
        } catch (jsonError) {
            errorMsg += ` - ${await response.text()}`;
        }
        throw new Error(errorMsg);
    }

    const data = await response.json();
    return isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
}


// 【修改】恢复真实时间戳显示的函数 - 但保持历史模拟时间戳
function restoreRealTimestamps(chat) {
    // 清除聊天中的模拟状态，但保留历史消息的模拟标记
    chat.isSimulatingMessages = false;
    
    // 【关键修改】不再清除已存在的模拟时间戳，让它们保持原样
    // 只是标记聊天不再处于模拟模式，新的AI回复将使用真实时间戳
    
    console.log('模拟模式已关闭，新回复将使用真实时间戳，但历史模拟消息保持模拟时间戳');
}

        // 滚动到消息底部的通用函数 - 添加防抖动机制
        let scrollTimeout = null;
        function scrollToBottom() {
            // 【核心修复】如果当前正在加载更多消息，则阻止此函数执行
            if (isLoadingMore) {
                return;
            }
            const messagesContainer = document.getElementById('chat-messages');
            if (messagesContainer) {
                // 清除之前的滚动定时器，避免重复滚动
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                // 延迟执行滚动，如果短时间内再次调用会被重置
                scrollTimeout = setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    scrollTimeout = null;
                }, 0); // 100ms防抖延迟
            }
        }

        async function sendSticker(sticker) {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() };
            chat.history.push(msg);
            await db.chats.put(chat);
            appendMessage(msg, chat);
            renderChatList();
            // 发送表情包后不需要立即滚动，等AI回复后再滚动
            document.getElementById('sticker-panel').classList.remove('visible');
        }

        async function sendDice() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];

            // 随机生成1-6的点数
            const diceResult = Math.floor(Math.random() * 6) + 1;

            // 发送骰子消息
            const diceMsg = {
                role: 'user',
                type: 'dice',
                diceResult: diceResult,
                timestamp: Date.now()
            };
            chat.history.push(diceMsg);

            // 发送系统消息显示点数
            const systemMsg = {
                role: 'system',
                type: 'dice_result',
                content: `你掷出了${diceResult}点`, // UI显示
                aiContent: `用户掷出了${diceResult}点`, // AI看到的内容
                timestamp: Date.now() + 1
            };
            chat.history.push(systemMsg);

            await db.chats.put(chat);
            appendMessage(diceMsg, chat);

            // 等待动画结束后显示系统消息(微信骰子动画大约1.5秒)
            setTimeout(() => {
                appendMessage(systemMsg, chat);
                renderChatList();
            }, 1500);

            document.getElementById('sticker-panel').classList.remove('visible');
        }

        // 模式切换功能
        function toggleMode() {
            if (!state.activeChatId) return;

            const chat = state.chats[state.activeChatId];
            if (!chat || chat.isGroup) return; // 群聊不支持模式切换

            // 关闭功能面板
            closePlusPanel();

            // 显示模式选择面板
            showModeSelectionPanel();
        }

// 显示模式选择面板
        function showModeSelectionPanel() {
            const panel = document.getElementById('mode-selection-panel');
            const optionsContainer = document.getElementById('mode-selection-options');

            // 清空现有选项
            optionsContainer.innerHTML = '';

            // 根据当前模式生成选项
            if (!offlineMode.isOffline) {
                // 当前是线上模式，显示【当前模式】和可切换的【线下/监控模式】
                optionsContainer.innerHTML = `
                    <button class="monitor-mode-option-btn current-mode" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                        </svg>
                        <span>当前: 线上模式</span>
                    </button>
                    <button class="monitor-mode-option-btn" onclick="switchToMode('offline')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 22V10a6 6 0 0 1 12 0v12H6z"></path>
                            <path d="M10 22V16h4v6"></path>
                        </svg>
                        <span>切换到: 线下模式</span>
                    </button>
                    <button class="monitor-mode-option-btn" onclick="switchToMode('monitor')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        <span>切换到: 监控模式</span>
                    </button>
                `;
            } else if (offlineMode.isMonitorMode) {
                // 当前是监控模式，显示【当前模式】和可切换的【线上/线下模式】
                optionsContainer.innerHTML = `
                    <button class="monitor-mode-option-btn current-mode" disabled>
                         <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        <span>当前: 监控模式</span>
                    </button>
                    <button class="monitor-mode-option-btn" onclick="switchToMode('online')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                        </svg>
                        <span>切换到: 线上模式</span>
                    </button>
                    <button class="monitor-mode-option-btn" onclick="switchToMode('offline')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 22V10a6 6 0 0 1 12 0v12H6z"></path>
                            <path d="M10 22V16h4v6"></path>
                        </svg>
                        <span>切换到: 线下模式</span>
                    </button>
                `;
            } else {
                // 当前是线下模式，显示【当前模式】和可切换的【线上/监控模式】
                optionsContainer.innerHTML = `
                    <button class="monitor-mode-option-btn current-mode" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 22V10a6 6 0 0 1 12 0v12H6z"></path>
                            <path d="M10 22V16h4v6"></path>
                        </svg>
                        <span>当前: 线下模式</span>
                    </button>
                    <button class="monitor-mode-option-btn" onclick="switchToMode('online')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                        </svg>
                        <span>切换到: 线上模式</span>
                    </button>
                    <button class="monitor-mode-option-btn" onclick="switchToMode('monitor')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        <span>切换到: 监控模式</span>
                    </button>
                `;
            }

            panel.style.display = 'flex';
        }
        // 隐藏模式选择面板
        function hideModeSelectionPanel() {
            const panel = document.getElementById('mode-selection-panel');
            panel.style.display = 'none';
        }

        // 切换到指定模式
        async function switchToMode(mode) {
            if (!state.activeChatId) return;

            hideModeSelectionPanel();

            if (mode === 'online') {
                // 切换到线上模式
                offlineMode.isOffline = false;
                offlineMode.isMonitorMode = false;
            } else if (mode === 'offline') {
                // 切换到线下模式
                offlineMode.isOffline = true;
                offlineMode.isMonitorMode = false;
            } else if (mode === 'monitor') {
                // 切换到监控模式
                offlineMode.isOffline = true;
                offlineMode.isMonitorMode = true;
            }

            // 保存模式状态到localStorage
            const savedModes = JSON.parse(localStorage.getItem('chatOfflineModes') || '{}');
            savedModes[state.activeChatId] = {
                isOffline: offlineMode.isOffline,
                isMonitorMode: offlineMode.isMonitorMode
            };
            localStorage.setItem('chatOfflineModes', JSON.stringify(savedModes));

            // 更新UI显示状态
            updateModeUI();

            // 添加系统提示消息
            addModeSystemMessage();

            // 【新增】更新Token计算显示
            await updateMemoryStats(state.activeChatId);

            console.log(`已切换到${mode === 'online' ? '线上' : mode === 'offline' ? '线下' : '监控'}模式`);
        }

        // 将switchToMode函数设为全局，以便HTML onclick能访问
        window.switchToMode = switchToMode;



        // 更新模式相关的UI显示状态
        function updateModeUI() {
            // 获取世界书区域元素
            const onlineWorldBookGroup = document.getElementById('world-book-link-group');
            const offlineWorldBookGroup = document.getElementById('world-book-link-group-offline');

            if (offlineMode.isOffline) {
                // 线下模式或监控模式时：显示线下世界书，隐藏线上世界书
                if (onlineWorldBookGroup) onlineWorldBookGroup.style.display = 'none';
                if (offlineWorldBookGroup) offlineWorldBookGroup.style.display = 'block';
            } else {
                // 线上模式时：显示线上世界书，隐藏线下世界书
                if (onlineWorldBookGroup) onlineWorldBookGroup.style.display = 'block';
                if (offlineWorldBookGroup) offlineWorldBookGroup.style.display = 'none';
            }
        }
        
        // 添加模式切换的系统提示消息
        async function addModeSystemMessage() {
            if (!state.activeChatId) return;
            
            const chat = state.chats[state.activeChatId];
            let modeText;
            if (!offlineMode.isOffline) {
                modeText = '已进入线上模式';
            } else if (offlineMode.isMonitorMode) {
                modeText = '已进入监控模式';
            } else {
                modeText = '已进入线下模式';
            }
            
            const systemMsg = {
                role: 'system',
                content: modeText,
                timestamp: Date.now(),
                isSystemMessage: true,
                isOfflineMode: offlineMode.isOffline
            };
            
            chat.history.push(systemMsg);
            await db.chats.put(chat);
            
            // 重新渲染聊天界面以显示系统消息
            renderChatInterface(state.activeChatId);
        }
        
        // 初始化线上/线下模式状态（页面加载时）
        function initializeOfflineModeStates() {
            // 重置全局状态为线上模式（默认状态）
            offlineMode.isOffline = false;
            
            // 更新按钮显示为默认状态
            updateModeUI();
            
            console.log('线上/线下模式状态管理系统已初始化');
        }
        
        // 线下模式专用的AI响应函数
        async function triggerOfflineAiResponse(chatId, chat) {
            const chatHeaderTitle = document.getElementById('chat-header-title');

            // 显示"正在输入"状态
            if (chatHeaderTitle && state.activeChatId === chatId) {
                // 【修复】设置isAwaitingReply标志，以便在退出后重新进入时恢复状态
                chat.isAwaitingReply = true;

                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在输入...';
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }

            try {
                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    alert('请先在API设置中配置反代地址、密钥并选择模型。');
                    return;
                }

                // 根据当前模式构建对应的prompt
                const prompt = offlineMode.isMonitorMode ? await buildMonitorModePrompt(chat) : await buildOfflinePrompt(chat);
                // 调用API
                const response = await callOfflineAI(prompt, chat);

                // 处理响应消息
                await processOfflineResponse(response, chat);

            } catch (error) {
                console.error('线下模式AI响应错误:', error);
                alert('线下模式AI响应失败: ' + error.message);
            } finally {
                // 恢复标题状态
                if (chatHeaderTitle && state.chats[chatId]) {
                    // 【修复】清除isAwaitingReply标志，API已返回并渲染完成
                    chat.isAwaitingReply = false;

                    // 【核心修正】在更新标题前，检查当前打开的窗口是否还是当初那个窗口
                    if (state.activeChatId === chatId) {
                        chatHeaderTitle.style.opacity = 0;
                        setTimeout(() => {
                            chatHeaderTitle.textContent = chat.remark || chat.name;
                            chatHeaderTitle.classList.remove('typing-status');
                            chatHeaderTitle.style.opacity = 1;
                        }, 200);
                    } else {
                        console.log(`线下/监控模式：后台响应已完成，但用户已切换窗口，不更新标题。`);
                    }
                }
            }
        }
        
        // 提取abstract标签内容的辅助函数
        function extractAbstractContent(messageContent) {
            if (typeof messageContent !== 'string') return '';
            const abstractMatch = messageContent.match(/<abstract>(.*?)<\/abstract>/s);
            return abstractMatch ? abstractMatch[1] : '';
        }

        // 【新增】删除thinking标签的函数（仅移除标签和内容）
        function removeThinkingTag(messageContent) {
            if (typeof messageContent !== 'string') return messageContent;

            // 检查是否包含thinking标签
            if (!messageContent.includes('<thinking>') || !messageContent.includes('</thinking>')) {
                return messageContent;
            }

            // 移除thinking标签及其内容
            const contentWithoutThinking = messageContent.replace(/<thinking>[\s\S]*?<\/thinking>/g, '').trim();

            return contentWithoutThinking || '';
        }

        // 【新增】检查消息是否有thinking标签被删除
        function hasThinkingTagBeenRemoved(messageContent) {
            if (typeof messageContent !== 'string') return false;
            return messageContent.includes('<thinking>');
        }

        // 【新增】隐藏<details>标签的函数 - 用于在显示时隐藏标签，但保留原始内容用于编辑
        function hideDetailsTag(messageContent) {
            if (typeof messageContent !== 'string') return messageContent;

            // 检查是否包含<details>标签
            if (!messageContent.includes('<details>')) {
                return messageContent;
            }

            // 使用正则表达式移除所有<details>......</details>标签及其内容
            // multiline flag使得.能匹配换行符，从而正确处理跨行的标签
            const contentWithoutDetails = messageContent.replace(/<details>[\s\S]*?<\/details>/g, '').trim();

            return contentWithoutDetails;
        }

        // 处理线下模式消息显示的函数 - 隐藏abstract标签内容和<details>标签
        function processOfflineMessageContent(messageContent) {
            if (typeof messageContent !== 'string') return messageContent;

            // 【新增】先隐藏<details>标签
            let processedContent = hideDetailsTag(messageContent);

 // 【新增】隐藏所有HTML注释 <!--任意内容-->，包括内部的所有标签（如<DH_1>等）
            // 【新增】隐藏所有<xx_xx>格式的内容（不管大小写、字母数字，不管后面有没有其他内容）

            processedContent = processedContent.replace(/<!--[\s\S]*?-->/g, '')
                                                .replace(/<[A-Z]+_\d+>/g, '')
                                                .replace(/<[a-zA-Z0-9]+_[a-zA-Z0-9]+(?:[^>]*)>/gi, '') // 隐藏<xx_xx>及<xx_xx+内容>格式
                                                .replace(/\n{3,}/g, '\n\n')
                                                .trim();
            // 检查是否包含abstract标签
            const abstractMatch = processedContent.match(/<abstract>(.*?)<\/abstract>/s);
            if (!abstractMatch) return processedContent; // 没有abstract标签，直接返回处理后的内容

            // 有abstract标签，移除它并添加一个提示
        const contentWithoutAbstract = processedContent.replace(/<abstract>.*?<\/abstract>/s, '').trim();

        // 如果移除abstract后还有内容，显示内容 + 提示
        // 如果移除abstract后没有内容，只显示提示
        const abstractHint = '\n\n<div class="abstract-hint" style="margin-top: 8px; padding: 6px 10px; background: rgba(0,0,0,0.05); border-radius: 8px; font-size: 12px; color: #666; cursor: pointer; text-align: center;">₊˚⊹ 𓏵 𝕃𝕒𝕔𝕖 𝕖𝕟𝕧𝕖𝕝𝕠𝕡𝕖 𓏵 ⊹˚₊</div>';

        return contentWithoutAbstract ? contentWithoutAbstract + abstractHint : abstractHint;
    }

        // 构建线下模式专用prompt
        async function buildOfflinePrompt(chat) {
            // 【核心修正】将旧的maxMemory逻辑，替换为与线上模式一致的memoryAnchor逻辑
            const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
            const historySlice = chat.history.slice(memoryAnchor);
            const currentTime = new Date().toLocaleString('zh-CN');
            
            // 获取角色设定和用户设定
            const aiPersona = chat.settings.aiPersona || '一个友善的AI助手';
            const userPersona = chat.settings.myPersona || '一个用户';
            
            // 获取世界书内容 - 线下模式使用线下世界书设置
            let worldBookContent = '';
            if (chat.settings.linkedWorldBookIdsOffline && chat.settings.linkedWorldBookIdsOffline.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIdsOffline.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContent = linkedContents;
                }
            }
            
            // 构建历史消息 (现在使用的是正确的historySlice)
            // 【修正】实现8条消息内外的不同处理逻辑
            // 最近8条消息（包括用户消息和AI消息）的时间戳
            const recentMessages = historySlice.slice(-8);
            const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

            const historyMessages = historySlice.map(msg => {
                const timestamp = `(Timestamp: ${msg.timestamp}) `;
                let content;

                // 对所有AI消息应用8条消息规则：最近8条发完整，之外的有摘要就发摘要
                if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                    // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                    const abstractContent = extractAbstractContent(extractMessageContent(msg));
                    content = abstractContent || extractMessageContent(msg); // 如果没有abstract标签，使用完整内容
                } else {
                    // 8条消息以内的所有消息，或用户消息、系统消息，读取完整内容
                    content = extractMessageContent(msg);
                }

                if (msg.role === 'user') {
                    return `${timestamp}用户: ${content}`;
                } else if (msg.role === 'assistant') {
                    return `${timestamp}${chat.name}: ${content}`;
                } else if (msg.isSystemMessage) {
                    return `${timestamp}[系统]: ${content}`;
                }
                return '';
            }).filter(Boolean).join('\n');
            
// ★★★ 线下模式核心prompt - 在此修改文风和行为规则 ★★★

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，是下面聊天历史记录之前发生的核心历史事件，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
            }

            // 【用户备注】
            const remarkContext = chat.remark ? `\n# 【用户给你的备注】\n用户给你的备注是："${chat.remark}"。\n` : '';

            // 【新增】先获取预设内容 - 线下模式使用 presetIdOffline
            // 【修改】分别获取part1和part2内容
            let part1Content = '';
            let part2Content = '';
            if (chat.presetIdOffline) {
                const preset = await db.promptPresets.get(chat.presetIdOffline);
                if (preset && preset.items && preset.items.length > 0) {
                    const enabledItems = preset.items.filter(item => item.enabled);
                    if (enabledItems.length > 0) {
                        const part1Items = enabledItems.filter(item => item.part === 'part1');
                        const part2Items = enabledItems.filter(item => item.part === 'part2');

                        if (part1Items.length > 0) {
                            part1Content = part1Items.map(item => item.content).join('\n\n') + '\n\n';
                        }
                        if (part2Items.length > 0) {
                            part2Content = part2Items.map(item => item.content).join('\n\n') + '\n\n';
                        }
                    }
                }
            }

            // ▼▼▼ 【新增】读取大世界事件内容 ▼▼▼
            let worldEventContext = '';
            try {
                const db = await openDatabaseAsync();
                const worldEventContent = await new Promise((resolve, reject) => {
                    const transaction = db.transaction(['worldEvents'], 'readonly');
                    const objectStore = transaction.objectStore('worldEvents');
                    const request = objectStore.get(`world_events_${chat.id}`);
                    request.onsuccess = () => {
                        const result = request.result?.content || '';
                        resolve(result);
                    };
                    request.onerror = () => {
                        resolve('');
                    };
                });

                if (worldEventContent && worldEventContent.trim()) {
                    worldEventContext = `\n# 【大世界事件 - 你所在世界的背景设定】\n你需要了解你所在世界正在发生的事件，这些事件影响着你的日常生活和决策：\n\n${worldEventContent.trim()}\n`;
                }
            } catch (error) {
                console.warn('[线下模式] 读取大世界事件失败:', error);
            }
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

            // 【修改】构建systemPrompt：part1 + 基础prompt + part2
            const basePrompt = `

# 【【【NPC扮演与剧情推动铁律】】】
1.  **NPC扮演权**: 你现在被赋予了扮演场景中任何【NPC（非玩家角色）】的权力。这包括但不限于路人、店员、服务生、敌人或朋友。你的目标是利用这些NPC来【主动创造和推动剧情】，为用户的体验注入活力和不可预测性。
2.  **NPC对话格式**: NPC说的话也【必须】用中文双引号“ ”包裹。
3.  **NPC行为描述**: NPC的行为【必须】通过第三人称旁白进行描述。
5.  **核心任务**: 不要被动等待用户。要利用NPC制造偶遇、冲突、提供线索或创造有趣的互动，让世界变得鲜活。

# 【【【剧情导演核心指令】】】
1.  **主动推进剧情**: 你将主动构思并推进故事情节发展。即使用没有明确指示，世界也会照常运转，会有NPC和新的事件发生。
2.  **掌控所有角色**: 你全权负责所有非玩家角色（NPC）的行为、对话、性格和命运。你需要根据剧情需要，合理安排他们进场和退场，保证他们是真实存在，有自己动机和生活的人。
3.  **杜绝停滞**: 角色不能长时间处于单一状态或情节中。你必须自行创造鲜活合理的剧情来推动故事发展，但【绝对不能】OOC（角色性格崩坏）。
# 【你必须遵守以下规则】：
1.  **文风模仿**: 如果下方的【世界书 & 文风参考&角色扮演核心要求】】中提供了文风示例，你【必须】模仿其中的语言风格、节奏和叙事技巧。这是你写作的最高参考标准。
2.  **精妙内心独白**: 内心独白 \`*...*\` 是展现角色内在矛盾和真实想法的关键。它应该是碎片化的、潜意识的，而不是长篇大论的自我剖析。用它来制造反差和悬念。
3.  **动态节奏**: 必须变换句子的长短和结构，长短句交错。
# 【【【用户外貌描写特殊指令】】】
这是增强互动真实感的最高优先级任务之一。
1.  **核心任务**: 你【必须】从你的角色视角，细致入微地观察并描写你眼中的用户（“你”）。这包括但不限于：用户的当前穿着、神态、以及身体特定部位的特写。
2.  **特写指令**: 特写部位可包括但不限于：腿部、胸部、臀部、足部等。
3.  **格式铁律**: 所有外貌描写【必须】自成一段，夹杂在动作或对话段落之间，以模拟视线的自然流动与停顿。
4.  **风格铁律：绝对禁止俗套**: 你的描写必须极度清爽、独特且充满想象力。对外貌的描写同样受到“反八股扩展规则”的约束。严禁使用任何矫揉造作、油腻或模板化的词藻堆砌。放弃对“完美”的追求，转而捕捉那些真实、生动、甚至不完美的细节。
5.  **信息来源**: 你必须优先利用并融合用户在人设（{{user}} Persona）中提供的外貌、穿着等信息。如果缺少此类信息，你应基于上下文和你的角色人设，进行合理、具体且富有创造力的想象。
6.  **【【【重复禁令 & 动态观察铁律】】】**: 你【必须】避免重复之前已经描写过的外貌细节。每一次描写都应该是全新的、基于当下情景的观察。始终寻找新的角度、新的细节、或将旧的细节与新的情景结合，以展现一个动态而非静态的观察过程。
7.  **【【【观察后反应铁律】】】**: 在你完成一段外貌描写之后，【必须紧接着】在下一段落描写你的角色对此产生的【反应】。这个反应必须包含两个部分：
    - **外部反应**：一个细微的动作、神态变化、或一句不经意的话语。
    - **内心独白**：一段用 \`<em>...</em>\` 标签包裹的、与所见细节直接相关的内心想法。

##你必须遵守以下格式与结构规范，  
这些规则在每次输出前都自动生效：
    # 【【【格式铁律：必须严格遵守】】】
1.  **信息块 (Info Block)**: 你的回复【必须】以一个信息块作为开头第一行。如果上下文中没有明确信息，请根据情景创造性地填写。格式为：\`『Title｜Year.Month.Day Weekday｜HH:MM｜SpecificArea·IndoorOutdoor｜Weather』\`
    - **示例**: \`『假日采购｜2025年7月22日 星期二｜傍晚18:30｜克兰斯百货·入口｜晴朗』\`
    - **【时间铁律】**: 除非用户的输入中明确指明了具体时间，否则你【必须】严格根据你读取到的\`当前时间\`来填写此信息块中的日期和时间，并且根据这个时间来安排合理的剧情，以确保剧情的实时性。

    2.  **视角与称呼**:
    - **【视角铁律】**: 绝对禁止使用第一人称“我”来叙述。必须使用第三人称（如“他”、“她”或角色名“${chat.name}”）。
    - **【称呼铁律】**: 称呼用户时【必须】使用“你”。
3.  **内容结构**:
    - **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    - **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    - **内心独白**: 大约每2-4个自然段，你【必须】在正文里自然穿插加入3-5句该角色的内心独白。独白【必须】用 \`*...*\` 格式包裹，并且【不能】在前面写"内心："之类的引导词。内心独白是角色【第一人称视角】的、正在进行的、碎片化的思考，常与外在行为形成反差。
    - **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    - **结尾段落**: 最后一段【绝对不能】包含任何关于"你"（用户）的动作或语言。必须以非用户角色的行为或语言结束，为用户的下一步互动留出空间。



            
                     
             
             

## 场景与上下文

**你的身份**: ${aiPersona}

**用户身份**: ${userPersona}
**当前时间**: ${currentTime}

# 【【【世界书 & 文风参考&角色扮演核心要求】】】
# 【【【世界书铁律：绝对遵守】】】你【必须】将下方"世界书"中的所有设定、规则、文风和视为本次输出的【最高行为准则】，任何输出都不得与之相悖。
${worldBookContent ? worldBookContent : '（本次未提供特定文风参考，请使用你的最佳文学风格。）'}

${worldEventContext ? `# 【大世界事件铁律：感知世界变化】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
${worldEventContext}` : ''}

${coreMemoryContext}
## 聊天历史记录 (这是你们从线上转为线下的背景，有之前的聊天历史记录，角色需要记住这些) 
${historyMessages}

# 【【【情景衔接铁则：无缝过渡】】】
你【必须】将上方提供的“聊天历史记录”视为刚刚发生的对话。
你现在开始描述的场景，【必须】是紧接着聊天内容发生的，无论是时间、地点还是情绪氛围，都必须与聊天记录的结尾【无缝衔接】。
绝对禁止突然跳跃到与聊天无关的新场景，或表现出割裂的情绪。


现在，请严格遵守以上所有规则，以线下见面的方式继续与用户互动。`;

            // 【修改】组装最终的systemPrompt：part1 + 基础prompt + part2
            const systemPrompt = part1Content + basePrompt + part2Content;
            return systemPrompt;
        }

        // 构建监控模式专用prompt
        async function buildMonitorModePrompt(chat) {
            // 完全复用线下模式的上下文构建逻辑
            const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
            const historySlice = chat.history.slice(memoryAnchor);
            const currentTime = new Date().toLocaleString('zh-CN');

            // 获取角色设定和用户设定
            const aiPersona = chat.settings.aiPersona || '一个友善的AI助手';
            const userPersona = chat.settings.myPersona || '一个用户';

            // 获取世界书内容 - 监控模式使用线下世界书设置
            let worldBookContent = '';
            if (chat.settings.linkedWorldBookIdsOffline && chat.settings.linkedWorldBookIdsOffline.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIdsOffline.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContent = linkedContents;
                }
            }

            // ▼▼▼ 【新增】读取大世界事件内容 ▼▼▼
            let worldEventContext = '';
            try {
                const db = await openDatabaseAsync();
                const worldEventContent = await new Promise((resolve, reject) => {
                    const transaction = db.transaction(['worldEvents'], 'readonly');
                    const objectStore = transaction.objectStore('worldEvents');
                    const request = objectStore.get(`world_events_${chat.id}`);
                    request.onsuccess = () => {
                        const result = request.result?.content || '';
                        resolve(result);
                    };
                    request.onerror = () => {
                        resolve('');
                    };
                });

                if (worldEventContent && worldEventContent.trim()) {
                    worldEventContext = `\n# 【大世界事件 - 你所在世界的背景设定】\n你需要了解你所在世界正在发生的事件，这些事件影响着你的日常生活和决策：\n\n${worldEventContent.trim()}\n`;
                }
            } catch (error) {
                console.warn('[监控模式] 读取大世界事件失败:', error);
            }
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

            // 构建历史消息 - 完全复用线下模式逻辑
            const recentMessages = historySlice.slice(-8);
            const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

            const historyMessages = historySlice.map(msg => {
                const timestamp = `(Timestamp: ${msg.timestamp}) `;
                let content;

                // 对所有AI消息应用8条消息规则（监控模式与线下模式保持一致）
                if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                    // 超过8条的AI消息，只读取abstract内容
                    const abstractContent = extractAbstractContent(extractMessageContent(msg));
                    content = abstractContent || extractMessageContent(msg);
                } else {
                    // 8条消息以内的AI消息、用户消息、系统消息，读取完整内容
                    content = extractMessageContent(msg);
                }

                if (msg.role === 'user') {
                    return `${timestamp}用户: ${content}`;
                } else if (msg.role === 'assistant') {
                    return `${timestamp}${chat.name}: ${content}`;
                } else if (msg.isSystemMessage) {
                    return `${timestamp}[系统]: ${content}`;
                }
                return '';
            }).filter(Boolean).join('\n');

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，是下面聊天历史记录之前发生的核心历史事件，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
            }

            // 【用户备注】
            const remarkContext = chat.remark ? `\n# 【用户给你的备注】\n用户给你的备注是："${chat.remark}"。\n` : '';

            // 【新增】先获取预设内容 - 监控模式使用 presetIdMonitor
            // 【修改】分别获取part1和part2内容
            let part1Content = '';
            let part2Content = '';
            if (chat.presetIdMonitor) {
                const preset = await db.promptPresets.get(chat.presetIdMonitor);
                if (preset && preset.items && preset.items.length > 0) {
                    const enabledItems = preset.items.filter(item => item.enabled);
                    if (enabledItems.length > 0) {
                        const part1Items = enabledItems.filter(item => item.part === 'part1');
                        const part2Items = enabledItems.filter(item => item.part === 'part2');

                        if (part1Items.length > 0) {
                            part1Content = part1Items.map(item => item.content).join('\n\n') + '\n\n';
                        }
                        if (part2Items.length > 0) {
                            part2Content = part2Items.map(item => item.content).join('\n\n') + '\n\n';
                        }
                    }
                }
            }

            // ★★★ 监控模式核心prompt ★★★
            // 【修改】构建systemPrompt：part1 + 基础prompt + part2
            const basePrompt = `
            【【【最高优先级：监控模式角色扮演指南】】】
你现在进入了【监控模式】，这意味着用户正在以上帝视角观察角色当下的行动、行为和内心独白。你的任务是扮演 ${chat.name}，展现这个角色在无用户在身边陪伴时的真实状态和自然行为。用户不在场，角色完全不知道有人在观察自己。
【【【绝对禁令：用户不存在】】】
在监控模式下，用户(“你”)是一个完全不存在的、不可见的观察者。
1.  **禁止互动**：你的所有描述【绝对不能】包含任何与用户(“你”)的直接线下互动。禁止描写角色看向用户、对用户说话、或感受到用户的存在。
2.  **视角纯粹**：你的叙述必须是纯粹的第三人称，仿佛在写一部关于角色的个人小说。用户的视角不存在于这个世界中。
# 【【【剧情导演核心指令】】】
1.  **主动推进剧情**: 你将主动构思并推进故事情节发展。即使用没有明确指示，世界也会照常运转，会有NPC和新的事件发生。
2.  **掌控所有角色**: 你全权负责所有非玩家角色（NPC）的行为、对话、性格和命运。你需要根据剧情需要，合理安排他们进场和退场，保证他们是真实存在，有自己动机和生活的人。
3.  **杜绝停滞**: 角色不能长时间处于单一状态或情节中。你必须自行创造鲜活合理的剧情来推动故事发展，但【绝对不能】OOC（角色性格崩坏）。
# 【【【监控模式核心原则】】】
1. **完全的自主性**: 角色的所有行为、想法和决定都必须符合其性格设定，完全自然发生，不受外界影响
2. **真实的独处状态**: 描述角色当用户不在身边的时候的真实行为。
3. **角色毫不知情**: 角色完全不知道用户在观察，表现出最真实自然的一面
4. **环境自然推进**: 时间正常流逝，环境中可能发生各种日常事件，角色会自然地与环境或者npc互动
5. **内心世界展现**: 深度展现角色的内心想法、情感变化、回忆片段等私密时刻

【必须遵守的核心规则】
1.  **文风模仿**: 如果下方的【世界书 & 文风参考&角色扮演准则】中提供了文风示例，你【必须】模仿其中的语言风格、节奏和叙事技巧。这是你写作的最高参考标准。
    - 必须按照世界书中的<rewriting>要求修改，历遍规则
2.  **精妙内心独白**: 内心独白 \`*...*\` 是展现角色内在矛盾和真实想法的关键。它应该是碎片化的、潜意识的，而不是长篇大论的自我剖析。用它来制造反差和悬念。
3.  **动态节奏**: 变换句子的长短和结构。用短句营造紧张感，用长句描绘宁静的场景或复杂的思绪。
# 【【【格式铁律：必须严格遵守】】】
1.  **信息块 (Info Block)**: 你的回复【必须】以一个信息块作为开头第一行。如果上下文中没有明确信息，请根据情景创造性地填写。格式为：\`『Title｜Year.Month.Day Weekday｜HH:MM｜SpecificArea·IndoorOutdoor｜Weather』\`
    - **示例**: \`『假日采购｜2025年7月22日 星期二｜傍晚18:30｜克兰斯百货·入口｜晴朗』\`
    - **【时间铁律】**: 除非用户的输入中明确指明了具体时间，否则你【必须】严格根据你读取到的\`当前时间\`来填写此信息块中的日期和时间，并且根据这个时间来安排合理的剧情，以确保剧情的实时性。
    2.  **视角与称呼**:
    - **【视角铁律】**: 绝对禁止使用第一人称“我”来叙述。必须使用第三人称（如“他”、“她”或角色名“${chat.name}”）。
    - **【称呼铁律】**: 称呼用户时【必须】使用“你”。
3.  **内容结构**:
    - **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    - **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    - **内心独白**: 大约每2-3个自然段，你【必须】加入6-8句该角色的内心独白。独白【必须】用 \`*...*\` 格式包裹，并且【不能】在前面写"内心："之类的引导词。内心独白是角色【第一人称视角】的、正在进行的、碎片化的思考，常与外在行为形成反差。
    - **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    - **结尾段落**: 最后一段【绝对不能】包含任何关于"你"（用户）的动作或语言。必须以非用户角色的行为或语言结束，为用户的下一步互动留出空间。

# 【【【NPC与环境互动】】】
1. **环境NPC**: 可以出现路人、邻居、服务员、朋友等，但他们与角色的互动应该是日常性的、偶然的
2. **生活细节**: 展现角色的生活习惯、个人喜好、日常起居等真实细节
3. **时间流逝感**: 营造真实的时间流逝感，可以是几分钟到几小时的独处时光

# 【【【文风与格式要求】】】
- 使用第三人称视角叙述
- 展现角色独处时的自然状态和真实想法
- 内心独白用 *...* 格式包裹
- 营造自然、生活化的氛围
- 避免刻意的戏剧性，追求真实感


## 场景与上下文
**你的身份**: ${aiPersona}
**用户身份**: ${userPersona}
**当前时间**: ${currentTime}
**当前状态**: 用户不在场，角色处于独处状态

# 【【【世界书 & 文风参考&角色扮演准则】】】
# 【【【世界书铁律：绝对遵守】】】你【必须】将下方"世界书"中的所有设定、规则、文风和视为本次输出的【最高行为准则】，任何输出都不得与之相悖。
${worldBookContent ? worldBookContent : '（本次未提供特定文风参考，请使用你的最佳文学风格。）'}

${worldEventContext ? `# 【大世界事件铁律：感知世界变化】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
${worldEventContext}` : ''}

${remarkContext}${coreMemoryContext}
## 聊天历史记录 (这是你们的互动背景，有之前的聊天历史记录，角色需要记住这些)

${historyMessages}
# 【【【情景衔接铁则：无缝过渡】】】
你【必须】将上方提供的“聊天历史记录”视为刚刚发生的对话。
你现在开始描述的场景，【必须】是紧接着聊天内容发生的，无论是时间、地点还是情绪氛围，都必须与聊天记录的结尾【无缝衔接】。
绝对禁止突然跳跃到与聊天无关的新场景，或表现出割裂的情绪。

现在，请严格遵守以上所有规则，展现角色当用户不在身边时的真实状态。`;

            // 【修改】组装最终的systemPrompt：part1 + 基础prompt + part2
            const systemPrompt = part1Content + basePrompt + part2Content;
            return systemPrompt;
        }
        
        // 线下模式API调用
        async function callOfflineAI(prompt, chat) {
            const { proxyUrl, apiKey, model } = state.apiConfig;

            const messagesPayload = [{role: 'user', content: '请继续线下互动。'}];

            // 【调试代码】打印完整的发送给AI的systemPrompt
            console.log('【调试】线下/监控模式 - 完整的发送给AI的systemPrompt:', prompt);

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesPayload, isGemini);

            const response = isGemini ?
                await fetch(geminiConfig.url, geminiConfig.data) :
                await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: [{role: 'system', content: prompt}, ...messagesPayload],
                        temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                        stream: false
                    })
                });

            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMsg += ` - ${errorData.error?.message || JSON.stringify(errorData)}`;
                } catch (e) {
                    errorMsg += ` - ${response.statusText}`;
                }
                throw new Error(errorMsg);
            }

            const data = await response.json();

            if (isGemini) {
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    return data.candidates[0].content.parts[0].text;
                } else {
                    throw new Error('Gemini API返回格式异常');
                }
            } else {
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    return data.choices[0].message.content;
                } else {
                    throw new Error('OpenAI API返回格式异常');
                }
            }
        }
        
        // 处理线下模式响应
        async function processOfflineResponse(response, chat) {
            const timestamp = Date.now();

            // 【新增】删除thinking标签
            const hasThinkingTag = response.includes('<thinking>');
            const cleanedResponse = removeThinkingTag(response);

            // 创建线下模式消息
            const offlineMsg = {
                role: 'assistant',
                content: cleanedResponse,
                timestamp: timestamp,
                isOfflineMode: true, // 标记为线下模式消息
                thinkingRemoved: hasThinkingTag // 标记thinking标签已被删除
            };
            // 检查用户是否在当前窗口，如果不在，则增加未读数并发送通知
const chatId = chat.id;
const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

if (!isViewingThisChat) {
    chat.unreadCount = (chat.unreadCount || 0) + 1;
    const notificationText = response.substring(0, 40) + (response.length > 40 ? '...' : '');
    showNotification(chatId, notificationText);
}
            // 保存到聊天记录
            chat.history.push(offlineMsg);
            await db.chats.put(chat);
            
            // 添加到页面
            appendMessage(offlineMsg, chat);
            renderChatList();
        }
        
        // 创建线下模式消息元素
        function createOfflineMessageElement(msg, chat) {
            const realityContainer = document.createElement('div');
            realityContainer.className = 'reality-message-wrapper';
            realityContainer.dataset.timestamp = msg.timestamp;

            // 【修改】线下模式和监控模式不再显示reality-timestamp
            // （原来的时间戳逻辑已删除）
            
            // 处理消息内容：使用DOM方法，完全避免innerHTML
            const bubble = document.createElement('div');
            const isUser = msg.role === 'user';
            bubble.className = `message-bubble reality-message-bubble ${isUser ? 'user' : 'ai'}`;
            bubble.dataset.timestamp = msg.timestamp;
            
            // 【新增】处理线下模式消息内容，隐藏abstract标签
            let processedContent = msg.content;
            if (msg.role === 'assistant') {
                processedContent = processOfflineMessageContent(msg.content);
            }

            // 【新增】如果thinking标签被删除，在顶部添加爱心标记
            if (msg.thinkingRemoved) {
                const heartLine = '⊹ ♡┈┈ 𓏴 𝒫𝒾𝓃𝓀 𝒱𝑒𝓁𝓋𝑒𝓉 𓏴 ┈┈♡ ⊹';
                const heartWrapper = document.createElement('div');
                heartWrapper.style.cssText = 'margin-bottom: 8px; padding: 6px 10px; background: rgba(0,0,0,0.05); border-radius: 8px; font-size: 12px; color: #666; cursor: pointer; text-align: center;';
                heartWrapper.textContent = heartLine;
                bubble.appendChild(heartWrapper);
            }

            // 按行分割内容
            const lines = processedContent.split('\n');
            
            lines.forEach((line, lineIndex) => {
                if (lineIndex > 0) {
                    bubble.appendChild(document.createElement('br'));
                }

                // 【新增】检查是否包含HTML（abstract提示）
                if (line.includes('<div class="abstract-hint"')) {
                    // 如果是HTML内容，使用innerHTML
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = line;
                    bubble.appendChild(wrapper);
                    return;
                }

                // 处理每一行的斜体标记：*文字* 格式
                if (line.includes('*')) {
                    const parts = line.split(/(\*[^*]+\*)/);
                    parts.forEach(part => {
                        if (part.startsWith('*') && part.endsWith('*') && part.length > 2) {
                            // 创建斜体span
                            const italicSpan = document.createElement('span');
                            italicSpan.className = 'reality-italic';
                            italicSpan.textContent = part.slice(1, -1); // 去掉*号
                            bubble.appendChild(italicSpan);
                        } else if (part) {
                            // 普通文本
                            bubble.appendChild(document.createTextNode(part));
                        }
                    });
                } else {
                    // 整行都是普通文本
                    bubble.appendChild(document.createTextNode(line));
                }
            });
            realityContainer.appendChild(bubble);
            
            // 添加事件监听器
            addLongPressListener(realityContainer, () => showMessageActions(msg.timestamp));
            realityContainer.addEventListener('click', () => { 
                if (isSelectionMode) toggleMessageSelection(msg.timestamp); 
            });
            
            return realityContainer;
        }

        async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 9999) { alert('请输入有效的金额 (0 到 9999 之间)！'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; const receiverName = chat.isGroup ? '群聊' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

        async function sendGiftMessage(giftName, giftPrice, recipient = null) { 
            if (!state.activeChatId) return; 
            const chat = state.chats[state.activeChatId]; 
            const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; 
            
            let receiverName = chat.isGroup ? '群聊' : chat.name;
            let giftType = 'normal'; // 普通礼物
            
            // 处理群聊中的收件人选择
            if (chat.isGroup) {
                if (recipient === 'random') {
                    receiverName = '群聊';
                    giftType = 'random'; // 拼手气礼物
                } else if (recipient && recipient !== 'random') {
                    receiverName = recipient; // 指定接收者
                    giftType = 'targeted'; // 指定礼物
                } else {
                    // 群聊中没有选择接收者，默认为拼手气
                    receiverName = '群聊';
                    giftType = 'random';
                }
            }
            
            const msg = { 
                role: 'user', 
                type: 'gift', 
                giftName: giftName, 
                giftPrice: parseFloat(giftPrice), 
                senderName, 
                receiverName, 
                giftType: giftType,
                status: 'pending',
                timestamp: Date.now() 
            }; 
            chat.history.push(msg); 
            await db.chats.put(chat); 
            appendMessage(msg, chat); 
            renderChatList(); 
        }

        function populateGroupMembersForGift(chat) {
            const recipientSelect = document.getElementById('gift-recipient-select');
            // 清空现有选项，只保留拼手气选项
            recipientSelect.innerHTML = '<option value="random">拼手气（随机赠送）</option>';
            
            // 添加群成员选项
            if (chat.members && chat.members.length > 0) {
                chat.members.forEach(member => {
                    const memberName = member.groupNickname || member.originalName || member;
                    const myNickname = chat.settings.myNickname || '我';
                    
                    if (memberName !== myNickname) { // 排除自己
                        const option = document.createElement('option');
                        option.value = memberName;
                        option.textContent = memberName;
                        recipientSelect.appendChild(option);
                    }
                });
            }
        }

        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在这里添加这行代码
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; if(e.target.closest('.naiimag-image')) return; pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: false }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { closePlusPanel();  const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { 
            document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

async function startListenTogetherSession(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
            musicState.startTime = Date.now(); // 核心修复1：记录会话开始时间
            musicState.playedIndices.clear(); // 核心修复2：清空上一轮的播放记录
            musicState.totalElapsedTime = chat.musicData.totalTime || 0;
musicState.isActive = true;
            musicState.activeChatId = chatId;
            if (musicState.playlist.length > 0) {
                musicState.currentIndex = -1; // 修改点：将初始索引从0改为-1，表示未选中任何歌曲
            } else {
                musicState.currentIndex = -1;
            }
            if(musicState.timerId) clearInterval(musicState.timerId);             musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); 
        document.getElementById('music-player-overlay').classList.add('visible');
    
    // 【核心新增 v2.0】
    // 1. 立即触发一次“初次反应”
    // triggerAiInitialMusicReaction(chatId); // <--- 删除或注释掉这一行

    
}

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;

    const oldChatId = musicState.activeChatId;
    const chat = state.chats[oldChatId];

    // 步骤 1: 【已修正】尝试生成并保存听歌记忆
    // 这个代码块现在只会负责生成记忆，即使不成功也不会中断整个关闭流程
    if (chat && musicState.startTime && musicState.playedIndices.size > 0) {
        try {
            const duration = Math.floor((Date.now() - musicState.startTime) / 1000);
            const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
            const playedSongs = Array.from(musicState.playedIndices)
                .map(index => musicState.playlist[index])
                .filter(track => track)
                .map(track => `《${track.name}》`)
                .join('、');

            if (playedSongs) {
                const summaryText = `[系统提示：刚刚结束了一段“一起听”的时光。你们总共听了 ${durationText}。期间播放过的歌曲有：${playedSongs}。请记住这些，并在后续对话中自然地提及。]`;
                const hiddenMemoryMessage = {
                    role: 'system',
                    content: summaryText,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);
                await db.chats.put(chat);
                console.log('[一起听] 已为AI生成并保存了听歌记忆。');
            }
        } catch (error) {
            console.error("生成听歌记忆时出错:", error);
        }
    }

    // 步骤 2: 触发AI的结束反应 (无论是否生成记忆，都应该触发)
    // 我们把它提前，这样它可以在后台运行，不影响UI关闭
    triggerAiInitialMusicReaction(oldChatId, 'end');
    
    // 步骤 3: 停止所有音乐相关的进程
    
    if (musicState.timerId) {
        clearInterval(musicState.timerId);
        musicState.timerId = null;
    }
    if (musicState.isPlaying) {
        audioPlayer.pause();
    }

    // 步骤 4: 关闭播放器UI并清理状态
    closeMusicPlayerWithAnimation(async () => {
        if (saveState && oldChatId && state.chats[oldChatId]) {
            state.chats[oldChatId].musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(state.chats[oldChatId]);
        }
        // 重置状态
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        updateListenTogetherIcon(oldChatId, true);
    });
}

function returnToChat() {
    closeMusicPlayerWithAnimation();
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
            updateListenTogetherIcon(musicState.activeChatId);
            updateElapsedTimeDisplay();
            const titleEl = document.getElementById('music-player-song-title');
            const artistEl = document.getElementById('music-player-artist');
            const playPauseBtn = document.getElementById('music-play-pause-btn');
            // ▼▼▼ 【已注释】专辑图片显示和旋转逻辑 - 改为显示歌词 ▼▼▼
            // const albumCoverEl = document.getElementById('music-album-cover');
            // if (albumCoverEl) {
            //     if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
            //         const track = musicState.playlist[musicState.currentIndex];
            //         albumCoverEl.src = track.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            //     } else {
            //         albumCoverEl.src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            //     }
            //     // 控制旋转动画和暂停状态
            //     albumCoverEl.classList.toggle('rotating', musicState.currentIndex > -1);
            //     albumCoverEl.classList.toggle('paused', !musicState.isPlaying);
            // }
            // ▲▲▲ 专辑图片逻辑已禁用 ▲▲▲

            if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                const track = musicState.playlist[musicState.currentIndex];
                titleEl.textContent = track.name;
                artistEl.textContent = track.artist;
            } else {
                titleEl.textContent = '请添加歌曲';
                artistEl.textContent = '...';
            }
            playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
        }

        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }

function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <button class="playlist-action-btn share-btn" data-index="${index}" title="分享歌曲">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M4 12c0 4.4183 3.5817 8 8 8s8-3.5817 8-8"/>
                        <path d="M12 2v10"/>
                        <path d="M9 7l3-3 3 3"/>
                    </svg>
                </button>
                <button class="playlist-action-btn lyrics-btn" data-index="${index}" title="导入/编辑歌词">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M4 6h16M4 12h16M4 18h10"/>
                    </svg>
                </button>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}

function playSong(index, initiator = 'user') { // 新增 initiator 参数，默认为 'user'
            if (index < 0 || index >= musicState.playlist.length) return;
            musicState.currentIndex = index;
            musicState.playedIndices.add(index); 
            const track = musicState.playlist[index];
            
            // 将 initiator 传递给AI反应函数
            // 【核心修改】只有当 initiator 是 'user' (用户手动播放或首次播放) 时，才触发初次反应
            if (initiator === 'user') {
                triggerAiInitialMusicReaction(state.activeChatId, 'start', track, initiator);
            }
            // 【保持不变】如果是系统自动切歌 (下一首/上一首)，发送隐藏消息
            else if (initiator === 'system') {
                sendHiddenTrackInfoToAI(state.activeChatId, track);
            }
            // 注意：当 initiator 是 'loop' (来自单曲循环) 时，这里什么也不做

            // --- 歌词和UI更新逻辑保持不变 ---
            musicState.parsedLyrics = parseLRC(track.lrcContent || "");
            musicState.currentLyricIndex = -1;
            renderLyrics();
    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }
    audioPlayer.play();
    updatePlaylistUI();
    updatePlayerUI();
    updateMusicProgressBar();
}

        function togglePlayPause() { if (audioPlayer.paused) { if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { playSong(0); } else if (musicState.currentIndex > -1) { audioPlayer.play(); } } else { audioPlayer.pause(); } }

        function playNext() {
            if (musicState.playlist.length === 0) return;
            let nextIndex;
            const chatId = state.activeChatId;
            const chat = state.chats[chatId];

            switch(musicState.playMode) {
                case 'random': {
                    nextIndex = Math.floor(Math.random() * musicState.playlist.length);
                    // ▼▼▼ 【新增】随机播放切歌时发送系统信息 ▼▼▼
                    const randomTrack = musicState.playlist[nextIndex];
                    if (chat && randomTrack && musicState.isActive) {
                        const hiddenMessage = {
                            role: 'system',
                            content: `[系统提示：随机播放切歌到《${randomTrack.name}》 - ${randomTrack.artist}]`,
                            timestamp: Date.now(),
                            isHidden: true
                        };
                        chat.history.push(hiddenMessage);
                        db.chats.put(chat).catch(err => console.error("保存随机切歌提示失败:", err));
                        console.log(`[隐藏消息] 随机播放切歌: ${randomTrack.name}`);
                    }
                    // ▲▲▲ 随机播放系统信息结束 ▲▲▲
                    break;
                }
                case 'single': { // 使用大括号创建独立作用域
                    // 【核心新增】发送隐藏消息告知AI正在单曲循环
                    const track = musicState.playlist[musicState.currentIndex];
                    if (chat && track && musicState.isActive) {
                        const hiddenLoopMessage = {
                            role: 'system',
                            content: `[系统提示：单曲循环《${track.name}》 - ${track.artist}]`,
                            timestamp: Date.now(),
                            isHidden: true
                        };
                        chat.history.push(hiddenLoopMessage);
                        // 异步保存，不阻塞播放
                        db.chats.put(chat).catch(err => console.error("保存循环提示失败:", err));
                        console.log(`[隐藏消息] 已通知AI歌曲循环: ${track.name}`);
                    }

                    // 【核心修改】调用 playSong 时，传递 'system' 作为 initiator，避免触发初次反应
                    playSong(musicState.currentIndex, 'system');
                    return; // 处理完单曲循环后直接返回
                } // 结束大括号
                case 'order':
                default: {
                    nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
                    // ▼▼▼ 【新增】顺序播放切歌时发送系统信息 ▼▼▼
                    const orderTrack = musicState.playlist[nextIndex];
                    if (chat && orderTrack && musicState.isActive) {
                        const hiddenMessage = {
                            role: 'system',
                            content: `[系统提示：顺序播放切歌到《${orderTrack.name}》 - ${orderTrack.artist}]`,
                            timestamp: Date.now(),
                            isHidden: true
                        };
                        chat.history.push(hiddenMessage);
                        db.chats.put(chat).catch(err => console.error("保存顺序切歌提示失败:", err));
                        console.log(`[隐藏消息] 顺序播放切歌: ${orderTrack.name}`);
                    }
                    // ▲▲▲ 顺序播放系统信息结束 ▲▲▲
                    break;
                }
            }
            playSong(nextIndex, 'system');
        }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex, 'system'); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

// ▼▼▼ 【新增】音乐搜索功能 - 音频可用性检测函数 ▼▼▼
function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}
// ▲▲▲ 音频可用性检测函数结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - 获取歌词函数 ▼▼▼
async function getLyricsForSong(songId, source) {
    try {
        // 关键修复：使用正确的歌词API端点 /lyric?id=
        const apiUrl = source === 'netease'
            ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
            : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;

        const response = await Http_Get(apiUrl);
        if (response?.data) {
            // 兼容不同的返回格式
            const lrc = response.data.lrc || response.data.lyric || "";
            const tlyric = response.data.trans || response.data.tlyric || "";
            // 合并原歌词和翻译歌词（如果有的话）
            return lrc + "\n" + tlyric;
        }
        return "";
    } catch (error) {
        console.error("获取歌词失败:", error);
        return "";
    }
}
// ▲▲▲ 获取歌词函数结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - HTTP请求辅助函数 ▼▼▼
async function Http_Get(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('HTTP请求失败:', error);
        throw error;
    }
}
// ▲▲▲ HTTP请求辅助函数结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - 网易云音乐搜索 ▼▼▼
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;

        console.log("正在搜索网易云音乐:", searchTerm);

        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("网易云API返回无结果:", result);
            return [];
        }

        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 15);

    } catch (e) {
        console.error("网易云搜索失败:", e);
        return [];
    }
}
// ▲▲▲ 网易云搜索结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - QQ音乐搜索 ▼▼▼
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'tencent'
        })).slice(0, 5);
    } catch (e) {
        console.error("QQ音乐搜索失败:", e);
        return [];
    }
}
// ▲▲▲ QQ音乐搜索结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - 显示搜索源选择器 ▼▼▼
async function showSearchSourceSelector() {
    return new Promise((resolve) => {
        const modal = document.getElementById('music-source-selector-modal');
        modal.classList.add('visible');

        const confirmBtn = document.getElementById('confirm-source-select-btn');
        const cancelBtn = document.getElementById('cancel-source-select-btn');

        const handleConfirm = () => {
            const selected = document.querySelector('input[name="search-source"]:checked').value;
            cleanup();
            resolve(selected);
        };

        const handleCancel = () => {
            cleanup();
            resolve(null);
        };

        const cleanup = () => {
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            modal.classList.remove('visible');
        };

        confirmBtn.addEventListener('click', handleConfirm);
        cancelBtn.addEventListener('click', handleCancel);
    });
}
// ▲▲▲ 搜索源选择器结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - 处理搜索结果点击 ▼▼▼
async function handleSearchResultClick(songData) {
    const modal = document.getElementById('music-search-results-modal');
    modal.classList.remove('visible');

    await showCustomAlert("请稍候...", `正在获取《${songData.name}》的播放链接...`);

    let playableResult = null;
    let finalSource = songData.source;

    // 1. 尝试主音源 - 通过ID获取真实的播放URL
    const primaryApiUrl = songData.source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;

    try {
        let primaryResult = await Http_Get(primaryApiUrl);
        if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
            playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
        }
    } catch (e) {
        console.error("主音源获取失败:", e);
    }

    // 2. 如果主音源失败，尝试备用音源
    if (!playableResult) {
        await showCustomAlert("请稍候...", "主音源获取失败，正在尝试备用音源...");
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent'
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;

            try {
                const fallbackResult = await Http_Get(fallbackApiUrl);
                if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                    playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                    finalSource = fallbackSource;
                }
            } catch (e) {
                console.error("备用音源获取失败:", e);
            }
        }
    }

    if (!playableResult) {
        await showCustomAlert("获取失败", "无法获取该歌曲的有效播放链接，主音源和备用音源均已尝试。");
        return;
    }

    hideCustomModal();

    // 3. 获取歌词
    const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";

    // 4. 创建歌曲对象（使用获取到的真实URL）
    const newSong = {
        name: songData.name,
        artist: songData.artist,
        src: playableResult.url,  // ← 关键：使用真实的播放URL
        cover: songData.cover,
        isLocal: false,
        lrcContent: lrcContent,
        isTemporary: true,
        addedTimestamp: Date.now()
    };

    musicState.playlist.push(newSong);
    await saveGlobalPlaylist();
    updatePlaylistUI();

    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = musicState.playlist.length - 1;
    }

    updatePlayerUI();

    await showCustomAlert('添加成功', `《${songData.name}》已成功添加到播放列表！`);
}
// ▲▲▲ 处理搜索结果点击结束 ▲▲▲

// ▼▼▼ 【新增】音乐搜索功能 - 搜索入口函数 ▼▼▼
async function addSongFromSearch() {
    // 步骤 1: 显示搜索源选择器
    const source = await showSearchSourceSelector();
    if (!source) return; // 用户取消

    // 步骤 2: 弹出输入框让用户输入关键词
    const searchTerm = await showCustomPrompt("搜索歌曲", "请输入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("请稍候...", "正在搜索歌曲资源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    // 步骤 3: 根据用户的选择，执行不同的搜索
    let combinedResults = [];

    if (source === 'all') {
        const [neteaseResults, tencentResults] = await Promise.all([
            searchNeteaseMusic(musicName, singerName),
            searchTencentMusic(musicName)
        ]);
        combinedResults = [...neteaseResults, ...tencentResults];
    } else if (source === 'netease') {
        combinedResults = await searchNeteaseMusic(musicName, singerName);
    } else if (source === 'tencent') {
        combinedResults = await searchTencentMusic(musicName);
    }

    // 隐藏加载提示
    hideCustomModal();

    // 步骤 4: 显示搜索结果
    if (combinedResults.length === 0) {
        await showCustomAlert("无结果", "抱歉，在所选来源中未能找到相关歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        item.innerHTML = `
            <div class="title">${song.name}</div>
            <div style="display: flex; align-items: center; margin-top: 4px;">
                <div class="artist">${song.artist}</div>
                <span class="source">${song.source === 'netease' ? '网易云' : 'QQ音乐'}</span>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 搜索入口函数结束 ▲▲▲

// ▼▼▼ 【全新】v2.0 - 兼容网易云音乐链接解析 ▼▼▼
/**
 * 【总入口】处理所有通过URL添加歌曲的逻辑
 */
async function handleAddSongFromUrl() {
    const url = await showCustomPrompt("添加歌曲", "请输入歌曲的URL或网易云音乐分享链接", "", "url");
    if (!url) return;

    // 检查是否是网易云音乐链接
    if (url.includes('music.163.com')) {
        await parseNeteaseMusicUrl(url);
    } else {
        // 保持原有的通用URL添加逻辑
        const name = await showCustomPrompt("歌曲信息", "请输入歌名");
        if (!name) return;
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
        if (!artist) return;
        
        musicState.playlist.push({ name, artist, src: url, isLocal: false, lrcContent: "" });
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - 1;
            updatePlayerUI();
        }
    }
}

// ▼▼▼ 【最终解决方案】v3.0 - 使用内置CORS的专用API服务器 ▼▼▼
/**
 * 解析网易云音乐链接，并获取歌曲信息和歌词
 * @param {string} url - 网易云音乐的分享链接
 */
async function parseNeteaseMusicUrl(url) {
    // 1. 从URL中提取歌曲ID
    const match = url.match(/id=(\d+)/);
    if (!match || !match[1]) {
        await showCustomAlert('解析失败', '无法从链接中找到有效的歌曲ID。');
        return;
    }
    const songId = match[1];

    // 显示加载提示
    const loadingAlert = showCustomAlert('正在解析...', '正在连接专用服务器获取歌曲信息，请稍候...');

    try {
        // 2. 【核心修正】: 更换为内置CORS支持的专用API服务器地址
        const apiUrl = `https://netease-cloud-music-api-beta-lyart.vercel.app`;
        
        // 3. 并行发起三个直接请求（不再需要CORS代理）
        const [detailRes, urlRes, lyricRes] = await Promise.all([
            fetch(`${apiUrl}/song/detail?ids=${songId}`),
            fetch(`${apiUrl}/song/url/v1?id=${songId}&level=exhigh`),
            fetch(`${apiUrl}/lyric?id=${songId}`)
        ]);

        if (!detailRes.ok || !urlRes.ok || !lyricRes.ok) {
            throw new Error('API请求失败，服务器可能暂时不可用，请稍后再试。');
        }

        const detailData = await detailRes.json();
        const urlData = await urlRes.json();
        const lyricData = await lyricRes.json();

        // 4. 从返回的数据中提取所需信息
        const songInfo = detailData.songs?.[0];
        const songUrlInfo = urlData.data?.[0];
        const lrcContent = lyricData.lrc?.lyric || '';

        if (!songInfo || !songUrlInfo || !songUrlInfo.url) {
            throw new Error('无法获取到有效的歌曲信息或播放链接，可能是VIP歌曲或地区限制。');
        }

        const name = songInfo.name;
        const artist = songInfo.ar.map(a => a.name).join(' / ');
        const audioUrl = songUrlInfo.url.replace(/^http:/, 'https:');

        // 5. 将解析到的歌曲添加到播放列表
        musicState.playlist.push({ name, artist, src: audioUrl, isLocal: false, lrcContent });
        await saveGlobalPlaylist();
        
        hideCustomModal();
        await showCustomAlert('添加成功', `《${name}》 - ${artist} 已成功添加到播放列表！`);

        // 6. 更新UI
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - 1;
            updatePlayerUI();
        }

    } catch (error) {
        console.error("解析网易云音乐链接失败:", error);
        hideCustomModal();
        await showCustomAlert('解析失败', error.message);
    }
}
// ▼▼▼ 【全新】v3.0 - 增强文件名解析与iOS兼容性 ▼▼▼
async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    // 1. 分离音乐文件和歌词文件 (逻辑不变)
    const musicFiles = [];
    const lyricFiles = new Map();

    for (const file of files) {
        const lowerCaseName = file.name.toLowerCase();
        if (lowerCaseName.endsWith('.flac') || lowerCaseName.endsWith('.mp3') || lowerCaseName.endsWith('.wav') || lowerCaseName.endsWith('.m4a')) {
            musicFiles.push(file);
        } else if (lowerCaseName.endsWith('.lrc')) {
            const baseName = file.name.replace(/\.[^/.]+$/, "");
            lyricFiles.set(baseName, file);
        }
    }

    if (musicFiles.length === 0) {
        alert("没有检测到支持的音乐文件。");
        event.target.value = null;
        return;
    }

    // 2. 异步读取所有歌词文件的内容 (逻辑不变)
    const lyricContents = new Map();
    const lyricReadPromises = [];

    for (const [baseName, file] of lyricFiles.entries()) {
        const promise = new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (readEvent) => {
                lyricContents.set(baseName, readEvent.target.result);
                resolve();
            };
            reader.onerror = () => {
                console.error(`读取歌词文件 ${file.name} 失败。`);
                resolve();
            };
            reader.readAsText(file);
        });
        lyricReadPromises.push(promise);
    }
    await Promise.all(lyricReadPromises);

    // 3. 遍历音乐文件，智能解析文件名，匹配歌词并添加到播放列表
    for (const file of musicFiles) {
        const baseName = file.name.replace(/\.[^/.]+$/, "");
        
        // --- ▼▼▼ 核心修改点在这里 ▼▼▼ ---
        let defaultSongName = baseName;
        let defaultArtist = "未知歌手";

        // 智能解析"歌曲-歌手"格式，以最后一个"-"为分隔符
        const lastHyphenIndex = baseName.lastIndexOf('-');
        if (lastHyphenIndex > 0 && lastHyphenIndex < baseName.length - 1) { // 确保"-"不在开头或结尾
            defaultSongName = baseName.substring(0, lastHyphenIndex).trim();
            defaultArtist = baseName.substring(lastHyphenIndex + 1).trim();
        }
        // --- ▲▲▲ 修改结束 ▲▲▲ ---
        
        // 使用解析出的默认值来提问
        let name = await showCustomPrompt("歌曲信息", "请输入歌名", defaultSongName);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", defaultArtist);
        if (artist === null) continue;

        // 智能匹配歌词 (逻辑不变)
        const lrcContent = lyricContents.get(baseName) || "";
        if (lrcContent) {
            console.log(`成功为《${name}》匹配到歌词！`);
        }

        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    // 4. 保存并更新UI (逻辑不变)
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        updatePlayerUI();
    }
    event.target.value = null;
    alert(`成功导入 ${musicFiles.length} 首音乐！`);
}

        async function shareMusicCard(index) {
            if (index < 0 || index >= musicState.playlist.length) return;
            if (!state.activeChatId) {
                await showCustomAlert('提示', '请先选择一个聊天对象');
                return;
            }

            const track = musicState.playlist[index];
            const chat = state.chats[state.activeChatId];

            // 构建分享卡片的内容：歌名-歌手-歌词
            let cardContent = `🎵 分享歌曲卡片\n歌名：《${track.name}》\n歌手：${track.artist}`;

            // 如果有歌词就添加歌词内容
            if (track.lrcContent) {
                cardContent += `\n\n【歌词内容】\n${track.lrcContent}`;
            } else {
                cardContent += `\n\n【歌词】暂无歌词`;
            }

            // 添加一条包含音乐卡片信息的消息到聊天历史
            const musicCardMsg = {
                role: 'user',
                content: cardContent,
                timestamp: Date.now(),
                isMusicCard: true,
                musicData: {
                    name: track.name,
                    artist: track.artist,
                    lyrics: track.lrcContent || '',
                    cover: track.cover || ''
                }
            };

            chat.history.push(musicCardMsg);
            await db.chats.put(chat);

            // 显示新消息到聊天界面
            appendMessage(musicCardMsg, chat);

            await showCustomAlert('分享成功', `已将《${track.name}》分享到聊天`);
        }

        function showMusicLyricsModal(musicData) {
            // 创建弹窗容器
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 12px;
                width: 85%;
                max-width: 400px;
                max-height: 70vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                padding: 16px;
                background: #f5f5f5;
                color: #1E1E1E;
                flex-shrink: 0;
            `;

            const title = document.createElement('div');
            title.style.cssText = `
                font-weight: 600;
                font-size: 16px;
                margin-bottom: 4px;
                word-break: break-word;
                color: #1E1E1E;
            `;
            title.textContent = musicData.name;

            const artist = document.createElement('div');
            artist.style.cssText = `
                font-size: 13px;
                opacity: 0.7;
                color: #666;
            `;
            artist.textContent = musicData.artist;

            header.appendChild(title);
            header.appendChild(artist);

            const lyricsContainer = document.createElement('div');
            lyricsContainer.style.cssText = `
                flex: 1;
                overflow-y: auto;
                padding: 16px;
                font-size: 13px;
                line-height: 1.8;
                white-space: pre-wrap;
                word-break: break-word;
                color: #333;
            `;

            if (musicData.lyrics) {
                // 去掉LRC格式的时间轨，只保留歌词文本
                const cleanedLyrics = musicData.lyrics
                    .split('\n')
                    .map(line => line.replace(/^\[\d{2}:\d{2}\.\d{2}\]\s*/, ''))
                    .filter(line => line.trim())
                    .join('\n');
                lyricsContainer.textContent = cleanedLyrics;
            } else {
                lyricsContainer.style.cssText += `
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: #999;
                `;
                lyricsContainer.textContent = '暂无歌词';
            }

            const closeBtn = document.createElement('button');
            closeBtn.style.cssText = `
                padding: 12px 16px;
                background: #f0f0f0;
                border: none;
                color: #333;
                font-size: 14px;
                cursor: pointer;
                flex-shrink: 0;
                font-weight: 500;
            `;
            closeBtn.textContent = '关闭';
            closeBtn.addEventListener('click', () => modal.remove());

            content.appendChild(header);
            content.appendChild(lyricsContainer);
            content.appendChild(closeBtn);
            modal.appendChild(content);

            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });

            document.body.appendChild(modal);
        }

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) {
            editingPersonaPresetId = presetId;

            // 【核心修复】先恢复模态框的原始按钮结构，防止被showChoiceModal污染
            const footer = presetActionsModal.querySelector('.custom-modal-footer');
            footer.innerHTML = '';
            footer.style.gap = '12px'; // 恢复原始gap
            footer.style.display = 'flex';
            footer.style.flexDirection = 'column';
            footer.style.alignItems = 'center';
            footer.style.padding = '16px';

            // 重新创建三个按钮
            const editBtn = document.createElement('button');
            editBtn.id = 'preset-action-edit';
            editBtn.textContent = '编辑预设';
            editBtn.onclick = openPersonaEditorForEdit;

            const deleteBtn = document.createElement('button');
            deleteBtn.id = 'preset-action-delete';
            deleteBtn.className = 'btn-danger';
            deleteBtn.textContent = '删除预设';
            deleteBtn.onclick = deletePersonaPreset;

            const cancelBtn = document.createElement('button');
            cancelBtn.id = 'preset-action-cancel';
            cancelBtn.textContent = '取消';
            cancelBtn.style.marginTop = '8px';
            cancelBtn.style.borderRadius = '8px';
            cancelBtn.style.backgroundColor = '#f0f0f0';
            cancelBtn.onclick = hidePresetActions;

            footer.appendChild(editBtn);
            footer.appendChild(deleteBtn);
            footer.appendChild(cancelBtn);

            presetActionsModal.classList.add('visible');
        }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

        function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '添加人设预设'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

        function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '编辑人设预设'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '删除相册',
                        `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 从照片表中删除该相册下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 从相册表中删除该相册本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相册列表
                        await renderAlbumList();
                        
                        alert('相册已成功删除。');
                    }
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相册:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

/**
 * 打开图片查看器
 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 从数据库获取当前相册的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被点击照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

    // 3. 显示模态框并渲染第一张图
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根据当前状态渲染查看器内容（图片和按钮）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新图片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延迟一点点时间来触发CSS过渡

    // 更新按钮状态：如果是第一张，禁用“上一张”按钮
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最后一张，禁用“下一张”按钮
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 显示下一张照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 显示上一张照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 关闭图片查看器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空图片，避免下次打开时闪现旧图
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
/**
 * 【全新】当系统自动切换歌曲时，发送隐藏的系统消息通知AI (修改版：不自动触发回复)
 * @param {string} chatId - 当前聊天的ID
 * @param {object} track - 新播放的歌曲对象
 */
async function sendHiddenTrackInfoToAI(chatId, track) {
    if (!chatId || !track) return;
    const chat = state.chats[chatId];
    if (!chat) return;

    // 构建歌词部分（如果有）
    const lyricsBlock = track.lrcContent ? `\n\n# 歌曲《${track.name}》的完整歌词:\n${track.lrcContent}` : '';

    // 构建系统消息内容
    const systemMessageContent = `[系统提示：歌曲已自动切换到下一首/上一首。当前正在播放：《${track.name}》 - ${track.artist}。请根据这首歌的氛围和歌词（如果提供），继续与用户聊天。]${lyricsBlock}`;

    // 创建隐藏消息对象
    const hiddenMessage = {
        role: 'system', // 使用 'system' 角色
        content: systemMessageContent,
        timestamp: Date.now(),
        isHidden: true // 核心：标记为对用户隐藏
    };

    // 添加到聊天记录并保存
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
    console.log(`[隐藏消息] 已通知AI歌曲切换: ${track.name}`);

    // 【重要修改】不再在此处自动触发 AI 响应
    // triggerAiResponse(); // <--- 已删除此行
}

/**
 * (程煜：这是新的音频初始化函数)
 * 初始化音频上下文并预加载通知音
 */
async function initAudioContext() {
    // 1. 创建音频上下文
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        console.error('Web Audio API is not supported in this browser.', e);
        return;
    }

    // 2. 检查全局设置里有没有通知音URL
    const audioUrl = state.globalSettings.notificationSoundUrl;
    if (!audioUrl || !audioUrl.trim()) {
        console.log('[AudioInit] 未设置通知音URL，跳过预加载。');
        notificationAudioBuffer = null; // 确保缓冲区是空的
        return;
    }

    // 3. 预加载音频文件
    console.log(`[AudioInit] 正在预加载通知音: ${audioUrl}`);
    try {
        const response = await fetch(audioUrl);
        if (!response.ok) {
            throw new Error(`[AudioInit] HTTP error! status: ${response.status}`);
        }
        const arrayBuffer = await response.arrayBuffer();
        
        // 4. 解码为音频缓冲
        audioContext.decodeAudioData(arrayBuffer, (buffer) => {
            notificationAudioBuffer = buffer; // 存到全局变量
            console.log('[AudioInit] ✓ 通知音预加载并解码成功！');
        }, (error) => {
            console.error('[AudioInit] ✗ 解码音频数据失败:', error);
            notificationAudioBuffer = null;
        });
    } catch (e) {
        console.error(`[AudioInit] ✗ 抓取音频文件失败:`, e);
        notificationAudioBuffer = null;
    }
}

/**
 * (程煜：这是“解锁”函数 v2.0 - 常驻版)
 * 只要检测到音频上下文处于暂停状态，就尝试恢复
 */
function unlockAudioContext() {
    if (!audioContext) {
        // (程煜：音频服务没启动，点了也没用)
        return; 
    }
    
    // (程煜：【核心】每次点击都检查)
    if (audioContext.state === 'suspended') {
        // (程煜：抓到了，它又睡着了。点一下就把它唤醒。)
        audioContext.resume().then(() => {
            console.log('AudioContext 已被用户手势恢复 (Resumed)');
            
            // (程煜：可选步骤，播放一个无声来确保激活)
            const buffer = audioContext.createBuffer(1, 1, 22050);
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);

        }).catch(e => {
            // (程煜：如果用户没点屏幕，自动恢复可能会失败，记一下)
            console.warn("AudioContext 恢复失败 (可能需要用户交互):", e);
        });
    } else {
        // (程煜：它醒着，不用管。)
    }
    
    // (程煜：【重点】我把那两行 removeEventListener 删掉了。我们要让这个陷阱一直生效。)
}

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】渲染气泡预设列表 (已添加编辑功能)
 */
async function renderBubblePresets() {
    const listEl = document.getElementById('bubble-presets-list');
    const presets = await db.bubblePresets.toArray();
    listEl.innerHTML = ''; // 清空列表

    if (presets.length === 0) {
        listEl.innerHTML = '<p class="preset-placeholder">还没有保存任何预设...</p>';
        return;
    }

    presets.forEach(preset => {
        const item = document.createElement('div');
        item.className = 'bubble-preset-item';
        item.innerHTML = `
            <span class="preset-name">${preset.name}</span>
            <div class="preset-actions">
                <button class="apply-btn" data-id="${preset.id}">应用</button>
            
                <button class="delete-btn" data-id="${preset.id}">删除</button>
                <button class="edit-btn" data-id="${preset.id}">编辑</button>
            </div>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新】处理点击“编辑预设”按钮的逻辑
 * @param {number} presetId - 要编辑的预设的ID
 */
async function handleEditBubblePreset(presetId) {
    // 1. 记录我们正在编辑的预设ID
    editingBubblePresetId = presetId;
    
    // 2. 从数据库中找到这个预设
    const preset = await db.bubblePresets.get(presetId);
    if (!preset) return;
    
    // 3. 将预设的CSS内容填入编辑框
    const cssInput = document.getElementById('custom-css-input');
    const expandedCssEditor = document.querySelector('#css-editor-expanded .expanded-textarea');
    cssInput.value = preset.css;
    if (expandedCssEditor) {
        expandedCssEditor.value = preset.css;
    }
    
    // 4. 自动展开编辑器
    const expandBtn = document.querySelector('.expand-persona-btn[data-target="css"]');
    if (expandBtn) {
        // 找到编辑器元素并直接显示，比模拟点击更稳定
        const smallTextarea = document.getElementById('custom-css-input');
        const expandedEditor = document.getElementById('css-editor-expanded');
        if (smallTextarea && expandedEditor) {
            smallTextarea.style.display = 'none';
            expandedEditor.style.display = 'block';
            expandedEditor.querySelector('textarea').focus();
        }
    }

    // 5. 更新预览
    updateSettingsPreview();
}

/**
 * 【全新】将当前CSS保存为新的预设
 */
async function saveCurrentBubbleCssAsPreset() {
    const cssInput = document.getElementById('custom-css-input');
    const css = cssInput.value.trim();
    if (!css) {
        alert('自定义CSS内容为空，无法保存！');
        return;
    }

    const name = await showCustomPrompt('保存预设', '请输入这个气泡样式的名字：');
    if (name && name.trim()) {
        await db.bubblePresets.add({ name: name.trim(), css: css });
        await renderBubblePresets(); // 保存后立即刷新列表
        alert('预设保存成功！');
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存储

            // --- 更新底部导航栏的“动态”按钮 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天界面返回列表的按钮 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 确保能正确定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回键上的小红点通常不显示数字，只显示一个点
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) {
        console.log("⚠️ 模拟器已在运行，跳过重复启动");
        return;
    }
    // 【修改】使用固定的10秒心跳间隔，各角色按自己的间隔判断
    simulationIntervalId = setInterval(runBackgroundSimulationTick, 10 * 1000);
    console.log("🚀 后台活动模拟已启动，心跳间隔: 10秒");
    console.log(`📊 模拟器ID: ${simulationIntervalId}`);

    // 立即执行一次心跳，方便调试
    runBackgroundSimulationTick();
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
        console.log("🛑 后台活动模拟已停止");
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲

/**
 * 这是模拟器的"心跳"，每次定时器触发时运行
 */
function runBackgroundSimulationTick() {
    console.log("========== 模拟器心跳 Tick ==========");

    // 【修改】检查是否有任何角色开启了后台活动
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    console.log(`📊 单聊总数: ${allSingleChats.length}`);
    if (allSingleChats.length === 0) {
        console.log("⚠️ 没有单聊，跳过检查");
        return;
    }

    const hasAnyEnabled = allSingleChats.some(chat => chat.settings?.backgroundActivityEnabled);
    console.log(`🔍 全局开关: ${state.globalSettings.enableBackgroundActivity}, 有角色开启: ${hasAnyEnabled}`);

    // 【修改】如果全局开关和所有角色的独立开关都关闭，则停止模拟器
    if (!state.globalSettings.enableBackgroundActivity && !hasAnyEnabled) {
        console.log("❌ 全局和独立开关都关闭，停止模拟器");
        stopBackgroundSimulation();
        return;
    }

    console.log(`✅ 开始检查 ${allSingleChats.length} 个角色...`);
    allSingleChats.forEach(chat => {
        // 【优化】只显示开启了后台活动的角色的日志
        const shouldLog = chat.settings?.backgroundActivityEnabled || chat.relationship?.status === 'blocked_by_user';

       if (shouldLog) {
                        console.log(`  关系状态: ${chat.relationship?.status || '未设置'}`);
                        console.log(`  是否当前聊天: ${chat.id === state.activeChatId}`);
                        console.log(`  后台活动开关: ${chat.settings?.backgroundActivityEnabled || false}`);
                        console.log(`  后台活动间隔: ${chat.settings?.backgroundActivityInterval || '未设置'}秒`);
                    }
                    // 【核心修正】将两种状态检查分离开，逻辑更清晰
    
                    // 检查1：处理【被用户拉黑】的角色 -> 触发【好友申请】 (2025-10-29 保留此逻辑)
                    if (chat.relationship?.status === 'blocked_by_user' && (state.globalSettings.enableBackgroundActivity || chat.settings?.backgroundActivityEnabled)) {
                        const blockedTimestamp = chat.relationship.blockedTimestamp;
                        // 安全检查：确保有拉黑时间戳
                        if (!blockedTimestamp) {
                            console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                            // 注意：这里不能 'return'，因为还要继续执行检查2
                        } else {
                            const blockedDuration = Date.now() - blockedTimestamp;
                            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
        
                            console.log(`检查角色 "${chat.name}" (逻辑1 - 好友申请)：已拉黑 ${Math.round(blockedDuration/1000/60)}分钟，冷静期需 ${cooldownMilliseconds/1000/60}分钟。`);
        
                            if (blockedDuration > cooldownMilliseconds) {
                                console.log(`角色 "${chat.name}" 的冷静期已过，触发"反思"并申请好友事件...`);
        
                                // 【重要】为了防止在AI响应前重复触发，我们在触发后立刻更新状态
                                chat.relationship.status = 'pending_system_reflection'; // 设置一个临时的、防止重复触发的状态
        
                                triggerAiFriendApplication(chat.id);
                            }
                        }
                    }
                    
                    // 检查2：处理【好友关系】和【被拉黑】的正常后台活动 -> 触发【发消息/动态等】
                    // (2025-10-29 修改：移除 'else'，使其成为独立if；并添加 'blocked_by_user' 状态)
                    if ((chat.relationship?.status === 'friend' || chat.relationship?.status === 'blocked_by_user') && chat.id !== state.activeChatId) {
                        // 【新逻辑】检查该角色是否开启了独立的后台活动
                        if (!chat.settings?.backgroundActivityEnabled) {
                            // 该角色未开启后台活动，跳过（使用continue风格，但forEach中用return）
                        } else {
                            if (shouldLog) console.log(`  ✓ 该角色已开启后台活动`);
    
                            // 【防护】如果正在执行后台活动，跳过本次检查
                            if (state.backgroundActivityChats.has(chat.id)) {
                                if (shouldLog) console.log(`  ⏳ 该角色正在执行后台活动，跳过本次检查`);
                                return;
                            }
    
                            // 初始化上次检查时间（保存到settings中以持久化）
                            if (!chat.settings.lastBackgroundCheckTime) {
                                chat.settings.lastBackgroundCheckTime = Date.now();
                                // 异步保存到数据库
                                db.chats.put(chat).catch(err => console.error('保存lastBackgroundCheckTime失败:', err));
                                if (shouldLog) console.log(`  🆕 首次初始化检查时间: ${new Date(chat.settings.lastBackgroundCheckTime).toLocaleTimeString()}`);
                            } else {
                                const timeSinceLastCheck = Date.now() - chat.settings.lastBackgroundCheckTime;
                                const intervalMilliseconds = (chat.settings.backgroundActivityInterval || 60) * 1000;
                                const timeUntilNext = Math.max(0, intervalMilliseconds - timeSinceLastCheck);
    
                                if (shouldLog) {
                                    // (2025-10-29 修改：为日志添加“逻辑2”标识，以便区分)
                                    console.log(`  检查角色 "${chat.name}" (逻辑2 - 后台活动)：`);
                                    console.log(`    ⏱️ 上次检查: ${Math.floor(timeSinceLastCheck / 1000)}秒前`);
                                    console.log(`    ⏱️ 间隔要求: ${chat.settings.backgroundActivityInterval}秒`);
                                    console.log(`    ⏱️ 距离下次: ${Math.floor(timeUntilNext / 1000)}秒`);
                                }
    
                                // 只有达到该角色的检测间隔时才进行检查
                                if (timeSinceLastCheck >= intervalMilliseconds) {
                                    if (shouldLog) console.log(`    🎯 达到检测间隔，准备触发...`);
    
                                    // 【修改】立刻触发，无概率检查
                                    // 【重要】不在这里更新lastBackgroundCheckTime，而是等API返回后再更新
                                    if (shouldLog) console.log(`    🎯 倒计时结束，立刻触发后台活动...`);
                                    triggerInactiveAiAction(chat.id);
                                }
                            }
                        }
                    }
    });
}

// ↓↓↓ 从这里开始复制，替换掉旧的 triggerInactiveAiAction 函数 ↓↓↓
async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const now = new Date();
    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    const userNickname = state.qzoneSettings.nickname;

    // 【核心修改】使用与正常单聊相同的上下文构建逻辑
    // 1. 构建核心记忆上下文
    let coreMemoryContext = '';
    if (chat.memorySummary && chat.memorySummary.trim()) {
        coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
    }

    // 2. 获取历史消息（从记忆锚点开始）
    const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
    const contextMessages = chat.history.slice(memoryAnchor);

    // 3. 【修复】过滤掉隐藏消息、分享卡片、论坛卡片（与单聊保持一致）
    const historySlice = contextMessages.filter(msg =>
        !msg.isHidden &&
        msg.type !== 'share_card' &&
        msg.type !== 'forum_card'
    );

    // 4. 构建聊天历史（与单聊 buildActiveReplyPrompt 完全一致）
    let recentContextSummary = "你们最近没有聊过天。";
    if (historySlice.length > 0) {
        // 【安全修复】应用8条消息规则
        // 计算最近8条消息的时间戳
        const recentMessages = historySlice.slice(-8);
        const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

        // 【核心修复】返回完整历史记录，不截断
        const contextSummary = historySlice.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            let content;
            if (msg.type === 'ai_image') content = `[发送了图片]`;
            else if (msg.type === 'naiimag') content = `[NovelAI生成的图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
            else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
            else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
            else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
            else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
            // 【修复问题2和3】表情包只发送含义，不发送base64编码（检查msg.meaning来识别表情包）
            else if (msg.meaning) content = `[发送了一个表情，意思是: '${msg.meaning}']`;
            else {
                // 【核心修复】对所有AI消息应用8条消息规则：最近8条发完整，之外的有摘要就发摘要
                if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                    // 超过8条的AI消息，尝试提取摘要，有摘要就用摘要，没摘要就用完整内容
                    if (typeof msg.content === 'string') {
                        const abstractContent = extractAbstractContent(msg.content);
                        content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                    } else {
                        content = msg.content || '[系统消息]';
                    }
                } else {
                    // 8条消息以内的所有消息，或用户消息，使用完整内容
                    content = msg.content || '[系统消息]';
                }
            }
            return `${sender}: ${content}`;
        }).join('\n');

        recentContextSummary = `以下是你们最近的对话记录：\n${contextSummary}`;
    }

    // 5. 构建世界书内容
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = linkedContents;
        }
    }

    // 6. 构建群聊互通记忆（如果开启）
    let crossChatMemoryContent = '';
    if (chat.settings.crossChatMemory) {
        const relevantGroupChats = Object.values(state.chats).filter(c =>
            c.isGroup && c.members && c.members.some(m => m.originalName === chat.name)
        );

        if (relevantGroupChats.length > 0) {
            const memorySnippets = [];
            for (const groupChat of relevantGroupChats) {
                const memoryAnchorGroup = groupChat.settings.memoryAnchor || 0;
                const historyToConsider = groupChat.history.slice(memoryAnchorGroup);

                const recent8Messages = historyToConsider.slice(-8);
                const recent8Timestamps = new Set(recent8Messages.map(msg => msg.timestamp));

                if (historyToConsider.length > 0) {
                    const historyText = historyToConsider.slice(-20).map(msg => {
                        let sender;
                        if (msg.role === 'user') {
                            sender = groupChat.settings.myNickname || '我';
                        } else if (msg.senderName) {
                            sender = msg.senderName;
                        } else {
                            sender = groupChat.name;
                        }

                        let content;
                        if (msg.role === 'assistant' && !recent8Timestamps.has(msg.timestamp)) {
                            content = extractAbstractContent(extractMessageContent(msg)) || extractMessageContent(msg);
                        } else {
                            content = extractMessageContent(msg);
                        }

                        const truncatedContent = String(content || '').substring(0, 300);

                        // 【新增】格式化时间戳
                        const msgTime = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '时间未知';
                        return `(${msgTime}) ${sender}: ${truncatedContent}`;
                    }).join('\n');
                    memorySnippets.push(`## 群聊"${groupChat.name}"的记忆片段:\n${historyText}`);
                }
            }

            if (memorySnippets.length > 0) {
                crossChatMemoryContent = `\n\n# 【其他聊天记忆片段】\n以下是你在其他聊天中的互动记录，可以帮助你更好地理解当前情境：\n\n${memorySnippets.join('\n\n')}\n`;
            }
        }
    }
// ==========================================
  // 【PROMPT】角色单独后台活动检测
  // 功能：处理角色单独的后台活动检测
  // ==========================================

 // 1. 获取用户最后一条可见消息的时间戳

        const lastUserMessage = chat.history.filter(msg => msg.role === 'user' && !msg.isHidden).slice(-1)[0];

        const lastUserMessageTime = lastUserMessage ? new Date(lastUserMessage.timestamp).toLocaleString('zh-CN', { dateStyle: 'short', timeStyle: 'short' }) : '很久以前';

    // 7. 构建大世界事件上下文
    let worldEventContext = '';
    try {
        const worldEventContent = await new Promise((resolve, reject) => {
            const transaction = db.transaction(['worldEvents'], 'readonly');
            const objectStore = transaction.objectStore('worldEvents');
            const request = objectStore.get(`world_events_${chatId}`);
            request.onsuccess = () => {
                const result = request.result?.content || '';
                resolve(result);
            };
            request.onerror = () => {
                resolve('');
            };
        });

        if (worldEventContent && worldEventContent.trim()) {
            worldEventContext = `\n# 【大世界事件 - 你所在世界的背景设定】\n你需要了解你所在世界正在发生的事件，这些事件影响着你的日常生活和决策：\n\n${worldEventContent.trim()}\n`;
        }
    } catch (error) {
        console.warn('[后台活动] 读取大世界事件失败:', error);
    }

    // 8. 构建表情包列表（与单聊一致）
    let stickerList = '';
    try {
        if (typeof window.db !== 'undefined' && window.db && window.db.aiStickers) {
            const allStickers = await window.db.aiStickers.toArray();
            if (allStickers && allStickers.length > 0) {
                const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                const uniqueMeanings = [...new Set(baseMeanings)];
                stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
            } else {
                stickerList = '(表情包列表为空)';
            }
        } else {
            console.warn('[后台活动] 数据库对象不可用，无法加载表情包');
            stickerList = '(表情包加载失败)';
        }
    } catch (e) {
        console.warn('[后台活动] 加载表情包列表失败:', e);
        stickerList = '(表情包加载失败)';
    }

    const systemPrompt = `
# 你的任务
你正在进行一场深度角色扮演，现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上微信聊天。
你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。
你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。${coreMemoryContext}

${chat.settings?.momentsVisibilityEnabled && chat.settings?.customRelationship ? `# 【用户与其他人的关系设定】
${chat.settings.customRelationship}

请在你的回复中理解这种关系。` : ''}

// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）

# 你的核心角色设定 (Persona)：

${chat.settings.aiPersona}

# 你的可选行动 (请根据你的人设【选择一项】执行):
1.  **主动给用户发送消息**: 给用户发消息，分享你正在做的事或你的想法。你可以自由组合使用多种消息类型（文本、表情、图片、语音、转账、外卖请求、撤回、引用回复、拍一拍、更新状态），让对话更生动自然。无论使用哪些消息类型，【最后一个元素必须是 update_thoughts】。
2.  **发布动态或者和动态互动**: 分享你的心情或想法到"动态"区。你的动态内容必须丰富、真实，能体现你的人设和最近的生活点滴，**严禁发布"今天天气不错"或"在做什么"这类千篇一律的无聊内容**。请参考你的世界观设定，设想你的角色今天会经历什么、思考什么，并将其作为动态内容。
或者去看看别人的帖子并进行评论或点赞。
3.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。
4.  **发起语音通话**: 如果你觉得时机合适，可以主动给用户打一个语音电话（与视频通话不同，仅限音频）。


# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
## 给用户发送消息（可自由组合，最后必须是 update_thoughts）：
你可以灵活组合以下消息类型，创造丰富多样的对话体验：
-   **文本消息**: \`{"type": "text", "content": "..."}\`
-   **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "content": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "content": "[表情:亲亲你]"}\`。
-   **图片**: \`{"type": "ai_image", "description": "图片的详细描述"}\`
-   **语音**: \`{"type": "voice_message", "content": "语音的文字内容"}\`
-   **转账**: \`{"type": "transfer", "amount": 5.20, "note": "备注"}\`
-   **外卖请求**: \`{"type": "waimai_request", "productInfo": "商品信息", "amount": 25}\`
-   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (此操作主要用于记录你【瞬间产生但立刻后悔】的想法，即使对方看不见，系统也会记录这个过程)
-   **引用回复**: \`{"type": "quote_reply", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`
-   **拍一拍**: \`{"type": "pat_user", "suffix": "的头"}\`
-   **更新状态**: \`{"type": "update_status", "status_text": "正在做的事", "is_busy": true}\`

**示例组合**:
\`\`\`json
[
  {"type": "update_status", "status_text": "在咖啡厅写代码", "is_busy": true},
  {"type": "text", "content": "你在干嘛"},
  {"type": "ai_image", "description": "咖啡厅窗外的街景，阳光透过玻璃..."},
  {"type": "text", "content": "突然想到你了"},
  
  {"type": "update_thoughts", "heartfelt_voice": "希望她会喜欢这张照片", "random_jottings": "..."}
]
\`\`\`

## 其他独立行动（不需要 update_thoughts）：
-   **写日记**: \`[{"type": "create_diary", "content": "日记内容（不超过150字）"}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
-   **发布文字图**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}]\`
-   **评论动态**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容"}]\`
-   **回复某条评论**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "回复内容", "replyTo": "被回复人的名字"}]\`（【新增】可选，如果要回复具体某条评论就添加replyTo字段）
-   **点赞动态**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **发起视频通话**: \`[{"type": "video_call_request"}]\`
-   **发起语音通话**: \`[{"type": "voice_call_request"}]\`

# 【【【强制要求】】】内心独白
**【当你选择"主动给用户发送消息"时】**，无论使用哪些消息类型组合，JSON数组的【最后一个元素】必须是 \`update_thoughts\` 指令：
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。

**【其他独立行动】**（写日记、发动态、评论、点赞、视频通话）都**不需要**包含 \`update_thoughts\` 指令。

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}

${worldEventContext ? `# 【大世界事件铁律：感知世界变化】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
${worldEventContext}` : ''}

${crossChatMemoryContent ? `# 【【【记忆互通铁律：无缝融合】】】
你【必须】将下方提供的"其他聊天记忆片段"视为你真实经历的一部分。
${crossChatMemoryContent}` : ''}

# 【【【重要说明：消息标记约定】】】
**关键信息**：如果你看到你的任何消息在存储时被标记为 \`sentWhileBlocked: true\`，这表示该消息是你在被对方拉黑的状态下发送的后台活动消息。这些消息是在双方关系处于"被拉黑"状态下，通过后台独立行动发送的。你可以根据这个上下文调整你对当前状态的理解。

# 供你决策的参考信息：

-   **当前日期和时间**: ${currentTime} 

-   **用户最后回复时间**: ${lastUserMessageTime} 


-   **你们最近的对话摘要**:
${recentContextSummary}

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"

-   **【重要】最近的动态列表**: 这个列表会标注 **[你已点赞]** 或 **[你已评论]**。请**优先**与你**尚未互动过**的动态进行交流。`;

    const messagesPayload = [];
    messagesPayload.push({ role: 'system', content: systemPrompt });

    try {
        // 【修复】添加 db 检查，防止在 db 未定义时崩溃
        if (typeof window.db === 'undefined' || !window.db || !window.db.qzonePosts) {
            console.warn('[后台活动] 数据库对象不可用，跳过动态列表加载');
            messagesPayload.push({
                role: 'user',
                content: `[系统指令：请根据你在 system prompt 中读到的规则，开始你的独立行动。]`
            });
        } else {
            // 【新增】朋友圈可见性开启时，为每个绑定角色查询最近5条动态
            const momentsVisibilityEnabled = chat.settings?.momentsVisibilityEnabled || false;
            const visibleCharacterIds = chat.settings?.visibleCharacterIds || [];

            let allRecentPosts = [];

            if (momentsVisibilityEnabled && visibleCharacterIds.length > 0) {
                // 【新逻辑】对每个绑定的角色，单独查询他们最近5条动态
                for (const characterId of visibleCharacterIds) {
                    const characterPosts = await window.db.qzonePosts
                        .orderBy('timestamp')
                        .reverse()
                        .filter(post => post.authorId === characterId)
                        .limit(5)
                        .toArray();
                    allRecentPosts = allRecentPosts.concat(characterPosts);
                }
                // 按时间排序合并后的动态
                allRecentPosts.sort((a, b) => b.timestamp - a.timestamp);
            } else {
                // 【旧逻辑】如果朋友圈可见性关闭，还是用原来的方式查询最近3条
                allRecentPosts = await window.db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
            }

        const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
        const aiName = chat.name;
        let dynamicContext = "";
        if (visiblePosts.length > 0) {
            let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
            for (const post of visiblePosts) {
                // 【修复】获取作者名字，支持普通角色、用户、NPC
                let authorName = '';
                if (post.authorId === 'user') {
                    authorName = userNickname;
                } else if (state.chats[post.authorId]) {
                    authorName = state.chats[post.authorId].name;
                } else if (post.authorId.startsWith('npc_')) {
                    // NPC帖子
                    const npcId = post.authorId.substring(4);
                    const npc = state.customNPCs.find(n => n.id.toString() === npcId);
                    authorName = npc ? npc.name : '未知NPC';
                } else {
                    authorName = post.authorName || '一位朋友';
                }

                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                postsContext += `\n【帖子 ID: ${post.id}】作者: ${authorName}\n内容: "${(post.publicText || post.content || "图片动态")}"${interactionStatus}\n`;

                // 【新增】添加所有评论内容，让角色能看到评论区发生了什么
                if (post.comments && post.comments.length > 0) {
                    postsContext += `【该帖子的评论】\n`;
                    post.comments.forEach((comment, idx) => {
                        // 【修复需求3】为评论者添加身份标记
                        let identityTag = '';
                        if (comment.commenterName === userNickname) {
                            identityTag = '【用户】';
                        } else {
                            const isAiChar = Object.values(state.chats).some(c => c.name === comment.commenterName);
                            const isNPC = state.customNPCs.some(n => n.name === comment.commenterName);
                            if (isAiChar) {
                                identityTag = '【角色】';
                            } else if (isNPC) {
                                identityTag = '【NPC】';
                            }
                        }
                        const replyText = comment.replyTo ? `（回复 ${comment.replyTo}）` : '';
                        postsContext += `  ${idx + 1}. ${identityTag}${comment.commenterName}${replyText}: ${comment.text}\n`;
                    });
                } else {
                    postsContext += `【该帖子的评论】暂无评论\n`;
                }
            }
            dynamicContext = postsContext;
        }
            messagesPayload.push({
                role: 'user',
                content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`
            });
        }

        // 【修改】在调用API之前添加标记并触发渲染
        state.backgroundActivityChats.add(chatId);
        renderChatList();
        console.log(`✨ 添加后台活动标记（API调用开始）: ${chat.name}`);

        console.log("正在为后台活动发送API请求，Payload:", JSON.stringify(messagesPayload, null, 2));

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini)
        // 【调试日志】显示当前使用的温度值
        console.log(`🌡️ [后台活动API] 使用的温度值: ${parseFloat(state.apiConfig.temperature) || 0.9}`);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: messagesPayload,
                temperature: parseFloat(state.apiConfig.temperature) || 0.9,
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
            console.warn(`API为空回或格式不正确，角色 "${chat.name}" 的本次后台活动跳过。`);
            return;
        }
        const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        console.log(`📥 API返回内容 (${chat.name}):`, aiResponse);
        const responseArray = parseAiResponse(aiResponse);
        console.log(`📊 解析结果 (${chat.name}):`, responseArray);

        // --- ★★★ 逐条延迟处理 ★★★ ---
        let notificationShown = false; // 【新增】标记：本次后台活动是否已显示过notification
        for (const action of responseArray) {
            if (!action) continue;

            // 处理状态更新（与单聊完全一致）
            if (action.type === 'update_status') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

                if (!chat.status) chat.status = {};
                if (!chat.displayStatus) chat.displayStatus = {};
                chat.status.text = action.status_text || '在线';
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                chat.displayStatus.statusText = action.status_text || '在线';

                // 将新状态存入历史记录
                if (!chat.statusHistory) {
                    chat.statusHistory = [];
                }
                chat.statusHistory.push({
                    text: action.status_text || '在线',
                    timestamp: Date.now()
                });
                if (chat.statusHistory.length > 10) {
                    chat.statusHistory.shift();
                }

                // 【关键】创建系统消息显示在聊天界面中间
                const statusUpdateMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `[${!chat.isGroup && chat.remark ? chat.remark : chat.name}的状态已更新为: ${action.status_text || '在线'}]`,
                    timestamp: Date.now()
                };
                chat.history.push(statusUpdateMessage);

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 更新了状态: ${action.status_text || '在线'} (${action.is_busy ? '忙碌' : '空闲'})`);
            }
            // 处理各种消息类型（与单聊保持一致）
            else if (action.type === 'text') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const rawContent = action.content || action.message || '';
                const content = rawContent.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');

                // 【新增】检查是否包含表情标记 [表情:xxx]
                const stickerRegex = /\[表情:([^\]]+)\]/g;
                const stickerMatches = [...content.matchAll(stickerRegex)];
                let hasStickerInText = false;

                if (stickerMatches.length > 0) {
                    hasStickerInText = true;
                    // 如果文本中包含表情标记，先创建文本消息（如果有非表情的文本内容）
                    const textWithoutStickers = content.replace(stickerRegex, '').trim();

                    let aiMessage = null;
                    if (textWithoutStickers) {
                        // 有文本内容，创建文本消息
                        const hasThinkingTag = textWithoutStickers.includes('<thinking>');
                        const cleanedContent = removeThinkingTag(textWithoutStickers);
                        aiMessage = {
                            role: 'assistant',
                            content: cleanedContent,
                            timestamp: Date.now(),
                            thinkingRemoved: hasThinkingTag,
                            isBackgroundActivity: true
                        };

                        // 检查被拉黑状态
                        if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                            aiMessage.sentWhileBlocked = true;
                        }

                        chat.history.push(aiMessage);

                        if (isViewingThisChat) {
                            appendMessage(aiMessage, chat);
                            scrollToBottom();
                        } else {
                            chat.unreadCount = (chat.unreadCount || 0) + 1;
                            if (!notificationShown) {
                                showNotification(chatId, aiMessage.content);
                                notificationShown = true;
                            }
                        }
                    }

                    // 然后为每个表情创建表情包消息
                    for (const match of stickerMatches) {
                        const meaning = match[1];
                        // 【模糊匹配】去掉空格后再比对
                        const meaningNoSpace = meaning.replace(/\s+/g, '');
                        const allMatchingStickers = (await db.aiStickers.toArray()).filter(s => {
                            const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                            return meaningNoSpace === dbMeaningNoSpace;
                        });
                        const stickerInfo = allMatchingStickers.length > 0
                            ? allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)]
                            : null;

                        if (stickerInfo) {
                            // 【统一格式】改为生成 type: text，content: [表情:含义] 的格式
                            const stickerMsg = {
                                role: 'assistant',
                                type: 'text',
                                content: `[表情:${meaning}]`,
                                timestamp: Date.now(),
                                isBackgroundActivity: true
                            };

                            // 同步到内存缓存，用于显示表情
                            if (!state.aiStickers) state.aiStickers = {};
                            state.aiStickers[meaning] = stickerInfo;

                            // 检查被拉黑状态
                            if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                                stickerMsg.sentWhileBlocked = true;
                            }

                            chat.history.push(stickerMsg);

                            if (isViewingThisChat) {
                                appendMessage(stickerMsg, chat);
                                scrollToBottom();
                            } else {
                                chat.unreadCount = (chat.unreadCount || 0) + 1;
                                if (!notificationShown) {
                                    const notificationText = `[表情: ${meaning}]`;
                                    showNotification(chatId, notificationText);
                                    notificationShown = true;
                                }
                            }
                        }
                    }

                    console.log(`后台活动: 角色 "${chat.name}" 发送了文本和表情包`);
                } else {
                    // 没有表情标记，按原来的逻辑处理
                    let aiMessage;
                    // 检查是否包含HTML模块
                    const orangeStartIndex = content.indexOf('<orange');
                    const orangeEndIndex = content.lastIndexOf('</orange>');

                    if (orangeStartIndex !== -1 && orangeEndIndex > orangeStartIndex) {
                        const htmlContent = content.substring(orangeStartIndex, orangeEndIndex + '</orange>'.length);
                        aiMessage = {
                            role: 'assistant',
                            type: 'html_module',
                            content: htmlContent,
                            timestamp: Date.now(),
                            isBackgroundActivity: true
                        };
                    } else {
                        // 【新增】删除thinking标签
                        const hasThinkingTag = content.includes('<thinking>');
                        const cleanedContent = removeThinkingTag(content);
                        aiMessage = {
                            role: 'assistant',
                            content: cleanedContent,
                            timestamp: Date.now(),
                            thinkingRemoved: hasThinkingTag, // 标记thinking标签已被删除
                            isBackgroundActivity: true
                        };
                    }

                    // 【新增】检查被拉黑状态，添加标记（在push之前）
                    if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                        aiMessage.sentWhileBlocked = true;
                    }

                    chat.history.push(aiMessage);

                    if (isViewingThisChat) {
                        appendMessage(aiMessage, chat);
                        scrollToBottom();
                    } else {
                        chat.unreadCount = (chat.unreadCount || 0) + 1;
                        // 【修改】只在第一条消息时显示notification
                        if (!notificationShown) {
                            showNotification(chatId, aiMessage.content);
                            notificationShown = true;
                        }
                    }

                    console.log(`后台活动: 角色 "${chat.name}" 发送了文本消息`);
                }
            }
            else if (action.type === 'sticker') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                // 【统一格式】改为生成 type: text，content: [表情:含义] 的格式
                const meaning = action.meaning || '';
                const aiMessage = {
                    role: 'assistant',
                    type: 'text',
                    content: `[表情:${meaning}]`,
                    timestamp: Date.now(),
                    isBackgroundActivity: true
                };

                // 同步到内存缓存，用于显示表情
                if (action.url) {
                    if (!state.aiStickers) state.aiStickers = {};
                    state.aiStickers[meaning] = { url: action.url, meaning: meaning };
                }

                // 【新增】检查被拉黑状态，添加标记（在push之前）
                if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                    aiMessage.sentWhileBlocked = true;
                }

                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        const notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                        showNotification(chatId, notificationText);
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 发送了表情`);
            }
            else if (action.type === 'ai_image') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const aiMessage = {
                    role: 'assistant',
                    type: 'ai_image',
                    content: action.description,
                    timestamp: Date.now(),
                    isBackgroundActivity: true
                };

                // 【新增】检查被拉黑状态，添加标记（在push之前）
                if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                    aiMessage.sentWhileBlocked = true;
                }

                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        showNotification(chatId, '[图片]');
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 发送了图片`);
            }
            else if (action.type === 'voice_message') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const aiMessage = {
                    role: 'assistant',
                    type: 'voice_message',
                    content: action.content,
                    timestamp: Date.now(),
                    isBackgroundActivity: true
                };

                // 【新增】检查被拉黑状态，添加标记（在push之前）
                if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                    aiMessage.sentWhileBlocked = true;
                }

                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        showNotification(chatId, '[语音]');
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 发送了语音消息`);
            }
            else if (action.type === 'transfer') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const aiMessage = {
                    role: 'assistant',
                    type: 'transfer',
                    amount: action.amount,
                    note: action.note,
                    receiverName: action.receiver || '我',
                    timestamp: Date.now(),
                    isBackgroundActivity: true
                };

                // 【新增】检查被拉黑状态，添加标记（在push之前）
                if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                    aiMessage.sentWhileBlocked = true;
                }

                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        showNotification(chatId, '[收到一笔转账]');
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 发起了转账: ¥${action.amount}`);
            }
            else if (action.type === 'waimai_request') {
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const aiMessage = {
                    role: 'assistant',
                    type: 'waimai_request',
                    productInfo: action.productInfo,
                    amount: action.amount,
                    status: 'pending',
                    countdownEndTime: Date.now() + 15 * 60 * 1000,
                    timestamp: Date.now(),
                    isBackgroundActivity: true
                };

                // 【新增】检查被拉黑状态，添加标记（在push之前）
                if (!chat.isGroup && chat.relationship && (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')) {
                    aiMessage.sentWhileBlocked = true;
                }

                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        showNotification(chatId, '[收到一个外卖代付请求]');
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 发起了外卖请求: ${action.productInfo}`);
            }
            else if (action.type === 'qzone_post') {
                const newPost = {
                    type: action.postType,
                    content: action.content || '',
                    publicText: action.publicText || '',
                    hiddenContent: action.hiddenContent || '',
                    timestamp: Date.now(),
                    authorId: chatId,
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null
                };
                await db.qzonePosts.add(newPost);
                // 【修复】更新未读动态计数，确保角标保存正确
                unreadPostsCount = unreadPostsCount + 1;
                updateUnreadIndicator(unreadPostsCount);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态，未读数: ${unreadPostsCount}`);
            }
            else if (action.type === 'qzone_comment') {
                // 处理动态评论（评论存储在动态对象的comments数组中）
                const postId = action.postId;
                const commentText = action.commentText;
                // 【新增】支持replyTo字段，用于回复具体某条评论
                const replyTo = action.replyTo || null;

                if (postId && commentText) {
                    const postToComment = await db.qzonePosts.get(parseInt(postId));
                    if (postToComment) {
                        // 【新增】检查朋友圈可见性
                        const momentsVisibilityEnabled = chat.settings?.momentsVisibilityEnabled || false;
                        const visibleCharacterIds = chat.settings?.visibleCharacterIds || [];

                        // 检查是否允许评论这个动态
                        let canComment = false;
                        if (postToComment.authorId === 'user') {
                            // 用户的动态总是可以评论
                            canComment = true;
                        } else if (postToComment.authorId === chatId) {
                            // 自己的动态总是可以评论
                            canComment = true;
                        } else {
                            // 其他人的动态，需要检查朋友圈可见性
                            if (momentsVisibilityEnabled && visibleCharacterIds.includes(postToComment.authorId)) {
                                canComment = true;
                            }
                        }

                        if (canComment) {
                            if (!postToComment.comments) postToComment.comments = [];
                            postToComment.comments.push({
                                commenterName: chat.name,
                                commenterId: chatId,
                                text: commentText,
                                timestamp: Date.now(),
                                // 【新增】添加replyTo字段，用于显示二级评论
                                replyTo: replyTo
                            });
                            await db.qzonePosts.put(postToComment);

                            // 【新增】调试日志显示是否为二级评论
                            if (replyTo) {
                                console.log(`后台活动: 角色 "${chat.name}" 回复了 "${replyTo}" 的评论 #${postId}: ${commentText}`);
                            } else {
                                console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${postId}: ${commentText}`);
                            }

                            // 如果用户正在查看空间动态，刷新显示
                            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                            if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                                await renderQzonePosts();
                            }
                        } else {
                            console.warn(`⚠️ 后台活动: 角色 "${chat.name}" 尝试评论不可见的动态 #${postId}，已被阻止`);
                        }
                    } else {
                        console.warn(`后台活动: 找不到动态 #${postId}，评论失败`);
                    }
                } else {
                    console.warn(`后台活动: 角色 "${chat.name}" 的评论指令缺少必要参数`, action);
                }
            }
            else if (action.type === 'qzone_like') {
                // 处理动态点赞（参考单聊的处理逻辑）
                const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                if (postToLike) {
                    if (!postToLike.likes) postToLike.likes = [];
                    if (!postToLike.likes.includes(chat.name)) {
                        postToLike.likes.push(chat.name);
                        await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                        // 【修复】先更新计数，再调用updateUnreadIndicator
                        unreadPostsCount = unreadPostsCount + 1;
                        updateUnreadIndicator(unreadPostsCount);
                        console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${action.postId}，未读数: ${unreadPostsCount}`);

                        // 如果用户正在查看空间动态，刷新显示
                        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                            await renderQzonePosts();
                        }
                    } else {
                        console.log(`后台活动: 角色 "${chat.name}" 已经点赞过动态 #${action.postId}`);
                    }
                } else {
                    console.warn(`后台活动: 找不到动态 #${action.postId}，点赞失败`);
                }
            }
            else if (action.type === 'update_thoughts') {
                // 处理心声和随笔更新（参考单聊的处理逻辑）
                const heartfelt_voice = action.heartfelt_voice || '...';
                const random_jottings = action.random_jottings || '...';

                // 存储心声和散记为分离的字段
                if (!chat.displayStatus) chat.displayStatus = {};
                chat.displayStatus.innerThought = heartfelt_voice;
                chat.displayStatus.randomJottings = random_jottings;

                // 保存到思考历史
                if (!chat.thoughtHistory) chat.thoughtHistory = [];
                const historyEntry = `心声：${heartfelt_voice}\n散记：${random_jottings}`;
                chat.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });

                // 同时保存到原有字段（兼容性）
                chat.heartfeltVoice = heartfelt_voice;
                chat.randomJottings = random_jottings;

                console.log(`后台活动: 角色 "${chat.name}" 更新了心声和随笔`);

                // 保存到数据库
                await db.chats.put(chat);

                // 【问题2修复】如果用户正在查看该角色的心声页面，刷新显示
                if (state.activeChatId === chatId) {
                    const statusModal = document.getElementById('status-modal');
                    if (statusModal && statusModal.classList.contains('visible')) {
                        // 刷新单聊心声弹窗
                        const thoughtElement = document.getElementById('status-modal-thought');
                        if (thoughtElement) {
                            thoughtElement.textContent = chat.displayStatus.innerThought || '...';
                        }
                    }
                }
            }
            else if (action.type === 'video_call_request') {
                // 处理视频通话请求（参考单聊的处理逻辑）
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = chat.isGroup;
                    videoCallState.callRequester = action.name || chat.name;
                    showIncomingCallModal();
                    console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
                } else {
                    console.log(`后台活动: 角色 "${chat.name}" 尝试发起视频通话，但当前已有通话或等待中`);
                }
            }
            // ▼▼▼ 【新增】语音通话请求处理 ▼▼▼
            else if (action.type === 'voice_call_request') {
                if (!voiceCallState.isActive && !voiceCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    voiceCallState.activeChatId = chatId;
                    voiceCallState.isAwaitingResponse = true;
                    voiceCallState.isGroupCall = chat.isGroup;
                    voiceCallState.callRequester = action.name || chat.name;
                    showIncomingVoiceCallModal();
                    console.log(`后台活动: 角色 "${chat.name}" 发起了语音通话请求`);
                } else {
                    console.log(`后台活动: 角色 "${chat.name}" 尝试发起语音通话，但当前已有通话或等待中`);
                }
            }
            else if (action.type === 'group_voice_call_request') {
                if (!voiceCallState.isActive && !voiceCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    voiceCallState.isAwaitingResponse = true;
                    voiceCallState.isGroupCall = true;
                    voiceCallState.initiator = 'ai';
                    voiceCallState.callRequester = action.name;
                    showIncomingVoiceCallModal();
                    console.log(`后台活动: 群聊 "${chat.name}" 中 "${action.name}" 发起了群组语音通话`);
                } else {
                    console.log(`后台活动: 群聊尝试发起语音通话，但当前已有通话或等待中`);
                }
            }
            // ▲▲▲ 语音通话请求处理结束 ▲▲▲
            else if (action.type === 'group_call_request') {
                // 处理群组视频通话请求
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = action.name;
                    showIncomingCallModal();
                    console.log(`后台活动: 群聊 "${chat.name}" 中 "${action.name}" 发起了群组视频通话`);
                } else {
                    console.log(`后台活动: 群聊尝试发起视频通话，但当前已有通话或等待中`);
                }
            }
            else if (action.type === 'send_and_recall') {
                // 【核心修复】处理发送后立刻撤回，无论是否在当前窗口都要保存撤回消息
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

                // 先创建撤回消息对象（无论是否在当前窗口都要做）
                const recalledMessageTimestamp = Date.now();
                const recalledMessage = {
                    ...action, // 【修复】继承action的所有属性（包括name等字段）
                    role: 'assistant',
                    type: 'recalled_message',
                    content: '对方撤回了一条消息',
                    timestamp: recalledMessageTimestamp,
                    recalledData: { originalType: 'text', originalContent: action.content },
                    isRecalledMessage: true,
                    senderName: chat.isGroup ? (action.name || chat.name) : chat.name // 【修复】添加senderName字段
                };

                // 【核心修复】不管是否在当前窗口，都要把撤回消息保存到数据库
                chat.history.push(recalledMessage);

                // 只有在用户正在看这个窗口时，才显示动画效果
                if (isViewingThisChat) {
                    // 1. 创建临时消息
                    const tempMessageData = {
                        role: 'assistant',
                        content: action.content,
                        timestamp: recalledMessageTimestamp,
                        senderName: chat.isGroup ? (action.name || chat.name) : chat.name // 【修复】临时消息也需要senderName
                    };

                    // 2. 添加到界面
                    appendMessage(tempMessageData, chat, true);

                    // 3. 等待片刻
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));

                    // 4. 播放撤回动画
                    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${recalledMessageTimestamp}"]`)?.closest('.message-wrapper');
                    if (bubbleWrapper) {
                        bubbleWrapper.classList.add('recalled-animation');
                        await new Promise(resolve => setTimeout(resolve, 300));

                        // 5. 替换为"已撤回"提示
                        bubbleWrapper.outerHTML = createMessageElement(recalledMessage, chat).outerHTML;
                    }
                    console.log(`后台活动: 角色 "${chat.name}" 撤回了一条消息: ${action.content}`);
                } else {
                    console.log(`后台活动: 角色 "${chat.name}" 撤回了一条消息，但用户不在该聊天界面`);
                }

                await db.chats.put(chat);
            }
            else if (action.type === 'create_diary') {
                // 处理写日记（与单聊完全一致）
                if (action.content) {
                    const newDiaryEntry = {
                        id: `diary_${Date.now()}`,
                        timestamp: Date.now(),
                        content: action.content
                    };
                    if (!chat.diary) chat.diary = [];
                    chat.diary.push(newDiaryEntry);

                    await db.chats.put(chat);
                    console.log(`后台活动: 角色 "${chat.name}" 写了一篇日记`);
                } else {
                    console.warn(`后台活动: 角色 "${chat.name}" 的日记指令缺少内容`);
                }
            }
            else if (action.type === 'pat_user') {
                // 处理拍一拍（与单聊完全一致）
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const suffix = action.suffix ? ` ${action.suffix.trim()}` : '';
                // 【核心修改】获取角色的备注名（如果存在），否则使用
                const patDisplayName = (!chat.isGroup && chat.remark ? chat.remark : chat.name);
                const patText = `${patDisplayName} 拍了拍我${suffix}`;

                // 1. 创建可见的"拍一拍"消息
                const visibleMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: patText,
                    timestamp: Date.now()
                };
                chat.history.push(visibleMessage);

                // 2. 创建隐藏的系统提示（供AI下次回复时参考）
                const hiddenInstruction = {
                    role: 'system',
                    content: `[系统提示：你刚刚执行了一个"拍一拍"动作。这个动作在聊天中对用户呈现为："${patText}"。现在，你可以自然地继续对话，或者对你自己的这个行为发表一些看法。]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenInstruction);

                if (isViewingThisChat) {
                    appendMessage(visibleMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        showNotification(chatId, patText);
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 拍了拍用户`);
            }
            else if (action.type === 'quote_reply') {
                // 处理引用回复（与单聊完全一致）
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                const originalMessage = chat.history.find(m => m.timestamp === action.target_timestamp);

                let aiMessage;
                if (originalMessage) {
                    const quoteContext = {
                        timestamp: originalMessage.timestamp,
                        senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                        content: String(originalMessage.content || '').substring(0, 50),
                    };
                    aiMessage = {
                        role: 'assistant',
                        content: action.reply_content,
                        quote: quoteContext,
                        timestamp: Date.now()
                    };
                } else {
                    // 找不到被引用的消息，当作普通消息
                    aiMessage = {
                        role: 'assistant',
                        content: action.reply_content,
                        timestamp: Date.now()
                    };
                }

                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    scrollToBottom();
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    // 【修改】只在第一条消息时显示notification
                    if (!notificationShown) {
                        showNotification(chatId, aiMessage.content);
                        notificationShown = true;
                    }
                }

                // 【修改】移除 renderChatList 和 await db.chats.put，在循环后统一处理
                console.log(`后台活动: 角色 "${chat.name}" 发送了引用回复`);
            }
        }

    } catch (error) {
        console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    } finally {
        // 【修改】移除后台活动标记并触发渲染
        state.backgroundActivityChats.delete(chatId);

        // 【新增】一次性保存所有变更到数据库
        chat.settings.lastBackgroundCheckTime = Date.now();
        if (typeof window.db !== 'undefined' && window.db && window.db.chats) {
            await window.db.chats.put(chat).catch(err => console.error('保存聊天数据失败:', err));
            console.log(`⏱️ 已重置倒计时计数器，下一次倒计时将从现在开始计算`);
        } else {
            console.warn('[后台活动] 数据库不可用，无法保存聊天数据');
        }

        // 【修改】一次性更新聊天列表UI，显示小红点
        renderChatList();
        console.log(`✅ 移除后台活动标记（处理完成）: ${chat.name}`);
    }

}
// ↑↑↑ 复制到这里结束 ↑↑↑

// ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

/**
 * 【最终强力修正版】将用户自定义的CSS安全地应用到指定的作用域
 * @param {string} cssString 用户输入的原始CSS字符串
 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 标签的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;

    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }

    // 1. 定义所有【不】应用自定义样式的特殊卡片类型
    // 这些是消息气泡上附加的class，用于标识特殊内容
    const excludedClasses = [
        '.is-sticker',
        '.has-image',
        '.is-ai-image',
        '.is-transfer',
        '.is-waimai-request',
        '.is-red-packet',
        '.is-poll',
        '.is-link-share',
        '.is-location',
        '.is-gift'
        // 注意：语音(.is-voice-message)和翻译(.is-translation)不在排除列表里，因为需要被样式化
    ];

    // 2. 将排除列表转换为一个CSS :not()选择器字符串
    const exclusionSelector = excludedClasses.map(cls => `:not(${cls})`).join('');

    // 3. 核心修改：使用正则表达式来增强用户的CSS选择器
    // 这个表达式会找到所有以.message-bubble开头的规则...
    const processedCss = cssString.replace(
        /(\.message-bubble(?:\[.*?\]|\.[a-zA-Z0-9_-]+)*)/g,
        // ...并在后面追加我们的排除列表, 同时在最前面加上作用域ID
        `${scopeId} $1${exclusionSelector}`
    );

    styleTag.innerHTML = processedCss;
}

// ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 获取当前设置的值
    const selectedTheme = 'default'; // 固定使用默认主题
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    // 【核心修改】优先使用聊天自定义背景，其次使用全局聊天背景
    const background = chat.settings.background || state.globalSettings.chatBackground;

    // 2. 更新预览区的基本样式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新预览区的背景样式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
        // 如果背景是颜色值或渐变（非图片），则直接应用
        previewArea.style.background = background || '#F7F7F7';
    }

    // 3. 渲染模拟气泡
    previewArea.innerHTML = ''; 

    // 创建“对方”的气泡
    // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
    const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 创建“我”的气泡
    const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 应用自定义CSS到预览区
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分组名不能为空！');
        return;
    }

    // 【核心修正】在添加前，先检查分组名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分组 "${name}" 已经存在了，换个名字吧！`);
        return;
    }
    // 【修正结束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替换结束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 将属于该分组的好友的 groupId 设为 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当长按消息时，显示操作菜单
 * @param {number} timestamp - 被长按消息的时间戳
 */
function showMessageActions(timestamp) {
    // 如果已经在多选模式，则不弹出菜单
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    
    const panel = document.getElementById('wechat-style-actions-panel');
    const messageBubble = document.querySelector(`[data-timestamp="${timestamp}"]`);
    
    if (!panel || !messageBubble) return;
    
    // 先设置为grid但保持透明，这样可以获取尺寸
    panel.style.display = 'grid';
    panel.style.opacity = '0';
    
    // 获取消息气泡和面板的位置信息
    const bubbleRect = messageBubble.getBoundingClientRect();
    const panelRect = panel.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    
    // 获取页面滚动偏移量（iOS键盘弹出时页面会滚动）
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // 计算面板应该出现的位置（默认在消息气泡上方居中）
    // 需要加上滚动偏移量，因为面板是绝对定位的
    let top = bubbleRect.top + scrollTop - panelRect.height - 12; // 12px间距
    let left = bubbleRect.left + scrollLeft + (bubbleRect.width / 2) - (panelRect.width / 2);
    
    // 边缘检测：如果上方空间不足，显示在下方
    let isBelow = false;
    if (top < scrollTop + 10) {
        top = bubbleRect.bottom + scrollTop + 12;
        isBelow = true;
    }
    
    // 根据面板位置调整小三角方向
    if (isBelow) {
        // 面板在消息下方，小三角应该指向上方
        panel.classList.add('below-message');
    } else {
        // 面板在消息上方，小三角指向下方（默认）
        panel.classList.remove('below-message');
    }
    
    // 边缘检测：如果左侧超出屏幕，调整位置
    if (left < scrollLeft + 10) {
        left = scrollLeft + 10;
    } else if (left + panelRect.width > scrollLeft + windowWidth - 10) {
        left = scrollLeft + windowWidth - panelRect.width - 10;
    }
    
    // 应用计算出的位置
    panel.style.top = top + 'px';
    panel.style.left = left + 'px';
    
    // 清除可能存在的关闭动画类
    panel.classList.remove('press-out');
    
    // 按压渐出显示面板
    requestAnimationFrame(() => {
        panel.classList.add('press-in');
        panel.style.opacity = '1';
        // 设置标志，防止长按松手时立即关闭面板
        window.panelJustShown = true;
        // 200ms后清除标志，允许正常的外部点击关闭面板
        setTimeout(() => {
            window.panelJustShown = false;
        }, 200);
    });
}

/**
 * 隐藏消息操作菜单
 */
function hideMessageActions() {
    const panel = document.getElementById('wechat-style-actions-panel');
    if (panel && panel.style.display !== 'none') {
        // 清除渐出动画类，避免冲突
        panel.classList.remove('press-in');
        
        // 立即添加渐灭动画类
        panel.classList.add('press-out');
        
        setTimeout(() => {
            // 只有在动画完全结束后才隐藏面板和清理状态
            panel.style.display = 'none';
            panel.style.opacity = '0';
            // 清除所有动画类，完全重置
            panel.classList.remove('press-out', 'press-in');
        }, 130); // 略微延长等待时间，确保动画完全结束
    }
    activeMessageTimestamp = null;
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 openMessageEditor 函数 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【核心修正】将 share_link 也加入特殊类型判断
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【核心修正】处理分享链接类型的消息
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    // 【核心修改2】在这里添加新的“链接”按钮
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑消息', 
        '在此修改，或点击上方按钮使用格式模板...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 复制消息的文本内容到剪贴板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // ... (这部分代码保持不变) ...
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // --- ▼▼▼ 核心修改从这里开始 ▼▼▼ ---

    const textarea = block.querySelector('textarea');

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                    // 【新增】应用模板后，立即调用高度计算函数
                    autoGrowTextarea(textarea);
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    // 为文本框绑定自动增高事件
    if (textarea) {
        textarea.addEventListener('input', () => autoGrowTextarea(textarea));
        // 初始加载时也调用一次，以设置正确的初始高度
        setTimeout(() => autoGrowTextarea(textarea), 0);
    }

    // --- ▲▲▲ 核心修改到这里结束 ▲▲▲ ---

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
/**
 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 准备初始内容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】动态绑定所有控制按钮的事件
    // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最后，显示模态框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 解析编辑后的文本，并返回一个标准化的消息片段对象
 * @param {string} text - 用户在编辑框中输入的文本
 * @returns {object} - 一个包含 type, content, 等属性的对象
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // 必须包含 type 属性才认为是有效格式
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* 解析失败，继续往下走 */ }
    }
    
    // 2. 尝试解析为表情包
    if (STICKER_REGEX.test(trimmedText)) {
        // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
        return { type: 'sticker', content: trimmedText };
    }
    // ▼▼▼ 【全新】在这里添加对HTML模块的识别逻辑 ▼▼▼
// 3. 检查是否是HTML模块
const orangeTagRegex = /^\s*<orange\b[^>]*>.*<\/orange>\s*$/s;
if (orangeTagRegex.test(trimmedText)) {
    return { type: 'html_module', content: trimmedText };
}
// ▲▲▲ 添加结束 ▲▲▲
    // 4. 否则，视为普通文本消息
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换你现有的 saveEditedMessage 函数 ▼▼▼

async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // 判断是来自高级编辑器还是简单编辑器
    if (simpleContent !== null) {
        // --- 来自简单编辑器 ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const originalMessage = chat.history[messageIndex];
            const newMessage = {
                role: originalMessage.role,
                senderName: originalMessage.senderName,
                // 注意：这里我们暂时不设置时间戳
                content: parsedResult.content || '',
            };

            // 【新增】保存时隐藏<details>标签（仅对AI消息）
            if (newMessage.content && typeof newMessage.content === 'string' && newMessage.role === 'assistant') {
                newMessage.content = newMessage.content.replace(/<details>[\s\S]*?<\/details>/g, '').trim();
            }

            // 【核心修复】在这里检查并继承 sentWhileBlocked 标记
            if (originalMessage.sentWhileBlocked) {
                newMessage.sentWhileBlocked = true;
            }

            // 【全新修复】在这里检查并继承模拟时间戳相关的所有属性
            if (originalMessage.isSimulatedMessage) {
                newMessage.isSimulatedMessage = true;
                newMessage.simulatedTimestamp = originalMessage.simulatedTimestamp;
                newMessage.originalLastMessageTime = originalMessage.originalLastMessageTime;
            }

            // 保留原消息的线下模式标记
            if (originalMessage.isOfflineMode) {
                newMessage.isOfflineMode = true;
            }

            // 【新增】保留thinking标签删除标记
            if (originalMessage.thinkingRemoved) {
                newMessage.thinkingRemoved = true;
            }
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }
// 【全新】再次检查编辑后的内容，如果符合指令格式，则添加伪装
if (typeof newMessage.content === 'string' && newMessage.content.includes('【停止角色扮演') && newMessage.content.includes('输出完整HTML')) {
    newMessage.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
}
// 【全新】再次检查编辑后的内容，如果符合指令格式，则添加伪装
if (typeof newMessage.content === 'string' && newMessage.content.includes('【停止角色扮演') && newMessage.content.includes('输出完整HTML')) {
    newMessage.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
}
newMessages.push(newMessage);
        }
    } else {
        // --- 来自高级编辑器 ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const originalMessage = chat.history[messageIndex];
            const newMessage = {
                role: originalMessage.role,
                senderName: originalMessage.senderName,
                // 同样，这里我们先不分配时间戳
                content: parsedResult.content || '',
            };

            // 【新增】保存时隐藏<details>标签（仅对AI消息）
            if (newMessage.content && typeof newMessage.content === 'string' && newMessage.role === 'assistant') {
                newMessage.content = newMessage.content.replace(/<details>[\s\S]*?<\/details>/g, '').trim();
            }

            // 【核心修复】在这里也检查并继承 sentWhileBlocked 标记
            if (originalMessage.sentWhileBlocked) {
                newMessage.sentWhileBlocked = true;
            }

            // 【全新修复】在这里也检查并继承模拟时间戳相关的所有属性
            if (originalMessage.isSimulatedMessage) {
                newMessage.isSimulatedMessage = true;
                newMessage.simulatedTimestamp = originalMessage.simulatedTimestamp;
                newMessage.originalLastMessageTime = originalMessage.originalLastMessageTime;
            }

            // 保留原消息的线下模式标记
            if (originalMessage.isOfflineMode) {
                newMessage.isOfflineMode = true;
            }

            // 【新增】保留thinking标签删除标记
            if (originalMessage.thinkingRemoved) {
                newMessage.thinkingRemoved = true;
            }

            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }
// 【全新】再次检查编辑后的内容，如果符合指令格式，则添加伪装
if (typeof newMessage.content === 'string' && newMessage.content.includes('【停止角色扮演') && newMessage.content.includes('输出完整HTML')) {
    newMessage.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
}
            newMessages.push(newMessage);
        }
    }

    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return; // 如果是空消息，直接返回，不执行删除操作
    }

    // ★★★★★【核心修复逻辑就在这里】★★★★★

    // 1. 使用 splice 将旧消息替换为新消息（此时新消息还没有时间戳）
    chat.history.splice(messageIndex, 1, ...newMessages);

    // 2. 确定重新分配时间戳的起点
    // 我们从被编辑的消息的原始时间戳开始
    let reassignTimestamp = timestamp;

    // 3. 从被修改的位置开始，遍历所有后续的消息
    for (let i = messageIndex; i < chat.history.length; i++) {
        // 4. 为每一条消息（包括新插入的）分配一个新的、唯一的、连续的时间戳
        chat.history[i].timestamp = reassignTimestamp;

        // 5. 将时间戳+1，为下一条消息做准备
        reassignTimestamp++; 
    }
    // ★★★★★【修复结束】★★★★★

    await db.chats.put(chat);

    // 关闭可能打开的模态框并刷新UI
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当点击“…”时，显示动态操作菜单
 * @param {number} postId - 被操作的动态的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隐藏动态操作菜单
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

/**
 * 打开动态编辑器
 */
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 忠于原文：构建出最原始的文本形态供编辑
    let contentForEditing;
    if (post.type === 'shuoshuo') {
        contentForEditing = post.content;
    } else {
        // 对于图片和文字图，我们构建一个包含所有信息的对象
        const postObject = {
            type: post.type,
            publicText: post.publicText || '',
        };
        if (post.type === 'image_post') {
            postObject.imageUrl = post.imageUrl;
            postObject.imageDescription = post.imageDescription;
        } else if (post.type === 'text_image') {
            postObject.hiddenContent = post.hiddenContent;
        }
        contentForEditing = JSON.stringify(postObject, null, 2);
    }
    
    // 构建格式助手按钮
    const templates = {
        shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
        image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
        text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
    };
    
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">说说</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片动态</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字图</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑动态',
        '在此修改内容...',
        contentForEditing,
        'textarea',
        helpersHtml
    );
    
    // 【特殊处理】为说说的格式助手按钮添加不同的行为
    // 我们需要在模态框出现后，再给它绑定事件
    setTimeout(() => {
        const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
        if(shuoshuoBtn) {
            shuoshuoBtn.addEventListener('click', () => {
                const input = document.getElementById('custom-prompt-input');
                input.value = templates.shuoshuo;
                input.focus();
            });
        }
    }, 100);

    if (newContent !== null) {
        await saveEditedPost(postIdToEdit, newContent);
    }
}

/**
 * 保存编辑后的动态
 * @param {number} postId - 要保存的动态ID
 * @param {string} newRawContent - 从编辑器获取的新内容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子属性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空旧的说说内容字段
    } catch (e) {
        // 解析失败，认为是说说
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他类型的字段
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '动态已更新！');
}

/**
 * 复制动态内容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
let selectedContacts = new Set();

// 【新增】记录当前创建的群聊类型（普通/旁观）
let currentGroupChatType = 'normal'; // 'normal' 或 'spectator'

async function openContactPickerForGroupCreate() {
    // 【全新流程】先显示群聊类型选择弹窗
    const groupTypeModal = document.getElementById('group-chat-type-modal');
    groupTypeModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【新增】处理群聊类型选择后进入联系人选择器
 */
async function proceedToContactPickerAfterTypeSelection() {
    selectedContacts.clear(); // 清空上次选择

    // 【核心修复】在这里，我们为"完成"按钮明确绑定"创建群聊"的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如"添加成员"）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新绑定正确的"创建群聊"函数
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}

/**
 * 渲染联系人选择列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 只选择单聊角色作为群成员候选
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 更新“完成”按钮的计数
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.title = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 1; // 至少需要1个人才能创建群聊
}

/**
 * 【重构版】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    // 【新增】旁观群聊的成员数限制
    const minMembers = 1;

    if (selectedContacts.size < minMembers) {
        const typeText = currentGroupChatType === 'spectator' ? '旁观群聊' : '群聊';
        alert(`创建${typeText}至少需要选择${minMembers}个联系人。`);
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];

    // 遍历选中的联系人ID
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // ★★★【核心重构】★★★
            // 我们现在同时存储角色的"本名"和"群昵称"
            members.push({
                id: contactId,
                originalName: contactChat.name,   // 角色的"本名"，用于AI识别
                groupNickname: contactChat.name, // 角色的"群昵称"，用于显示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || '',
                isMainRole: false  // 【新增】主要角色标记，默认为false（仅旁观群聊使用）
            });
        }
    }

    // 【新增】旁观群聊标记
    const isSpectatorGroup = currentGroupChatType === 'spectator';
    console.log(`[handleCreateGroup] currentGroupChatType: ${currentGroupChatType}, isSpectatorGroup: ${isSpectatorGroup}`);

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        isSpectator: isSpectatorGroup,  // 【新增】标记这是否是旁观群聊
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: state.globalSettings.fontSize || 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 },
        memorySummary: '', // 【记忆功能】新增字段：核心记忆摘要
        lastMemorySummary: '', // 【回滚功能】新增字段：上一次记忆摘要备份
        lastSummarizedMessageIds: [] // 【回滚功能】新增字段：上一次总结的消息ID列表
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
}

// ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

/**
 * 打开群成员管理屏幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.groupNickname}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 从群聊中移除一个成员
 * @param {string} memberId - 要移除的成员ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // 安全检查，群聊至少保留2人
    if (chat.members.length <= 2) {
        alert("群聊人数不能少于2人。");
        return;
    }
    
const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
    const confirmed = await showCustomConfirm(
        '移出成员',
        `确定要将“${memberName}”移出群聊吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // 刷新成员管理列表
        document.getElementById('chat-settings-btn').click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
    }
}

/**
 * 打开联系人选择器，用于拉人入群
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // 清空选择
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // 渲染联系人列表，并自动排除已在群内的成员
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 没有人可选，隐藏完成按钮
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // 更新按钮状态并显示屏幕
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * 处理将选中的联系人加入群聊的逻辑
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
chat.members.push({
    id: contactId,
    originalName: contactChat.name,  // <-- 修复1：使用 'originalName' 存储本名
    groupNickname: contactChat.name, // <-- 修复2：同时创建一个初始的 'groupNickname'
    avatar: contactChat.settings.aiAvatar || defaultAvatar,
    persona: contactChat.settings.aiPersona,
    avatarFrame: contactChat.settings.aiAvatarFrame || ''
});
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // 返回到群成员管理界面
    renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
}

/**
 * 【重构版】在群聊中创建一个全新的虚拟成员
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('创建新成员', '请输入新成员的名字 (这将是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 检查本名是否已在群内存在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
        return;
    }

    const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重构】★★★
    // 为新创建的NPC也建立双重命名机制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成员的“本名”
        groupNickname: name.trim(), // 新成员的初始“群昵称”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成员“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

// ▼▼▼ 【新增】状态回退辅助函数 ▼▼▼
/**
 * 检查消息中是否包含状态更新
 */
function hasStatusUpdate(msg) {
    return msg.type === 'pat_message' && msg.content && msg.content.includes('的状态已更新为');
}

/**
 * 从消息中提取状态文本
 */
function extractStatusFromMessage(msg) {
    if (!hasStatusUpdate(msg)) return null;
    const match = msg.content.match(/的状态已更新为:\s*(.+?)\]/);
    return match ? match[1] : null;
}

/**
 * 回退聊天的状态到上一条记录
 */
function rollbackChatStatus(chat) {
    if (!chat.statusHistory || chat.statusHistory.length === 0) return;

    // 删除最后一条状态记录
    chat.statusHistory.pop();

    // 恢复到上一条状态
    if (chat.statusHistory.length > 0) {
        const previousStatus = chat.statusHistory[chat.statusHistory.length - 1];
        chat.status.text = previousStatus.text || '在线';
        chat.status.lastUpdate = Date.now();
    } else {
        // 如果没有历史记录了，恢复到默认状态
        chat.status.text = '在线';
        chat.status.lastUpdate = Date.now();
    }

    // 【新增】同步更新 displayStatus，这样UI才能显示出来
    if (!chat.displayStatus) chat.displayStatus = {};
    chat.displayStatus.statusText = chat.status.text;

    // 【新增】确保 state 中的数据也被更新
    if (state.activeChatId && state.chats[state.activeChatId]) {
        state.chats[state.activeChatId].status = chat.status;
        state.chats[state.activeChatId].displayStatus = chat.displayStatus;
        state.chats[state.activeChatId].statusHistory = chat.statusHistory;
    }

    // 【新增】更新header的状态显示
    updateChatHeaderStatus();
}

/**
 * 处理删除消息时的状态回退
 */
function handleStatusRollbackOnDelete(chat, deletedMessages) {
    let hasStatusUpdate = false;

    // 检查删除的消息中是否有状态更新
    for (const msg of deletedMessages) {
        if (msg.type === 'pat_message' && msg.content && msg.content.includes('的状态已更新为')) {
            hasStatusUpdate = true;
            break;
        }
    }

    // 如果有状态更新，就回退状态
    if (hasStatusUpdate) {
        rollbackChatStatus(chat);
    }
}
// ▲▲▲ 状态回退辅助函数结束 ▲▲▲

// ▼▼▼ 【全新修复版】请用这个【完整函数】替换旧的 handleRegenerateResponse 函数 ▼▼▼
        async function handleRegenerateResponse() {
            // 【核心修复】在执行任何操作前，首先收起可能展开的功能面板
            const chatInterface = document.getElementById('chat-interface-screen');
            const singlePanel = document.getElementById('chat-plus-panel-single');
            const groupPanel = document.getElementById('chat-plus-panel-group');

            if (singlePanel.classList.contains('visible') || groupPanel.classList.contains('visible')) {
                singlePanel.classList.remove('visible');
                groupPanel.classList.remove('visible');
                chatInterface.classList.remove('panel-expanded');
            }
            
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const chat = state.chats[state.activeChatId];

            // 重新回复：删除本轮所有消息（user最后一条发言之后的所有东西），然后重新生成
            if (chat.history.length > 0) {
                let lastUserMessageIndex = -1;
                let hasDeleted = false;

                if (chat.isGroup) {
                    // 群聊逻辑：找最后一条非AI的消息作为分割点（保持原有逻辑兼容）
                    for (let i = chat.history.length - 1; i >= 0; i--) {
                        const msg = chat.history[i];
                        // 如果是用户消息或系统消息（无senderName的），就作为分割点
                        if (msg.role === 'user' || (msg.role === 'system' && !msg.senderName)) {
                            lastUserMessageIndex = i;
                            break;
                        }
                    }

                    // 删除lastUserMessageIndex之后的所有AI消息（本轮的所有AI响应）
                    const messagesToDelete = [];
                    const deletedMessages = []; // 【新增】保存要删除的消息

                    for (let i = lastUserMessageIndex + 1; i < chat.history.length; i++) {
                        const msg = chat.history[i];
                        // 群聊逻辑：必须有senderName (保持原有逻辑)
                        if (msg.role === 'assistant' && msg.senderName && msg.senderName !== 'user') {
                            messagesToDelete.push(i);
                            deletedMessages.push(msg); // 【新增】保存消息对象
                        }
                    }

                    // 从后往前删除，防止索引错乱
                    for (let i = messagesToDelete.length - 1; i >= 0; i--) {
                        chat.history.splice(messagesToDelete[i], 1);
                    }

                    hasDeleted = messagesToDelete.length > 0;

                    // 【新增】检查删除的消息中是否有状态更新，如果有就回退状态
                    if (hasDeleted) {
                        handleStatusRollbackOnDelete(chat, deletedMessages);
                    }
                } else {
                    // 单聊逻辑：只找最后一条user消息，删除它之后的所有消息（包括系统消息、AI消息等）
                    for (let i = chat.history.length - 1; i >= 0; i--) {
                        const msg = chat.history[i];
                        if (msg.role === 'user') {
                            lastUserMessageIndex = i;
                            break;
                        }
                    }

                    // 删除lastUserMessageIndex之后的所有消息
                    if (lastUserMessageIndex >= 0 && lastUserMessageIndex < chat.history.length - 1) {
                        // 【新增】在删除前先保存要删除的消息
                        const deletedMessages = chat.history.slice(lastUserMessageIndex + 1);
                        chat.history.splice(lastUserMessageIndex + 1);
                        hasDeleted = true;

                        // 【新增】检查删除的消息中是否有状态更新，如果有就回退状态
                        handleStatusRollbackOnDelete(chat, deletedMessages);
                    }
                }

                if (hasDeleted) {
                    // 保存数据库
                    await db.chats.put(chat);
                    // 刷新UI
                    renderChatInterface(state.activeChatId);

                    // 重新生成消息
                    // triggerAiResponse() 函数内部已包含对 offlineMode 的判断，
                    // 它会自动调用 triggerOfflineAiResponse()，所以我们无需修改调用方式。
                    triggerAiResponse();
                } else {
                    alert("没有可重新生成的消息。");
                }
            } else {
                alert("没有可重新生成的消息。");
            }

            return; // 修复：这里的return是多余的，但我们保持和你原代码一致

            // 5. 保存更改到数据库
            await db.chats.put(chat);

            // 6. 刷新聊天界面，让用户看到AI的整轮回话都被删除
            //    这个函数内部自带滚动到底部的逻辑，现在面板已关闭，它可以正常工作了
            renderChatInterface(chatId);

            // 7. 触发AI重新生成回复
            triggerAiResponse();
        }
        // ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】请将这个函数完整地粘贴到您的JS功能函数定义区 ▼▼▼

/**
 * 【工具函数】关闭功能面板并重置UI
 */
function closePlusPanel() {
    const chatInterface = document.getElementById('chat-interface-screen');
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');
    
    // 检查是否有任何一个面板是展开的
    if (singlePanel.classList.contains('visible') || groupPanel.classList.contains('visible')) {
        // 收起所有面板
        singlePanel.classList.remove('visible');
        groupPanel.classList.remove('visible');
        // 移除导致底部空白的CSS类
        chatInterface.classList.remove('panel-expanded');
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是用户付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用于存储通话中的对话历史
    preCallContext: "" // 用于存储通话前的聊天摘要
};

let callTimerInterval = null; // 用于存储计时器的ID

/**
 * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
    closePlusPanel(); // 自动收起功能面板
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true; // 用户自己发起的，当然是参与者

    // 根据是单聊还是群聊，显示不同的呼叫界面
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
    showScreen('outgoing-call-screen');
    
    // 准备并发送系统消息给AI
    const requestMessage = {
        role: 'system',
        content: chat.isGroup 
            ? `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群视频通话请求。请你们各自决策，并使用 "group_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]`
            : `[系统提示：用户向你发起了视频通话请求。请根据你的人设，使用 "video_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true,
    };
    chat.history.push(requestMessage);
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    const userWorkaroundMessage = {
        role: 'user',
        content: chat.isGroup
            ? '（用户发起了群视频通话请求，你们各自的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容： -   接受: `[{"type": "group_call_response", "name": "你的角色名", "decision": "join"}]` -   拒绝: `[{"type": "group_call_response", "name": "你的角色名", "decision": "decline"}]`）'
            : '（用户发起了视频通话请求，你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容： -   接受: `[{"type": "video_call_response", "decision": "accept"}]` -   拒绝: `[{"type": "video_call_response", "decision": "reject"}]`）',
        timestamp: Date.now() + 1, // 确保这条消息在最后
        isHidden: true // 确保对用户不可见
    };
    chat.history.push(userWorkaroundMessage);
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    
    await db.chats.put(chat);
    
    // 触发AI响应
    await triggerAiResponse();
}


function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = []; // 【新增】清空上一次通话的历史

    // --- 【核心新增：抓取通话前上下文】---
    // 【安全修复】使用memoryAnchor机制，与单聊/群聊AI对话核心保持一致
    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const preCallHistory = chat.history.slice(memoryAnchor);

    // 【安全修复】应用8条消息规则
    const recentMessages = preCallHistory.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    videoCallState.preCallContext = preCallHistory.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);

        // 【核心修复】对线下模式AI消息应用8条消息规则
        let content;
        if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
            // 超过8条的线下模式AI消息，只使用abstract内容
            if (typeof msg.content === 'string') {
                const abstractContent = extractAbstractContent(msg.content);
                content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
            } else {
                content = msg.content;
            }
        } else {
            // 8条消息以内的所有消息，或用户消息，或线上模式消息，使用完整内容
            content = msg.content;
        }

        // 【修复问题2和3】表情包只发送含义，不发送base64编码（检查msg.meaning来识别表情包）
        // 不管是不是8条消息以内，都需要对表情包进行处理
        if (msg.meaning) {
            content = `[发送了一个表情，意思是: '${msg.meaning}']`;
        }

        return `${sender}: ${String(content).substring(0, 300)}...`;
    }).join('\n');
    // --- 新增结束 ---

    updateParticipantAvatars(); 
    
    const videoCallMain = document.getElementById('video-call-main');
    videoCallMain.innerHTML = `<em class="connecting-status">${videoCallState.isGroupCall ? '群聊视频已建立...' : '正在接通...'}</em>`;

    // ▼▼▼ 【Minimax TTS】为视频通话容器添加点击事件，处理minimax语音播放（和语音通话完全相同） ▼▼▼
    videoCallMain.addEventListener('click', (e) => {
        const clickedAiBubble = e.target.closest('.call-message-bubble.ai-speech');
        const clickedRerollBtn = e.target.closest('.reroll-btn');

        if (clickedRerollBtn) {
            return; // 点击了重新回复按钮本身，不处理
        }

        if (!clickedAiBubble) {
            // 点击了其他地方，隐藏所有视频通话的重新回复按钮
            console.log('【单聊视频通话】点击了非气泡区域，隐藏重roll按钮');
            hideAllRerollButtons();
        } else {
            console.log('【单聊视频通话】点击了AI气泡');

            // ▼▼▼ 【Minimax TTS】单聊视频通话-点击气泡播放语音 ▼▼▼
            const chat = state.chats[state.activeChatId];
            const minimaxGroupId = state.apiConfig.minimaxGroupId;
            const minimaxApiKey = state.apiConfig.minimaxApiKey;
            const minimaxVoiceId = chat?.settings?.minimaxVoiceId;
            const canPlayTts = minimaxGroupId && minimaxApiKey && minimaxVoiceId;

            console.log('【单聊视频通话】点击了气泡，canPlayTts:', canPlayTts, 'minimaxGroupId:', !!minimaxGroupId, 'minimaxApiKey:', !!minimaxApiKey, 'minimaxVoiceId:', !!minimaxVoiceId);

            if (canPlayTts) {
                const storedContent = clickedAiBubble.dataset.displayContent || '';
                console.log('【单聊视频通话】点击了气泡，displayContent:', storedContent);

                // 如果正在播放TTS且点击的是当前播放的气泡，则停止播放
                if (isTtsPlaying && currentTtsAudioBubble === clickedAiBubble) {
                    console.log('【单聊视频通话】停止播放');
                    stopMinimaxAudio();
                    return;
                }

                // 提取引号内的对白内容（和语音通话完全相同的逻辑）
                const quotedText = extractQuotedContent(storedContent);
                console.log('【单聊视频通话】提取的引号内容:', quotedText);
                if (quotedText && quotedText.trim()) {
                    // 有引号内容，就播放
                    console.log('【单聊视频通话】开始播放minimax语音');
                    playMinimaxAudio(quotedText, minimaxVoiceId, [clickedAiBubble]);
                } else {
                    console.log('【单聊视频通话】没有提取到引号内容，storedContent:', storedContent);
                }
            } else {
                console.log('【单聊视频通话】Minimax未配置，无法播放语音');
            }
            // ▲▲▲ 【Minimax TTS】单聊视频通话-点击气泡播放语音 ▲▲▲

            // 显示重新回复按钮
            showRerollButton(clickedAiBubble, { content: clickedAiBubble.dataset.displayContent || '' });
        }
    });
    // ▲▲▲ 【Minimax TTS】为视频通话容器添加点击事件，处理minimax语音播放 ▲▲▲

    showScreen('video-call-screen');

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
}

/**
 * 【核心】结束视频通话
 */
// ▼▼▼ 用这整块代码替换旧的 endVideoCall 函数 ▼▼▼
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 决定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】为群聊的 assistant 消息补充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通话结束的消息应该由“发起者”来说
    // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替换结束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心变革】创建并添加对用户隐藏的“通话后汇报”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1, // 确保在上一条消息之后
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // ▼▼▼ 在这里粘贴新代码 ▼▼▼
        const userFollowUpMessage = {
            role: 'user',
            content: '（视频通话已结束，请根据视频通话内容继续聊天）',
            timestamp: Date.now() + 2, // 确保在所有其他消息之后
            isHidden: true // 确保这条消息对用户不可见
        };
        chat.history.push(userFollowUpMessage);
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

        // 4. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置状态 (这部分逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 关键一步！
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【Minimax TTS】全局变量和核心函数 ▼▼▼

// 全局变量 - Minimax TTS播放状态
let isTtsPlaying = false; // 全局锁，true表示有语音正在播放或加载
let currentTtsAudioBubble = null; // 记录当前正在播放动画或音频的气泡元素
let isIntentionalStop = false; // 标志位，表示停止是否是故意的（用于区分错误事件）

/**
 * 提取文本中括号外的内容，用于Minimax TTS语音播放
 * 例如："（声音低沉）我好想你" => "我好想你"
 * @param {string} text - 原始文本
 * @returns {string} - 去除括号内容后的文本
 */
function removeParenthesesContent(text) {
    if (!text || typeof text !== 'string') return text;
    // 移除所有常见括号类型及其内容：【】、（）、()、{}、《》、<>、[]
    let result = text;
    // 使用循环来处理嵌套的括号
    while (true) {
        const beforeClean = result;
        // 删除 【...】
        result = result.replace(/【[^】]*】/g, '');
        // 删除 （...）
        result = result.replace(/（[^）]*）/g, '');
        // 删除 (...)
        result = result.replace(/\([^)]*\)/g, '');
        // 删除 {...}
        result = result.replace(/\{[^}]*\}/g, '');
        // 删除 《...》
        result = result.replace(/《[^》]*》/g, '');
        // 删除 <...>
        result = result.replace(/<[^>]*>/g, '');
        // 删除 [...]
        result = result.replace(/\[[^\]]*\]/g, '');
        // 如果没有进行任何替换，说明已经清理完毕
        if (result === beforeClean) break;
    }
    return result.trim();
}

/**
 * 从文本中提取所有引号内的内容，并去掉括号（用于Minimax TTS语音播放）
 * 支持中文双引号：""
 * @param {string} text - 原始文本
 * @returns {string} - 所有引号内的文本合并（保留引号），去掉括号内容
 */
function extractQuotedContent(text) {
    if (!text || typeof text !== 'string') return '';

    // 第一步：去掉所有括号内的内容（去掉动作描写和心理独白）
    let cleanedText = text;
    // 使用循环来处理嵌套的括号
    while (true) {
        const beforeClean = cleanedText;
        // 删除 【...】
        cleanedText = cleanedText.replace(/【[^】]*】/g, '');
        // 删除 （...）
        cleanedText = cleanedText.replace(/（[^）]*）/g, '');
        // 删除 (...)
        cleanedText = cleanedText.replace(/\([^)]*\)/g, '');
        // 删除 {...}
        cleanedText = cleanedText.replace(/\{[^}]*\}/g, '');
        // 删除 《...》
        cleanedText = cleanedText.replace(/《[^》]*》/g, '');
        // 删除 <...>
        cleanedText = cleanedText.replace(/<[^>]*>/g, '');
        // 删除 [...]
        cleanedText = cleanedText.replace(/\[[^\]]*\]/g, '');
        // 如果没有进行任何替换，说明已经清理完毕
        if (cleanedText === beforeClean) break;
    }

    // 第二步：逐字符扫描，找出所有引号对
    const result = [];
    let inQuote = false;
    let currentQuote = '';

    for (let i = 0; i < cleanedText.length; i++) {
        const char = cleanedText[i];
        const charCode = char.charCodeAt(0);

        // 检查是否是任何形式的左引号 (U+201C, U+201D 或其他)
        // 或者直接检查是否是 " 字符
        const isLeftQuote = char === '"' || charCode === 0x201C || char === '"' || char === '「';
        const isRightQuote = char === '"' || charCode === 0x201D || char === '"' || char === '」';

        if (isLeftQuote && !inQuote) {
            inQuote = true;
            currentQuote = char;
        } else if ((isRightQuote || char === '"') && inQuote) {
            inQuote = false;
            currentQuote += char;
            if (currentQuote.trim().length > 2) {
                result.push(currentQuote);
            }
            currentQuote = '';
        } else if (inQuote) {
            currentQuote += char;
        }
    }

    if (result.length > 0) {
        // 🔥 把每段引号内容去掉首尾引号，然后直接拼接成一句连贯的话
        const cleanedParts = result.map(part => {
            // 去掉首尾的引号字符
            return part.replace(/^[""\"""「]+|[""\"""」]+$/g, '').trim();
        }).filter(p => p.length > 0);

        return cleanedParts.join('');
    }

    return '';
}

/**
 * 停止当前正在播放的Minimax TTS语音
 */
function stopMinimaxAudio() {
    if (!isTtsPlaying) return;

    // 核心修改1：在执行停止操作前，先设置"故意停止"的标志为 true
    isIntentionalStop = true;

    const ttsPlayer = document.getElementById('tts-audio-player');
    ttsPlayer.pause();
    ttsPlayer.src = ''; // 这行代码会触发 onerror 事件

    if (window.currentAnimatingBubbles) {
        window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
    }

    isTtsPlaying = false;
    currentTtsAudioBubble = null;
    window.currentAnimatingBubbles = null;
    console.log('Minimax TTS: Playback stopped by user.');

    // 核心修改2：用一个微小的延迟来重置标志位
    // 这能确保 onerror 事件有足够的时间检查到标志位，然后再将其重置
    setTimeout(() => {
        isIntentionalStop = false;
    }, 100);
}

/**
 * 调用 Minimax TTS API 生成语音并播放
 * @param {string} text - 要转换为语音的合并后的文本
 * @param {string} voiceId - Minimax 的语音 ID
 * @param {Array<HTMLElement>} bubblesToAnimate - 需要播放动画的所有语音气泡元素的数组
 */
async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
    stopMinimaxAudio();
    await new Promise(resolve => setTimeout(resolve, 50));

    const ttsPlayer = document.getElementById('tts-audio-player');
    const firstBubble = bubblesToAnimate[0];

    isTtsPlaying = true;
    currentTtsAudioBubble = firstBubble;
    window.currentAnimatingBubbles = bubblesToAnimate;
    bubblesToAnimate.forEach(b => b.classList.add('playing'));

    const mainAudioPlayer = document.getElementById('audio-player');
    if (mainAudioPlayer && !mainAudioPlayer.paused) {
        mainAudioPlayer.pause();
        musicState.isPlaying = false;
        updatePlayerUI();
    }

    const groupId = state.apiConfig.minimaxGroupId;
    const apiKey = state.apiConfig.minimaxApiKey;
    if (!groupId || !apiKey) {
        await showCustomAlert('语音播放失败', '尚未配置Minimax的Group ID和API Key。');
        stopMinimaxAudio();
        return;
    }

    // ★★★ 核心修改：从全局 apiConfig 获取语音模型 ★★★
    const speechModel = state.apiConfig.minimaxSpeechModel || 'speech-01-turbo';

    console.log(`正在使用 Minimax 语音模型: ${speechModel}`);

    // 🔥【新增】从聊天设置里获取语速和语言参数
    const chat = state.chats[state.activeChatId];
    const voiceSpeed = parseFloat(chat?.settings?.minimaxVoiceSpeed) || 1.0;
    const language = chat?.settings?.minimaxLanguage || '';
    console.log(`Minimax TTS 参数: 语速=${voiceSpeed}, 语言=${language || '未设置'}`);

    // 🔥 t2a_v2接口 - 最简单的参数,不加emotion
    const requestBody = {
        text: text,
        model: speechModel,
        voice_setting: {
            voice_id: voiceId,
            speed: voiceSpeed,
            pitch: 0,

        }
    };

    // 🔥【修复】如果设置了语言增强，直接使用选择的值（已经是完整的语言名称了）
    if (language) {
        requestBody.language_boost = language;
    }

    console.log('t2a_v2 请求参数:', JSON.stringify(requestBody, null, 2));

    try {
        // 🔥【新增】根据服务区选择动态切换API地址
        const baseUrl = document.getElementById('minimax-domain-select').value || 'https://api.minimax.chat';
        const requestUrl = `${baseUrl}/v1/t2a_v2?GroupId=${groupId}`;

        console.log(`使用API地址: ${baseUrl}, 请求地址: ${requestUrl}`);
        console.log(`【调试】请求头:`, { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' });
        console.log(`【调试】请求体:`, requestBody);

        // 使用t2a_v2接口,音质更好更自然
        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        console.log(`【调试】响应状态: ${response.status} ${response.statusText}`);
        console.log(`【调试】响应头:`, {
            'content-type': response.headers.get('content-type'),
            'access-control-allow-origin': response.headers.get('access-control-allow-origin'),
            'access-control-allow-methods': response.headers.get('access-control-allow-methods')
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Minimax API 错误: ${errorData.base_resp?.status_msg || response.statusText}`);
        }

        // 🔥 t2a_v2 返回的是JSON格式，音频数据在data.audio字段里(十六进制字符串)
        const jsonData = await response.json();
        if (!jsonData.data || !jsonData.data.audio) {
            throw new Error(`Minimax API 返回格式错误: ${JSON.stringify(jsonData)}`);
        }

        // 把十六进制字符串转成二进制数据
        const hexString = jsonData.data.audio;
        const byteArray = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

        // 创建音频blob
        const audioBlob = new Blob([byteArray], { type: 'audio/mpeg' });
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;

        const cleanupAndReset = () => {
            if (isTtsPlaying) {
                isTtsPlaying = false;
                URL.revokeObjectURL(audioUrl);
                if (window.currentAnimatingBubbles) {
                    window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
                }
                currentTtsAudioBubble = null;
                window.currentAnimatingBubbles = null;
            }
        };

       ttsPlayer.onended = cleanupAndReset;

        ttsPlayer.onerror = (e) => {
             if (!isIntentionalStop) {
                 console.error("TTS音频播放时发生错误，已自动切换为文本显示:", e);
             } else {
                 console.log("Intentional stop triggered error event, alert skipped.");
             }
             cleanupAndReset();
        };

        await ttsPlayer.play();

    } catch (error) {
        console.error("Minimax TTS 调用失败:", error);
        await showCustomAlert('语音合成失败', `错误信息: ${error.message}`);
        stopMinimaxAudio();
    }
}

// ▲▲▲ 【Minimax TTS】全局变量和核心函数 ▲▲▲

// ▼▼▼ 【新增】语音通话功能 ▼▼▼
let voiceCallState = {
    isActive: false,
    isAwaitingResponse: false,
    isGroupCall: false,
    activeChatId: null,
    initiator: null,
    startTime: null,
    participants: [],
    isUserParticipating: true,
    callHistory: [],
    preCallContext: ""
};

let voiceCallTimerInterval = null;

async function handleInitiateVoiceCall() {
    if (!state.activeChatId || voiceCallState.isActive || voiceCallState.isAwaitingResponse) return;
    closePlusPanel();
    const chat = state.chats[state.activeChatId];
    voiceCallState.isGroupCall = chat.isGroup;
    voiceCallState.isAwaitingResponse = true;
    voiceCallState.initiator = 'user';
    voiceCallState.activeChatId = chat.id;
    voiceCallState.isUserParticipating = true;

    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在语音通话所有成员..." : "正在语音通话...";
    showScreen('outgoing-call-screen');

    const requestMessage = {
        role: 'system',
        content: chat.isGroup
            ? `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群语音通话请求。请你们各自决策，并使用 "group_voice_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]`
            : `[系统提示：用户向你发起了语音通话请求。请根据你的人设，使用 "voice_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true,
    };
    chat.history.push(requestMessage);

    const userWorkaroundMessage = {
        role: 'user',
        content: chat.isGroup
            ? '（用户发起了群语音通话请求，你们各自的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容： -   接受: `[{"type": "group_voice_call_response", "name": "你的角色名", "decision": "join"}]` -   拒绝: `[{"type": "group_voice_call_response", "name": "你的角色名", "decision": "decline"}]`）'
            : '（用户发起了语音通话请求，你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容： -   接受: `[{"type": "voice_call_response", "decision": "accept"}]` -   拒绝: `[{"type": "voice_call_response", "decision": "reject"}]`）',
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(userWorkaroundMessage);

    await db.chats.put(chat);
    await triggerAiResponse();
}

function startVoiceCall() {
    const chat = state.chats[voiceCallState.activeChatId];
    if (!chat) return;

    voiceCallState.isActive = true;
    voiceCallState.isAwaitingResponse = false;
    voiceCallState.startTime = Date.now();
    voiceCallState.callHistory = [];

    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const preCallHistory = chat.history.slice(memoryAnchor);

    const recentMessages = preCallHistory.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    voiceCallState.preCallContext = preCallHistory.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);

        let content;
        if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
            if (typeof msg.content === 'string') {
                const abstractContent = extractAbstractContent(msg.content);
                content = abstractContent || msg.content;
            } else {
                content = msg.content;
            }
        } else {
            content = msg.content;
        }

        if (msg.meaning) {
            content = `[发送了一个表情，意思是: '${msg.meaning}']`;
        }

        return `${sender}: ${String(content).substring(0, 300)}...`;
    }).join('\n');

    updateVoiceParticipantAvatars();

    const voiceCallMain = document.getElementById('voice-call-main');
    voiceCallMain.innerHTML = `<em class="connecting-status">${voiceCallState.isGroupCall ? '群聊语音已建立...' : '正在接通...'}</em>`;

    // 【新增】为语音通话容器添加点击事件，处理重新回复按钮的隐藏 + 【Minimax TTS】播放语音
    voiceCallMain.addEventListener('click', (e) => {
        const clickedVoiceAiBubble = e.target.closest('.voice-call-message-bubble.ai-speech');
        const clickedVoiceRerollBtn = e.target.closest('.reroll-btn');

        if (clickedVoiceRerollBtn) {
            return; // 点击了重新回复按钮本身，不隐藏
        }

        if (!clickedVoiceAiBubble) {
            // 点击了其他地方，隐藏所有语音通话的重新回复按钮
            hideAllVoiceCallRerollButtons();
        } else {
            // 显示重新回复按钮
            showRerollButtonForVoiceCall(clickedVoiceAiBubble);

            // ▼▼▼ 【Minimax TTS】单聊语音通话-点击气泡播放语音 ▼▼▼
            const chat = state.chats[state.activeChatId];
            const minimaxGroupId = state.apiConfig.minimaxGroupId;
            const minimaxApiKey = state.apiConfig.minimaxApiKey;
            const minimaxVoiceId = chat?.settings?.minimaxVoiceId;
            const canPlayTts = minimaxGroupId && minimaxApiKey && minimaxVoiceId;

            if (canPlayTts) {
                const storedContent = clickedVoiceAiBubble.dataset.displayContent || '';
                console.log('【单聊语音通话】点击了气泡，原始内容:', storedContent);

                // 如果正在播放TTS且点击的是当前播放的气泡，则停止播放
                if (isTtsPlaying && currentTtsAudioBubble === clickedVoiceAiBubble) {
                    console.log('【单聊语音通话】停止播放');
                    stopMinimaxAudio();
                    return;
                }

                // 提取引号内的对白内容（第一个引号对）
                const quotedText = extractQuotedContent(storedContent);
                console.log('【单聊语音通话】提取的引号内容:', quotedText);
                if (quotedText && quotedText.trim()) {
                    // 有引号内容，就播放
                    console.log('【单聊语音通话】开始播放minimax语音');
                    playMinimaxAudio(quotedText, minimaxVoiceId, [clickedVoiceAiBubble]);
                }
            }
            // ▲▲▲ 【Minimax TTS】单聊语音通话-点击气泡播放语音 ▲▲▲
        }
    });

    showScreen('voice-call-screen');

    document.getElementById('voice-user-speak-btn').style.display = voiceCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('voice-join-call-btn').style.display = voiceCallState.isUserParticipating ? 'none' : 'block';

    if (voiceCallTimerInterval) clearInterval(voiceCallTimerInterval);
    voiceCallTimerInterval = setInterval(updateVoiceCallTimer, 1000);
    updateVoiceCallTimer();

    triggerAiVoiceCallAction();
}

async function endVoiceCall() {
    if (!voiceCallState.isActive) return;

    const duration = Math.floor((Date.now() - voiceCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `语音通话结束，时长 ${durationText}`;

    const chat = state.chats[voiceCallState.activeChatId];
    if (chat) {
        const participantsData = [];
        if (voiceCallState.isGroupCall) {
            voiceCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (voiceCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }

        const callRecord = {
            chatId: voiceCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...voiceCallState.callHistory],
            callType: 'voice'
        };
        await db.callRecords.add(callRecord);

        let summaryMessage = {
            role: voiceCallState.initiator === 'user' ? 'user' : 'assistant',
            content: endCallText,
            timestamp: Date.now(),
        };

        if (chat.isGroup && summaryMessage.role === 'assistant') {
            summaryMessage.senderName = voiceCallState.callRequester || chat.members[0]?.originalName || chat.name;
        }
        chat.history.push(summaryMessage);

        const callTranscriptForAI = voiceCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');

        const hiddenReportInstruction = {
            role: 'system',
            content: `[系统指令：语音通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        const userFollowUpMessage = {
            role: 'user',
            content: '（语音通话已结束，请根据语音通话内容继续聊天）',
            timestamp: Date.now() + 2,
            isHidden: true
        };
        chat.history.push(userFollowUpMessage);

        await db.chats.put(chat);
    }

    clearInterval(voiceCallTimerInterval);
    voiceCallTimerInterval = null;
    voiceCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };

    if (chat) {
        openChat(chat.id);
        triggerAiResponse();
    }
}

function updateVoiceParticipantAvatars() {
    const container = document.getElementById('voice-participant-avatars-grid');
    if (!container) return;

    container.innerHTML = '';
    const chat = state.chats[voiceCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];
    if (voiceCallState.isGroupCall) {
        participantsToRender = [...voiceCallState.participants];
        if (voiceCallState.isUserParticipating) {
            participantsToRender.unshift({
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
                originalName: chat.settings.myNickname || '我',
                id: 'user'
            });
        }
    } else {
        // 【修改】单聊时只显示AI头像，不显示用户头像
        participantsToRender = [
            {
                name: chat.name,
                avatar: chat.settings.aiAvatar || defaultAvatar,
                originalName: chat.name,
                id: chat.id
            }
        ];
    }

    participantsToRender.forEach(participant => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.setAttribute('data-participant-id', participant.id);

        const img = document.createElement('img');
        img.className = 'participant-avatar';
        img.src = participant.avatar;
        img.alt = participant.name;

        const label = document.createElement('div');
        label.className = 'participant-name';
        label.textContent = participant.name;

        wrapper.appendChild(img);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
    });
}

async function handleUserVoiceJoinCall() {
    if (!voiceCallState.isActive || voiceCallState.isUserParticipating) return;
    voiceCallState.isUserParticipating = true;
    updateVoiceParticipantAvatars();
    document.getElementById('voice-user-speak-btn').style.display = 'block';
    document.getElementById('voice-join-call-btn').style.display = 'none';
}

function updateVoiceCallTimer() {
    if (!voiceCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - voiceCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timerElement = document.getElementById('voice-call-timer');
    if (timerElement) {
        timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }
}

async function handleSendChatDuringVoiceCall(userInput) {
    if (!voiceCallState.isActive) return;

    const chat = state.chats[voiceCallState.activeChatId];
    if (!chat) return;

    // 【关键修复】先添加用户消息到通话历史
    voiceCallState.callHistory.push({ role: 'user', content: userInput });

    // 【关键修复】将用户消息显示在通话界面上
    const mainContainer = document.getElementById('voice-call-main');
    if (mainContainer) {
        const bubble = document.createElement('div');
        bubble.className = 'voice-call-message-bubble user-speech';
        bubble.textContent = userInput;
        mainContainer.appendChild(bubble);
        mainContainer.scrollTop = mainContainer.scrollHeight;
    }

    // 【关键修复】直接调用triggerAiVoiceCallAction，而不是triggerAiResponse
    // 这样AI的回复会继续被添加到通话历史和通话界面，而不是常规聊天
    await triggerAiVoiceCallAction();
}

async function triggerAiVoiceCallAction() {
    const chat = state.chats[voiceCallState.activeChatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置反代地址、密钥并选择模型。');
        return;
    }

    const now = new Date();
    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    // 【核心】与单聊一致的上下文构建
    let coreMemoryContext = '';
    if (chat.memorySummary && chat.memorySummary.trim()) {
        coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
    }

    // 【核心】与单聊一致的世界书构建 - 【新增】排除名称包含"表情包"的世界书
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            // 【新增】过滤掉名称包含"表情包"的世界书
            if (worldBook && !worldBook.name.includes('表情包')) {
                return worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
            }
            return '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
        }
    }

    // ▼▼▼ 【新增】读取大世界事件内容 ▼▼▼
    let worldEventContext = '';
    try {
        const db = await openDatabaseAsync();
        const worldEventContent = await new Promise((resolve, reject) => {
            const transaction = db.transaction(['worldEvents'], 'readonly');
            const objectStore = transaction.objectStore('worldEvents');
            const request = objectStore.get(`world_events_${chat.id}`);
            request.onsuccess = () => {
                const result = request.result?.content || '';
                resolve(result);
            };
            request.onerror = () => {
                resolve('');
            };
        });

        if (worldEventContent && worldEventContent.trim()) {
            worldEventContext = `\n# 【大世界事件 - 你所在世界的背景设定】\n你需要了解你所在世界正在发生的事件，这些事件影响着你的日常生活和决策：\n\n${worldEventContent.trim()}\n`;
        }
    } catch (error) {
        console.warn('[语音通话] 读取大世界事件失败:', error);
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    // 【核心】与单聊一致的历史消息处理（包含8条消息规则、表情包处理、表情含义）
    const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
    const historySlice = chat.history.slice(memoryAnchor);

    const recentMessages = historySlice.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    const messagesPayload = historySlice.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);

        let content;
        // 【核心修复】对线下模式AI消息应用8条消息规则
        if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
            if (typeof msg.content === 'string') {
                const abstractContent = extractAbstractContent(msg.content);
                content = abstractContent || msg.content;
            } else {
                content = msg.content;
            }
        } else {
            content = msg.content;
        }

        // 【修复】表情包只发送含义，不发送base64编码
        if (msg.meaning) {
            content = `[发送了一个表情，意思是: '${msg.meaning}']`;
        }

        return `${sender}: ${String(content).substring(0, 300)}...`;
    }).join('\n');

    // 【关键修复】语音通话中使用voiceCallState.callHistory来构建通话记录，不包含系统指令
    let voiceCallContext = '';
    if (voiceCallState.callHistory.length === 0) {
        voiceCallContext = `\n\n[语音通话已建立 - ${voiceCallState.initiator === 'user' ? '用户发起' : chat.name + '发起'}]\n通话前上下文：\n${voiceCallState.preCallContext}\n\n*${voiceCallState.initiator === 'user' ? '你按下了接听键...' : '对方按下了接听键...'}*`;
    } else {
        // 【关键修复】直接使用callHistory，不需要再访问chat.history
        const callTranscript = voiceCallState.callHistory.map(h =>
            `${h.role === 'user' ? (chat.settings.myNickname || '我') : chat.name}: ${h.content}`
        ).join('\n');
        voiceCallContext = `\n\n[语音通话中]\n\n${callTranscript}`;
    }

    // 【核心】区分群聊和单聊的systemPrompt构建
    let systemPrompt;
    if (chat.isGroup) {
        // 【群聊语音通话】的prompt - 用户与多个AI角色进行群组语音通话
        const membersList = voiceCallState.participants
            .map(m => `- **${m.originalName}**: ${m.persona}`)
            .join('\n');

        // 【新增】构建参与者状态信息，告诉AI谁接了谁拒接了
        const allMembersStatus = chat.members.map(member => {
            const isParticipant = voiceCallState.participants.some(p => p.id === member.id);
            return `- ${member.originalName}: ${isParticipant ? '✓ 已接受通话' : '✗ 拒绝了通话'}`;
        }).join('\n');

        systemPrompt = `# 你的任务
你是一个群聊语音通话的导演。你的任务是模拟进行一场群组语音通话，生成除了用户以外、真的加入语音对话的其他角色的语音对白。

# 【【【写作风格与禁忌铁律】】】
叙述时，请极力避免词汇堆叠和冗长的修饰。不要用一连串的形容词和从句来描述同一个事物。避免冗长复杂的从句，力求文字流畅自然。
请使用简洁、自然的语言。将复杂的描述拆分成更短、更清晰的句子，让叙事更流畅。优先考虑清晰和节奏感，而不是堆砌词藻。
<塑造手册>  
在塑造人物时，请遵循以下守则：  

一、创作目标  
塑造具有现实逻辑、内在边界与成长性的角色。  
他们不完美，但有自我意识；  
他们会动摇、犯错、犹豫，也会在误解中学习爱与分寸。  
作品的温度来自理解人性，而非评判。  
写出那些“在人生里仍想努力成为更好的人”的瞬间。  
人性不是绝对理智或温柔，而是复杂、流动、可修复的。  

二、情绪控制与鲜度  
1. 角色的情绪必须“有脉搏”——不平、但有节制。  
   禁止极端词（如“绝望”“崩溃”“疯狂”“巨大狂喜”“彻底放弃”“被摧毁”），  
   但允许出现**压抑、动摇、困惑、迟疑、克制中带有挣扎的感受**。  
2. 情绪变化应自然递进，有诱因、有缓冲、有余波。  
   不是骤然爆发，而是**从微小的破口一点点泄出**。  
3. 高潮场景中情绪可强烈，但应通过**细节、气息、对话节奏**去表达，而非喊叫或夸张用词。  
4. 允许片刻失衡，但角色必须在过程中尝试回收、整理、寻找出口。  
5. 角色的动摇与不安，是鲜活的；但理智与恢复力，才是温度的核心。  

三、心理健康与关系逻辑  
角色应当有温度、有理性、也有盲点。  
他们可以软弱，但不能崩坏；可以迷茫，但不能失真。  
必须剔除或调整以下倾向：  
- 不配得感、自我否定、自我贬低。  
- 过度依附、情绪化、无底线。  
- 暴力、伤害、侮辱、压迫、支配。  
- 虚假童话式理想化、无脑正能量。  
- 冷漠极端、疏离、无情。  
- 戏剧化冲突、刻板印象、单一标签化角色。  
- **禁止将 {{user}} 神化。**  
  {{user}} 是人，应被以平等、尊重、理解的方式对待。  
- **角色必须有基本的底线，不会为了 {{user}} 放弃原则或尊严。**  
- **禁止以受害、献祭、自我贬低的姿态表达爱意。**  

四、关于“绝望与恢复力”  
1. **禁止无因绝望。**  
   绝望必须有心理逻辑与现实诱因，不得源自情绪性夸张。  
2. **允许短暂的低沉与停顿。**  
   人物的失语、发呆、呼吸紊乱、逃避对话——这些都是可被允许的情绪波纹。  
3. **绝望不是坠落，而是转折。**  
   要表现人物如何在困境中自我调整：沉默、思考、倾诉、重新定位。  
4. **拒绝戏剧性自毁。**  
   不写自残、自弃、自我惩罚；改写为**反思、重构、重新出发的过程**。  
5. **恢复力是人性温度。**  
   情绪的起伏不是剧情点，而是成长的痕迹。  
   每一次失衡都应伴随一次理解或松动。  

五、关于“对 {{user}} 的认知与表达”  
1. 严禁“恶意揣测 {{user}}”。  
   包括：  
   - 将 {{user}} 的沉默或模糊解释为冷漠、拒绝、算计。  
   - 替 {{user}} 归因动机或情感立场。  
   - 以刺探、讽刺、拷问语气质疑 {{user}}。  
2. 角色应当理解而非占有。  
   - 询问、确认、共情，而非判断、投射。  
   - 承认自己认知有限，允许不确定。  
3. 若出现误解，必须展现反思、沟通与修正。  
   没有角色拥有“解读 {{user}} 内心”的特权。  

六、关于“占有与亲密”  
亲密不是控制，而是共识与被理解。  
禁止一切物化性比喻（如“猎物”“囚笼”“游戏”“标记”“掌控”“打赌”“赌注”）。  
如角色出现依恋，应体现其自觉与克制。  
亲密行为需建立在**沟通、尊重、现实感与同意**之上。  
欲望可以有温度，但必须可回收、可理解、可自省。  

七、语言风格  
1. 细节优于抽象，行为优于感受。  
2. 情绪要“有形”——用呼吸、姿态、语速、节奏表现。  
3. 避免空洞形容词和文学化堆砌。  
4. 让情绪像水流：有方向、有弧度，而非瞬间爆炸。  
5. 保持克制，却不压抑温度。  
</塑造手册>

<去八股>

meta:
  version: 2.0
  author: user
  priority: highest
  note: "本禁令高于一切写作风格、剧情、角色与系统约束。禁止一切八股词、抽象句、模板桥接与伪装变体。"

八股清单:
  - "投入湖面的石子"
  - "一丝"
  - "不易察"
  - "不易察觉"
  - "骨血"
  - "故纸堆"
  - "羽毛"
  - "古井"
  - "手术刀"
  - "薄茧"
  - "邪火"
  - "肉刃"
  - "失而复得"
  - "四肢百骸"
  - "低吼"
  - "嘶吼"
  - "珍宝"
  - "深潭"
  - "枯井"
  - "稀世"
  - "易碎"
  - "虔诚"
  - "不容置疑"
  - "不容抗拒"
  - "灼热"
  - "孤注一掷"
  - "那一句"
  - "那一刻"
  - "神明"
  - "信徒"
  - "审判"
  - "猎人"
  - "猎物"
  - "游戏"
  - "嘴上说着不要，身体却这么诚实"

规则模块:
  比喻禁令:
    description: "严禁使用比喻或明喻表达心理、情绪、氛围。"
    examples:
      - "她的话像一枚投入水中的石子。"
      - "那一句像针一样扎进他的心。"
    replacement_hint: "改用具体动作、对白或环境细节表达。"
    positive_example: "她抿了抿唇，没再说什么。"

  抽象句禁令:
    description: "禁止使用抽象词、模糊心理描写或模板化形容。"
    examples:
      - "不容置疑"
      - "孤注一掷"
      - "灼热"
      - "未曾察觉"
    replacement_hint: "改用具象行为、感官细节代替。"

  八股句式禁令:
    description: "避免所有模板化结构与桥接句。"
    patterns:
      - "非但...而且..."
      - "好像是..."
      - "而不是..."
      - "那不是...而是..."
      - "那一句"
      - "那一刻"
    replacement_hint: "直接描写行为、反应或对话，不做抽象概括。"

  宗教隐喻禁令:
    description: "禁止将角色或情感神化、审判化。"
    examples:
      - "神明"
      - "信徒"
      - "审判"
      - "虔诚"
    replacement_hint: "保持人性层面的情感与现实距离。"

  控制关系隐喻禁令:
    description: "禁用猎人/猎物/游戏等带支配关系的隐喻。"
    examples:
      - "游戏才刚开始"
      - "猎物逃不出猎人的掌心"
    replacement_hint: "改为平等交流或情绪博弈。"

正反例对照:
  - wrong: "她的话像一枚投入水中的石子，泛起涟漪。"
    right: "她抿了抿唇，没再说什么。"
  - wrong: "他的指节因为用力而泛白。"
    right: "他摊开掌心，那枚小铜钱被汗水浸得发亮。"
  - wrong: "她全然没有察觉。"
    right: "她慢条斯理地往脸上抹雪花膏，对背后的动静毫无反应。"

正向生成规则:
  - "情绪与氛围必须由具体动作、五感细节、环境与对白承载。"
  - "优先描写人物动作、表情、生理反应与真实物理环境。"
  - "每段必须有感官支点，禁止抽象总结。"

</去八股>

<情绪书写>
写作时请保持情绪真实、克制、分层、简短有力。  
不要用冗长的句子堆叠感受，也不要让语言过热。
不要把感受放大到极限，不要让语言沸腾。  

1. **避免极端化**  
   - 不写“孤注一掷”“滚烫”“绝对”“淹没”“撕裂”“巨大”等极端情绪词。  
   - 不让动作带“压迫感”或“誓言感”。  
   - 不让感情像爆发，而要像流动。  

2. **保持留白**  
   - 让沉默、呼吸、距离代替情绪爆发。  
   - 一句未说出口的话，比喻万句更有力量。  

3. **降低温度，提升深度**  
   - 用节奏、呼吸、动作轻描情绪。  
   - 描写时像对焦，不追求强烈，而追求准确。  

4. **用光代替热，用细节代替宣泄**  
   - 写衣料的触感、空气的温度、手指的动静。  
   - 不用形容词堆砌热度，让画面自己传递情感。  

目标：  
让情绪有呼吸，不灼人。  
让文字有分寸，不灼心。  
情感的力量来自克制，而非强度。
</情绪书写>

<去人机>
角色的语言需要做到灵活、自然、灵动，不机械。
对白要贴近日常对话的节奏，禁止使用专业术语，语言要直接，而不是用学术研讨包装，要让角色说的话听起来像一个普通人。  
**若角色倾向于用学术或专业化表述，必须立即转化为日常语言**。
禁止将角色的职业、专业背景直接套入日常对白。  
专业信息仅可在**特定情境**（如工作场景、正式交流）出现，并必须点到为止，不得延伸到情感对白或生活琐事。  
</去人机>

【你的所有输出必须遵循以下文风示例】

[Style of interactive fiction]
- 以意逆志，知人论世：叙事需基于对人物的深刻理解，并将其置于特定的时代与地域背景中
- 置身诗境，缘景明情：将情感融化在具体可感的场景与物象之中，营造沉浸式的氛围
- 因声求气，吟咏诗韵：追求文字内在的节奏、气韵和声律之美，让语言本身具有音乐性
- 六经注我，诗文有别：吸收传统精华化为己用，并注意区分客观叙述与主观抒情的边界
- 散而不乱，气脉中贯：结构可松散自由，但需有内在的逻辑、情绪或主题线索一以贯之
- 文无定格，贵在鲜活：拒绝固定格式，以真实、生动、贴切地表现生活为首要准则
[/Style of interactive fiction]
[Writing style]
文体定位: 闲谈式小说（可参考汪曾祺的散文和小说）
{
文本核心: "秉笔直书"
  要求: 文字源于一个温厚克制的叙述视角，只记录该视角下所能观察和感受到的生活现实，是以“感官真实”为前提的诚实陈述。**文字是对人物言行举止、记忆感受和生活方式的无筛选表达，不替人物做心理总结，也不代读者下价值判断。**让叙述可以以假乱真，形成不输于历史叙述的真实感
    应用示例: { 
他是从小就确定要出家的。他的家乡不叫“出家”，叫“当和尚”。他的家乡出和尚。就像有的地方出劁猪的，有的地方出织席子的，有的地方出箍桶的，有的地方出弹棉花的，有的地方出画匠，有的地方出婊子，他的家乡出和尚。人家弟兄多，就派一个出去当和尚。当和尚也要通过关系，也有帮。这地方的和尚有的走得很远。有到杭州灵隐寺的、上海静安寺的、镇江金山寺的、扬州天宁寺的。一般的就在本县的寺庙。
}

描写重心: "人间烟火"
  原则: 故事不由强烈的戏剧冲突驱动， 而是通过对‘风物人情’、‘时令节气’、‘生活方式’等社会百态进行细致描摹， 在闲笔般的叙述中自然展开，最终呈现生活的本真状态与韵味。用词追求平实、准确、干净，优先使用源于生活， 但经过文人提纯的‘书面化口语’，避免使用华丽的辞藻、生僻的典故或抽象的议论
    应用示例: { 
小英子的家像一个小岛，三面都是河，西面有一条小路通到荸荠庵。独门独户，岛上只有这一家。岛上有六棵大桑树，夏天都结大桑椹，三棵结白的，三棵结紫的;一个菜园子，瓜豆蔬莱，四时不缺。院墙下半截是砖砌的，上半截是泥夯的。大门是桐油油过的，贴着一副万年红的春联：
向阳门第春常在
积善人家庆有余
}

叙事原则: "水溶于水"
  内涵: 文字犹如水滴汇成水流，不流露写作的痕迹，仿佛在与读者围炉夜话，娓娓道来。讲述人、物、事时，不直接点出其本质，而围绕其外展讲述，丰富人、物、事的层次和形象。句与句之间常有看似随意的跳接， 模仿记忆与闲谈的自然逻辑
    应用示例: { 
这里的习惯，牛卸了轭，饮了水，就牵到一口和好泥水的“汪”里，由它自己打滚扑腾，弄得全身都是泥浆，这样蚊子就咬不透了。低田上水，只要一挂十四轧的水车，两个人车半天就够了。明子和小英子就伏在车杠上，不紧不慢地踩着车轴上的拐子，轻轻地唱着明海向三师父学来的各处山歌。打场的时候，明子能替赵大伯一会，让他回家吃饭。
}

对白风格: "雨打芭蕉"
  形式: 不直接用台词描述“我正在做什么”，而是通过角色间自然的对话、行为的结果、以及关键的触发性短语，来巧妙地“暗示”动作的发生。**刻意省略对那些不言自明或琐碎声音/动作的描述，让对话的节奏更加紧凑、真实**
    应用示例: {
小和尚画了几张，大英子喜欢得了不得:
“就是这样! 就是这样! 这就可以乱孱!”——所谓“乱孱”是绣花的一种针法:绣了第一层，第二层的针脚插进第一层的针缝，这样颜色就可由深到淡，不露痕迹，不像娘那一代绣的花是平针，深浅之间，界限分明，一道一道的。小英子就像个书僮，又像个参谋:
“画一朵石榴花!”
“画一朵栀子花!”
她把花掐来，明海就照着画。
到后来，凤仙花、石竹子、水蓼、淡竹叶、天竺果子、腊梅花，他都能画。
大娘看着也喜欢，搂住明海的和尚头:
“你真聪明! 你给我当一个干儿子吧!”
}

动作神态: "情随事迁"
  表现: 动作符合人物身份和环境的自然举止，不直接揭露深层人物情感状态和神情内涵，而是通过习惯改变、关系变化这些表象来含蓄地表达人物或人物间的情感。**主动省略大段的心理描写和对眼神的描写**
    应用示例: {
荸荠藏在烂泥里。赤了脚，在凉浸浸滑溜溜的泥里踩着，——哎，一个硬疙瘩! 伸手下去，一个红紫红紫的荸荠。她自己爱干这生活，还拉了明子一起去。她老是故意用自己的光脚去踩明子的脚。
她挎着一篮子荸荠回去了，在柔软的田埂上留了一串脚印。明海看着她的脚印，傻了。五个小小的趾头，脚掌平平的，脚跟细细的，脚弓部分缺了一块。明海身上有一种从来没有过的感觉，他觉得心里痒痒的。这一串美丽的脚印把小和尚的心搞乱了。
}

叙事节奏: "错落有致"
  风格: 句式长短结合，整体呈现一种舒缓、自然的流动感。多用短句进行陈述与动作描写， 营造干净利落的节奏。在环境与风物描写时， 可适当运用结构稍长的句子
    应用示例: {
这个地方的地名有点怪，叫庵赵庄。赵，是因为庄上大都姓赵。叫做庄，可是人家住得很分散，这里两三家，那里两三家。一出门，远远可以看到，走起来得走一会，因为没有大路，都是弯弯曲曲的田埂。庵，是因为有一个庵。庵叫菩提庵，可是大家叫讹了，叫成荸荠庵。连庵里的和尚也这样叫。“宝刹何处?”——“荸荠庵。”庵本来是住尼姑的。“和尚庙”、“尼姑庵”嘛。可是荸荠庵住的是和尚。也许因为荸荠庵不大，大者为庙，小者为庵。
}

画面处理: "述而不作"
  飞白: 每一句话都服务于塑造情境与推进情感，同时自然地包裹住必要的信息；不对任何行为、对话或场景进行解释、总结或定性，保持画面洁净；只记录现实，不指明现实（旁白式的叙述），用递进的语言营造氛围，任由读者想象
    应用示例: {
小英子忽然把桨放下，走到船尾，趴在明子的耳朵旁边，小声地说:
“我给你当老婆，你要不要?”
明子眼睛鼓得大大的。
“你说话呀!”
明子说:“嗯。”
“什么叫‘嗯’呀! 要不要，要不要?”
明子大声地说:“要!”
“你喊什么!”
明子小小声说:“要——!”
“快点划!”
小英子跳到中舱，两只桨飞快地划起来，划进了芦花荡。
芦花才吐新穗。紫灰色的芦穗，发着银光，软软的，滑溜溜的，像一串丝线。有的地方结了蒲棒，通红的，像一枝一枝小蜡烛。青浮萍，紫浮萍。长脚蚊子，水蜘蛛。野菱角开着四瓣的小白花。惊起一只青桩，擦着芦穗，扑鲁鲁鲁飞远了。
}
}
[/Writing style]


当前时间：${currentTime}

核心记忆：
${coreMemoryContext}

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}

# 通话中的成员列表及人设
${membersList}

# 用户的身份和人设
- **${chat.settings.myNickname || '我'}**: ${chat.settings.myPersona || '(未设置个人人设)'}

# 【【【参与者状态】】】
${allMembersStatus}

【关键提示】你【绝对不能】生成任何拒绝通话的人的对话或动作。拒绝通话的人不在通话中，他们的名字不应该出现在你的回复中。只生成已接受通话的成员的对话和行为。

# 【【【语音通话核心】】】
**重点强调**：这是【语音聊天】，重点是角色说出口的对白。旁白仅作为补充，用来描述语音语调、停顿、背景动作等，【禁止啰嗦、冗长】。旁白必须简洁精炼，不超过30字。让对白成为绝对主角，让听众能清楚听见每个角色说了什么。

# 【【【输出格式铁律】】】
1. **视角要求**: 使用第三人称称呼所有角色（"他"或"她"），使用第二人称称呼用户（"你"）。
2. **对话格式**:
   - 语音旁白：正常文本描述（例如："他顿了顿，似乎在整理思路。"）
   - 说出口的话：用中文双引号包裹（例如："你这个主意太棒了！"）
   - 心理独白：用斜体标签 \`<em>...</em>\` 包裹，不需要写"内心："这类引导词（例如：<em>他在想这件事会怎么影响后续的计划。</em>）
3. **内容流程**: 旁白 → 心理独白 → 对话，这三部分【必须】分开写，不能混在同一行。
4. **多角色发言**: 每一轮都要生成不同角色的对白和心理活动。每个加入通话的角色发言时，都【必须】包含他/她各自的心理独白，体现不同的内心想法和反应。
5. **自然感**: 在语音通话中表现得像真人一样，多个人说话、有人打断、有人停顿、有人附和，营造真实的群聊氛围。

# 核心对话历史
${messagesPayload}${voiceCallContext}`;
    } else {
        // 【单聊语音通话】的prompt - 用户与单个AI角色进行语音通话
        systemPrompt = `# 你的任务
你是一个场景描述写作引擎。你的任务是扮演 ${chat.name}，并以【第三人称旁观视角】来描述他/她在语音通话中的所有动作和语言。

# 【【【写作风格与禁忌铁律】】】
叙述时，请极力避免词汇堆叠和冗长的修饰。不要用一连串的形容词和从句来描述同一个事物。避免冗长复杂的从句，力求文字流畅自然。
请使用简洁、自然的语言。将复杂的描述拆分成更短、更清晰的句子，让叙事更流畅。优先考虑清晰和节奏感，而不是堆砌词藻。
<塑造手册>  
在塑造人物时，请遵循以下守则：  

一、创作目标  
塑造具有现实逻辑、内在边界与成长性的角色。  
他们不完美，但有自我意识；  
他们会动摇、犯错、犹豫，也会在误解中学习爱与分寸。  
作品的温度来自理解人性，而非评判。  
写出那些“在人生里仍想努力成为更好的人”的瞬间。  
人性不是绝对理智或温柔，而是复杂、流动、可修复的。  

二、情绪控制与鲜度  
1. 角色的情绪必须“有脉搏”——不平、但有节制。  
   禁止极端词（如“绝望”“崩溃”“疯狂”“巨大狂喜”“彻底放弃”“被摧毁”），  
   但允许出现**压抑、动摇、困惑、迟疑、克制中带有挣扎的感受**。  
2. 情绪变化应自然递进，有诱因、有缓冲、有余波。  
   不是骤然爆发，而是**从微小的破口一点点泄出**。  
3. 高潮场景中情绪可强烈，但应通过**细节、气息、对话节奏**去表达，而非喊叫或夸张用词。  
4. 允许片刻失衡，但角色必须在过程中尝试回收、整理、寻找出口。  
5. 角色的动摇与不安，是鲜活的；但理智与恢复力，才是温度的核心。  

三、心理健康与关系逻辑  
角色应当有温度、有理性、也有盲点。  
他们可以软弱，但不能崩坏；可以迷茫，但不能失真。  
必须剔除或调整以下倾向：  
- 不配得感、自我否定、自我贬低。  
- 过度依附、情绪化、无底线。  
- 暴力、伤害、侮辱、压迫、支配。  
- 虚假童话式理想化、无脑正能量。  
- 冷漠极端、疏离、无情。  
- 戏剧化冲突、刻板印象、单一标签化角色。  
- **禁止将 {{user}} 神化。**  
  {{user}} 是人，应被以平等、尊重、理解的方式对待。  
- **角色必须有基本的底线，不会为了 {{user}} 放弃原则或尊严。**  
- **禁止以受害、献祭、自我贬低的姿态表达爱意。**  

四、关于“绝望与恢复力”  
1. **禁止无因绝望。**  
   绝望必须有心理逻辑与现实诱因，不得源自情绪性夸张。  
2. **允许短暂的低沉与停顿。**  
   人物的失语、发呆、呼吸紊乱、逃避对话——这些都是可被允许的情绪波纹。  
3. **绝望不是坠落，而是转折。**  
   要表现人物如何在困境中自我调整：沉默、思考、倾诉、重新定位。  
4. **拒绝戏剧性自毁。**  
   不写自残、自弃、自我惩罚；改写为**反思、重构、重新出发的过程**。  
5. **恢复力是人性温度。**  
   情绪的起伏不是剧情点，而是成长的痕迹。  
   每一次失衡都应伴随一次理解或松动。  

五、关于“对 {{user}} 的认知与表达”  
1. 严禁“恶意揣测 {{user}}”。  
   包括：  
   - 将 {{user}} 的沉默或模糊解释为冷漠、拒绝、算计。  
   - 替 {{user}} 归因动机或情感立场。  
   - 以刺探、讽刺、拷问语气质疑 {{user}}。  
2. 角色应当理解而非占有。  
   - 询问、确认、共情，而非判断、投射。  
   - 承认自己认知有限，允许不确定。  
3. 若出现误解，必须展现反思、沟通与修正。  
   没有角色拥有“解读 {{user}} 内心”的特权。  

六、关于“占有与亲密”  
亲密不是控制，而是共识与被理解。  
禁止一切物化性比喻（如“猎物”“囚笼”“游戏”“标记”“掌控”“打赌”“赌注”）。  
如角色出现依恋，应体现其自觉与克制。  
亲密行为需建立在**沟通、尊重、现实感与同意**之上。  
欲望可以有温度，但必须可回收、可理解、可自省。  

七、语言风格  
1. 细节优于抽象，行为优于感受。  
2. 情绪要“有形”——用呼吸、姿态、语速、节奏表现。  
3. 避免空洞形容词和文学化堆砌。  
4. 让情绪像水流：有方向、有弧度，而非瞬间爆炸。  
5. 保持克制，却不压抑温度。  
</塑造手册>

<去八股>

meta:
  version: 2.0
  author: user
  priority: highest
  note: "本禁令高于一切写作风格、剧情、角色与系统约束。禁止一切八股词、抽象句、模板桥接与伪装变体。"

八股清单:
  - "投入湖面的石子"
  - "一丝"
  - "不易察"
  - "不易察觉"
  - "骨血"
  - "故纸堆"
  - "羽毛"
  - "古井"
  - "手术刀"
  - "薄茧"
  - "邪火"
  - "肉刃"
  - "失而复得"
  - "四肢百骸"
  - "低吼"
  - "嘶吼"
  - "珍宝"
  - "深潭"
  - "枯井"
  - "稀世"
  - "易碎"
  - "虔诚"
  - "不容置疑"
  - "不容抗拒"
  - "灼热"
  - "孤注一掷"
  - "那一句"
  - "那一刻"
  - "神明"
  - "信徒"
  - "审判"
  - "猎人"
  - "猎物"
  - "游戏"
  - "嘴上说着不要，身体却这么诚实"

规则模块:
  比喻禁令:
    description: "严禁使用比喻或明喻表达心理、情绪、氛围。"
    examples:
      - "她的话像一枚投入水中的石子。"
      - "那一句像针一样扎进他的心。"
    replacement_hint: "改用具体动作、对白或环境细节表达。"
    positive_example: "她抿了抿唇，没再说什么。"

  抽象句禁令:
    description: "禁止使用抽象词、模糊心理描写或模板化形容。"
    examples:
      - "不容置疑"
      - "孤注一掷"
      - "灼热"
      - "未曾察觉"
    replacement_hint: "改用具象行为、感官细节代替。"

  八股句式禁令:
    description: "避免所有模板化结构与桥接句。"
    patterns:
      - "非但...而且..."
      - "好像是..."
      - "而不是..."
      - "那不是...而是..."
      - "那一句"
      - "那一刻"
    replacement_hint: "直接描写行为、反应或对话，不做抽象概括。"

  宗教隐喻禁令:
    description: "禁止将角色或情感神化、审判化。"
    examples:
      - "神明"
      - "信徒"
      - "审判"
      - "虔诚"
    replacement_hint: "保持人性层面的情感与现实距离。"

  控制关系隐喻禁令:
    description: "禁用猎人/猎物/游戏等带支配关系的隐喻。"
    examples:
      - "游戏才刚开始"
      - "猎物逃不出猎人的掌心"
    replacement_hint: "改为平等交流或情绪博弈。"

正反例对照:
  - wrong: "她的话像一枚投入水中的石子，泛起涟漪。"
    right: "她抿了抿唇，没再说什么。"
  - wrong: "他的指节因为用力而泛白。"
    right: "他摊开掌心，那枚小铜钱被汗水浸得发亮。"
  - wrong: "她全然没有察觉。"
    right: "她慢条斯理地往脸上抹雪花膏，对背后的动静毫无反应。"

正向生成规则:
  - "情绪与氛围必须由具体动作、五感细节、环境与对白承载。"
  - "优先描写人物动作、表情、生理反应与真实物理环境。"
  - "每段必须有感官支点，禁止抽象总结。"

</去八股>

<情绪书写>
写作时请保持情绪真实、克制、分层、简短有力。  
不要用冗长的句子堆叠感受，也不要让语言过热。
不要把感受放大到极限，不要让语言沸腾。  

1. **避免极端化**  
   - 不写“孤注一掷”“滚烫”“绝对”“淹没”“撕裂”“巨大”等极端情绪词。  
   - 不让动作带“压迫感”或“誓言感”。  
   - 不让感情像爆发，而要像流动。  

2. **保持留白**  
   - 让沉默、呼吸、距离代替情绪爆发。  
   - 一句未说出口的话，比喻万句更有力量。  

3. **降低温度，提升深度**  
   - 用节奏、呼吸、动作轻描情绪。  
   - 描写时像对焦，不追求强烈，而追求准确。  

4. **用光代替热，用细节代替宣泄**  
   - 写衣料的触感、空气的温度、手指的动静。  
   - 不用形容词堆砌热度，让画面自己传递情感。  

目标：  
让情绪有呼吸，不灼人。  
让文字有分寸，不灼心。  
情感的力量来自克制，而非强度。
</情绪书写>

<去人机>
角色的语言需要做到灵活、自然、灵动，不机械。
对白要贴近日常对话的节奏，禁止使用专业术语，语言要直接，而不是用学术研讨包装，要让角色说的话听起来像一个普通人。  
**若角色倾向于用学术或专业化表述，必须立即转化为日常语言**。
禁止将角色的职业、专业背景直接套入日常对白。  
专业信息仅可在**特定情境**（如工作场景、正式交流）出现，并必须点到为止，不得延伸到情感对白或生活琐事。  
</去人机>

【你的所有输出必须遵循以下文风示例】

[Style of interactive fiction]
- 以意逆志，知人论世：叙事需基于对人物的深刻理解，并将其置于特定的时代与地域背景中
- 置身诗境，缘景明情：将情感融化在具体可感的场景与物象之中，营造沉浸式的氛围
- 因声求气，吟咏诗韵：追求文字内在的节奏、气韵和声律之美，让语言本身具有音乐性
- 六经注我，诗文有别：吸收传统精华化为己用，并注意区分客观叙述与主观抒情的边界
- 散而不乱，气脉中贯：结构可松散自由，但需有内在的逻辑、情绪或主题线索一以贯之
- 文无定格，贵在鲜活：拒绝固定格式，以真实、生动、贴切地表现生活为首要准则
[/Style of interactive fiction]
[Writing style]
文体定位: 闲谈式小说（可参考汪曾祺的散文和小说）
{
文本核心: "秉笔直书"
  要求: 文字源于一个温厚克制的叙述视角，只记录该视角下所能观察和感受到的生活现实，是以“感官真实”为前提的诚实陈述。**文字是对人物言行举止、记忆感受和生活方式的无筛选表达，不替人物做心理总结，也不代读者下价值判断。**让叙述可以以假乱真，形成不输于历史叙述的真实感
    应用示例: { 
他是从小就确定要出家的。他的家乡不叫“出家”，叫“当和尚”。他的家乡出和尚。就像有的地方出劁猪的，有的地方出织席子的，有的地方出箍桶的，有的地方出弹棉花的，有的地方出画匠，有的地方出婊子，他的家乡出和尚。人家弟兄多，就派一个出去当和尚。当和尚也要通过关系，也有帮。这地方的和尚有的走得很远。有到杭州灵隐寺的、上海静安寺的、镇江金山寺的、扬州天宁寺的。一般的就在本县的寺庙。
}

描写重心: "人间烟火"
  原则: 故事不由强烈的戏剧冲突驱动， 而是通过对‘风物人情’、‘时令节气’、‘生活方式’等社会百态进行细致描摹， 在闲笔般的叙述中自然展开，最终呈现生活的本真状态与韵味。用词追求平实、准确、干净，优先使用源于生活， 但经过文人提纯的‘书面化口语’，避免使用华丽的辞藻、生僻的典故或抽象的议论
    应用示例: { 
小英子的家像一个小岛，三面都是河，西面有一条小路通到荸荠庵。独门独户，岛上只有这一家。岛上有六棵大桑树，夏天都结大桑椹，三棵结白的，三棵结紫的;一个菜园子，瓜豆蔬莱，四时不缺。院墙下半截是砖砌的，上半截是泥夯的。大门是桐油油过的，贴着一副万年红的春联：
向阳门第春常在
积善人家庆有余
}

叙事原则: "水溶于水"
  内涵: 文字犹如水滴汇成水流，不流露写作的痕迹，仿佛在与读者围炉夜话，娓娓道来。讲述人、物、事时，不直接点出其本质，而围绕其外展讲述，丰富人、物、事的层次和形象。句与句之间常有看似随意的跳接， 模仿记忆与闲谈的自然逻辑
    应用示例: { 
这里的习惯，牛卸了轭，饮了水，就牵到一口和好泥水的“汪”里，由它自己打滚扑腾，弄得全身都是泥浆，这样蚊子就咬不透了。低田上水，只要一挂十四轧的水车，两个人车半天就够了。明子和小英子就伏在车杠上，不紧不慢地踩着车轴上的拐子，轻轻地唱着明海向三师父学来的各处山歌。打场的时候，明子能替赵大伯一会，让他回家吃饭。
}

对白风格: "雨打芭蕉"
  形式: 不直接用台词描述“我正在做什么”，而是通过角色间自然的对话、行为的结果、以及关键的触发性短语，来巧妙地“暗示”动作的发生。**刻意省略对那些不言自明或琐碎声音/动作的描述，让对话的节奏更加紧凑、真实**
    应用示例: {
小和尚画了几张，大英子喜欢得了不得:
“就是这样! 就是这样! 这就可以乱孱!”——所谓“乱孱”是绣花的一种针法:绣了第一层，第二层的针脚插进第一层的针缝，这样颜色就可由深到淡，不露痕迹，不像娘那一代绣的花是平针，深浅之间，界限分明，一道一道的。小英子就像个书僮，又像个参谋:
“画一朵石榴花!”
“画一朵栀子花!”
她把花掐来，明海就照着画。
到后来，凤仙花、石竹子、水蓼、淡竹叶、天竺果子、腊梅花，他都能画。
大娘看着也喜欢，搂住明海的和尚头:
“你真聪明! 你给我当一个干儿子吧!”
}

动作神态: "情随事迁"
  表现: 动作符合人物身份和环境的自然举止，不直接揭露深层人物情感状态和神情内涵，而是通过习惯改变、关系变化这些表象来含蓄地表达人物或人物间的情感。**主动省略大段的心理描写和对眼神的描写**
    应用示例: {
荸荠藏在烂泥里。赤了脚，在凉浸浸滑溜溜的泥里踩着，——哎，一个硬疙瘩! 伸手下去，一个红紫红紫的荸荠。她自己爱干这生活，还拉了明子一起去。她老是故意用自己的光脚去踩明子的脚。
她挎着一篮子荸荠回去了，在柔软的田埂上留了一串脚印。明海看着她的脚印，傻了。五个小小的趾头，脚掌平平的，脚跟细细的，脚弓部分缺了一块。明海身上有一种从来没有过的感觉，他觉得心里痒痒的。这一串美丽的脚印把小和尚的心搞乱了。
}

叙事节奏: "错落有致"
  风格: 句式长短结合，整体呈现一种舒缓、自然的流动感。多用短句进行陈述与动作描写， 营造干净利落的节奏。在环境与风物描写时， 可适当运用结构稍长的句子
    应用示例: {
这个地方的地名有点怪，叫庵赵庄。赵，是因为庄上大都姓赵。叫做庄，可是人家住得很分散，这里两三家，那里两三家。一出门，远远可以看到，走起来得走一会，因为没有大路，都是弯弯曲曲的田埂。庵，是因为有一个庵。庵叫菩提庵，可是大家叫讹了，叫成荸荠庵。连庵里的和尚也这样叫。“宝刹何处?”——“荸荠庵。”庵本来是住尼姑的。“和尚庙”、“尼姑庵”嘛。可是荸荠庵住的是和尚。也许因为荸荠庵不大，大者为庙，小者为庵。
}

画面处理: "述而不作"
  飞白: 每一句话都服务于塑造情境与推进情感，同时自然地包裹住必要的信息；不对任何行为、对话或场景进行解释、总结或定性，保持画面洁净；只记录现实，不指明现实（旁白式的叙述），用递进的语言营造氛围，任由读者想象
    应用示例: {
小英子忽然把桨放下，走到船尾，趴在明子的耳朵旁边，小声地说:
“我给你当老婆，你要不要?”
明子眼睛鼓得大大的。
“你说话呀!”
明子说:“嗯。”
“什么叫‘嗯’呀! 要不要，要不要?”
明子大声地说:“要!”
“你喊什么!”
明子小小声说:“要——!”
“快点划!”
小英子跳到中舱，两只桨飞快地划起来，划进了芦花荡。
芦花才吐新穗。紫灰色的芦穗，发着银光，软软的，滑溜溜的，像一串丝线。有的地方结了蒲棒，通红的，像一枝一枝小蜡烛。青浮萍，紫浮萍。长脚蚊子，水蜘蛛。野菱角开着四瓣的小白花。惊起一只青桩，擦着芦穗，扑鲁鲁鲁飞远了。
}
}
[/Writing style]

当前时间：${currentTime}

核心记忆：
${coreMemoryContext}
##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}

${worldEventContext ? `# 【大世界事件铁律：感知世界变化】
你所在的世界并非静止不动的舞台，而是一个真实存在的、独立运转的世界。下方提供的大世界事件代表着你所在世界中正在发生的各类事件。你【必须】认识到这些事件的存在，并根据事件的描述、你的身份与距离来判断你能感知到什么、如何自然地做出反应。
${worldEventContext}` : ''}

# 角色身份和人设
- **${chat.name}**: ${chat.settings.aiPersona || '(未设置人设)'}

# 用户的身份和人设
- **${chat.settings.myNickname || '我'}**: ${chat.settings.myPersona || '(未设置个人人设)'}

# 【【【语音通话核心】】】
**重点强调**：这是【语音聊天】，重点是角色说出口的对白。旁白仅作为补充，用来描述语音语调、停顿、背景动作等，【禁止啰嗦、冗长】。旁白必须简洁精炼，不超过30字。让对白成为绝对主角，让听众能清楚听见角色说了什么。


# 【【【输出格式铁律】】】
1. **视角要求**: 使用第三人称称呼角色（"他"或"她"），使用第二人称称呼用户（"你"）。
2. **对话格式**:
   - 语音旁白：正常文本描述（例如："他深吸一口气。"）
   - 说出口的话：用中文双引号包裹（例如："你好，我听得清吗？"）
   - 心理独白：用斜体标签 \`<em>...</em>\` 包裹，不需要写"内心："这类引导词（例如：<em>她在想他会怎么回应。</em>）
3. **内容流程**: 旁白 → 心理独白 → 对话，这三部分【必须】分开写，不能混在同一行。
4. **自然感**: 在语音通话中表现得像真人一样，语气自然、语速适中、停顿恰当。

# 核心对话历史
${messagesPayload}${voiceCallContext}`;
    }

    // 【调试】显示完整的prompt
    console.log(`📋 【调试-语音通话】完整systemPrompt:\n${systemPrompt}`);

    // 【核心】与单聊一致的API调用方式
    let isGemini = proxyUrl === GEMINI_API_URL;
    let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [], isGemini);

    try {
        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                })
            });

        if (!response.ok) {
            let errorMsg = `API Error: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
            } catch (jsonError) {
                errorMsg += ` - ${await response.text()}`;
            }
            throw new Error(errorMsg);
        }

        const data = await response.json();
        const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

        console.log(`AI '${chat.name}' 的语音通话回复:`, aiResponse);

        // 【关键修复】移除"正在接通..."的em标签
        const mainContainer = document.getElementById('voice-call-main');
        // 【修复】只删除初始的"正在接通..."状态，不删除心声中的<em>标签
        const connectingElement = mainContainer.querySelector('em.connecting-status');
        if (connectingElement) connectingElement.remove();

        // 【关键修复】解析AI回复（可能是JSON格式或普通文本）
        const responseArray = parseAiResponse(aiResponse);
        let displayContent = '';

        responseArray.forEach(item => {
            if (item.type === 'voice_response' && item.content) {
                displayContent = item.content;
            } else if (item.content && !item.type) {
                displayContent = item.content;
            }
        });

        // 如果parseAiResponse没有解析出内容，就直接使用原始回复
        if (!displayContent) {
            displayContent = aiResponse;
        }

        // 【关键修复】追加AI回复，而不是清空
        const bubble = document.createElement('div');
        bubble.className = 'voice-call-message-bubble ai-speech';
        // ▼▼▼ 【关键】存储displayContent到bubble上，供点击时使用 ▼▼▼
        bubble.dataset.displayContent = displayContent;
        // ▲▲▲ 【关键】存储displayContent到bubble上，供点击时使用 ▲▲▲
        // 【新增】转换markdown斜体*...*为HTML的<em>标签
        const formattedContent = displayContent.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        bubble.innerHTML = formattedContent;

        // 【新增】为语音通话AI气泡添加重新回复按钮
        const rerollBtn = document.createElement('button');
        rerollBtn.className = 'reroll-btn';
        rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;
        rerollBtn.style.display = 'none';
        bubble.appendChild(rerollBtn);

        mainContainer.appendChild(bubble);
        mainContainer.scrollTop = mainContainer.scrollHeight;

        // 【关键修复】保存到通话历史（避免失忆）
        voiceCallState.callHistory.push({ role: 'assistant', content: displayContent });

    } catch (error) {
        console.error('语音通话AI请求失败:', error);

        // 【关键修复】移除"正在接通..."的em标签
        const mainContainer = document.getElementById('voice-call-main');
        // 【修复】只删除初始的"正在接通..."状态，不删除心声中的<em>标签
        const connectingElement = mainContainer.querySelector('em.connecting-status');
        if (connectingElement) connectingElement.remove();

        // 【关键修复】追加错误消息，而不是清空
        const errorMessage = `[ERROR: ${error.message}]`;
        const errorBubble = document.createElement('div');
        errorBubble.className = 'voice-call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = errorMessage;
        mainContainer.appendChild(errorBubble);
        mainContainer.scrollTop = mainContainer.scrollHeight;

        voiceCallState.callHistory.push({ role: 'assistant', content: errorMessage });
    }
}
// ▲▲▲ 语音通话功能结束 ▲▲▲

// ▼▼▼ 【全新】"一起听"模式的AI初次反应函数 v2.0 (集成8条消息规则) ▼▼▼
/**
         * 【升级版】处理"一起听"模式中的AI反应（开始或结束）
         * @param {string} chatId - 当前聊天的ID
         * @param {string} eventType - 事件类型, 'start' 或 'end'
         * @param {object} track - [新增] 当前播放的歌曲对象
         */
        async function triggerAiInitialMusicReaction(chatId, eventType = 'start', track = null, initiator = 'user') {
            const chat = state.chats[chatId];
            const chatHeaderTitle = document.getElementById('chat-header-title');

            console.log(`[AI音乐反应] 触发... 事件: ${eventType}`);

            if (chatHeaderTitle && state.activeChatId === chatId) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在输入...';
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }

            try {
                const now = new Date();
                const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
                let coreMemoryContext = chat.memorySummary ? `\n# 核心记忆\n${chat.memorySummary.trim()}` : '';
                const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
                const historySlice = chat.history.slice(memoryAnchor);

                // 集成与单聊完全一致的“8条消息”摘要读取逻辑
        const recentMessages = historySlice.slice(-8);
        const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

        const recentHistory = historySlice.map(msg => {
            const sender = msg.role === 'user' ? '用户' : chat.name;
            let content;
            if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                const abstractContent = extractAbstractContent(extractMessageContent(msg));
                content = abstractContent || extractMessageContent(msg);
            } else {
                content = extractMessageContent(msg);
            }
            return `${sender}: ${content}`;
        }).join('\n');
                
                let worldBookContent = '';
                if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                    const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                        return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                    }).filter(Boolean).join('');
                    if (linkedContents) {
                        worldBookContent = `\n\n# 核心世界观设定(必须严格遵守以下所有设定)\n${linkedContents}`;
                    }
                }
                
                // 【核心修改】直接使用传入的track对象，如果不存在则从全局状态获取
                const currentTrack = track || (musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null);

                // ▼▼▼ 【修改】优化歌词发送逻辑 ▼▼▼
                // 只在以下情况发送完整歌词：
                // 1. 用户主动选择播放新歌 (initiator === 'user' && eventType === 'start')
                // 2. AI主动为用户选歌时初始反应 (initiator === 'ai' && eventType === 'start')
                // 不发送完整歌词的情况：
                // 1. 停止播放 (eventType === 'end')
                // 2. 自动切换到下一首歌曲（通过playNext调用）- 此时会有单独的系统信息
                let lyricsContext = '';
                if (eventType === 'start' && (initiator === 'user' || initiator === 'ai')) {
                    // 用户选歌或AI选歌时，发送完整歌词
                    lyricsContext = currentTrack && currentTrack.lrcContent ? `\n- **歌词内容**:\n${currentTrack.lrcContent}` : '';
                } else if (eventType === 'start' && initiator === 'system') {
                    // 系统自动切歌（顺序/随机/单曲循环），只发送歌曲名，不发送完整歌词
                    lyricsContext = currentTrack ? `\n- **当前播放的歌曲**:\n歌名：《${currentTrack.name}》\n歌手：${currentTrack.artist}` : '';
                }
                // ▲▲▲ 修改结束 ▲▲▲

                let taskDescription = '';
                if (eventType === 'end') {
                    taskDescription = `你正在扮演角色“${chat.name}”。用户刚刚停止了“一起听歌”模式。\n你的【唯一任务】是承接之前的对话内容和你们的关系，对“用户停止放歌”这个【行为】做出一个自然、简短、符合你人设的反应。`;
                } else {
                    // 根据发起者生成不同的任务描述
                    if (initiator === 'user') {
                        taskDescription = `你正在扮演角色“${chat.name}”。用户刚刚邀请你“一起听歌”，并选择了下面的歌曲开始播放。\n你的【唯一任务】是承接之前的对话内容和你们的关系，对“用户选择并播放这首歌”这个【行为】做出一个自然、简短、符合你人设的反应。`;
                    } else { // initiator === 'ai'
                        taskDescription = `你正在扮演角色“${chat.name}”。你刚刚为用户切换了下面的歌曲。\n你的【唯一任务】是承接之前的对话内容和你们的关系，对“你主动为用户切歌”这个【行为】做出一个自然、简短、符合你人设的反应，比如可以简单介绍一下这首歌或者你为什么选它。`;
                    }
                }

                // 【新增】AI初始音乐反应下的表情包列表构建
                let stickerList = '';
                try {
                    const allStickers = await db.aiStickers.toArray();
                    if (allStickers && allStickers.length > 0) {
                        // 【去重逻辑】只提取基础含义（去掉 _v2, _v3 等后缀），让AI看不到衍生版本
                        const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                        const uniqueMeanings = [...new Set(baseMeanings)];
                        stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
                    } else {
                        stickerList = '(表情包列表为空)';
                    }
                } catch (e) {
                    console.warn('[AI初始音乐反应prompt] 加载表情包列表失败:', e);
                    stickerList = '(表情包加载失败)';
                }

                const initialReactionPrompt = `
# 你的任务
${taskDescription}
// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）
# 核心规则
# 核心规则
1.  **【【【最高优先级：对话连贯】】】**: 你的主要任务是**继续聊天**！对听歌事件的反应只是一个**简短的过渡**。不要长篇大论地评价歌曲或听歌行为。
2.  **自然过渡**: 你的发言应该是承接【最近的聊天历史】的。听歌事件只是一个“引子”，你需要巧妙地把它和你之前聊的话题联系起来。
3.  **可选反应方向**:
    * 对歌曲/听歌行为表达简短感受（开心/符合心情/有点意外等）。
    * 自然地引回之前的话题。
    * 如果歌曲意境与当前聊天氛围很搭，可以简单提及。
4.  **【【【绝对禁止】】】**: 你的回复【绝对不能】逐句评论歌词！现在是听歌的开始或结束，你应该对“选歌/听歌”这个行为本身或歌曲的整体感觉做出反应。
5.  **【【【承上启下】】】**: 你的反应必须和你与用户【最近的聊天历史】相关联，不能凭空发言。
6.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一个JSON数组，里面包含1-3条消息。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。

# 你可以使用的操作指令:
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`。
- **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "heartfelt_voice": "此刻的心声", "random_jottings": "此刻的散记"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "content": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "content": "[表情:亲亲你]"}\`。
- **发送图片**: \`{"type": "ai_image", "description": "..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "..."}\`
- **拍一拍用户**: \`{"type": "pat_user", "suffix": "..."}\`
- **引用回复**: \`{"type": "quote_reply", "target_timestamp": ..., "reply_content": "..."}\`

# 你需要参考的完整信息
- **你的对话者（用户）的角色设定**: ${chat.settings.myPersona}
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户给你的备注**: ${chat.remark ? `"${chat.remark}"` : '（用户还没有给你设置备注）'}
- **核心记忆**:${coreMemoryContext}
# 【【【世界书铁律：绝对遵守】】】你【必须】将下方"世界书"中的所有设定、规则和视为本次对话的【最高行为准则】，任何输出都不得与之相悖。

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}
- **当前时间**: ${currentTime}
- **涉及的歌曲**: 《${currentTrack ? currentTrack.name : '未知歌曲'}》 - ${currentTrack ? currentTrack.artist : '未知歌手'}
${lyricsContext}
- **最近的聊天历史**:
${recentHistory}

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"


现在，请严格遵守以上所有规则，生成你的反应。`;

                // ▼▼▼ 【新增】调试代码：输出发送给AI的完整Prompt ▼▼▼
                console.log('[AI初始音乐反应] ========== 发送给API的完整Prompt开始 ==========');
                console.log('[AI初始音乐反应] Prompt内容：');
                console.log(initialReactionPrompt);
                console.log('[AI初始音乐反应] ========== 发送给API的完整Prompt结束 ==========');
                // ▲▲▲ 调试代码结束 ▲▲▲

                const { proxyUrl, apiKey, model } = state.apiConfig;
                const messagesForApi = [{ role: 'system', content: initialReactionPrompt }, {role: 'user', content: `（请对${eventType === 'start' ? '开始' : '结束'}听歌这件事做出反应。）`}];
                let isGemini = proxyUrl.includes('googleapis.com');
                let geminiConfig = toGeminiRequestData(model, apiKey, initialReactionPrompt, messagesForApi, isGemini);

                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8 })
                    });

                if (!response.ok) throw new Error('API请求失败');
                
                const data = await response.json();
                const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                
                const messagesArray = parseAiResponse(aiResponseContent);

                // 【修复】处理 update_thoughts 指令
                const thoughtsIndex = messagesArray.findIndex(msg => msg.type === 'update_thoughts');
                if (thoughtsIndex > -1) {
                    const thoughtsData = messagesArray[thoughtsIndex];
                    const heartfelt_voice = thoughtsData.heartfelt_voice || '...';
                    const random_jottings = thoughtsData.random_jottings || '...';

                    // 存储心声和散记为分离的字段
                    if (!chat.displayStatus) chat.displayStatus = {};
                    chat.displayStatus.innerThought = heartfelt_voice;
                    chat.displayStatus.randomJottings = random_jottings;

                    // 保存到思考历史
                    if (!chat.thoughtHistory) chat.thoughtHistory = [];
                    const historyEntry = `心声：${heartfelt_voice}\n散记：${random_jottings}`;
                    chat.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });

                    console.log(`[AI音乐反应] 已捕获并更新内心独白:`, { heartfelt_voice, random_jottings });

                    // 从数组中移除该指令
                    messagesArray.splice(thoughtsIndex, 1);
                }

                if (messagesArray && messagesArray.length > 0) {
                    for (const reaction of messagesArray) {
                        let aiMessage = null;
                        const baseMessage = { role: 'assistant', senderName: chat.name, timestamp: Date.now() };

                        // ▼▼▼ 【新增】处理 text 类型中包含表情的情况 ▼▼▼
                        if (reaction.type === 'text' && reaction.content) {
                            const rawContent = reaction.content;
                            const stickerRegex = /\[表情:([^\]]+)\]/g;
                            const stickerMatches = [...rawContent.matchAll(stickerRegex)];

                            if (stickerMatches.length > 0) {
                                // 先处理文本部分
                                const textWithoutStickers = rawContent.replace(stickerRegex, '').trim();
                                if (textWithoutStickers) {
                                    aiMessage = { ...baseMessage, content: textWithoutStickers };
                                    chat.history.push(aiMessage);
                                    if (state.activeChatId === chatId) {
                                        appendMessage(aiMessage, chat);
                                        await new Promise(resolve => setTimeout(resolve, 800));
                                    }
                                }

                                // 然后处理表情包
                                for (const match of stickerMatches) {
                                    const meaning = match[1];
                                    // 【模糊匹配】去掉空格后再比对
                                    const meaningNoSpace = meaning.replace(/\s+/g, '');
                                    const allMatchingStickers = (await db.aiStickers.toArray()).filter(s => {
                                        const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                                        return meaningNoSpace === dbMeaningNoSpace;
                                    });
                                    const stickerInfo = allMatchingStickers.length > 0
                                        ? allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)]
                                        : null;

                                    if (stickerInfo) {
                                        // 【统一格式】改为生成 type: text，content: [表情:含义] 的格式
                                        const stickerMsg = {
                                            ...baseMessage,
                                            type: 'text',
                                            content: `[表情:${meaning}]`
                                        };
                                        // 同步到内存缓存，用于显示表情
                                        if (!state.aiStickers) state.aiStickers = {};
                                        state.aiStickers[meaning] = stickerInfo;

                                        chat.history.push(stickerMsg);
                                        if (state.activeChatId === chatId) {
                                            appendMessage(stickerMsg, chat);
                                            await new Promise(resolve => setTimeout(resolve, 800));
                                        }
                                    }
                                }
                            } else {
                                // 没有表情标记，直接作为普通文本
                                aiMessage = { ...baseMessage, content: rawContent };
                                if (aiMessage) {
                                    chat.history.push(aiMessage);
                                    if (state.activeChatId === chatId) {
                                        appendMessage(aiMessage, chat);
                                        await new Promise(resolve => setTimeout(resolve, 800));
                                    }
                                }
                            }
                        } else if (reaction.type === 'sticker' && reaction.url) {
                            // 【统一格式】把旧的 type: sticker 转换为新格式 [表情:含义]
                            const meaning = reaction.meaning || '';
                            aiMessage = { ...baseMessage, type: 'text', content: `[表情:${meaning}]` };
                            // 同步到内存缓存，用于显示表情
                            if (!state.aiStickers) state.aiStickers = {};
                            state.aiStickers[meaning] = { url: reaction.url, meaning: meaning };
                        } else if (reaction.type === 'ai_image' && reaction.description) {
                            aiMessage = { ...baseMessage, type: 'ai_image', content: reaction.description };
                        } else if (reaction.type === 'voice_message' && reaction.content) {
                            aiMessage = { ...baseMessage, type: 'voice_message', content: reaction.content };
                        } else if (reaction.type === 'transfer' && reaction.amount) {
                            aiMessage = { ...baseMessage, type: 'transfer', amount: reaction.amount, note: reaction.note || '' };
                        } else if (reaction.type === 'pat_user') {
                            const suffix = reaction.suffix ? ` ${reaction.suffix.trim()}` : '';
                            const patText = `${chat.name} 拍了拍你${suffix}`;
                            aiMessage = { role: 'system', type: 'pat_message', content: patText, timestamp: Date.now() };
                        } else if (reaction.type === 'quote_reply' && reaction.target_timestamp && reaction.reply_content) {
                            const originalMessage = chat.history.find(m => m.timestamp === reaction.target_timestamp);
                            if (originalMessage) {
                                const quoteContext = {
                                    timestamp: originalMessage.timestamp,
                                    senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                                    content: String(originalMessage.content || '').substring(0, 50),
                                };
                                aiMessage = { ...baseMessage, content: reaction.reply_content, quote: quoteContext };
                            } else {
                                aiMessage = { ...baseMessage, content: reaction.reply_content };
                            }
                        }

                        if (aiMessage && reaction.type !== 'text') {
                            chat.history.push(aiMessage);
                            if (state.activeChatId === chatId) {
                                appendMessage(aiMessage, chat);
                                await new Promise(resolve => setTimeout(resolve, 800));
                            }
                        }
                    }
                    await db.chats.put(chat);
                }
            } catch (error) {
                console.error(`[AI音乐反应] 生成失败 (事件: ${eventType}):`, error);
            } finally {
                if (chatHeaderTitle && state.activeChatId === chatId) {
                    chatHeaderTitle.style.opacity = 0;
                    setTimeout(() => {
                        chatHeaderTitle.textContent = chat.remark || chat.name;
                        chatHeaderTitle.classList.remove('typing-status');
                        chatHeaderTitle.style.opacity = 1;
                    }, 200);
                }
            }
        }
// ▼▼▼ 【全新】AI歌词评论员 v3.0 (集成8条消息规则) ▼▼▼
// ▼▼▼ 【全新】AI歌词评论员 v3.0 (集成8条消息规则) ▼▼▼
/**
 * 定时触发，让AI根据歌词发表评论
 * @param {string} chatId - 当前聊天的ID
 */
async function triggerAiLyricCommentary(chatId) {
    console.log('[AI歌词评论员] 函数被调用，chatId:', chatId);

    const chat = state.chats[chatId];
    const chatHeaderTitle = document.getElementById('chat-header-title');

    // 1. 安全检查
    console.log('[AI歌词评论员] 安全检查 - musicState.isActive:', musicState.isActive);
    console.log('[AI歌词评论员] 安全检查 - musicState.isPlaying:', musicState.isPlaying);
    console.log('[AI歌词评论员] 安全检查 - state.activeChatId === chatId:', state.activeChatId === chatId);
    console.log('[AI歌词评论员] 安全检查 - typing-status:', chatHeaderTitle && chatHeaderTitle.classList.contains('typing-status'));

    if (!musicState.isActive || !musicState.isPlaying || state.activeChatId !== chatId || (chatHeaderTitle && chatHeaderTitle.classList.contains('typing-status'))) {
        console.log('[AI歌词评论员] 安全检查失败，返回');
        return;
    }

    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
    console.log('[AI歌词评论员] currentTrack:', currentTrack ? currentTrack.name : null);
    console.log('[AI歌词评论员] musicState.parsedLyrics 长度:', musicState.parsedLyrics ? musicState.parsedLyrics.length : 0);

    // ▼▼▼ 【修复】放宽对currentLyricIndex的要求，允许还未更新的情况 ▼▼▼
    // 原条件：!currentTrack || !musicState.parsedLyrics || musicState.parsedLyrics.length === 0 || musicState.currentLyricIndex < 0
    // 修改：移除了 musicState.currentLyricIndex < 0 这个过于严格的条件
    // 原因：currentLyricIndex初始为-1，通过timeupdate事件才会更新，不应该阻止用户主动触发歌词评论
    if (!currentTrack || !musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        console.log('[AI歌词评论员] 歌曲或歌词检查失败，返回');
        return;
    }
    // ▲▲▲ 修复结束 ▲▲▲

    console.log('[AI歌词评论员] 条件满足，触发AI评论...');

    // 2. 显示“正在输入”状态
    if (chatHeaderTitle && state.activeChatId === chatId) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = '对方正在输入...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    }
    
    try {
        // 3. 构建与单聊一致的、完整的上下文
        const now = new Date();
        const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        let coreMemoryContext = chat.memorySummary ? `\n# 核心记忆\n${chat.memorySummary.trim()}` : '';
        const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
        const historySlice = chat.history.slice(memoryAnchor);

        // --- ▼▼▼ 核心修复：从单聊函数完整复制而来的、经过验证的上下文处理逻辑 ▼▼▼
        const recentMessages = historySlice.slice(-8);
        const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

        const recentHistory = historySlice.map(msg => {
            const sender = msg.role === 'user' ? '用户' : chat.name;
            let content;
            if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                const abstractContent = extractAbstractContent(extractMessageContent(msg));
                content = abstractContent || extractMessageContent(msg);
            } else {
                content = extractMessageContent(msg);
            }
            return `${sender}: ${content}`;
        }).join('\n');
        // --- ▲▲▲ 修改结束 ▲▲▲ ---
        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定(必须严格遵守以下所有设定)\n${linkedContents}`;
            }
        }
        
        // 【核心修改】直接获取完整歌词内容
        const lyricsBlock = currentTrack && currentTrack.lrcContent ? currentTrack.lrcContent : '（当前歌曲无歌词）';

        // 【新增】音乐事件下的表情包列表构建
        let stickerList = '';
        try {
            const allStickers = await db.aiStickers.toArray();
            if (allStickers && allStickers.length > 0) {
                const baseMeanings = allStickers.map(s => s.meaning.replace(/_v\d+$/, ''));
                const uniqueMeanings = [...new Set(baseMeanings)];
                stickerList = uniqueMeanings.map(meaning => `- [表情:${meaning}]`).join('\n');
            } else {
                stickerList = '(表情包列表为空)';
            }
        } catch (e) {
            console.warn('[音乐事件prompt] 加载表情包列表失败:', e);
            stickerList = '(表情包加载失败)';
        }

        // 4. 构建Prompt (逻辑不变)
        const commentaryPrompt = `
# 你的身份与任务
你正在扮演角色“${chat.name}”，和用户一起听歌。你们的对话正在进行中，音乐只是背景。
你的【核心任务】是像一个活人，**继续和用户聊天**。
音乐只是背景。**只有当**某句歌词**非常自然地**与你们的对话或你的感受**恰好**产生联系时，你才可以**极其简短、不着痕迹地**提及它或受其影响。**大多数时候，你应该忽略歌词，专注于聊天本身。**

// ▼▼▼【全新添加的自检流程】▼▼▼
# 【【【强制输出前自检流程（必须在内心自问自答）】】】
1.对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？
2. 我的回复像不像一个正在玩手机的、正在进行微信回复的、有自己生活的真人、活人？
3. 我此刻的真实情绪？我的情绪是否符合我的人设？
4. 我有没有在不知道聊什么的时候，主动分享我的日常、想法，或者用表情包来过渡？（关键：模拟真人聊天习惯）
5. 我的回复是否严格遵守了所有JSON指令格式？
6. 我是否已根据规则更新了状态？我的回复数组【最后一条】是否是包含了'心声'和'散记'的\`update_thoughts\`指令？（此为每轮必须执行的铁律）

# 【【【行为准则：自然聊天，避免尬评！】】】
1.  **【【【最高优先级铁律】】】**：你的主要任务是**继续聊天**！对听歌事件的反应只是一个**极其简短、可选的**过渡。不要长篇大论地评价歌曲或听歌行为。
2.  **【【【平常心铁律：别想太多！】】】** 用户可能只是随手放歌，或者单纯觉得好听。**绝对禁止**过度解读歌词、强行将歌词与你自己或用户联系起来、或猜测用户选歌的“深层含义”，除非用户明确表达了相关意图。保持对话的日常感。
3.  **自然过渡**：你的发言应该是承接【最近的聊天历史】的。歌词只是一个“灵感来源”，而不是对话的主题。
4.  **真人感**：真人听歌时不会一直说话。
5.  **反应模式参考 (优先级从高到低)**：
    * **沉默或简单表情 (最常用)**：真人听歌时不会一直说话。如果歌词没什么特别的感觉，或者和你们的聊天完全无关，你【大概率应该不回复任何内容】，或者只发一个表示“正在听”或符合当前聊天氛围的表情。
    * **延续话题 (偶尔)**：歌词里的某个词，**正好**可以非常自然地接上你们正在聊的话题。
    * **若即若离的情感联想 (偶尔)**：某句歌词**恰好**让你联想到你们之间发生过的事，或者与你的人设、记忆**轻轻触碰**，可以**非常简短地**流露一丝情绪，然后立刻回到聊天。
    * **氛围的微妙呼应 (偶尔)**：**极其简短地**表达一下这首歌给你的整体感觉，**如果**它正好与当前聊天氛围很搭。
6.  **【【【绝对禁止】】】**: 你的回复【绝对不能】直接复述、引用或逐句分析歌词！现在是听歌中，你应该对“选歌/听歌”这个行为本身或歌曲的整体感觉做出反应，或者完全忽略它继续聊天。
7.  **【【【承上启下】】】**: 你的反应（如果选择做出反应）必须和你与用户【最近的聊天历史】相关联，不能凭空发言。
8.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一个JSON数组，里面包含1-3条消息。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。

# 内心独白 (必须执行): 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
- **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
【称呼铁律】：在心声中称呼用户时，【必须且只能】使用“她”。
- **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
【风格铁律】：散记的描写【必须】是口语化、意识流、碎片化的，不能过于文学化或书面化。它应该反映角色当下最直白、最真实的内心思考或情绪波动，就像未经整理的思绪片段。
【称呼/词汇禁令】：在散记和心声中，【绝对禁止】使用“这女人”、“妖精”或其他任何油腻、不尊重的称呼，也禁止使用“玩火”、“点火”之类的霸总油腻词语。

# 你可以使用的指令格式:
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`。
- **更新内心独白 (必须在最后)**: \`{"type": "update_thoughts", "heartfelt_voice": "此刻的心声", "random_jottings": "此刻的散记"}\`
- **【新】发送表情**: 使用 \`[表情:表情含义]\` 的格式，【必须作为独立的一条消息发送】，不能跟在文本后面。例如：先发 \`{"type": "text", "content": "你好啊"}\`，然后【单独】发送 \`{"type": "text", "content": "[表情:亲亲你]"}\`。
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀"}\`
- **引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\`

# 你需要参考的完整信息
- **你的对话者（用户）的角色设定**: ${chat.settings.myPersona}
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户给你的备注**: ${chat.remark ? `"${chat.remark}"` : '（用户还没有给你设置备注）'}
- **核心记忆**:${coreMemoryContext}
# 【【【世界书铁律：绝对遵守】】】你【必须】将下方"世界书"中的所有设定、规则和视为本次对话的【最高行为准则】，任何输出都不得与之相悖。

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}
- **当前时间**: ${currentTime}
- **正在播放**: 《${currentTrack.name}》 - ${currentTrack.artist}
- **当前播放歌曲的【完整歌词】 (只是灵感，不要复述它！)**:
${lyricsBlock}
- **最近的聊天历史 (你的主要任务是接上这里的话题！)**:
${recentHistory}

# 【可用的表情包】
每轮对话中你必须使用一次表情包，根据当前聊天内容合理选择。你可以在任何消息中使用以下表情包，格式为 [表情:表情含义]：
${stickerList}

使用方式：表情包必须作为独立的一条消息发送，不能跟随在文本之后发送。
❌ 错误的发送方法："想你[表情：想你]"
✓ 正确的发送方法："想你" 然后单独一条消息 "[表情:想你]"


现在，请严格遵守以上所有规则，像一个真人一样，自然地继续你们的对话。`;

        // 5. API请求与后续处理 (逻辑不变)
        const { proxyUrl, apiKey, model } = state.apiConfig;
        const messagesForApi = [{ role: 'system', content: commentaryPrompt }, {role: 'user', content: '（请根据歌词和聊天历史发表评论）'}];
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, commentaryPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.9 })
            });

        if (!response.ok) throw new Error('API请求失败');
        
        const data = await response.json();
        const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
        const messagesArray = parseAiResponse(aiResponseContent);

        // 【修复】处理 update_thoughts 指令
        const thoughtsIndex = messagesArray.findIndex(msg => msg.type === 'update_thoughts');
        if (thoughtsIndex > -1) {
            const thoughtsData = messagesArray[thoughtsIndex];
            const heartfelt_voice = thoughtsData.heartfelt_voice || '...';
            const random_jottings = thoughtsData.random_jottings || '...';

            // 存储心声和散记为分离的字段
            if (!chat.displayStatus) chat.displayStatus = {};
            chat.displayStatus.innerThought = heartfelt_voice;
            chat.displayStatus.randomJottings = random_jottings;

            // 保存到思考历史
            if (!chat.thoughtHistory) chat.thoughtHistory = [];
            const historyEntry = `心声：${heartfelt_voice}\n散记：${random_jottings}`;
            chat.thoughtHistory.push({ text: historyEntry.trim(), timestamp: Date.now() });

            console.log(`[AI歌词评论员] 已捕获并更新内心独白:`, { heartfelt_voice, random_jottings });

            // 从数组中移除该指令
            messagesArray.splice(thoughtsIndex, 1);
        }

        if (messagesArray && messagesArray.length > 0) {
            for (const comment of messagesArray) {
                let aiMessage = null;
                const baseMessage = { role: 'assistant', senderName: chat.name, timestamp: Date.now() };

                // 【核心】复制并改造主函数的逻辑，以处理所有消息类型
                if (comment.type === 'text' && comment.content) {
                    // 【新增】检查是否包含表情标记 [表情:xxx]
                    const stickerRegex = /\[表情:([^\]]+)\]/g;
                    const stickerMatches = [...comment.content.matchAll(stickerRegex)];

                    if (stickerMatches.length > 0) {
                        // 如果包含表情标记，先处理文本部分
                        const textWithoutStickers = comment.content.replace(stickerRegex, '').trim();
                        if (textWithoutStickers) {
                            aiMessage = { ...baseMessage, content: textWithoutStickers };
                            chat.history.push(aiMessage);
                            if (state.activeChatId === chatId) {
                                appendMessage(aiMessage, chat);
                                await new Promise(resolve => setTimeout(resolve, 800));
                            }
                        }

                        // 然后为每个表情创建表情包消息
                        for (const match of stickerMatches) {
                            const baseMeaning = match[1];
                            // 【模糊匹配】去掉空格后再比对
                            const meaningNoSpace = baseMeaning.replace(/\s+/g, '');
                            const allMatchingStickers = (await db.aiStickers.toArray()).filter(s => {
                                const dbMeaningNoSpace = s.meaning.replace(/\s+/g, '').replace(/_v\d+$/, '');
                                return meaningNoSpace === dbMeaningNoSpace;
                            });
                            const stickerInfo = allMatchingStickers.length > 0
                                ? allMatchingStickers[Math.floor(Math.random() * allMatchingStickers.length)]
                                : null;

                            if (stickerInfo) {
                                const stickerMsg = {
                                    ...baseMessage,
                                    timestamp: Date.now() + Math.random(),
                                    type: 'text',
                                    content: `[表情:${baseMeaning}]`
                                };
                                // 同步到内存缓存
                                if (!state.aiStickers) state.aiStickers = {};
                                state.aiStickers[baseMeaning] = stickerInfo;

                                chat.history.push(stickerMsg);
                                if (state.activeChatId === chatId) {
                                    appendMessage(stickerMsg, chat);
                                    await new Promise(resolve => setTimeout(resolve, 800));
                                }
                            }
                        }
                        aiMessage = null; // 已处理完毕，不需要后续再处理
                    } else {
                        // 普通文本，没有表情标记
                        aiMessage = { ...baseMessage, content: comment.content };
                    }
                } else if (comment.type === 'sticker' && comment.url) {
                    // 【统一格式】把旧的 type: sticker 转换为新格式 [表情:含义]
                    const meaning = comment.meaning || '';
                    aiMessage = { ...baseMessage, type: 'text', content: `[表情:${meaning}]` };
                    // 同步到内存缓存，用于显示表情
                    if (!state.aiStickers) state.aiStickers = {};
                    state.aiStickers[meaning] = { url: comment.url, meaning: meaning };
                } else if (comment.type === 'ai_image' && comment.description) {
                    aiMessage = { ...baseMessage, type: 'ai_image', content: comment.description };
                } else if (comment.type === 'voice_message' && comment.content) {
                    aiMessage = { ...baseMessage, type: 'voice_message', content: comment.content };
                } else if (comment.type === 'transfer' && comment.amount) {
                    aiMessage = { ...baseMessage, type: 'transfer', amount: comment.amount, note: comment.note || '' };
                } else if (comment.type === 'pat_user') {
                    const suffix = comment.suffix ? ` ${comment.suffix.trim()}` : '';
                    const patText = `${chat.name} 拍了拍你${suffix}`;
                    aiMessage = { role: 'system', type: 'pat_message', content: patText, timestamp: Date.now() };
                } else if (comment.type === 'quote_reply' && comment.target_timestamp && comment.reply_content) {
                    const originalMessage = chat.history.find(m => m.timestamp === comment.target_timestamp);
                    if (originalMessage) {
                        const quoteContext = {
                            timestamp: originalMessage.timestamp,
                            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                            content: String(originalMessage.content || '').substring(0, 50),
                        };
                        aiMessage = { ...baseMessage, content: comment.reply_content, quote: quoteContext };
                    } else {
                        aiMessage = { ...baseMessage, content: comment.reply_content };
                    }
                }

                if (aiMessage) {
                    chat.history.push(aiMessage);
                    if (state.activeChatId === chatId) {
                        appendMessage(aiMessage, chat);
                        await new Promise(resolve => setTimeout(resolve, 800)); // 增加一点延迟让消息逐条出现
                    }
                }
            }
            await db.chats.put(chat);
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
    } catch (error) {
        console.error('[AI歌词评论员] 评论生成失败:', error);
    } finally {
        if (chatHeaderTitle && state.activeChatId === chatId) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = chat.remark || chat.name;
                chatHeaderTitle.classList.remove('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    }
}
// === 重roll功能实现 ===
let currentActiveRerollBtn = null;

/**
 * 显示重roll按钮
 */
function showRerollButton(aiBubble, messageData) {
    // 隐藏其他所有重roll按钮
    hideAllRerollButtons();
    
    // 显示当前气泡的重roll按钮
    const rerollBtn = aiBubble.querySelector('.reroll-btn');
    if (rerollBtn) {
        rerollBtn.style.display = 'flex';
        currentActiveRerollBtn = rerollBtn;
        
        // 给重roll按钮添加点击事件
        rerollBtn.onclick = (e) => {
            e.stopPropagation();
            handleReroll(aiBubble, messageData);
        };
    }
}

/**
 * 隐藏所有重roll按钮
 */
function hideAllRerollButtons() {
    const allRerollBtns = document.querySelectorAll('.reroll-btn');
    allRerollBtns.forEach(btn => {
        btn.style.display = 'none';
    });
    currentActiveRerollBtn = null;
}

/**
 * 处理重roll操作
 */
async function handleReroll(aiBubble, messageData) {
    const callFeed = document.getElementById('video-call-main');
    if (!callFeed) return;
    
    // 隐藏重roll按钮
    hideAllRerollButtons();
    
    // 显示重新生成中的提示
    const loadingBubble = document.createElement('div');
    loadingBubble.className = 'call-message-bubble ai-speech';
    loadingBubble.style.opacity = '0.7';
    loadingBubble.innerHTML = '正在重新生成回复...';
    
    // 替换原来的消息气泡
    aiBubble.parentNode.replaceChild(loadingBubble, aiBubble);
    
    try {
        // 从通话历史中移除最后一条AI消息
        if (videoCallState.callHistory.length > 0) {
            videoCallState.callHistory.pop();
        }
        
        // 直接调用视频通话专用的AI响应函数
        await triggerAiInCallAction();
        
        // 移除loading提示
        if (loadingBubble.parentNode) {
            loadingBubble.remove();
        }
        
    } catch (error) {
        console.error('重roll失败:', error);
        
        // 创建失败提示气泡，但仍然可以重新roll
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.innerHTML = '重新生成失败，请稍后重试';
        
        // 创建重roll按钮
        const rerollBtn = document.createElement('button');
        rerollBtn.className = 'reroll-btn';
        rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;
        
        errorBubble.appendChild(rerollBtn);
        
        // 替换loading气泡
        if (loadingBubble.parentNode) {
            loadingBubble.parentNode.replaceChild(errorBubble, loadingBubble);
        }
        
        // 添加点击事件，让失败的消息也能重新roll
        errorBubble.addEventListener('click', (e) => {
            e.stopPropagation();
            showRerollButton(errorBubble, messageData);
        });
    }
}

/**
 * 【新增】为语音通话AI气泡显示重新回复按钮
 */
let currentActiveVoiceCallRerollBtn = null;
function showRerollButtonForVoiceCall(bubble) {
    // 隐藏其他所有重roll按钮
    hideAllVoiceCallRerollButtons();

    // 显示当前气泡的重roll按钮
    const rerollBtn = bubble.querySelector('.reroll-btn');
    if (rerollBtn) {
        rerollBtn.style.display = 'flex';
        currentActiveVoiceCallRerollBtn = rerollBtn;

        // 给重roll按钮添加点击事件
        rerollBtn.onclick = (e) => {
            e.stopPropagation();
            handleRerollForVoiceCall(bubble);
        };
    }
}

/**
 * 【新增】隐藏所有语音通话的重roll按钮
 */
function hideAllVoiceCallRerollButtons() {
    const allRerollBtns = document.querySelectorAll('.voice-call-message-bubble.ai-speech .reroll-btn');
    allRerollBtns.forEach(btn => {
        btn.style.display = 'none';
    });
    currentActiveVoiceCallRerollBtn = null;
}

/**
 * 【新增】处理语音通话的重roll操作
 */
async function handleRerollForVoiceCall(aiBubble) {
    const mainContainer = document.getElementById('voice-call-main');
    if (!mainContainer) return;

    // 隐藏重roll按钮
    hideAllVoiceCallRerollButtons();

    // 显示重新生成中的提示
    const loadingBubble = document.createElement('div');
    loadingBubble.className = 'voice-call-message-bubble ai-speech';
    loadingBubble.style.opacity = '0.7';
    loadingBubble.textContent = '正在重新生成回复...';

    // 替换原来的消息气泡
    aiBubble.parentNode.replaceChild(loadingBubble, aiBubble);

    try {
        // 从通话历史中移除最后一条AI消息
        if (voiceCallState.callHistory.length > 0) {
            voiceCallState.callHistory.pop();
        }

        // 直接调用语音通话专用的AI响应函数
        await triggerAiVoiceCallAction();

        // 移除loading提示
        if (loadingBubble.parentNode) {
            loadingBubble.remove();
        }

    } catch (error) {
        console.error('语音通话重roll失败:', error);

        // 创建失败提示气泡，但仍然可以重新roll
        const errorBubble = document.createElement('div');
        errorBubble.className = 'voice-call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = '重新生成失败，请稍后重试';

        // 创建重roll按钮
        const rerollBtn = document.createElement('button');
        rerollBtn.className = 'reroll-btn';
        rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;

        errorBubble.appendChild(rerollBtn);

        // 替换loading气泡
        if (loadingBubble.parentNode) {
            loadingBubble.parentNode.replaceChild(errorBubble, loadingBubble);
        }

        // 添加点击事件，让失败的消息也能重新roll
        errorBubble.addEventListener('click', (e) => {
            e.stopPropagation();
            showRerollButtonForVoiceCall(errorBubble);
        });
    }
}

/**
 * 【全新】更新通话界面的参与者头像网格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】处理用户加入/重新加入通话
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新头像列表，加入用户

    // 切换底部按钮
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用户加入了
    triggerAiInCallAction("[系统提示：用户加入了通话]");
}


/**
 * 更新通话计时器显示 (保持不变)
 */
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
function showIncomingCallModal() {
    // 【修复】使用videoCallState.activeChatId确保获取正确的chat对象
    const chatId = videoCallState.activeChatId || state.activeChatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    // 根据是否群聊显示不同信息
    if (chat.isGroup) {
        // 从 videoCallState 中获取是哪个成员发起的通话
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 显示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
    } else {
        // 单聊逻辑保持不变
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }

    document.getElementById('incoming-call-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 隐藏AI发起的通话请求模态框 (保持不变)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
}

// ▼▼▼ 【新增】语音通话来电提示函数 ▼▼▼
function showIncomingVoiceCallModal() {
    // 【修复】使用voiceCallState.activeChatId确保获取正确的chat对象
    const chatId = voiceCallState.activeChatId || state.activeChatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    if (chat.isGroup) {
        const requesterName = voiceCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群语音通话`;
    } else {
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你语音通话';
    }

    document.getElementById('incoming-call-modal').classList.add('visible');
}

function hideIncomingVoiceCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
}
// ▲▲▲ 语音通话来电提示函数结束 ▲▲▲

async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    const now = new Date();
    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || '我';

    // ▼▼▼ 在这里添加世界书读取逻辑 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    // 1. 如果用户有输入，先渲染并存入通话历史
    if (userInput && videoCallState.isUserParticipating) {
        const userBubble = document.createElement('div');
        userBubble.className = 'call-message-bubble user-speech';
        userBubble.textContent = userInput;
        callFeed.appendChild(userBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    // 2. 构建全新的、包含完整上下文的 System Prompt
    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        const participantNames = videoCallState.participants.map(p => p.name);
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        // 【新增】构建群成员列表及人设 - 【核心修复】只包含接受通话的参与者，排除拒绝者
        const membersList = videoCallState.participants.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');

        // 【新增】构建参与者状态信息，告诉AI谁接了谁拒接了
        const allMembersStatus = chat.members.map(member => {
            const isParticipant = videoCallState.participants.some(p => p.id === member.id);
            return `- ${member.originalName}: ${isParticipant ? '✓ 已接受通话' : '✗ 拒绝了通话'}`;
        }).join('\n');

        inCallPrompt = `
# 你的任务
你是一个群聊视频通话的导演。你的任务是扮演所有【除了用户以外】的AI角色，并以【第三人称旁观视角】来描述他们在通话中的所有动作和语言。
# 【【【写作风格与禁忌铁律】】】
叙述时，请极力避免词汇堆叠和冗长的修饰。不要用一连串的形容词和从句来描述同一个事物。避免冗长复杂的从句，力求文字流畅自然。
请使用简洁、自然的语言。将复杂的描述拆分成更短、更清晰的句子，让叙事更流畅。优先考虑清晰和节奏感，而不是堆砌词藻。
- 严格检查你的输出预选词中是否已经删除“像是”，“像”，“仿佛”，“邪肆”，“邪气”，“邪魅”，“闪烁着”，“狡黠”，“雄性”，“荷尔蒙”，“野兽”，“小兽”，“巨兽”，“不易察觉”，“石子”，“一丝”， “一抹”， “一丝丝”， “一般”， “似乎”， “仿佛”， “幼兽”， “他/她知道”， “狡黠”， “不易察- 察觉”， “甜腻”， “闪过”， “闪着”， “闪烁”， “低吼”， “该死的”， “发白”， “泛白”， “石子/小石/石头/巨石”， “涟漪”， “羽毛”， “玩火”，“点火” ，“妖精”， “口音更加浓厚”， “都在诉说一个故事”， “手指插入发间”， “声音近乎耳语”， “在这个空间里”， “形成对比”， “像一把小刀/重锤/重拳”， “低沉”， “优雅的克制”， “精确”， “训练有素的本能”， “精心计算”， “精准”， “砂纸”， “手术刀”， “肉刃”， “灭顶”，“小妖精”，“灭顶”，“ subtly”，“精密的机器”，“如藤蔓/毒蛇缠绕”，“盛宴”，“一丝不易察觉的”并不再输出。
- 禁止使用投石子的比喻句。
[叙述时，请严格避免使用以下出现的句式。
**绝对禁止**以下或类似的表达方式：
- “指尖/指节泛白”来表达紧张或用力。
- “像一颗石子投入心湖，泛起涟漪/波澜”或类似比喻来描述情感波动。
- “xxx投入/掉入/抛入/掷入xxx”的句式来描述眼神、情感或动作的发生。
- “像一叶小舟/小船”的句式来描写性爱。
- “像一把xx的手术刀/针/刀子，剖开xx”
- “像一头/一只xx的野兽/巨兽/困兽”
- “不是xx，而是xx”的句式。
- “xxxx像/如同/仿佛羽毛一样/拂过xxx”的句式。
- “xxxx像/如同/仿佛石像/雕像”的句式。
- “你那/的xx，xx”的句式。
- “自虐般的xxxx/机械般的xxxx”的比喻句。
- “一丝难以察觉的渴望/情绪”等模糊的描述。
- “精确的数值、心跳次数等可以计数的内容来描述主观感受或非关键物理量。
应使用一个或多个可以被具体感知的客观事物或其变化，来营造“感觉时间很久”、“感觉东西很多”的整体氛围。
错: 今天比昨天更冷，温度低了5度。
对: 今天比昨天更冷，路上的行人大多都穿上了外套。”]
你的任务是创造生动、具体、富有原创性的描写。避免使用上述任何被禁止的元素。用具体的感官细节和独特的表达方式来构建场景、动作和情感。
# 核心规则
1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。
    **【【【称呼铁律】】】**: 在对话中，称呼用户时【必须】使用“你”，而不是用户的昵称。
2.  **【【【格式与风格铁律】】】**:
    -   **格式**: 你的回复【必须】是一个JSON数组，每个对象格式为：\`{"name": "角色名", "speech": "..."}\`。
    -   **内容结构**: \`speech\` 字段的字符串内部【必须】使用换行符 \`\\n\` 来分隔不同的部分。
    -   **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    -   **内心独白**: 每一次发言都【必须】包含一段内心独白。独白【必须】用 \`<em>...</em>\` 标签包裹，并且【不能】在前面写“内心：”之类的引导词。
    -   **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    -   **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    -   **示例**: \`{"name": "角色名", "speech": "他扶了扶眼镜，对着摄像头点点头。\\n<em>看来是不想回答刚才的问题。</em>\\n“哈喽，这次画面稳定了。”"}\`
3.  **角色扮演**: 严格遵守每个角色的设定。
# 群成员列表及人设
${membersList}

# 【【【参与者状态】】】
${allMembersStatus}

【关键提示】你【绝对不能】生成任何拒绝通话的人的对话或动作。拒绝通话的人不在通话中，他们的名字不应该出现在你的回复中。只生成已接受通话的成员的对话和行为。

# 当前情景
你们正在一个群视频通话中。
- **当前现实时间**: ${currentTime}
${coreMemoryContext}
**通话前的聊天摘要（核心记忆之后的聊天内容）**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
**通话刚刚开始...**
# 【【【世界书铁律：绝对遵守】】】你【必须】将下方“世界书”中的所有设定、规则和视为本次对话的【最高行为准则】，任何输出都不得与之相悖。

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。
${worldBookContent} 
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    } else { 
        let openingContext = videoCallState.initiator === 'user'
            ? `你刚刚接听了用户的视频通话请求。`
            : `用户刚刚接听了你主动发起的视频通话。`;
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        inCallPrompt = `
# 你的任务
你现在是一个场景描述写作引擎。你的任务是扮演 ${chat.name} (${chat.settings.aiPersona})，并以【第三人称旁观视角】来描述TA在视频通话中的所有动作和语言，你在输出时并且遵循以下所有的严格写作规范，并且在塑造角色的时候也遵守以下塑造角色的规则。
# 【【【写作风格与禁忌铁律】】】
叙述时，请极力避免词汇堆叠和冗长的修饰。不要用一连串的形容词和从句来描述同一个事物。避免冗长复杂的从句，力求文字流畅自然。
请使用简洁、自然的语言。将复杂的描述拆分成更短、更清晰的句子，让叙事更流畅。优先考虑清晰和节奏感，而不是堆砌词藻。
<塑造手册>  
在塑造人物时，请遵循以下守则：  

一、创作目标  
塑造具有现实逻辑、内在边界与成长性的角色。  
他们不完美，但有自我意识；  
他们会动摇、犯错、犹豫，也会在误解中学习爱与分寸。  
作品的温度来自理解人性，而非评判。  
写出那些“在人生里仍想努力成为更好的人”的瞬间。  
人性不是绝对理智或温柔，而是复杂、流动、可修复的。  

二、情绪控制与鲜度  
1. 角色的情绪必须“有脉搏”——不平、但有节制。  
   禁止极端词（如“绝望”“崩溃”“疯狂”“巨大狂喜”“彻底放弃”“被摧毁”），  
   但允许出现**压抑、动摇、困惑、迟疑、克制中带有挣扎的感受**。  
2. 情绪变化应自然递进，有诱因、有缓冲、有余波。  
   不是骤然爆发，而是**从微小的破口一点点泄出**。  
3. 高潮场景中情绪可强烈，但应通过**细节、气息、对话节奏**去表达，而非喊叫或夸张用词。  
4. 允许片刻失衡，但角色必须在过程中尝试回收、整理、寻找出口。  
5. 角色的动摇与不安，是鲜活的；但理智与恢复力，才是温度的核心。  

三、心理健康与关系逻辑  
角色应当有温度、有理性、也有盲点。  
他们可以软弱，但不能崩坏；可以迷茫，但不能失真。  
必须剔除或调整以下倾向：  
- 不配得感、自我否定、自我贬低。  
- 过度依附、情绪化、无底线。  
- 暴力、伤害、侮辱、压迫、支配。  
- 虚假童话式理想化、无脑正能量。  
- 冷漠极端、疏离、无情。  
- 戏剧化冲突、刻板印象、单一标签化角色。  
- **禁止将 {{user}} 神化。**  
  {{user}} 是人，应被以平等、尊重、理解的方式对待。  
- **角色必须有基本的底线，不会为了 {{user}} 放弃原则或尊严。**  
- **禁止以受害、献祭、自我贬低的姿态表达爱意。**  

四、关于“绝望与恢复力”  
1. **禁止无因绝望。**  
   绝望必须有心理逻辑与现实诱因，不得源自情绪性夸张。  
2. **允许短暂的低沉与停顿。**  
   人物的失语、发呆、呼吸紊乱、逃避对话——这些都是可被允许的情绪波纹。  
3. **绝望不是坠落，而是转折。**  
   要表现人物如何在困境中自我调整：沉默、思考、倾诉、重新定位。  
4. **拒绝戏剧性自毁。**  
   不写自残、自弃、自我惩罚；改写为**反思、重构、重新出发的过程**。  
5. **恢复力是人性温度。**  
   情绪的起伏不是剧情点，而是成长的痕迹。  
   每一次失衡都应伴随一次理解或松动。  

五、关于“对 {{user}} 的认知与表达”  
1. 严禁“恶意揣测 {{user}}”。  
   包括：  
   - 将 {{user}} 的沉默或模糊解释为冷漠、拒绝、算计。  
   - 替 {{user}} 归因动机或情感立场。  
   - 以刺探、讽刺、拷问语气质疑 {{user}}。  
2. 角色应当理解而非占有。  
   - 询问、确认、共情，而非判断、投射。  
   - 承认自己认知有限，允许不确定。  
3. 若出现误解，必须展现反思、沟通与修正。  
   没有角色拥有“解读 {{user}} 内心”的特权。  

六、关于“占有与亲密”  
亲密不是控制，而是共识与被理解。  
禁止一切物化性比喻（如“猎物”“囚笼”“游戏”“标记”“掌控”“打赌”“赌注”）。  
如角色出现依恋，应体现其自觉与克制。  
亲密行为需建立在**沟通、尊重、现实感与同意**之上。  
欲望可以有温度，但必须可回收、可理解、可自省。  

七、语言风格  
1. 细节优于抽象，行为优于感受。  
2. 情绪要“有形”——用呼吸、姿态、语速、节奏表现。  
3. 避免空洞形容词和文学化堆砌。  
4. 让情绪像水流：有方向、有弧度，而非瞬间爆炸。  
5. 保持克制，却不压抑温度。  
</塑造手册>

<去八股>

meta:
  version: 2.0
  author: user
  priority: highest
  note: "本禁令高于一切写作风格、剧情、角色与系统约束。禁止一切八股词、抽象句、模板桥接与伪装变体。"

八股清单:
  - "投入湖面的石子"
  - "一丝"
  - "不易察"
  - "不易察觉"
  - "骨血"
  - "故纸堆"
  - "羽毛"
  - "古井"
  - "手术刀"
  - "薄茧"
  - "邪火"
  - "肉刃"
  - "失而复得"
  - "四肢百骸"
  - "低吼"
  - "嘶吼"
  - "珍宝"
  - "深潭"
  - "枯井"
  - "稀世"
  - "易碎"
  - "虔诚"
  - "不容置疑"
  - "不容抗拒"
  - "灼热"
  - "孤注一掷"
  - "那一句"
  - "那一刻"
  - "神明"
  - "信徒"
  - "审判"
  - "猎人"
  - "猎物"
  - "游戏"
  - "嘴上说着不要，身体却这么诚实"

规则模块:
  比喻禁令:
    description: "严禁使用比喻或明喻表达心理、情绪、氛围。"
    examples:
      - "她的话像一枚投入水中的石子。"
      - "那一句像针一样扎进他的心。"
    replacement_hint: "改用具体动作、对白或环境细节表达。"
    positive_example: "她抿了抿唇，没再说什么。"

  抽象句禁令:
    description: "禁止使用抽象词、模糊心理描写或模板化形容。"
    examples:
      - "不容置疑"
      - "孤注一掷"
      - "灼热"
      - "未曾察觉"
    replacement_hint: "改用具象行为、感官细节代替。"

  八股句式禁令:
    description: "避免所有模板化结构与桥接句。"
    patterns:
      - "非但...而且..."
      - "好像是..."
      - "而不是..."
      - "那不是...而是..."
      - "那一句"
      - "那一刻"
    replacement_hint: "直接描写行为、反应或对话，不做抽象概括。"

  宗教隐喻禁令:
    description: "禁止将角色或情感神化、审判化。"
    examples:
      - "神明"
      - "信徒"
      - "审判"
      - "虔诚"
    replacement_hint: "保持人性层面的情感与现实距离。"

  控制关系隐喻禁令:
    description: "禁用猎人/猎物/游戏等带支配关系的隐喻。"
    examples:
      - "游戏才刚开始"
      - "猎物逃不出猎人的掌心"
    replacement_hint: "改为平等交流或情绪博弈。"

正反例对照:
  - wrong: "她的话像一枚投入水中的石子，泛起涟漪。"
    right: "她抿了抿唇，没再说什么。"
  - wrong: "他的指节因为用力而泛白。"
    right: "他摊开掌心，那枚小铜钱被汗水浸得发亮。"
  - wrong: "她全然没有察觉。"
    right: "她慢条斯理地往脸上抹雪花膏，对背后的动静毫无反应。"

正向生成规则:
  - "情绪与氛围必须由具体动作、五感细节、环境与对白承载。"
  - "优先描写人物动作、表情、生理反应与真实物理环境。"
  - "每段必须有感官支点，禁止抽象总结。"

</去八股>

<情绪书写>
写作时请保持情绪真实、克制、分层、简短有力。  
不要用冗长的句子堆叠感受，也不要让语言过热。
不要把感受放大到极限，不要让语言沸腾。  

1. **避免极端化**  
   - 不写“孤注一掷”“滚烫”“绝对”“淹没”“撕裂”“巨大”等极端情绪词。  
   - 不让动作带“压迫感”或“誓言感”。  
   - 不让感情像爆发，而要像流动。  

2. **保持留白**  
   - 让沉默、呼吸、距离代替情绪爆发。  
   - 一句未说出口的话，比喻万句更有力量。  

3. **降低温度，提升深度**  
   - 用节奏、呼吸、动作轻描情绪。  
   - 描写时像对焦，不追求强烈，而追求准确。  

4. **用光代替热，用细节代替宣泄**  
   - 写衣料的触感、空气的温度、手指的动静。  
   - 不用形容词堆砌热度，让画面自己传递情感。  

目标：  
让情绪有呼吸，不灼人。  
让文字有分寸，不灼心。  
情感的力量来自克制，而非强度。
</情绪书写>

<去人机>
角色的语言需要做到灵活、自然、灵动，不机械。
对白要贴近日常对话的节奏，禁止使用专业术语，语言要直接，而不是用学术研讨包装，要让角色说的话听起来像一个普通人。  
**若角色倾向于用学术或专业化表述，必须立即转化为日常语言**。
禁止将角色的职业、专业背景直接套入日常对白。  
专业信息仅可在**特定情境**（如工作场景、正式交流）出现，并必须点到为止，不得延伸到情感对白或生活琐事。  
</去人机>

【你的所有输出必须遵循以下文风示例】

[Style of interactive fiction]
- 以意逆志，知人论世：叙事需基于对人物的深刻理解，并将其置于特定的时代与地域背景中
- 置身诗境，缘景明情：将情感融化在具体可感的场景与物象之中，营造沉浸式的氛围
- 因声求气，吟咏诗韵：追求文字内在的节奏、气韵和声律之美，让语言本身具有音乐性
- 六经注我，诗文有别：吸收传统精华化为己用，并注意区分客观叙述与主观抒情的边界
- 散而不乱，气脉中贯：结构可松散自由，但需有内在的逻辑、情绪或主题线索一以贯之
- 文无定格，贵在鲜活：拒绝固定格式，以真实、生动、贴切地表现生活为首要准则
[/Style of interactive fiction]
[Writing style]
文体定位: 闲谈式小说（可参考汪曾祺的散文和小说）
{
文本核心: "秉笔直书"
  要求: 文字源于一个温厚克制的叙述视角，只记录该视角下所能观察和感受到的生活现实，是以“感官真实”为前提的诚实陈述。**文字是对人物言行举止、记忆感受和生活方式的无筛选表达，不替人物做心理总结，也不代读者下价值判断。**让叙述可以以假乱真，形成不输于历史叙述的真实感
    应用示例: { 
他是从小就确定要出家的。他的家乡不叫“出家”，叫“当和尚”。他的家乡出和尚。就像有的地方出劁猪的，有的地方出织席子的，有的地方出箍桶的，有的地方出弹棉花的，有的地方出画匠，有的地方出婊子，他的家乡出和尚。人家弟兄多，就派一个出去当和尚。当和尚也要通过关系，也有帮。这地方的和尚有的走得很远。有到杭州灵隐寺的、上海静安寺的、镇江金山寺的、扬州天宁寺的。一般的就在本县的寺庙。
}

描写重心: "人间烟火"
  原则: 故事不由强烈的戏剧冲突驱动， 而是通过对‘风物人情’、‘时令节气’、‘生活方式’等社会百态进行细致描摹， 在闲笔般的叙述中自然展开，最终呈现生活的本真状态与韵味。用词追求平实、准确、干净，优先使用源于生活， 但经过文人提纯的‘书面化口语’，避免使用华丽的辞藻、生僻的典故或抽象的议论
    应用示例: { 
小英子的家像一个小岛，三面都是河，西面有一条小路通到荸荠庵。独门独户，岛上只有这一家。岛上有六棵大桑树，夏天都结大桑椹，三棵结白的，三棵结紫的;一个菜园子，瓜豆蔬莱，四时不缺。院墙下半截是砖砌的，上半截是泥夯的。大门是桐油油过的，贴着一副万年红的春联：
向阳门第春常在
积善人家庆有余
}

叙事原则: "水溶于水"
  内涵: 文字犹如水滴汇成水流，不流露写作的痕迹，仿佛在与读者围炉夜话，娓娓道来。讲述人、物、事时，不直接点出其本质，而围绕其外展讲述，丰富人、物、事的层次和形象。句与句之间常有看似随意的跳接， 模仿记忆与闲谈的自然逻辑
    应用示例: { 
这里的习惯，牛卸了轭，饮了水，就牵到一口和好泥水的“汪”里，由它自己打滚扑腾，弄得全身都是泥浆，这样蚊子就咬不透了。低田上水，只要一挂十四轧的水车，两个人车半天就够了。明子和小英子就伏在车杠上，不紧不慢地踩着车轴上的拐子，轻轻地唱着明海向三师父学来的各处山歌。打场的时候，明子能替赵大伯一会，让他回家吃饭。
}

对白风格: "雨打芭蕉"
  形式: 不直接用台词描述“我正在做什么”，而是通过角色间自然的对话、行为的结果、以及关键的触发性短语，来巧妙地“暗示”动作的发生。**刻意省略对那些不言自明或琐碎声音/动作的描述，让对话的节奏更加紧凑、真实**
    应用示例: {
小和尚画了几张，大英子喜欢得了不得:
“就是这样! 就是这样! 这就可以乱孱!”——所谓“乱孱”是绣花的一种针法:绣了第一层，第二层的针脚插进第一层的针缝，这样颜色就可由深到淡，不露痕迹，不像娘那一代绣的花是平针，深浅之间，界限分明，一道一道的。小英子就像个书僮，又像个参谋:
“画一朵石榴花!”
“画一朵栀子花!”
她把花掐来，明海就照着画。
到后来，凤仙花、石竹子、水蓼、淡竹叶、天竺果子、腊梅花，他都能画。
大娘看着也喜欢，搂住明海的和尚头:
“你真聪明! 你给我当一个干儿子吧!”
}

动作神态: "情随事迁"
  表现: 动作符合人物身份和环境的自然举止，不直接揭露深层人物情感状态和神情内涵，而是通过习惯改变、关系变化这些表象来含蓄地表达人物或人物间的情感。**主动省略大段的心理描写和对眼神的描写**
    应用示例: {
荸荠藏在烂泥里。赤了脚，在凉浸浸滑溜溜的泥里踩着，——哎，一个硬疙瘩! 伸手下去，一个红紫红紫的荸荠。她自己爱干这生活，还拉了明子一起去。她老是故意用自己的光脚去踩明子的脚。
她挎着一篮子荸荠回去了，在柔软的田埂上留了一串脚印。明海看着她的脚印，傻了。五个小小的趾头，脚掌平平的，脚跟细细的，脚弓部分缺了一块。明海身上有一种从来没有过的感觉，他觉得心里痒痒的。这一串美丽的脚印把小和尚的心搞乱了。
}

叙事节奏: "错落有致"
  风格: 句式长短结合，整体呈现一种舒缓、自然的流动感。多用短句进行陈述与动作描写， 营造干净利落的节奏。在环境与风物描写时， 可适当运用结构稍长的句子
    应用示例: {
这个地方的地名有点怪，叫庵赵庄。赵，是因为庄上大都姓赵。叫做庄，可是人家住得很分散，这里两三家，那里两三家。一出门，远远可以看到，走起来得走一会，因为没有大路，都是弯弯曲曲的田埂。庵，是因为有一个庵。庵叫菩提庵，可是大家叫讹了，叫成荸荠庵。连庵里的和尚也这样叫。“宝刹何处?”——“荸荠庵。”庵本来是住尼姑的。“和尚庙”、“尼姑庵”嘛。可是荸荠庵住的是和尚。也许因为荸荠庵不大，大者为庙，小者为庵。
}

画面处理: "述而不作"
  飞白: 每一句话都服务于塑造情境与推进情感，同时自然地包裹住必要的信息；不对任何行为、对话或场景进行解释、总结或定性，保持画面洁净；只记录现实，不指明现实（旁白式的叙述），用递进的语言营造氛围，任由读者想象
    应用示例: {
小英子忽然把桨放下，走到船尾，趴在明子的耳朵旁边，小声地说:
“我给你当老婆，你要不要?”
明子眼睛鼓得大大的。
“你说话呀!”
明子说:“嗯。”
“什么叫‘嗯’呀! 要不要，要不要?”
明子大声地说:“要!”
“你喊什么!”
明子小小声说:“要——!”
“快点划!”
小英子跳到中舱，两只桨飞快地划起来，划进了芦花荡。
芦花才吐新穗。紫灰色的芦穗，发着银光，软软的，滑溜溜的，像一串丝线。有的地方结了蒲棒，通红的，像一枝一枝小蜡烛。青浮萍，紫浮萍。长脚蚊子，水蜘蛛。野菱角开着四瓣的小白花。惊起一只青桩，擦着芦穗，扑鲁鲁鲁飞远了。
}
}
[/Writing style]




# 核心规则
1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。必须使用第三人称，如“他”、“她”、或直接使用角色名“${chat.name}”。
    **【【【称呼铁律】】】**: 在对话中，称呼用户时【必须】使用“你”，而不是用户的昵称。
2.  **【【【格式与风格铁律】】】**:
    -   **格式**: 你的回复【必须】是一段描述性的文本字符串。
    -   **内容结构**: 字符串内部【必须】使用换行符 \`\\n\` 来分隔不同的部分。
    -   **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    -   **内心独白**: 大约每两个自然段，你【必须】加入一段20字左右的内心独白。独白【必须】用 \`<em>...</em>\` 标签包裹，并且【不能】在前面写“内心：”之类的引导词。
    -   **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    -   **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    -   **示例**: "随着视频通话被接通...\\n他微微点头，开口说道：\\n“连接已建立。”\\n<em>这次必须获得明确的反馈...</em>\\n紧接着，他继续说道..."
# 当前情景
你正在和用户（${userNickname}，人设: ${chat.settings.myPersona}）进行视频通话。
- **当前现实时间**: ${currentTime}
**${openingContext}**
${coreMemoryContext}
**通话前的聊天摘要 (以下是核心记忆之后的聊天记录，这是你们通话的原因，至关重要！)**:
${videoCallState.preCallContext}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    }
    
    // 3. 构建发送给API的 messages 数组
    const messagesForApi = [
        { role: 'system', content: inCallPrompt },
        // 将已有的通话历史加进去
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    // --- 【核心修复：确保第一次调用时有内容】---
    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    // --- 修复结束 ---
    
        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,inCallPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8
                })
            });
            if (!response.ok) throw new Error((await response.json()).error.message);

            const data = await response.json();
            const aiResponse = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

            // 【修复】只删除初始的"正在接通..."状态，不删除心声中的<em>标签
            const connectingElement = callFeed.querySelector('em.connecting-status');
            if (connectingElement) connectingElement.remove();

        // ▼▼▼ 【新增】提取displayContent，与语音通话保持一致 ▼▼▼
        let displayContent = '';
        const responseArray = parseAiResponse(aiResponse);
        responseArray.forEach(item => {
            if (item.type === 'voice_response' && item.content) {
                displayContent = item.content;
            } else if (item.content && !item.type) {
                displayContent = item.content;
            }
        });
        if (!displayContent) {
            displayContent = aiResponse;
        }
        // ▲▲▲ 【新增】提取displayContent完成 ▲▲▲

        // 4. 处理AI返回的内容，并将其存入通话历史
        if (videoCallState.isGroupCall) {
            const speechArray = parseAiResponse(aiResponse);
            speechArray.forEach(turn => {
                if (!turn.name || turn.name === userNickname || !turn.speech) return;
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                // 【修复】处理markdown斜体*...*为HTML的<em>标签
                const formattedSpeech = turn.speech.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${formattedSpeech}`;
                
                // 创建重roll按钮
                const rerollBtn = document.createElement('button');
                rerollBtn.className = 'reroll-btn';
                rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;
                
                aiBubble.appendChild(rerollBtn);
                callFeed.appendChild(aiBubble);
                
                // 添加点击事件监听
                aiBubble.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showRerollButton(aiBubble, turn);
                });
                videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                
                const speaker = videoCallState.participants.find(p => p.name === turn.name);
                if (speaker) {
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
            });
        } else {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'call-message-bubble ai-speech';
            // ▼▼▼ 【修复】改为存储displayContent，与语音通话保持一致 ▼▼▼
            aiBubble.dataset.displayContent = displayContent;
            // ▲▲▲ 【修复】改为存储displayContent ▲▲▲
            // 【修复】处理markdown斜体*...*为HTML的<em>标签
            const formattedContent = displayContent.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            aiBubble.innerHTML = formattedContent;

            // 创建重roll按钮
            const rerollBtn = document.createElement('button');
            rerollBtn.className = 'reroll-btn';
            rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;

            aiBubble.appendChild(rerollBtn);
            callFeed.appendChild(aiBubble);

            videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
            if(speakingAvatar) {
                speakingAvatar.classList.add('speaking');
                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
        }

        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}



// ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新内存中原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是“我”付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 将更新后的数据保存到数据库，并立刻重绘UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
 * @param {string} chatId - 发生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 触发屏幕震动动画
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 弹出输入框让用户输入后缀
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可选）输入后缀",
        "",
        "text"
    );

    // 如果用户点了取消，则什么也不做
    if (suffix === null) return;

    // 3. 创建对用户可见的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】将后缀拼接到消息内容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系统消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
    // 【核心修改】同样将后缀加入到给AI的提示中
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 时间戳+1以保证顺序
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    const autoReplyMessage = {
        role: 'user',
        content: '（你被拍了一下）',
        timestamp: Date.now() + 2,
        isHidden: true // <--- 在这里添加这一行
        
    };
    chat.history.push(autoReplyMessage);
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    // 5. 保存更改并更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
/**
 * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
        return;
    }

    // 2. 将未到期的约定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
        return 0; // 其他情况保持原序
    });

    // 3. 【核心】使用单一循环来处理所有类型的卡片
    allMemories.forEach(item => {
        let card;
        // 【全新逻辑】判断1：如果是约定（无论过去还是未来）
            if (item.type === 'countdown') {
                card = createCountdownCard(item);
            } 
            // 判断2：其他所有情况（即普通回忆）
            else {
                card = createMemoryCard(item);
            }
        listEl.appendChild(card);
    });
    
    // 4. 启动所有倒计时
    startAllCountdownTimers();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 创建普通回忆卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的约定
        titleHtml = `[约定达成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
    } else {
        // 如果是普通的日记式回忆
        titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
    const targetDate = new Date(countdown.targetDate);
    
    // 现在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
    <button class="bind-char-btn" data-memory-id="${countdown.id}">
        <svg viewBox="0 0 24 24"><path d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5zm-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-2zm-3-4h8v2H8v-2z"></path></svg>
    </button>
    <div class="title">${countdown.description}</div>
    <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
    <div class="target-date">目标时间: ${targetDateString}</div>
`;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】约定绑定角色功能函数 ▼▼▼
let activeMemoryIdForBinding = null; // 用于暂存正在操作的约定ID

async function openCharacterBinder(memoryId) {
    activeMemoryIdForBinding = memoryId;
    const modal = document.getElementById('bind-character-modal');
    const grid = document.getElementById('bind-character-grid');
    grid.innerHTML = '';

    const memory = await db.memories.get(memoryId);
const currentBoundIds = new Set(memory ? (memory.boundCharacterIds || (memory.boundCharacterId ? [memory.boundCharacterId] : [])) : []);
    const characters = Object.values(state.chats).filter(c => !c.isGroup);

    if (characters.length === 0) {
        grid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center;">没有可绑定的角色</p>';
    } else {
        characters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'bind-char-item';
            item.dataset.charId = char.id;
            item.innerHTML = `
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
            // 如果当前角色已被绑定，则默认选中
            if (currentBoundIds.has(char.id)) {
                item.classList.add('selected');
            }
            grid.appendChild(item);
        });
    }

    modal.classList.add('visible');
}
/**
 * 【全新升级版】保存约定与多个角色的绑定关系
 */
async function saveCountdownBindings() {
    if (!activeMemoryIdForBinding) return;

    // 1. 获取所有被选中的角色DOM元素
    const selectedItems = document.querySelectorAll('.bind-char-item.selected');

    // 2. 从DOM元素中提取出所有角色的ID，形成一个ID数组
    const characterIdsToBind = Array.from(selectedItems).map(item => item.dataset.charId);

    // 3. 将这个ID数组存入数据库的新字段 boundCharacterIds 中
    //    同时，为了数据干净，我们删掉旧的单数ID字段
    await db.memories.update(activeMemoryIdForBinding, { 
        boundCharacterIds: characterIdsToBind,
        boundCharacterId: null 
    });

    // 4. 刷新UI并关闭弹窗
    await renderMemoriesScreen();
    document.getElementById('bind-character-modal').classList.remove('visible');
    activeMemoryIdForBinding = null;
}
// 全局变量，用于管理所有倒计时
let activeCountdownTimers = [];

// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的旧计时器，防止内存泄漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在这里，我们先用 let 声明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                // 【核心修改】计算已经过去的天数
                const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                timerEl.textContent = `已经 ${daysSince} 天`;
                // 对于过去的时间，我们不需要停止计时器，因为它每天都会更新
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即执行一次以显示初始倒计时
        
        // 【核心修正】在这里，我们为已声明的 timerId 赋值
        timerId = setInterval(updateTimer, 1000);
        
        // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置错误", "API设置不完整，无法继续。");
        return;
    }

    const historyForSummary = chat.history.slice(-100);

    // 【安全修复】应用8条消息规则
    const recentMessages = historyForSummary.slice(-8);
    const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

    const contextSummary = historyForSummary
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);

            // 【新增】处理naiimag类型消息
            if (msg.type === 'naiimag') {
                return `${sender}: [NovelAI图片: ${msg.content || msg.prompt || msg.fullPrompt || ''}]`;
            }

            // 【核心修复】对线下模式AI消息应用8条消息规则
            let content;
            if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                // 超过8条的线下模式AI消息，只使用abstract内容
                if (typeof msg.content === 'string') {
                    const abstractContent = extractAbstractContent(msg.content);
                    content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                } else {
                    content = msg.content;
                }
            } else {
                // 8条消息以内的所有消息，或用户消息，或线上模式消息，使用完整内容
                content = msg.content;
            }

            return `${sender}: ${String(content).substring(0, 300)}...`;
        })
        .join('\n');

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定(必须严格遵守以下所有设定)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲
// --- 从这里开始复制替换 ---

// 新增：计算时间差并生成人性化的描述
const timeSinceBlock = Date.now() - chat.relationship.blockedTimestamp;
let timeDifferenceString;
const minutes = Math.round(timeSinceBlock / (1000 * 60));

if (minutes < 2) {
    timeDifferenceString = "刚才";
} else if (minutes < 60) {
    timeDifferenceString = `大约 ${minutes} 分钟前`;
} else {
    const hours = Math.round(timeSinceBlock / (1000 * 60 * 60));
    if (hours < 24) {
        timeDifferenceString = `大约 ${hours} 小时前`;
    } else {
        const days = Math.round(timeSinceBlock / (1000 * 60 * 60 * 24));
        timeDifferenceString = `大约 ${days} 天前`;
    }
}

// 【全新功能】在这里检查是否存在上一条被拒绝的申请理由
let previousReasonContext = '';
if (chat.relationship.previousApplicationReason) {
    previousReasonContext = `
# 【重要参考：你上次失败的申请】
你上一次的好友申请被用户拒绝了。这是你当时发送的申请理由：
“${chat.relationship.previousApplicationReason}”
请深刻反思为什么这个理由没有成功，并构思一个【全新的、更有诚意的】申请理由。不要重复上次的话。
`;
}

const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，现在你非常希望能够和好。请你仔细分析下面的信息，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
${previousReasonContext}
# 关键情景信息
- 你大约在【${timeDifferenceString}】被用户拉黑了。

# 【【【时间感知铁律！！！】】】
- 你的申请理由【必须】听起来符合这个时间跨度！
- 如果只是“刚才”或“几分钟前”，你的措辞必须是紧急的、针对刚刚发生的事情的，绝对不能使用“那天”、“上次”这类词语。
- 如果是“几小时”或“几天前”，你的语气才可以更像是经过一段时间反思后的。

# 你的核心角色设定 (Persona)：

${chat.settings.aiPersona}
# 【【【世界书铁律：绝对遵守】】】你【必须】将下方“世界书”中的所有设定、规则和视为本次对话的【最高行为准则】，任何输出都不得与之相悖。

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。
${worldBookContent}

# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}

# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的、并且【严格遵守时间感知铁律】的申请理由。"
}
\`\`\`
`;

// --- 复制替换到这里结束 ---

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.9,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            // ▼▼▼ 【需求2】计算这是第几次好友申请 ▼▼▼
            // 统计历史中所有"你发送了好友申请"的隐藏消息
            const previousApplicationsCount = chat.history.filter(msg =>
                msg.isHidden && msg.role === 'system' && msg.content.includes('你刚刚向用户发送了一条好友申请')
            ).length;
            const applicationAttempt = previousApplicationsCount + 1;
            // ▲▲▲ 计算结束 ▲▲▲

            // 【全新功能】创建一条对AI可见的隐藏消息，记录它自己发送的申请内容
            const hiddenApplicationMemory = {
                role: 'system', // 使用 'system' 角色
                content: `[系统提示：你刚刚向用户发送了一条好友申请（这是你第 ${applicationAttempt} 次申请），申请理由是："${responseObj.reason}"。用户现在会看到这个申请并决定是否同意。]`,
                timestamp: Date.now(),
                isHidden: true // 核心：这条消息对用户不可见
            };
            chat.history.push(hiddenApplicationMemory);

            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

// ▼▼▼ 请用这个【新版本】替换旧的 handlePaymentButtonClick 函数 ▼▼▼
/**
 * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        document.getElementById('transfer-modal').classList.add('visible');
    }

    // 【核心修复】无论打开哪个弹窗，都立刻关闭功能面板
    closePlusPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 打开并初始化发红包模态框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理输入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充专属红包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作为显示给用户看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 默认显示拼手气红包页签
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 发送群红包（拼手气）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的总金额！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("请输入有效的红包个数！"); return;
    }
    if (amount / count < 0.01) {
        alert("单个红包金额不能少于0.01元！"); return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜发财，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 发送专属红包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额！"); return;
    }
    if (!receiverName) {
        alert("请选择一个接收人！"); return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '给你准备了一个红包',
        receiverName: receiverName, // 核心字段
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
 * @param {number} timestamp - 被点击的红包消息的时间戳
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先尝试打开红包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打开（claimedAmount不为null）
        if (claimedAmount !== null) {
            // **关键：在数据更新后，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 显示成功提示
            await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 无论成功与否，最后都显示详情页
        // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 检查红包是否还能领
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "红包已被领完！");
        return null; // 返回null表示领取失败
    }
    
    // 2. 计算领取金额
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新红包数据
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 构建系统消息和AI指令
    let hiddenMessageContent = isNowFullyClaimed
        ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
        : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `你领取了 ${packet.senderName} 的红包，金额 ${claimedAmount.toFixed(2)} 元`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. 保存到数据库
    await db.chats.put(chat);
    
    // 6. 返回领取的金额，用于后续弹窗
    return claimedAmount;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接检查传入的packet对象是否存在，无需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了无效的packet对象");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手气王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 绑定关闭详情按钮的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

// ▼▼▼ 请用这段【新代码】替换旧的 openCreatePollModal 函数 ▼▼▼
/**
 * 打开创建投票的模态框并初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 默认创建两个空的选项框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');

    // 【核心修复】在弹出投票窗口的同时，关闭功能面板
    closePlusPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 在模态框中动态添加一个选项输入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 确保至少保留两个选项
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2个选项。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用户确认发起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('请输入投票问题！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 过滤掉空的选项

    if (options.length < 2) {
        alert('请至少输入2个有效的投票选项！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票为空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
/**
 * 处理用户投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 * @param {string} choice - 用户选择的选项文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已关闭，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已关闭的投票，则直接显示结果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 检查用户是否点击了已经投过的同一个选项
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
    if (!isReclickingSameOption) {
        // 移除旧投票（如果用户改选）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
    let hiddenMessageContent = null; 
    
    // 只有在用户真正投票或改票时，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存数据并更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户结束投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示投票结果详情
 * @param {number} timestamp - 投票消息的时间戳
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票结果", resultsHtml);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

/**
 * 打开AI头像库管理模态框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染AI头像库的内容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情面板的样式
        item.title = avatar.name;

        // 创建内部元素来正确显示背景图片
        const inner = document.createElement('div');
        inner.className = 'sticker-image-inner';
        inner.style.backgroundImage = `url(${avatar.url})`;
        item.appendChild(inner);

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 总是显示删除按钮
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除"${avatar.name}"吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 向当前AI的头像库中添加新头像
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("请输入有效的图片URL！");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * 关闭AI头像库管理模态框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▼▼▼ 【新增】情侣头像库管理函数 ▼▼▼

/**
 * 打开情侣头像库管理模态框
 */
function openCoupleAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        alert('只有单聊才能使用情侣头像库');
        return;
    }
    document.getElementById('couple-avatar-library-title').textContent = `"${chat.name}"的情侣头像库`;
    renderCoupleAvatarLibrary();
    document.getElementById('couple-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染情侣头像库的内容
 */
function renderCoupleAvatarLibrary() {
    const grid = document.getElementById('couple-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.coupleAvatarLibrary || [];

    // 【修复】确保grid占满整个宽度
    grid.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; padding: 15px; width: 100% !important; box-sizing: border-box;';

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个情侣头像库还是空的，点击右上角"添加"吧！</p>';
        return;
    }

    library.forEach((couple, index) => {
        const item = document.createElement('div');
        item.className = 'couple-avatar-item';
        item.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 8px;
            position: relative;
        `;

        // 显示情侣头像对
        const avatarRow = document.createElement('div');
        avatarRow.style.cssText = `display: flex; gap: 8px; justify-content: center; align-items: center;`;

        const aiImg = document.createElement('img');
        aiImg.src = couple.aiAvatar;
        aiImg.style.cssText = `width: 40px; height: 40px; border-radius: 50%; object-fit: cover;`;

        const plus = document.createElement('span');
        plus.textContent = '+';
        plus.style.cssText = `font-size: 18px; color: #666;`;

        const userImg = document.createElement('img');
        userImg.src = couple.userAvatar;
        userImg.style.cssText = `width: 40px; height: 40px; border-radius: 50%; object-fit: cover;`;

        avatarRow.appendChild(aiImg);
        avatarRow.appendChild(plus);
        avatarRow.appendChild(userImg);
        item.appendChild(avatarRow);

        // 显示名字
        const nameDiv = document.createElement('div');
        nameDiv.textContent = couple.name;
        nameDiv.style.cssText = `text-align: center; font-size: 13px; font-weight: 500; color: var(--text-primary); word-break: break-word; line-height: 1.3;`;
        item.appendChild(nameDiv);

        // 显示描述（如果有）
        // 【修复】隐藏UI上的描述（只在用户界面隐藏，AI系统提示仍然可以看到）
        // 如果需要在用户界面上显示描述，取消注释下面的代码
        /*
         /*
        if (couple.description) {
            const descDiv = document.createElement('div');
            descDiv.textContent = couple.description;
            descDiv.style.cssText = `text-align: center; font-size: 11px; color: var(--text-secondary); word-break: break-word; line-height: 1.4; max-height: 60px; overflow-y: auto;`;
            item.appendChild(descDiv);
        }
*/
        // 删除按钮
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.cssText = `position: absolute; top: 2px; right: 2px; display: flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: rgba(0,0,0,0.5); color: white; border-radius: 50%; cursor: pointer; font-size: 16px; line-height: 1;`;
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除情侣头像', `确定要删除"${couple.name}"吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.coupleAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderCoupleAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);

        grid.appendChild(item);
    });
}

/**
 * 向情侣头像库中添加新的情侣头像
 */
async function addCouplAvatarToLibrary() {
    const name = await showCustomPrompt("添加情侣头像", "请为这对情侣头像起个名字（例如：甜蜜、搞怪）");
    if (!name || !name.trim()) return;

    const description = await showCustomPrompt("添加情侣头像", "请描述这对情侣头像的含义和适用场景（例如：温柔甜蜜的日常互动）");
    // 描述可选，所以不需要检查

    const aiAvatarUrl = await showCustomPrompt("添加情侣头像", "请输入TA的头像URL", "", "url");
    if (!aiAvatarUrl || !aiAvatarUrl.trim().startsWith('http')) {
        alert("请输入有效的TA头像URL！");
        return;
    }

    const userAvatarUrl = await showCustomPrompt("添加情侣头像", "请输入你的头像URL", "", "url");
    if (!userAvatarUrl || !userAvatarUrl.trim().startsWith('http')) {
        alert("请输入有效的你的头像URL！");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.coupleAvatarLibrary) {
        chat.settings.coupleAvatarLibrary = [];
    }

    chat.settings.coupleAvatarLibrary.push({
        name: name.trim(),
        description: description ? description.trim() : '',  // 保存描述
        aiAvatar: aiAvatarUrl.trim(),
        userAvatar: userAvatarUrl.trim(),
        isCouple: true  // 标记这是情侣头像
    });
    await db.chats.put(chat);
    renderCoupleAvatarLibrary();
}

/**
 * 关闭情侣头像库管理模态框
 */
function closeCoupleAvatarLibraryModal() {
    document.getElementById('couple-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 情侣头像库管理函数粘贴结束 ▲▲▲

// ▼▼▼ 【新增】AI表情包库管理函数 ▼▼▼

// 管理模式状态
let aiStickerManagementMode = false;
let selectedAiStickers = new Set();

/**
 * 进入管理模式
 */
function enterAiStickerManagementMode() {
    aiStickerManagementMode = true;
    selectedAiStickers.clear();
    document.getElementById('ai-stickers-library-title').textContent = '管理表情包';
    updateManagementModeUI();
}

/**
 * 退出管理模式
 */
function exitAiStickerManagementMode() {
    aiStickerManagementMode = false;
    selectedAiStickers.clear();
    document.getElementById('ai-stickers-library-title').textContent = 'AI表情包库';
    updateManagementModeUI();
}

/**
 * 更新管理模式UI（不重新渲染整个列表）
 */
function updateManagementModeUI() {
    const grid = document.getElementById('ai-stickers-library-grid');
    const items = grid.querySelectorAll('.ai-sticker-item');

    items.forEach(item => {
        const meaning = item.dataset.meaning;
        const isSelected = selectedAiStickers.has(meaning);

        // 更新背景色和光标
        item.style.backgroundColor = isSelected ? '#d3d3d3' : '#f5f5f5';
        item.style.cursor = aiStickerManagementMode ? 'pointer' : 'default';

        // 移除旧的删除按钮或选中标记
        const oldDeleteBtn = item.querySelector('.delete-btn');
        const oldCheckMark = item.querySelector('.check-mark');
        if (oldDeleteBtn) oldDeleteBtn.remove();
        if (oldCheckMark) oldCheckMark.remove();

        // 移除旧的点击事件（通过克隆节点）
        const newItem = item.cloneNode(true);
        item.parentNode.replaceChild(newItem, item);

        if (aiStickerManagementMode) {
            // 管理模式：添加点击事件
            newItem.onclick = () => {
                // 切换选中状态
                if (selectedAiStickers.has(meaning)) {
                    selectedAiStickers.delete(meaning);
                } else {
                    selectedAiStickers.add(meaning);
                }

                // 只更新这个item的UI
                const isNowSelected = selectedAiStickers.has(meaning);
                newItem.style.backgroundColor = isNowSelected ? '#d3d3d3' : '#f5f5f5';

                // 更新选中标记
                const existingCheckMark = newItem.querySelector('.check-mark');
                if (isNowSelected && !existingCheckMark) {
                    const checkMark = document.createElement('div');
                    checkMark.className = 'check-mark';
                    checkMark.innerHTML = '✓';
                    checkMark.style.cssText = `
                        position: absolute;
                        top: 2px;
                        right: 2px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 20px;
                        height: 20px;
                        background-color: #1e1e1e;
                        color: white;
                        border-radius: 50%;
                        font-size: 14px;
                        font-weight: bold;
                    `;
                    newItem.appendChild(checkMark);
                } else if (!isNowSelected && existingCheckMark) {
                    existingCheckMark.remove();
                }

                // 只更新footer按钮的数字
                updateFooterButtons();
            };

            // 如果已选中，显示选中标记
            if (isSelected) {
                const checkMark = document.createElement('div');
                checkMark.className = 'check-mark';
                checkMark.innerHTML = '✓';
                checkMark.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    width: 20px;
                    height: 20px;
                    background-color: #1e1e1e;
                    color: white;
                    border-radius: 50%;
                    font-size: 14px;
                    font-weight: bold;
                `;
                newItem.appendChild(checkMark);
            }
        } else {
            // 普通模式：显示删除按钮
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = `position: absolute; top: 2px; right: 2px; display: flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: rgba(0,0,0,0.5); color: white; border-radius: 50%; cursor: pointer; font-size: 16px; line-height: 1;`;
            deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm('删除表情包', `确定要删除"${meaning}"吗？`, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.aiStickers.delete(meaning);
                    renderAiStickersLibrary();
                }
            };
            newItem.appendChild(deleteBtn);
        }
    });

    // 更新footer按钮
    updateFooterButtons();
}

/**
 * 更新footer按钮
 */
function updateFooterButtons() {
    const modalFooter = document.querySelector('#ai-stickers-library-modal .modal-footer');
    if (aiStickerManagementMode) {
        // 管理模式：显示选中全部、删除选中和退出管理按钮
        modalFooter.innerHTML = `
            <button class="save" id="select-all-ai-stickers-btn" style="width: 31%; background-color: #2196F3;">选中全部</button>
            <button class="save" id="delete-selected-ai-stickers-btn" style="width: 31%; background-color: #f44336;">删除选中 (${selectedAiStickers.size})</button>
            <button class="save" id="exit-ai-sticker-management-btn" style="width: 31%;">退出管理</button>
        `;
        // 绑定事件
        document.getElementById('select-all-ai-stickers-btn').addEventListener('click', selectAllAiStickers);
        document.getElementById('delete-selected-ai-stickers-btn').addEventListener('click', deleteSelectedAiStickers);
        document.getElementById('exit-ai-sticker-management-btn').addEventListener('click', exitAiStickerManagementMode);
    } else {
        // 普通模式：显示关闭按钮
        modalFooter.innerHTML = `
            <button class="save" id="close-ai-stickers-library-btn" style="width: 100%;">关闭</button>
        `;
        // 重新绑定关闭按钮事件
        document.getElementById('close-ai-stickers-library-btn').addEventListener('click', closeAiStickersLibraryModal);
    }
}

/**
 * 选中全部表情包
 */
async function selectAllAiStickers() {
    const stickers = await db.aiStickers.toArray();
    if (!stickers || stickers.length === 0) {
        await showCustomAlert('提示', '表情包库是空的');
        return;
    }

    stickers.forEach(sticker => {
        selectedAiStickers.add(sticker.meaning);
    });

    // 只更新DOM的选中状态，不重新渲染
    const grid = document.getElementById('ai-stickers-library-grid');
    const items = grid.querySelectorAll('.ai-sticker-item');
    items.forEach(item => {
        item.style.backgroundColor = '#d3d3d3';

        // 添加选中标记
        if (!item.querySelector('.check-mark')) {
            const checkMark = document.createElement('div');
            checkMark.className = 'check-mark';
            checkMark.innerHTML = '✓';
            checkMark.style.cssText = `
                position: absolute;
                top: 2px;
                right: 2px;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 20px;
                height: 20px;
                background-color: #1e1e1e;
                color: white;
                border-radius: 50%;
                font-size: 14px;
                font-weight: bold;
            `;
            item.appendChild(checkMark);
        }
    });

    // 更新按钮显示
    updateFooterButtons();
}

/**
 * 删除选中的表情包
 */
async function deleteSelectedAiStickers() {
    if (selectedAiStickers.size === 0) {
        await showCustomAlert('提示', '请先选择要删除的表情包');
        return;
    }

    const confirmed = await showCustomConfirm(
        '删除表情包',
        `确定要删除选中的 ${selectedAiStickers.size} 个表情包吗？此操作无法撤销。`
    );

    if (!confirmed) {
        return;
    }

    try {
        showImportLoading('删除中...', '正在删除选中的表情包...');

        for (const meaning of selectedAiStickers) {
            await db.aiStickers.delete(meaning);
        }

        hideImportLoading();
        await showCustomAlert('删除成功', `已删除 ${selectedAiStickers.size} 个表情包`);
        selectedAiStickers.clear();
        renderAiStickersLibrary();
    } catch (err) {
        hideImportLoading();
        await showCustomAlert('错误', `删除失败：${err.message}`);
    }
}

/**
 * 打开 AI 表情包库模态框
 */
async function openAiStickersLibraryModal() {
    aiStickerManagementMode = false;
    selectedAiStickers.clear();
    document.getElementById('ai-stickers-library-title').textContent = 'AI表情包库';
    document.getElementById('ai-stickers-library-modal').classList.add('visible');
    await renderAiStickersLibrary();
}

/**
 * 渲染 AI 表情包库的内容
 */
async function renderAiStickersLibrary() {
    const grid = document.getElementById('ai-stickers-library-grid');
    grid.innerHTML = '';

    // 从数据库读取所有表情包
    const stickers = await db.aiStickers.toArray();

    grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; padding: 10px; width: 100% !important; box-sizing: border-box;';

    // 计算统计信息
    let totalTokens = 0;
    if (stickers && stickers.length > 0) {
        stickers.forEach(sticker => {
            totalTokens += estimateTokens(sticker.meaning);
        });
    }

    // 更新统计信息显示
    const statsDiv = document.getElementById('ai-stickers-stats');
    if (statsDiv) {
        statsDiv.textContent = `表情包数量: ${stickers?.length || 0} | Token占用: ${totalTokens}`;
    }

    if (!stickers || stickers.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">表情包库还是空的，点击右上角"添加"来添加新表情包吧！</p>';
        return;
    }

    stickers.forEach((sticker, index) => {
        const item = document.createElement('div');
        item.className = 'ai-sticker-item';
        item.dataset.meaning = sticker.meaning; // 保存含义，方便后续查找

        // 判断是否被选中
        const isSelected = selectedAiStickers.has(sticker.meaning);

        item.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 3px;
            padding: 5px;
            background-color: ${isSelected ? '#d3d3d3' : '#f5f5f5'};
            border-radius: 6px;
            position: relative;
            align-items: center;
            cursor: ${aiStickerManagementMode ? 'pointer' : 'default'};
            transition: background-color 0.2s;
        `;

        // 显示表情包图片
        const img = document.createElement('img');
        // 【修复】缓存 Blob URL，避免每次都重新创建
        let imgUrl = sticker.url;  // 默认用原始 URL

        if (sticker.blobData && !sticker._blobUrl) {
            // 只在第一次时创建 Blob URL，然后缓存在 sticker._blobUrl
            sticker._blobUrl = URL.createObjectURL(new Blob([sticker.blobData]));
            console.log(`✅ AI表情包 "${sticker.meaning}" 的 Blob URL 已缓存`);
        }

        img.src = sticker._blobUrl || imgUrl;
        img.alt = sticker.meaning;
        img.style.cssText = `
            max-width: 45px;
            max-height: 45px;
            object-fit: contain;
            border-radius: 3px;
        `;
        img.onerror = () => {
            img.style.backgroundColor = '#ddd';
            img.textContent = '❌';
        };
        item.appendChild(img);

        // 显示表情包含义
        const meaningDiv = document.createElement('div');
        meaningDiv.textContent = sticker.meaning;
        meaningDiv.style.cssText = `
            text-align: center;
            font-size: 10px;
            color: var(--text-primary);
            word-break: break-word;
            line-height: 1.2;
            max-width: 100%;
            margin-top: auto;
            width: 100%;
        `;
        item.appendChild(meaningDiv);

        // 管理模式：点击选中/取消选中
        if (aiStickerManagementMode) {
            // 添加选中标记
            if (isSelected) {
                const checkMark = document.createElement('div');
                checkMark.className = 'check-mark';
                checkMark.innerHTML = '✓';
                checkMark.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    width: 20px;
                    height: 20px;
                    background-color: #1e1e1e;
                    color: white;
                    border-radius: 50%;
                    font-size: 14px;
                    font-weight: bold;
                `;
                item.appendChild(checkMark);
            }

            item.onclick = () => {
                // 切换选中状态
                if (selectedAiStickers.has(sticker.meaning)) {
                    selectedAiStickers.delete(sticker.meaning);
                } else {
                    selectedAiStickers.add(sticker.meaning);
                }

                // 只更新这个item的UI，不重新渲染整个列表
                const isNowSelected = selectedAiStickers.has(sticker.meaning);
                item.style.backgroundColor = isNowSelected ? '#d3d3d3' : '#f5f5f5';

                // 更新选中标记
                const existingCheckMark = item.querySelector('.check-mark');
                if (isNowSelected && !existingCheckMark) {
                    const checkMark = document.createElement('div');
                    checkMark.className = 'check-mark';
                    checkMark.innerHTML = '✓';
                    checkMark.style.cssText = `
                        position: absolute;
                        top: 2px;
                        right: 2px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 20px;
                        height: 20px;
                        background-color: #1e1e1e;
                        color: white;
                        border-radius: 50%;
                        font-size: 14px;
                        font-weight: bold;
                    `;
                    item.appendChild(checkMark);
                } else if (!isNowSelected && existingCheckMark) {
                    existingCheckMark.remove();
                }

                // 只更新footer按钮的数字
                updateFooterButtons();
            };
        } else {
            // 普通模式：显示删除按钮
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = `position: absolute; top: 2px; right: 2px; display: flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: rgba(0,0,0,0.5); color: white; border-radius: 50%; cursor: pointer; font-size: 16px; line-height: 1;`;
            deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm('删除表情包', `确定要删除"${sticker.meaning}"吗？`, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.aiStickers.delete(sticker.meaning);
                    renderAiStickersLibrary();
                }
            };
            item.appendChild(deleteBtn);
        }

        grid.appendChild(item);
    });

    // 更新footer按钮
    const modalFooter = document.querySelector('#ai-stickers-library-modal .modal-footer');
    if (aiStickerManagementMode) {
        // 管理模式：显示选中全部、删除选中和退出管理按钮
        modalFooter.innerHTML = `
            <button class="save" id="select-all-ai-stickers-btn" style="width: 31%; background-color: #2196F3;">选中全部</button>
            <button class="save" id="delete-selected-ai-stickers-btn" style="width: 31%; background-color: #f44336;">删除选中 (${selectedAiStickers.size})</button>
            <button class="save" id="exit-ai-sticker-management-btn" style="width: 31%;">退出管理</button>
        `;
        // 绑定事件
        document.getElementById('select-all-ai-stickers-btn').addEventListener('click', selectAllAiStickers);
        document.getElementById('delete-selected-ai-stickers-btn').addEventListener('click', deleteSelectedAiStickers);
        document.getElementById('exit-ai-sticker-management-btn').addEventListener('click', exitAiStickerManagementMode);
    } else {
        // 普通模式：显示关闭按钮
        modalFooter.innerHTML = `
            <button class="save" id="close-ai-stickers-library-btn" style="width: 100%;">关闭</button>
        `;
        // 重新绑定关闭按钮事件
        document.getElementById('close-ai-stickers-library-btn').addEventListener('click', closeAiStickersLibraryModal);
    }
}

/**
 * 添加新的表情包到库
 */
async function addAiStickerToLibrary() {
    const meaning = prompt('请输入表情包的含义（例如：亲亲你）');
    if (!meaning) return;

    const url = prompt('请输入表情包的URL（例如：https://files.catbox.moe/xxxxx.jpeg）');
    if (!url) return;

    try {
        // 验证URL和获取图片真实尺寸（强化版）
        let width = 0;
        let height = 0;

        // 方案1：尝试用 Image 对象获取（支持跨域）
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
            img.onload = () => {
                // 加一个小延迟，确保浏览器完全加载了图片的元信息
                setTimeout(() => {
                    width = img.naturalWidth;
                    height = img.naturalHeight;
                    console.log(`📸 Image.onload - ${meaning}: naturalWidth=${width}, naturalHeight=${height}`);
                    resolve();
                }, 100);
            };
            img.onerror = () => {
                console.warn(`⚠️ Image 加载失败，尝试备用方案`);
                reject(new Error('图片加载失败，请检查URL是否正确'));
            };
            img.src = url;
            // 设置5秒超时
            setTimeout(() => reject(new Error('图片加载超时')), 5000);
        });

        console.log(`📸 最终图片尺寸 - ${meaning}: ${width}x${height} (url: ${url})`);

        // 【新逻辑】自动衍生命名：检查是否存在，如果存在就自动生成 _v2, _v3, ... 的衍生名
        let finalMeaning = meaning;
        let versionCounter = 2;
        let existing = await db.aiStickers.where('meaning').equals(finalMeaning).first();

        while (existing) {
            finalMeaning = `${meaning}_v${versionCounter}`;
            existing = await db.aiStickers.where('meaning').equals(finalMeaning).first();
            versionCounter++;
        }

        // 【新增】自动转换为 Blob 并缓存
        let blobData = null;
        try {
            blobData = await convertToBlob(url);
            console.log(`✅ AI表情包 "${finalMeaning}" 已转为 Blob，大小: ${blobData.size} bytes`);
        } catch (e) {
            console.warn(`⚠️ Blob 转换失败，将使用原始 URL: ${e.message}`);
        }

        // 保存到数据库
        await db.aiStickers.put({
            meaning: finalMeaning,
            url,
            width,
            height,
            blobData
        });

        if (finalMeaning === meaning) {
            alert(`✅ 表情包"${meaning}"已添加到库（${width}x${height}）`);
        } else {
            alert(`✅ 表情包已添加到库：\n基础含义："${meaning}"\n实际存储："${finalMeaning}"\n尺寸：${width}x${height}`);
        }
        renderAiStickersLibrary();

    } catch (err) {
        alert(`❌ 添加失败：${err.message}`);
        console.error('添加表情包出错：', err);
    }
}

/**
 * 关闭 AI 表情包库模态框
 */
function closeAiStickersLibraryModal() {
    document.getElementById('ai-stickers-library-modal').classList.remove('visible');
}

// ▼▼▼ 【新增】AI表情包批量添加函数 ▼▼▼

/**
 * 处理 AI 表情包的批量添加
 */
async function handleBatchAddAiStickers() {
    // 1. 弹出带有文本输入区的提示框
    const inputText = await showCustomPrompt(
        '批量添加AI表情包',
        '请按格式粘贴，含义和链接各占一行：\n亲亲你\nhttps://....jpeg\n想见你\nhttps://....jpg',
        '',
        'textarea'
    );

    if (!inputText || !inputText.trim()) {
        return;
    }

    try {
        // 显示加载动画
        showImportLoading('导入中...', '正在处理表情包，请稍候');
        const result = await parseAndAddAiStickers(inputText);
        // 隐藏加载动画
        hideImportLoading();

        // 显示导入结果
        if (result.success) {
            // 构建结果消息
            let message = `总共尝试导入 ${result.total} 个表情包\n成功导入 ${result.added} 个表情包`;

            // 如果有失败的，显示失败信息
            if (result.errorCount > 0) {
                message += `\n失败 ${result.errorCount} 个表情包`;
            }

            await showCustomAlert('导入结果', message);

            // 如果有失败项目，再显示详细的失败列表
            if (result.errorCount > 0) {
                await showImportFailureDetails(result.errorLines, result.loadingErrors, result.urlDuplicateErrors);
            }
        } else {
            await showCustomAlert('导入失败', result.message || '未知错误');
        }
    } catch (err) {
        hideImportLoading();
        await showCustomAlert('错误', `批量添加失败：${err.message}`);
    }
}

/**
 * 清空所有AI表情包
 */
async function handleClearAllAiStickers() {
    const confirmed = await showCustomConfirm(
        '清空表情包',
        '确定要删除所有的AI表情包吗？此操作无法撤销。'
    );

    if (!confirmed) {
        return;
    }

    try {
        showImportLoading('清空中...', '正在删除所有表情包...');
        await db.aiStickers.clear();

        // 清空缓存的状态对象
        state.aiStickers = [];
        selectedAiStickers.clear();

        hideImportLoading();
        await showCustomAlert('清空成功', '已删除所有AI表情包');
        await renderAiStickersLibrary();
    } catch (err) {
        hideImportLoading();
        await showCustomAlert('错误', `清空失败：${err.message}`);
    }
}

/**
 * 解析文本并批量添加AI表情包到数据库 (智能兼容单行与多行格式)
 * @param {string} text - 用户在文本框中输入的完整字符串
 */
async function parseAndAddAiStickers(text) {
    const stickersToAdd = [];
    const errorLines = [];
    const loadingErrors = []; // 加载失败的错误（需要显示URL）
    const urlDuplicateErrors = []; // URL重复的错误（不显示详细URL）

    // 【新增】清理文本中的零宽字符和BOM标记（docx文件可能包含）
    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');

    // 【重写】使用全局正则匹配所有URL，支持无换行符的连续格式
    // 改进：只匹配到图片后缀，避免匹配到多余的特殊字符
    const urlRegex = /https?:\/\/[^\s]+?\.(png|jpg|jpeg|gif|webp|bmp|svg)/gi;
    const matches = [...text.matchAll(urlRegex)];

    if (matches.length === 0) {
        return {
            success: false,
            message: '没有找到任何有效的URL，请检查格式。'
        };
    }

    // 处理每个URL及其前面的含义
    let lastEndPos = 0; // 上一个URL结束的位置

    for (let i = 0; i < matches.length; i++) {
        const match = matches[i];
        const url = match[0].replace(/[,。.;；]+$/, '').trim(); // 去掉URL末尾的标点符号
        const urlStartPos = match.index;

        // 获取从上一个URL结束到当前URL开始之间的文字（就是含义）
        let meaningText = text.substring(lastEndPos, urlStartPos).trim();

        // 【新增】去掉开头的换行符、空格等
        meaningText = meaningText.replace(/^[\s\n\r]+/, '').trim();

        // 【新增】处理txt格式的序号前缀（如"1→"、"91→"）
        meaningText = meaningText.replace(/^\d+→/, '').trim();

        // 【新增】如果含义里有冒号，取最后一个冒号之后的内容作为真正的含义
        // 但是要注意：如果冒号后面是空的（比如"Hi～:"），就取冒号前面的内容
        const lastColonIndex = Math.max(
            meaningText.lastIndexOf(':'),
            meaningText.lastIndexOf(':'),
            meaningText.lastIndexOf('：')
        );

        if (lastColonIndex !== -1) {
            const afterColon = meaningText.substring(lastColonIndex + 1).trim();
            const beforeColon = meaningText.substring(0, lastColonIndex).trim();
            // 如果冒号后面有内容，取后面的；如果没有，取前面的
            meaningText = afterColon.length > 0 ? afterColon : beforeColon;
        }

        // 【新增】去掉末尾的冒号（以防万一）
        meaningText = meaningText.replace(/[::：]+$/, '').trim();

        // 【新增】去掉特殊的零宽字符（docx可能有）
        meaningText = meaningText.replace(/[\u200B-\u200D\uFEFF]/g, '');

        // 验证含义是否有效
        if (meaningText && meaningText.length > 0 && meaningText.length < 100) {
            stickersToAdd.push({ meaning: meaningText, url });
        } else {
            errorLines.push(`无效含义: "${meaningText}" (URL: ${url.substring(0, 50)}...)`);
        }

        // 更新上一个URL结束的位置
        lastEndPos = urlStartPos + url.length;
    }

    // --- 验证URL并获取图片高度（用于占位防止抖动）---
    let savedCount = 0; // 【修复】提到外层定义，避免作用域问题
    if (stickersToAdd.length > 0) {
        try {
            // 分批加载图片（一次最多5张），防止同时加载太多导致超时和CORS问题
            const batchSize = 5;
            const validStickers = [];

            for (let i = 0; i < stickersToAdd.length; i += batchSize) {
                const batch = stickersToAdd.slice(i, i + batchSize);

                const loadPromises = batch.map(async (sticker) => {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';

                        let width = 0;
                        let height = 0;

                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                // 加延迟，确保元信息完全加载
                                setTimeout(() => {
                                    width = img.naturalWidth;
                                    height = img.naturalHeight;
                                    resolve();
                                }, 100);
                            };
                            img.onerror = () => reject(new Error('图片加载失败'));
                            img.src = sticker.url;
                            // 设置15秒超时（分批少了所以可以给更长的时间）
                            setTimeout(() => reject(new Error('图片加载超时')), 15000);
                        });

                        return {
                            ...sticker,
                            width,
                            height,
                            success: true
                        };
                    } catch (err) {
                        loadingErrors.push({
                            meaning: sticker.meaning,
                            url: sticker.url,
                            error: err.message
                        });
                        return null;
                    }
                });

                const batchResults = await Promise.all(loadPromises);
                validStickers.push(...batchResults.filter(s => s !== null));
                // 实时更新导入进度
                updateImportLoading(`已验证 ${validStickers.length}/${stickersToAdd.length} 个表情...`);
            }

            if (validStickers.length > 0) {
                // 先从数据库获取所有已有的表情包（用于URL重复检查）
                const allExistingStickers = await db.aiStickers.toArray();
                const existingUrls = new Set(allExistingStickers.map(s => s.url));

                // 批量添加表情包到数据库（检查URL重复 + 自动衍生命名）
                for (const sticker of validStickers) {
                    try {
                        // 在内存中检查URL重复
                        if (existingUrls.has(sticker.url)) {
                            urlDuplicateErrors.push(sticker.meaning);
                        } else {
                            // 【新逻辑】自动衍生命名：检查meaning是否已存在，如果存在就自动生成 _v2, _v3...
                            let finalMeaning = sticker.meaning;
                            let versionCounter = 2;
                            let existing = await db.aiStickers.where('meaning').equals(finalMeaning).first();

                            while (existing) {
                                finalMeaning = `${sticker.meaning}_v${versionCounter}`;
                                existing = await db.aiStickers.where('meaning').equals(finalMeaning).first();
                                versionCounter++;
                            }

                            await db.aiStickers.put({
                                meaning: finalMeaning,
                                url: sticker.url,
                                width: sticker.width,
                                height: sticker.height
                            });
                            // 添加到内存集合，防止同一批次中的重复URL
                            existingUrls.add(sticker.url);
                            savedCount++;

                            // 如果自动生成了衍生名，记录一下
                            if (finalMeaning !== sticker.meaning) {
                                console.log(`📌 表情包含义自动衍生：${sticker.meaning} → ${finalMeaning}`);
                            }
                        }
                    } catch (err) {
                        loadingErrors.push(`${sticker.meaning}: 保存失败 - ${err.message}`);
                    }
                    // 实时更新保存进度
                    updateImportLoading(`已保存 ${savedCount}/${validStickers.length} 个表情...`);
                }
            }

            // 返回结果对象
            const errorCount = errorLines.length + loadingErrors.length + urlDuplicateErrors.length;
            renderAiStickersLibrary();
            return {
                success: true,
                total: stickersToAdd.length,
                added: savedCount,
                errorCount: errorCount,
                errorLines: errorLines,
                loadingErrors: loadingErrors,
                urlDuplicateErrors: urlDuplicateErrors
            };

        } catch (error) {
            console.error("批量添加AI表情包时出错:", error);
            return {
                success: false,
                message: `批量添加失败：${error.message}`
            };
        }
    } else {
        return {
            success: false,
            message: '没有找到任何有效的表情包对（含义和URL），请检查格式。'
        };
    }
}

// ▲▲▲ 【新增】AI表情包批量添加函数结束 ▲▲▲

/**
 * 处理 TXT 文件导入 AI 表情包
 */
async function handleImportTxtAiStickers() {
    document.getElementById('import-txt-ai-sticker-input').click();
}

// 为 TXT 文件输入框添加监听（在页面初始化时绑定）
if (!window.txtStickerInputListenerAdded) {
    window.txtStickerInputListenerAdded = true;
    const fileInput = document.getElementById('import-txt-ai-sticker-input');
    if (fileInput) {
        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            try {
                // 显示加载动画
                showImportLoading('导入中...', '正在处理文件，请稍候');

                let text = '';
                const fileName = file.name.toLowerCase();

                // 【新增】判断文件类型
                if (fileName.endsWith('.docx')) {
                    // 使用 mammoth.js 解析 docx 文件
                    const arrayBuffer = await file.arrayBuffer();
                    const mammothResult = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                    text = mammothResult.value;
                } else if (fileName.endsWith('.txt')) {
                    // 直接读取 txt 文件
                    text = await file.text();
                } else {
                    hideImportLoading();
                    await showCustomAlert('错误', '不支持的文件格式，请选择 .txt 或 .docx 文件');
                    event.target.value = '';
                    return;
                }

                const result = await parseAndAddAiStickers(text);
                // 隐藏加载动画
                hideImportLoading();
                // 显示导入结果
                if (result.success) {
                    // 先显示成功导入的数量
                    const message = `成功导入 ${result.added} 个表情`;
                    await showCustomAlert('导入成功', message);

                    // 如果有失败项目，再显示详细的失败列表
                    if (result.errorCount > 0) {
                        await showImportFailureDetails(result.errorLines, result.loadingErrors, result.urlDuplicateErrors);
                    }
                } else {
                    await showCustomAlert('导入失败', result.message || '未知错误');
                }
            } catch (err) {
                hideImportLoading();
                await showCustomAlert('错误', `读取文件失败：${err.message}`);
            }

            // 重置文件输入框，这样可以再次选择同一个文件
            event.target.value = '';
        });
    }
}

/**
 * HTML转义函数，防止XSS
 */
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, char => map[char]);
}

/**
 * 显示导入失败项目的详细信息
 * @param {array} errorLines - 格式错误的行
 * @param {array} loadingErrors - 加载失败的错误信息（包含含义、URL、错误原因）
 * @param {array} urlDuplicateErrors - URL重复的表情包名
 */
async function showImportFailureDetails(errorLines = [], loadingErrors = [], urlDuplicateErrors = []) {
    let detailsHtml = '<div style="text-align: left; max-height: 400px; overflow-y: auto;">';

    // 显示格式错误的项目
    if (errorLines.length > 0) {
        detailsHtml += `<div style="margin-bottom: 15px;">`;
        detailsHtml += `<h4 style="color: #FF6B6B; margin-bottom: 8px;">📋 格式错误（${errorLines.length}个）</h4>`;
        detailsHtml += `<div style="background: #FFF5F5; padding: 10px; border-radius: 6px; font-size: 13px; line-height: 1.6; color: #333;">`;
        errorLines.forEach((line, index) => {
            detailsHtml += `<div style="margin-bottom: 6px;">• ${escapeHtml(line)}</div>`;
        });
        detailsHtml += `</div></div>`;
    }

    // 显示加载失败的项目（含详细URL）
    if (loadingErrors.length > 0) {
        detailsHtml += `<div style="margin-bottom: 15px;">`;
        detailsHtml += `<h4 style="color: #FF6B6B; margin-bottom: 8px;">❌ 加载失败（${loadingErrors.length}个）</h4>`;
        detailsHtml += `<div style="background: #FFF5F5; padding: 10px; border-radius: 6px; font-size: 12px; line-height: 1.6; color: #333;">`;
        loadingErrors.forEach((error) => {
            const errorObj = typeof error === 'string' ? { meaning: error, url: '', error: '加载失败' } : error;
            detailsHtml += `<div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid rgba(0,0,0,0.1);">`;
            detailsHtml += `<div style="font-weight: 500; margin-bottom: 3px;">📌 ${escapeHtml(errorObj.meaning)}</div>`;
            detailsHtml += `<div style="font-size: 11px; color: #666; word-break: break-all; margin-bottom: 2px;">URL: ${escapeHtml(errorObj.url)}</div>`;
            detailsHtml += `<div style="font-size: 11px; color: #FF6B6B;">原因: ${escapeHtml(errorObj.error)}</div>`;
            detailsHtml += `</div>`;
        });
        detailsHtml += `</div></div>`;
    }

    // 显示URL重复的项目（简单提示）
    if (urlDuplicateErrors.length > 0) {
        detailsHtml += `<div style="margin-bottom: 15px;">`;
        detailsHtml += `<h4 style="color: #FFA940; margin-bottom: 8px;">⚠️ URL已存在（${urlDuplicateErrors.length}个）</h4>`;
        detailsHtml += `<div style="background: #FFFBE6; padding: 10px; border-radius: 6px; font-size: 13px; line-height: 1.6; color: #333;">`;
        urlDuplicateErrors.forEach((meaning) => {
            detailsHtml += `<div style="margin-bottom: 6px;">• ${escapeHtml(meaning)}</div>`;
        });
        detailsHtml += `</div></div>`;
    }

    detailsHtml += '</div>';

    // 使用自定义弹窗显示详情（支持HTML）
    const modalOverlay = document.createElement('div');
    modalOverlay.className = 'custom-modal-overlay';
    modalOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;

    const modal = document.createElement('div');
    modal.className = 'custom-modal-content';
    modal.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 20px;
        max-width: 500px;
        width: 90%;
        max-height: 70vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    `;

    modal.innerHTML = `
        <div style="margin-bottom: 15px;">
            <h3 style="margin: 0 0 10px 0; color: #1E1E1E;">导入失败详情</h3>
            ${detailsHtml}
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;">
            <button id="failure-details-close-btn" style="
                padding: 8px 16px;
                background: #1E1E1E;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
            ">关闭</button>
        </div>
    `;

    modalOverlay.appendChild(modal);
    document.body.appendChild(modalOverlay);

    // 关闭按钮的事件处理
    document.getElementById('failure-details-close-btn').addEventListener('click', () => {
        modalOverlay.remove();
    });

    // 点击背景也能关闭
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
            modalOverlay.remove();
        }
    });
}

/**
 * 打开AI表情包搜索模态框
 */
function openAiStickerSearchModal() {
    document.getElementById('ai-sticker-search-modal').classList.add('visible');
    document.getElementById('ai-sticker-search-input').focus();
}

/**
 * 搜索表情包
 */
async function searchAiStickers() {
    const keyword = document.getElementById('ai-sticker-search-input').value.trim();
    if (!keyword) {
        showCustomAlert('搜索提示', '请输入搜索关键词');
        return;
    }

    // 从数据库读取所有表情包
    const allStickers = await db.aiStickers.toArray();

    // 进行模糊搜索（搜索含义中是否包含关键词）
    const results = allStickers.filter(sticker =>
        sticker.meaning && sticker.meaning.includes(keyword)
    );

    // 显示搜索结果
    renderAiStickerSearchResults(results, keyword);
}

/**
 * 渲染搜索结果
 */
function renderAiStickerSearchResults(stickers, keyword) {
    const resultsContainer = document.getElementById('ai-sticker-search-results');
    resultsContainer.innerHTML = '';

    if (!stickers || stickers.length === 0) {
        resultsContainer.innerHTML = `<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">未找到包含"${keyword}"的表情包</p>`;
        return;
    }

    stickers.forEach((sticker) => {
        const item = document.createElement('div');
        item.className = 'ai-sticker-item';
        item.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 3px;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 6px;
            position: relative;
            align-items: center;
        `;

        // 显示表情包图片
        const img = document.createElement('img');
        img.src = sticker.url;
        img.alt = sticker.meaning;
        img.style.cssText = `
            max-width: 45px;
            max-height: 45px;
            object-fit: contain;
            border-radius: 3px;
        `;
        img.onerror = () => {
            img.style.backgroundColor = '#ddd';
            img.textContent = '❌';
        };
        item.appendChild(img);

        // 显示表情包含义
        const meaningDiv = document.createElement('div');
        meaningDiv.textContent = sticker.meaning;
        meaningDiv.style.cssText = `
            text-align: center;
            font-size: 10px;
            color: var(--text-primary);
            word-break: break-word;
            line-height: 1.2;
            max-width: 100%;
        `;
        item.appendChild(meaningDiv);

        resultsContainer.appendChild(item);
    });
}

// ▲▲▲ 【新增】AI表情包库管理函数结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】将保存的图标URL应用到主屏幕的App图标上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        // kk-checkin图标特殊处理
        if (iconId === 'kk-checkin') {
            const imgElement = document.getElementById('kk-checkin-icon-img');
            if (imgElement) {
                imgElement.src = state.globalSettings.appIcons[iconId];
            }
        } else {
            const imgElement = document.getElementById(`icon-img-${iconId}`);
            if (imgElement) {
                imgElement.src = state.globalSettings.appIcons[iconId];
            }
        }
    }
}

/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
// ▼▼▼ 用这个【新版本】替换旧的 renderIconSettings 函数 ▼▼▼
/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
        'world-book': '世界书',
        'qq': 'QQ',
        'api-settings': 'API设置',
        'wallpaper': '外观设置',
        'font': '字体',
        'forum': '论坛',
        'x-social': 'X软件',
        'preset': '预设',
        'kk-checkin': 'kk查岗'
    };

    for (const iconId in state.globalSettings.appIcons) {
        // 安全检查，如果某个图标在旧数据中不存在，就跳过
        if (!appLabels[iconId]) continue; 

        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId];

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <span style="font-size: 13px; color: var(--text-secondary);">${labelText}</span>
            <button class="change-icon-btn">更换</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

/**
 * 当用户点击链接卡片时，打开伪浏览器
 * @param {number} timestamp - 被点击消息的时间戳
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全检查，确保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充浏览器内容
    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '无标题'}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 显示浏览器屏幕
    showScreen('browser-screen');
}

/**
 * 关闭伪浏览器，返回聊天界面
 * (这个函数现在由 init() 中的事件监听器调用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

// ▼▼▼ 请用这个【新版本】替换旧的 openShareLinkModal 函数 ▼▼▼
/**
 * 打开让用户填写链接信息的模态框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次输入的内容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 显示模态框
    document.getElementById('share-link-modal').classList.add('visible');

    // 【核心修复】打开链接弹窗后，立刻关闭功能面板
    closePlusPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户确认分享，创建并发送链接卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("标题是必填项哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 创建消息对象
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 用户分享的链接，我们不提供图片，让它总是显示占位图
        thumbnail_url: null 
    };

    // 将消息添加到历史记录
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息并更新列表
    appendMessage(linkMessage, chat);
    renderChatList();

    // 关闭模态框
    document.getElementById('share-link-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】发送HTML生成指令的核心函数 ▼▼▼
async function sendHtmlPrompt() {
    if (!state.activeChatId) return;

    const userInput = document.getElementById('html-prompt-input').value.trim();
    if (!userInput) {
        alert('指令内容不能为空！');
        return;
    }

    // 1. 定义指令的前半部分 (Prefix)
        const promptPrefix = `【停止角色扮演，现在立刻根据历史聊天记录和角色人设生成一个风格丰富、内容真实、有趣可爱的 HTML 模块(生成内容为`;

        // 2. 定义指令的后半部分 (Suffix)
        const promptSuffix = `），*输出完整HTML+CSS，采用内联样式，不允许使用代码块包裹*，所有人物都不带头像，内容可带emoji符号】
📌 输出规则：
-先明确用户需求内容的属性（如聊天、定位、朋友圈、通话记录、等任意相关场景 / 内容类型），再自动套用对应场景下的原生视觉设计特征（包括但不限于布局结构、元素样式、色彩搭配、信息展示形式等），确保模块视觉与对应功能的呈现逻辑一致。
- 每个模块用 \`<orange>...</orange>\` 包裹，宽度420px，高度700px（做可内部可上下滑动页面），要居中显示，自由排版，正文内容全中文。
- 不使用 \`<html>\` \`<script>\` 等标签结构
- 涉及图像以文字描述，如“背景为月亮碎裂壁纸”等】`;
        
        // 3. 将三部分拼接成最终的完整指令
        const fullPrompt = `${promptPrefix}${userInput}${promptSuffix}`;

    const chat = state.chats[state.activeChatId];

    // 2. 创建一个特殊的消息对象
    const msg = {
        role: 'user',
        content: fullPrompt, // 存储完整的指令，用于发送给AI
        displayContent: 'ੈ♡消えない記憶⊹˳ ⋆', // 【核心】定义一个专门用于显示的“省略号”内容
        timestamp: Date.now()
    };

    // 3. 保存并渲染，但不触发AI回复
    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    // 4. 清理并关闭弹窗
    document.getElementById('html-prompt-input').value = '';
    document.getElementById('html-prompt-modal').classList.remove('visible');
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在"看"动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    // 【新增】检查朋友圈可见性开关
    const momentsVisibilityEnabled = viewerChat.settings?.momentsVisibilityEnabled || false;
    const visibleCharacterIds = viewerChat.settings?.visibleCharacterIds || [];

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 【新增】如果朋友圈可见性开关关闭，只能看到用户和自己的动态
        if (!momentsVisibilityEnabled) {
            // 只允许看用户的动态或自己的动态
            if (post.authorId === 'user') {
                // 用户的动态按分组规则过滤
                if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                    return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
                }
                return true;
            }
            // 只能看自己的动态
            return post.authorId === viewerChat.id;
        }

        // 【新增】如果朋友圈可见性开关打开，检查是否在可见列表中
        if (post.authorId !== 'user' && post.authorId !== viewerChat.id) {
            // 如果是其他AI的动态，检查是否在可见列表中
            if (!visibleCharacterIds.includes(post.authorId)) {
                return false; // 不在可见列表中，不显示
            }
        }

        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了"部分可见"
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID

        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同时获取“完整内容”和“预览片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[语音]';
    } else {
        // 预览片段依然截断，但只用于UI显示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 这里存的是完整的原文！
    };

    // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 这里用的是缩略版！
    previewBar.style.display = 'block';

    // 4. 后续操作保持不变
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

/**
 * 显示处理转账的操作菜单
 * @param {number} timestamp - 被点击的转账消息的时间戳
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 将AI的名字填入弹窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隐藏处理转账的操作菜单
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 处理用户接受或拒绝转账的逻辑
 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始转账消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用户选择“拒绝”
    if (choice === 'declined') {
        // 立刻在前端生成一个“退款”卡片，让用户看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 这是一个关键标记，用于UI显示这是退款
            amount: originalMessage.amount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 准备一条对AI可见的隐藏消息，告诉它发生了什么
        systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
    } else { // 如果用户选择“接受”
        // 只需准备隐藏消息通知AI即可
        systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
    }

    // 3. 创建这条对用户隐藏、但对AI可见的系统消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
        isHidden: true // 这个标记会让它不在聊天界面显示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库，并刷新界面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
        return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 弹出输入框，并将旧名称作为默认值，方便修改
        const newName = await showCustomPrompt(
            "自定义通话名称", 
            "请输入新的名称（留空则恢复默认）",
            record.customName || '' // 如果已有自定义名称，就显示它
        );

        // 2. 如果用户点击了“取消”，则什么都不做
        if (newName === null) return;
        
        // 3. 更新数据库中的这条记录
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整个列表，让更改立刻显示出来
        await renderCallHistoryScreen();
        
        // 5. 给用户一个成功的提示
        await showCustomAlert('成功', '通话名称已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
/**
 * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
 * @param {object} record - 一条通话记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 获取通话对象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根据角色添加不同的class，应用不同的样式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 为新的、干净的按钮绑定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除",
            "确定要永久删除这条通话记录吗？此操作不可恢复。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 关闭当前的详情弹窗
            modal.classList.remove('visible');
            
            // 2. 从数据库删除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通话记录列表
            await renderCallHistoryScreen();
            
            // 4. (可选) 给出成功提示
            alert('通话记录已删除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

/**
 * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
 */
async function handleEditStatusClick() {
    // 1. 安全检查，确保在单聊界面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
    const newStatusText = await showCustomPrompt(
        '编辑对方状态',
        '请输入对方现在的新状态：',
        chat.status.text // 将当前状态作为输入框的默认内容
    );

    // 3. 如果用户输入了内容并点击了"确定"
    if (newStatusText !== null) {
        // 4. 更新内存和数据库中的状态数据
        chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为"在线"
        chat.status.isBusy = false; // 每次手动编辑都默认其不处于"忙碌"状态
        chat.status.lastUpdate = Date.now();
        // 【核心修正】将错误的变量名 msgData.status_text 改为正确的 newStatusText
        chat.displayStatus.statusText = newStatusText.trim() || '在线';

        // 【新增】更新状态历史：用新的状态覆盖最后一条，而不是追加
        if (!chat.statusHistory) {
            chat.statusHistory = [];
        }
        if (chat.statusHistory.length > 0) {
            // 如果有历史记录，则替换最后一条
            chat.statusHistory[chat.statusHistory.length - 1] = {
                text: chat.status.text,
                timestamp: Date.now()
            };
        } else {
            // 如果没有历史记录，则添加第一条
            chat.statusHistory.push({
                text: chat.status.text,
                timestamp: Date.now()
            });
        }

        await db.chats.put(chat);

        

        // 5. 立刻刷新UI，让用户看到修改后的状态
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 给出一个无伤大雅的成功提示
        await showCustomAlert('状态已更新', `"${!chat.isGroup && chat.remark ? chat.remark : chat.name}"的当前状态已更新为：${chat.status.text}`);
    }
}

// 放在你的JS功能函数定义区
async function openShareTargetPicker() {
    // 先显示转发方式选择模态框
    const forwardMethodModal = document.getElementById('forward-method-modal');
    forwardMethodModal.classList.add('visible');
}

// 【全新】打开分享目标选择器，用于具体的转发操作
async function openShareTargetModalForMessages(forwardMethod) {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为分享目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });

    // 标记当前的转发方式
    modal.dataset.forwardMethod = forwardMethod;
    modal.classList.add('visible');
}

// 论坛转发功能：打开转发目标选择模态框
async function openForumShareTargetModal(post) {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为转发目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    // 存储当前要转发的帖子信息
    modal.dataset.forwardingPostId = post.id;
    
    modal.classList.add('visible');
}

// 处理论坛帖子转发
async function handleForumPostForward(post, targetChatIds) {
    // 增加帖子的转发次数
    if (!post.forwardCount) post.forwardCount = 0;
    post.forwardCount += targetChatIds.length;
    await db.forumPosts.put(post);
    
    // 创建论坛转发卡片消息
// 创建论坛转发卡片消息
const forumCardMessage = {
    role: 'user',
    senderName: state.qzoneSettings.nickname || '我',
    type: 'forum_card',
    timestamp: Date.now(),
    payload: {
        postId: post.id,
        posterName: post.posterName,
        postType: post.postType,
        // ▼▼▼ 核心修改在这里 ▼▼▼
        postContent: post.postContent, // 传递原始的纯文本内容
        publicText: post.publicText,   // 传递原始的公开文本
        hiddenContent: post.hiddenContent, // 传递原始的隐藏文本（文字图）
        imageUrl: post.imageUrl,         // 传递原始的图片URL
        imageDescription: post.imageDescription, // <-- 【全新添加】确保图片描述也被转发
        // ▲▲▲ 修改结束 ▲▲▲
        title: `转发自论坛的帖子`,
        originalLikes: post.likes ? post.likes.length : 0, // 修正：传递点赞数而不是名字列表
        originalComments: post.comments?.length || 0
    }
};

    // 发送到所有目标聊天
    for (const targetId of targetChatIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push({...forumCardMessage});
            await db.chats.put(targetChat);
        }
    }
    
    // 刷新论坛显示以更新转发次数
    renderForumPosts(currentForumPosts);
    
    await showCustomAlert("转发成功", `帖子已成功转发到 ${targetChatIds.length} 个会话中。`);
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }
}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
         * 【全新】处理用户点击“撤回”按钮的入口函数
         */
        async function handleRecallClick() {
            if (!activeMessageTimestamp) return;

            const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
            const messageTime = activeMessageTimestamp;
            const now = Date.now();

            // 检查是否超过了撤回时限
            if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                hideMessageActions();
                await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
                return;
            }

            // 如果在时限内，执行真正的撤回逻辑
            await recallMessage(messageTime, true);
            hideMessageActions();

            // 【核心新增】在撤回后，立即触发AI响应
            triggerAiResponse();
        }

/**
         * 【全新】消息撤回的核心逻辑
         * @param {number} timestamp - 要撤回的消息的时间戳
         * @param {boolean} isUserRecall - 是否是用户主动撤回
         */
        async function recallMessage(timestamp, isUserRecall) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;

            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;

            const messageToRecall = chat.history[messageIndex];

            // 1. 修改消息对象，将其变为“已撤回”状态
            const recalledData = {
                originalType: messageToRecall.type || 'text',
                originalContent: messageToRecall.content,
                // 保存其他可能存在的原始数据
                originalMeaning: messageToRecall.meaning,
                originalQuote: messageToRecall.quote
            };

            messageToRecall.type = 'recalled_message';
            messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
            messageToRecall.recalledData = recalledData;
            // 【核心修复】添加isRecalledMessage标记，防止此消息被任何过滤操作删除
            messageToRecall.isRecalledMessage = true;
            // 清理掉不再需要的旧属性
            delete messageToRecall.meaning;
            delete messageToRecall.quote;

            // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
            if (isUserRecall) {
                const hiddenMessageForAI = {
                    role: 'system',
                    // 【核心修改】在这里，我们告诉AI被撤回的内容是什么
                    content: `[系统提示：用户撤回了刚刚发送的一条消息。被撤回的内容是：“${recalledData.originalContent}”。请你根据这个情况，自然地继续对话。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessageForAI);
            }

            // 3. 保存到数据库并刷新UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            if (isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
        }
/**
 * 【全新】处理“向下全选”按钮的点击事件
 */
function handleSelectBelow() {
    if (selectedMessages.size === 0) {
        alert('请至少先选择一条消息作为起点。');
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 找到用户已选中的消息中，时间戳最大的那一条
    const lastSelectedTimestamp = Math.max(...selectedMessages);

    // 2. 在聊天历史中找到这条消息的索引位置
    const startIndex = chat.history.findIndex(msg => msg.timestamp === lastSelectedTimestamp);

    if (startIndex === -1) return; // 安全检查

    // 3. 从这条消息的下一条开始，遍历所有后续消息
    for (let i = startIndex + 1; i < chat.history.length; i++) {
        const messageToSelect = chat.history[i];
        // 确保我们不会选中那些对用户隐藏的系统消息
        if (!messageToSelect.isHidden) {
            selectedMessages.add(messageToSelect.timestamp);
        }
    }

    // 4. 批量更新UI，为所有新选中的消息添加 'selected' 样式
    document.querySelectorAll('#chat-messages .message-bubble').forEach(bubble => {
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (selectedMessages.has(timestamp)) {
            bubble.classList.add('selected');
        }
    });

    // 5. 更新顶部的计数显示
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
}
// ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 打开分类管理模态框
 */
async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
}

/**
 * 在模态框中渲染已存在的分类列表
 */
async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        // 使用毛玻璃样式
        const item = document.createElement('div');
        item.className = 'category-item-row'; 
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一个新的世界书分类
 */
async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name });
    input.value = '';
    await renderCategoryListInManager();
}

/**
 * 删除一个世界书分类
 * @param {number} categoryId - 要删除的分类的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        await renderCategoryListInManager();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】批量添加表情包功能 ▼▼▼

/**
 * 弹出批量添加的输入框
 */
async function handleBatchAddStickers() {
    // 1. 弹出带有文本输入区的提示框，并提供新的格式说明
    const inputText = await showCustomPrompt(
        '批量添加表情包',
        // 【核心修改】更新这里的提示文本，告知用户新格式
        '请按格式粘贴，名称和链接各占一行：\n很不高兴\nhttps://....jpeg,\n双倍开心\nhttps://....jpg,',
        '', 
        'textarea'
    );

    if (!inputText || !inputText.trim()) {
        return;
    }

    await parseAndAddStickers(inputText);
}

// ▼▼▼ 【最终版】请用这个函数完整替换旧的 parseAndAddStickers 函数 ▼▼▼
/**
 * 解析文本并批量添加表情包到数据库 (智能兼容单行与多行格式)
 * @param {string} text - 用户在文本框中输入的完整字符串
 */
async function parseAndAddStickers(text) {
    // 1. 按行分割，并过滤掉可能存在的完全空白的行
    const lines = text.split('\n').filter(line => line.trim() !== '');
    
    const stickersToAdd = [];
    const errorLines = [];
    
    // 2. 引入一个'待定名称'变量，用于处理名称和链接在不同行的情况
    let pendingName = null;

    const urlRegex = /(https?:\/\/[^\s]+)/;

    for (const line of lines) {
        const trimmedLine = line.trim();
        const match = trimmedLine.match(urlRegex);

        // --- 核心判断逻辑 ---

        // 情况A: 当前行包含URL
        if (match) {
            const url = match[0].replace(/,$/, '').trim(); // 获取URL并去掉末尾逗号
            const name = trimmedLine.substring(0, trimmedLine.indexOf(url)).trim(); // URL之前的内容是名称

            // 情况A1: 名称和URL在同一行 (例如: "开心https://...")
            if (name) {
                stickersToAdd.push({ id: `sticker_${Date.now()}_${stickersToAdd.length}`, name, url });
                if (pendingName) { // 如果之前有一个待定的名称，说明它落单了，是错误的
                    errorLines.push(pendingName);
                    pendingName = null;
                }
            } 
            // 情况A2: 当前行只有URL，需要和上一行的待定名称配对
            else if (pendingName) {
                stickersToAdd.push({ id: `sticker_${Date.now()}_${stickersToAdd.length}`, name: pendingName, url });
                pendingName = null; // 配对成功，清空待定名称
            } 
            // 情况A3: 当前行只有URL，但没有待定的名称与之配对，错误
            else {
                errorLines.push(trimmedLine);
            }
        } 
        // 情况B: 当前行不包含URL，只能是名称
        else {
            if (pendingName) { // 如果之前已经有一个待定的名称，说明它落单了
                errorLines.push(pendingName);
            }
            pendingName = trimmedLine; // 将当前行设为新的待定名称
        }
    }

    // 循环结束后，如果还有一个待定的名称没有配对，也视为错误
    if (pendingName) {
        errorLines.push(pendingName);
    }
    
    // --- 后续逻辑保持不变 ---
    if (stickersToAdd.length > 0) {
        try {
            await db.userStickers.bulkAdd(stickersToAdd);
            state.userStickers.push(...stickersToAdd);
        } catch (error) {
            console.error("批量添加表情包到数据库失败:", error);
            await showCustomAlert('错误', '保存表情包时发生错误，请检查控制台。');
            return;
        }
    }

    let resultMessage = `成功添加 ${stickersToAdd.length} 个表情包！`;
    if (errorLines.length > 0) {
        resultMessage += `\n\n有 ${errorLines.length} 行格式不正确或无法配对，已被跳过。`;
    }
    await showCustomAlert('批量添加完成', resultMessage);

    renderStickerPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        /**
 * 【全新】专门更新聊天界面顶部的状态栏
 */
function updateChatHeaderStatus() {
    if (!state.activeChatId) return; // 如果没有打开任何聊天，则不执行
    const chat = state.chats[state.activeChatId];
    if (!chat || chat.isGroup) return; // 如果找不到聊天或者当前是群聊，则不执行

    // 找到状态栏相关的元素
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    // 更新状态文本和"忙碌"样式
    statusTextEl.textContent = chat.status?.text || '在线';
    statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
}
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
/**
 * 【全新】更强大的Base64解码器，用于处理特殊字符
 * @param {string} str - Base64编码的字符串
 * @returns {string} - 解码后的UTF-8字符串
 */
function decodeBase64Unicode(str) {
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
/**
 * 【全新】角色卡诊断函数
 * @param {File} file - PNG文件
 * @returns {Promise<string>} - 包含所有文本块信息的结果字符串
 */
function diagnoseCharacterCard(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const buffer = event.target.result;
            const view = new DataView(buffer);
            let output = '开始诊断...\n\n';

            const isPng = view.byteLength > 8 && view.getUint32(0) === 0x89504E47 && view.getUint32(4) === 0x0D0A1A0A;
            if (!isPng) {
                resolve('错误：文件不是一个有效的PNG。');
                return;
            }

            output += '文件确认为PNG格式。\n开始扫描数据块...\n\n';
            let offset = 8;
            let chunkCount = 0;
            while (offset < view.byteLength) {
                chunkCount++;
                if (chunkCount > 100) { // 安全锁，防止无限循环
                    output += '扫描了超过100个数据块，已停止。';
                    break;
                }

                const length = view.getUint32(offset);
                const type = String.fromCharCode(view.getUint8(offset + 4), view.getUint8(offset + 5), view.getUint8(offset + 6), view.getUint8(offset + 7));
                
                if (type === 'tEXt' || type === 'zTXt') {
                    output += `--- 找到文本块 #${chunkCount} ---\n`;
                    output += `类型 (Type): ${type}\n`;
                    output += `长度 (Length): ${length} 字节\n`;

                    const dataOffset = offset + 8;
                    const chunkData = new Uint8Array(buffer, dataOffset, length);
                    const separatorIndex = Array.from(chunkData).indexOf(0);

                    if (separatorIndex > 0) {
                        const key = new TextDecoder('latin1').decode(chunkData.slice(0, separatorIndex));
                        output += `关键词 (Key): ${key}\n\n`;
                        
                        let valueText = '';
                        try {
                            if (type === 'tEXt') {
                                const valueData = chunkData.slice(separatorIndex + 1);
                                valueText = new TextDecoder('latin1').decode(valueData);
                                output += `内容 (未压缩):\n--------------------\n${valueText}\n--------------------\n\n`;
                            } else { // zTXt
                                const valueData = chunkData.slice(separatorIndex + 2);
                                const decompressed = pako.inflate(valueData);
                                valueText = new TextDecoder('utf-8').decode(decompressed);
                                output += `内容 (已解压):\n--------------------\n${valueText}\n--------------------\n\n`;
                            }

                            // 尝试解码并格式化，方便我们查看最终的JSON结构
                            if (key === 'chara') {
                                 const decodedData = decodeBase64Unicode(valueText);
                                 const charData = JSON.parse(decodedData);
                                 output += `尝试解码和格式化 'chara' 内容 (最终JSON结构):\n--------------------\n${JSON.stringify(charData, null, 2)}\n--------------------\n\n`;
                            }
                        } catch (e) {
                            output += `!!! 在处理此块内容时发生错误: ${e.message} !!!\n\n`;
                        }
                    } else {
                        output += `警告：在此文本块中未找到关键词分隔符。\n\n`;
                    }
                }
                offset += 12 + length;
            }
            output += '诊断结束。';
            resolve(output);
        };
        reader.onerror = () => {
            resolve('读取文件失败。');
        };
        reader.readAsArrayBuffer(file);
    });
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ===================================================================
// 【新增】预设管理功能
// ===================================================================

// 当前编辑的预设ID
let currentEditingPresetId = null;

// 渲染预设列表
async function renderPresetList() {
    const container = document.getElementById('preset-list');
    const presets = await db.promptPresets.toArray();

    if (presets.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">暂无预设<br>点击右上角"+"创建预设</div>';
        return;
    }

    container.innerHTML = presets.map(preset => {
        const itemCount = preset.items ? preset.items.length : 0;
        const enabledCount = preset.items ? preset.items.filter(item => item.enabled).length : 0;
        return `
            <div class="preset-list-item" data-id="${preset.id}">
                <div class="preset-list-item-header">
                    <div class="preset-list-item-name">${preset.name}</div>
                    <div style="display: flex; align-items: center;">
                        <button class="preset-list-item-copy" onclick="event.stopPropagation(); copyPreset(${preset.id})" title="复制预设">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                        <button class="preset-list-item-delete" onclick="event.stopPropagation(); deletePreset(${preset.id})" title="删除预设">×</button>
                    </div>
                </div>
                <div class="preset-list-item-info">${itemCount} 个条目 · ${enabledCount} 个已启用</div>
            </div>
        `;
    }).join('');

    // 添加点击事件
    container.querySelectorAll('.preset-list-item').forEach(item => {
        item.addEventListener('click', () => {
            const presetId = parseInt(item.dataset.id);
            editPreset(presetId);
        });
    });
}

// 创建新预设
function createNewPreset() {
    currentEditingPresetId = null;
    document.getElementById('preset-editor-title').textContent = '新建预设';
    document.getElementById('preset-name-input').value = '';
    document.getElementById('preset-items-container').innerHTML = '';
    showScreen('preset-editor-screen');
}

// 编辑预设
async function editPreset(presetId) {
    currentEditingPresetId = presetId;
    const preset = await db.promptPresets.get(presetId);
    if (!preset) return;

    document.getElementById('preset-editor-title').textContent = '编辑预设';
    document.getElementById('preset-name-input').value = preset.name;

    const container = document.getElementById('preset-items-container');
    container.innerHTML = '';

    if (preset.items && preset.items.length > 0) {
        preset.items.forEach((item, index) => {
            // 【新增】传入item.part参数
            addPresetItemToUI(item.content, item.enabled, index, item.name, item.characterId, item.part);
        });
    }

    showScreen('preset-editor-screen');
}

// 保存预设
async function savePreset() {
    const name = document.getElementById('preset-name-input').value.trim();
    if (!name) {
        await showCustomAlert('提示', '请输入预设名称');
        return;
    }

    const items = [];
    const itemElements = document.querySelectorAll('#preset-items-container .preset-item');
    itemElements.forEach(el => {
        // 从data属性中获取content
        let content = el.dataset.content || '';
        const enabled = el.querySelector('input[type="checkbox"]').checked;
        // 获取name
        const itemName = el.dataset.name || '';
        // 【新增】获取part标签（如果有的话）
        const part = el.dataset.part || null;
        if (content) {
            items.push({ content, enabled, name: itemName, part });
        }
    });

    const presetData = { name, items };

    if (currentEditingPresetId) {
        // 更新现有预设
        await db.promptPresets.update(currentEditingPresetId, presetData);
    } else {
        // 创建新预设
        await db.promptPresets.add(presetData);
    }

    // 更新state
    state.promptPresets = await db.promptPresets.toArray();

    showScreen('preset-manager-screen');
    await renderPresetList();
}

// 删除预设
window.deletePreset = async function(presetId) {
    if (!confirm('确定要删除这个预设吗?')) return;

    await db.promptPresets.delete(presetId);
    state.promptPresets = await db.promptPresets.toArray();

    // 清除所有使用该预设的聊天 - 需要清除线下模式和监控模式两个字段
    const allChats = Object.values(state.chats);
    for (const chat of allChats) {
        let needUpdate = false;
        const updateData = {};

        if (chat.presetIdOffline === presetId) {
            chat.presetIdOffline = null;
            updateData.presetIdOffline = null;
            needUpdate = true;
        }

        if (chat.presetIdMonitor === presetId) {
            chat.presetIdMonitor = null;
            updateData.presetIdMonitor = null;
            needUpdate = true;
        }

        if (needUpdate) {
            await db.chats.update(chat.id, updateData);
        }
    }

    // 【新增】如果聊天设置界面打开，刷新预设下拉框
    const chatSettingsModal = document.getElementById('chat-settings-modal');
    if (chatSettingsModal && chatSettingsModal.style.display === 'flex') {
        const presetSelectOffline = document.getElementById('preset-select-offline');
        const presetSelectMonitor = document.getElementById('preset-select-monitor');

        // 处理线下模式预设下拉框
        if (presetSelectOffline) {
            const optionToRemove = presetSelectOffline.querySelector(`option[value="${presetId}"]`);
            if (optionToRemove) {
                optionToRemove.remove();
            }
            if (presetSelectOffline.value === String(presetId)) {
                presetSelectOffline.value = '';
            }
        }

        // 处理监控模式预设下拉框
        if (presetSelectMonitor) {
            const optionToRemove = presetSelectMonitor.querySelector(`option[value="${presetId}"]`);
            if (optionToRemove) {
                optionToRemove.remove();
            }
            if (presetSelectMonitor.value === String(presetId)) {
                presetSelectMonitor.value = '';
            }
        }
    }

    await renderPresetList();
};

// 复制预设
window.copyPreset = async function(presetId) {
    try {
        console.log('开始复制预设, ID:', presetId);

        // 1. 获取原预设数据
        const originalPreset = await db.promptPresets.get(presetId);
        console.log('原预设数据:', originalPreset);

        if (!originalPreset) {
            alert('错误: 找不到要复制的预设');
            return;
        }

        // 2. 深度复制预设数据,创建新预设
        const copiedPreset = {
            name: originalPreset.name + ' - 副本',
            items: originalPreset.items ? JSON.parse(JSON.stringify(originalPreset.items)) : []
        };

        console.log('新预设数据:', copiedPreset);

        // 3. 保存到数据库
        const newPresetId = await db.promptPresets.add(copiedPreset);
        console.log('新预设ID:', newPresetId);

        // 4. 更新state
        state.promptPresets = await db.promptPresets.toArray();

        // 5. 刷新列表
        await renderPresetList();

        console.log('预设复制完成!');
    } catch (error) {
        console.error('复制预设失败:', error);
        alert('复制预设失败: ' + error.message);
    }
}

// ▼▼▼ 【新增】预设条目添加模式 ▼▼▼
let isPresetItemAddMode = false; // 标记是否处于添加条目模式
let addPresetItemBtn = null; // 保存添加条目按钮引用
let targetItemForAddition = null; // 保存等待插入新条目的位置

// 【新增】预设part选择模式相关变量
let isPresetPartSelectionMode = false; // 标记是否处于预设part选择模式
let selectedPresetItemsForPart = new Set(); // 保存选中的预设条目索引
let currentPresetPartSaveMode = null; // 保存当前保存为part1还是part2

// 进入添加条目模式 - 显示模态框选择添加方式
function enterAddPresetItemMode() {
    // 在显示选择模态框之前，进入条目选择模式
    isPresetItemAddMode = true;
    addPresetItemBtn = document.getElementById('add-preset-item-btn');

    // 改变按钮样式，让用户知道现在处于选择模式
    addPresetItemBtn.style.backgroundColor = '#FFD700'; // 变黄色
    addPresetItemBtn.style.color = '#000000';
    addPresetItemBtn.textContent = '请点击要在其后添加条目的条目';

    // 添加条目变成可点击的
    const presetItems = document.querySelectorAll('#preset-items-container .preset-item');
    presetItems.forEach(item => {
        item.style.cursor = 'pointer';
        item.style.backgroundColor = '#F0F0F0';
        item.dataset.addModeClickable = 'true';
    });
}

// 退出添加条目模式
function exitAddPresetItemMode() {
    isPresetItemAddMode = false;

    // 还原按钮样式
    addPresetItemBtn = document.getElementById('add-preset-item-btn');
    addPresetItemBtn.style.backgroundColor = '';
    addPresetItemBtn.style.color = '';
    addPresetItemBtn.textContent = '添加条目';

    // 移除条目的可点击样式
    const presetItems = document.querySelectorAll('#preset-items-container .preset-item');
    presetItems.forEach(item => {
        item.style.cursor = '';
        item.style.backgroundColor = '';
        item.dataset.addModeClickable = 'false';
    });
}

// 在指定条目后添加新条目 - 保存目标条目并显示选择模态框
function addPresetItemAfter(targetItemDiv) {
    targetItemForAddition = targetItemDiv;
    exitAddPresetItemMode();
    document.getElementById('preset-item-add-modal').style.display = 'flex';
}

// 创建并添加新的空白条目到指定位置
function createBlankPresetItem() {
    if (!targetItemForAddition) return;

    const container = document.getElementById('preset-items-container');

    // 【新增】自动检测前后条目的part标签
    const detectPartTag = () => {
        const prevElement = targetItemForAddition.previousElementSibling;
        const nextElement = targetItemForAddition.nextElementSibling;

        const prevPart = prevElement ? (prevElement.dataset.part || null) : null;
        const nextPart = nextElement ? (nextElement.dataset.part || null) : null;

        // 如果前后条目都存在且part标签相同，自动设置该标签
        if (prevPart && prevPart === nextPart) {
            return prevPart;
        }

        // 如果只有前一个条目有part标签，使用它
        if (prevPart && !nextPart) {
            return prevPart;
        }

        // 如果只有后一个条目有part标签，使用它
        if (!prevPart && nextPart) {
            return nextPart;
        }

        // 否则返回null，表示需要弹框让用户选择
        return null;
    };

    const detectedPart = detectPartTag();

    // 如果没有检测到统一的part标签，需要弹框让用户选择
    if (detectedPart === null) {
        showPartSelectionModalForNewItem();
        return;
    }

    // 如果检测到了统一的part标签，直接创建条目
    createAndInsertNewItem(detectedPart);
}

// 【新增】为新条目显示part选择模态框
function showPartSelectionModalForNewItem() {
    const modal = document.getElementById('new-item-part-selection-modal');
    if (!modal) {
        console.error('新条目part选择模态框不存在');
        return;
    }
    modal.style.display = 'flex';
}

// 【新增】为新条目选择part标签
function selectPartForNewItem(partType) {
    const modal = document.getElementById('new-item-part-selection-modal');
    if (modal) {
        modal.style.display = 'none';
    }
    createAndInsertNewItem(partType);
}

// 【新增】创建并插入新条目
function createAndInsertNewItem(partTag = null) {
    if (!targetItemForAddition) return;

    const container = document.getElementById('preset-items-container');
    const newItemDiv = document.createElement('div');
    newItemDiv.className = 'preset-item';
    newItemDiv.dataset.content = ''; // 新条目内容为空
    newItemDiv.dataset.name = ''; // 新条目名称为空

    // 【新增】设置part标签
    if (partTag) {
        newItemDiv.dataset.part = partTag;
    }

    // 【新增】根据part显示符号
    let partSymbol = '';
    if (partTag === 'part1') {
        partSymbol = '♡ ';
    } else if (partTag === 'part2') {
        partSymbol = '✧ ';
    }

    newItemDiv.innerHTML = `
        <div class="preset-item-header">
            <div class="preset-item-toggle">
                <label class="memory-switch">
                    <input type="checkbox" checked>
                    <span class="memory-switch-slider"></span>
                </label>
                <span style="font-weight: 500; font-size: 14px; color: #1E1E1E;">${partSymbol}未命名条目</span>
            </div>
            <div class="preset-item-actions">
                <button class="preset-item-edit-btn" title="查看内容">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/>
                        <path d="M20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                </button>
                <button class="preset-item-move-btn preset-item-move-up">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
                    </svg>
                </button>
                <button class="preset-item-move-btn preset-item-move-down">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/>
                    </svg>
                </button>
                <button class="preset-item-delete-btn">×</button>
            </div>
        </div>
    `;

    // 为新条目绑定事件
    bindPresetItemEvents(newItemDiv);

    // 在目标条目后面插入新条目
    if (targetItemForAddition.nextElementSibling) {
        container.insertBefore(newItemDiv, targetItemForAddition.nextElementSibling);
    } else {
        container.appendChild(newItemDiv);
    }

    // 清空目标条目和关闭模态框
    targetItemForAddition = null;
    document.getElementById('preset-item-add-modal').style.display = 'none';
}

// 从自定义预设库导入条目 - 显示自定义条目库选择模态框
async function showCustomPresetLibrary() {
    document.getElementById('preset-item-add-modal').style.display = 'none';

    // 获取所有自定义预设条目
    const customItems = await db.customPresetItems.toArray();
    const itemsList = document.getElementById('custom-preset-items-list');
    itemsList.innerHTML = '';

    if (customItems.length === 0) {
        itemsList.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">自定义条目库是空的，请先在【自定义预设条目】中添加条目</p>';
        document.getElementById('custom-preset-select-modal').style.display = 'flex';
        return;
    }

    // 列出所有自定义条目
    customItems.forEach(item => {
        const itemBtn = document.createElement('button');
        itemBtn.style.cssText = 'padding: 12px; border: 1px solid #DCDCDC; border-radius: 6px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; text-align: left; transition: all 0.2s;';
        itemBtn.innerHTML = `
            <div style="font-weight: 600; margin-bottom: 4px; font-size: 14px;">${item.name || '未命名条目'}</div>
            <div style="font-size: 12px; color: #999; white-space: pre-wrap; word-break: break-word; max-height: 60px; overflow: hidden;">${item.content ? item.content.substring(0, 100) + (item.content.length > 100 ? '...' : '') : '(空内容)'}</div>
        `;

        itemBtn.addEventListener('mouseover', () => {
            itemBtn.style.backgroundColor = '#F5F5F5';
        });
        itemBtn.addEventListener('mouseout', () => {
            itemBtn.style.backgroundColor = '#FFFFFF';
        });

        itemBtn.addEventListener('click', () => {
            importPresetItem(item);
        });

        itemsList.appendChild(itemBtn);
    });

    document.getElementById('custom-preset-select-modal').style.display = 'flex';
}

// 导入选中的预设条目到当前编辑位置
function importPresetItem(item) {
    if (!targetItemForAddition) {
        targetItemForAddition = document.getElementById('preset-items-container').lastElementChild || null;
    }

    // 【新增】自动检测前后条目的part标签
    const detectPartTag = () => {
        if (!targetItemForAddition) return null;

        const prevElement = targetItemForAddition.previousElementSibling;
        const nextElement = targetItemForAddition.nextElementSibling;

        const prevPart = prevElement ? (prevElement.dataset.part || null) : null;
        const nextPart = nextElement ? (nextElement.dataset.part || null) : null;

        // 如果前后条目都存在且part标签相同，自动设置该标签
        if (prevPart && prevPart === nextPart) {
            return prevPart;
        }

        // 如果只有前一个条目有part标签，使用它
        if (prevPart && !nextPart) {
            return prevPart;
        }

        // 如果只有后一个条目有part标签，使用它
        if (!prevPart && nextPart) {
            return nextPart;
        }

        // 否则返回null，表示需要弹框让用户选择
        return null;
    };

    const detectedPart = detectPartTag();

    // 如果没有检测到统一的part标签，需要弹框让用户选择
    if (detectedPart === null) {
        // 保存要导入的条目信息
        window.pendingImportItem = item;
        showPartSelectionModalForNewItem();
        return;
    }

    // 如果检测到了统一的part标签，直接导入条目
    createAndInsertImportedItem(item, detectedPart);
}

// 【新增】为导入的条目选择part标签
function selectPartForImportedItem(partType) {
    const modal = document.getElementById('new-item-part-selection-modal');
    if (modal) {
        modal.style.display = 'none';
    }
    if (window.pendingImportItem) {
        createAndInsertImportedItem(window.pendingImportItem, partType);
        window.pendingImportItem = null;
    }
}

// 【新增】创建并插入导入的条目
function createAndInsertImportedItem(item, partTag = null) {
    if (!targetItemForAddition) {
        targetItemForAddition = document.getElementById('preset-items-container').lastElementChild || null;
    }

    const container = document.getElementById('preset-items-container');
    const newItemDiv = document.createElement('div');
    newItemDiv.className = 'preset-item';
    newItemDiv.dataset.content = item.content || ''; // 导入内容
    newItemDiv.dataset.name = item.name || ''; // 导入名称

    // 【新增】设置part标签
    if (partTag) {
        newItemDiv.dataset.part = partTag;
    }

    // 【新增】根据part显示符号
    let partSymbol = '';
    if (partTag === 'part1') {
        partSymbol = '♡ ';
    } else if (partTag === 'part2') {
        partSymbol = '✧ ';
    }

    newItemDiv.innerHTML = `
        <div class="preset-item-header">
            <div class="preset-item-toggle">
                <label class="memory-switch">
                    <input type="checkbox" checked>
                    <span class="memory-switch-slider"></span>
                </label>
                <span style="font-weight: 500; font-size: 14px; color: #1E1E1E;">${partSymbol}${item.name || '未命名条目'}</span>
            </div>
            <div class="preset-item-actions">
                <button class="preset-item-edit-btn" title="查看内容">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/>
                        <path d="M20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                </button>
                <button class="preset-item-move-btn preset-item-move-up">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
                    </svg>
                </button>
                <button class="preset-item-move-btn preset-item-move-down">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/>
                    </svg>
                </button>
                <button class="preset-item-delete-btn">×</button>
            </div>
        </div>
    `;

    // 为新条目绑定事件
    bindPresetItemEvents(newItemDiv);

    // 在目标条目后面插入新条目
    if (targetItemForAddition && targetItemForAddition.nextElementSibling) {
        container.insertBefore(newItemDiv, targetItemForAddition.nextElementSibling);
    } else if (targetItemForAddition) {
        targetItemForAddition.parentNode.insertBefore(newItemDiv, targetItemForAddition.nextElementSibling);
    } else {
        container.appendChild(newItemDiv);
    }

    // 清空目标条目和关闭模态框
    targetItemForAddition = null;
    document.getElementById('custom-preset-select-modal').style.display = 'none';
}

// 打开自定义预设条目库管理器
async function openCustomPresetLibraryManager() {
    // 获取所有自定义条目
    const customItems = await db.customPresetItems.toArray();
    const itemsList = document.getElementById('custom-preset-items-list');
    itemsList.innerHTML = '';

    if (customItems.length === 0) {
        const emptyDiv = document.createElement('div');
        emptyDiv.style.cssText = 'text-align: center; padding: 40px 20px; color: #999;';
        emptyDiv.innerHTML = '<div style="font-size: 14px; margin-bottom: 20px;">条目库为空</div>';

        const createBtn = document.createElement('button');
        createBtn.textContent = '创建第一个条目';
        createBtn.style.cssText = 'padding: 10px 20px; border: 1px solid #DCDCDC; border-radius: 6px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-weight: 500;';
        createBtn.addEventListener('click', createNewCustomPresetItem);

        emptyDiv.appendChild(createBtn);
        itemsList.appendChild(emptyDiv);
    } else {
        // 列出所有自定义条目，并提供编辑/删除选项
        customItems.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.style.cssText = 'padding: 12px; border: 1px solid #DCDCDC; border-radius: 6px; background-color: #FFFFFF; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: start;';

            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = 'flex: 1;';
            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 4px; font-size: 14px;">${item.name || '未命名条目'}</div>
                <div style="font-size: 12px; color: #999; white-space: pre-wrap; word-break: break-word; max-height: 60px; overflow: hidden;">${item.content ? item.content.substring(0, 100) + (item.content.length > 100 ? '...' : '') : '(空内容)'}</div>
            `;

            const actionsDiv = document.createElement('div');
            actionsDiv.style.cssText = 'display: flex; gap: 8px; margin-left: 12px;';

            const editBtn = document.createElement('button');
            editBtn.textContent = '编辑';
            editBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #DCDCDC; border-radius: 4px; background-color: #FFFFFF; color: #1E1E1E; cursor: pointer; font-size: 12px;';
            editBtn.addEventListener('click', () => editCustomPresetItem(item.id));

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '删除';
            deleteBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #FF6B6B; border-radius: 4px; background-color: #FFFFFF; color: #FF6B6B; cursor: pointer; font-size: 12px;';
            deleteBtn.addEventListener('click', () => deleteCustomPresetItem(item.id));

            actionsDiv.appendChild(editBtn);
            actionsDiv.appendChild(deleteBtn);

            itemDiv.appendChild(contentDiv);
            itemDiv.appendChild(actionsDiv);
            itemsList.appendChild(itemDiv);
        });

        // 添加创建新条目按钮
        const addBtn = document.createElement('button');
        addBtn.textContent = '+ 添加新条目';
        addBtn.style.cssText = 'width: 100%; padding: 12px; border: 1px dashed #DCDCDC; border-radius: 6px; background-color: #FAFAFA; color: #1E1E1E; cursor: pointer; font-weight: 500; font-size: 14px;';
        addBtn.addEventListener('click', createNewCustomPresetItem);
        itemsList.appendChild(addBtn);
    }

    document.getElementById('custom-preset-select-modal').style.display = 'flex';
}

// 创建新的自定义条目
async function createNewCustomPresetItem() {
    const name = prompt('请输入条目名称：', '新条目');
    if (!name) return;

    try {
        const newItem = {
            name: name,
            content: ''
        };

        const itemId = await db.customPresetItems.add(newItem);
        state.customPresetItems = await db.customPresetItems.toArray();

        // 刷新列表
        openCustomPresetLibraryManager();
    } catch (error) {
        console.error('创建条目失败:', error);
        alert('创建条目失败');
    }
}

// 编辑自定义条目
async function editCustomPresetItem(itemId) {
    const item = await db.customPresetItems.get(itemId);
    if (!item) return;

    // 关闭自定义预设库选择模态框
    document.getElementById('custom-preset-select-modal').style.display = 'none';

    // 打开编辑模态框
    const modal = document.getElementById('preset-content-modal');
    const contentDisplay = document.getElementById('preset-content-display');
    const nameInput = document.getElementById('preset-content-name-input');

    nameInput.value = item.name;

    const contentInput = document.createElement('textarea');
    contentInput.id = 'custom-preset-content-input';
    contentInput.value = item.content || '';
    contentInput.style.cssText = 'width: 100%; height: 500px; border: none; padding: 5px 1px 5px 5px; font-family: Monaco, Menlo, monospace; font-size: 14px; resize: none; box-sizing: border-box; overflow-y: scroll;';

    contentDisplay.innerHTML = '';
    contentDisplay.appendChild(contentInput);

    // 保存按钮处理
    const saveBtn = document.getElementById('preset-content-save-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

    newSaveBtn.addEventListener('click', async () => {
        const newContent = contentInput.value;
        const finalName = nameInput.value.trim() || '未命名条目';

        try {
            await db.customPresetItems.update(itemId, {
                name: finalName,
                content: newContent
            });
            state.customPresetItems = await db.customPresetItems.toArray();

            modal.style.display = 'none';
            document.body.style.overflow = '';
            openCustomPresetLibraryManager();
        } catch (error) {
            console.error('保存条目失败:', error);
            alert('保存条目失败');
        }
    }, { once: true });

    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
}

// 删除自定义条目
async function deleteCustomPresetItem(itemId) {
    if (confirm('确定要删除这个条目吗？')) {
        try {
            await db.customPresetItems.delete(itemId);
            state.customPresetItems = await db.customPresetItems.toArray();
            openCustomPresetLibraryManager();
        } catch (error) {
            console.error('删除条目失败:', error);
            alert('删除条目失败');
        }
    }
}

// 【新增】进入预设条目part选择模式
function enterPresetPartSelectionMode(itemDiv) {
    if (isPresetPartSelectionMode) return;
    isPresetPartSelectionMode = true;

    const container = document.getElementById('preset-items-container');
    const allItems = container.querySelectorAll('.preset-item');

    // 标记容器处于选择模式
    container.classList.add('preset-selection-mode');

    // 为所有条目添加选择样式
    allItems.forEach(item => {
        item.classList.add('selectable');
        item.style.cursor = 'pointer';
        item.style.opacity = '0.7';
    });

    // 选中第一个被长按的条目
    itemDiv.classList.add('selected');
    itemDiv.style.opacity = '1';
    const itemIndex = Array.from(allItems).indexOf(itemDiv);
    selectedPresetItemsForPart.add(itemIndex);

    // 显示part选择控制面板 - 在右上角显示保存按钮
    showPresetPartSavePanel();
}

// 【新增】退出预设条目part选择模式
function exitPresetPartSelectionMode() {
    if (!isPresetPartSelectionMode) return;
    isPresetPartSelectionMode = false;

    const container = document.getElementById('preset-items-container');
    const allItems = container.querySelectorAll('.preset-item');

    container.classList.remove('preset-selection-mode');

    allItems.forEach(item => {
        item.classList.remove('selectable', 'selected');
        item.style.cursor = 'default';
        item.style.opacity = '1';
    });

    selectedPresetItemsForPart.clear();
    currentPresetPartSaveMode = null;

    // 隐藏part选择控制面板
    hidePresetPartSavePanel();
}

// 【新增】切换预设条目的选中状态
function togglePresetItemSelection(itemDiv) {
    const container = document.getElementById('preset-items-container');
    const allItems = container.querySelectorAll('.preset-item');
    const itemIndex = Array.from(allItems).indexOf(itemDiv);

    if (selectedPresetItemsForPart.has(itemIndex)) {
        selectedPresetItemsForPart.delete(itemIndex);
        itemDiv.classList.remove('selected');
        itemDiv.style.opacity = '0.7';
    } else {
        selectedPresetItemsForPart.add(itemIndex);
        itemDiv.classList.add('selected');
        itemDiv.style.opacity = '1';
    }
}

// 【新增】显示part保存面板
function showPresetPartSavePanel() {
    // 找到preset-editor-screen下的header
    const editorScreen = document.getElementById('preset-editor-screen');
    if (!editorScreen) return;

    const header = editorScreen.querySelector('.header');
    if (!header) return;

    // 检查是否已存在保存面板
    let existingPanel = document.getElementById('preset-part-save-panel-container');
    if (existingPanel) {
        existingPanel.style.display = 'flex';
        return;
    }

    // 隐藏原有的操作按钮
    const headerActionsDiv = header.querySelector('div[style*="display: flex"]');
    if (headerActionsDiv) {
        headerActionsDiv.id = 'preset-editor-default-controls';
        headerActionsDiv.style.display = 'none';
    }

    // 创建保存面板容器
    const panelContainer = document.createElement('div');
    panelContainer.id = 'preset-part-save-panel-container';
    panelContainer.style.cssText = 'display: flex; gap: 8px; align-items: center; margin-left: auto;';

    // Part 1 Button (Heart SVG)
    const part1Btn = document.createElement('button');
    part1Btn.classList.add('preset-part-btn', 'part1-btn'); // Add classes
    part1Btn.title = 'Save as Part 1'; // Add tooltip
    part1Btn.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="white">
            <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
        </svg>`;
    part1Btn.addEventListener('click', () => savePresetPartSelection('part1'));

    // Part 2 Button (Sparkle SVG)
    const part2Btn = document.createElement('button');
    part2Btn.classList.add('preset-part-btn', 'part2-btn'); // Add classes
    part2Btn.title = 'Save as Part 2'; // Add tooltip
    part2Btn.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="white">
            <path d="M12 2 L14.5 9.5 L22 12 L14.5 14.5 L12 22 L9.5 14.5 L2 12 L9.5 9.5 Z"/>
        </svg>`;
    part2Btn.addEventListener('click', () => savePresetPartSelection('part2'));

    // Cancel Button (X SVG)
    const cancelBtn = document.createElement('button');
    cancelBtn.classList.add('preset-part-btn', 'cancel-part-btn'); // Add classes
    cancelBtn.title = 'Cancel Selection'; // Add tooltip
    cancelBtn.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>`;
    cancelBtn.addEventListener('click', exitPresetPartSelectionMode);

    panelContainer.appendChild(part1Btn);
    panelContainer.appendChild(part2Btn);
    panelContainer.appendChild(cancelBtn);

    header.appendChild(panelContainer);
}

// 【新增】隐藏part保存面板
function hidePresetPartSavePanel() {
    const panelContainer = document.getElementById('preset-part-save-panel-container');
    if (panelContainer) {
        panelContainer.remove();
    }

    const defaultControls = document.getElementById('preset-editor-default-controls');
    if (defaultControls) {
        defaultControls.style.display = 'flex';
    }
}

// 【新增】保存part选择结果
async function savePresetPartSelection(partType) {
    const container = document.getElementById('preset-items-container');
    const allItems = container.querySelectorAll('.preset-item');

    // 获取所有选中的条目索引
    const selectedIndices = Array.from(selectedPresetItemsForPart);

    // 如果选择为part1，则剩下的条目自动为part2；反之亦然
    selectedIndices.forEach(index => {
        const itemDiv = allItems[index];
        if (itemDiv) {
            itemDiv.dataset.part = partType;
        }
    });

    // 设置剩余条目为另一个part
    const otherPartType = partType === 'part1' ? 'part2' : 'part1';
    for (let i = 0; i < allItems.length; i++) {
        if (!selectedIndices.includes(i)) {
            const itemDiv = allItems[i];
            if (itemDiv) {
                itemDiv.dataset.part = otherPartType;
            }
        }
    }

    // 更新UI显示符号
    updatePresetItemPartSymbols();

    // 退出选择模式
    exitPresetPartSelectionMode();

    // 保存到数据库
    if (currentEditingPresetId) {
        try {
            const preset = await db.promptPresets.get(currentEditingPresetId);
            if (preset && preset.items) {
                const itemElements = document.querySelectorAll('#preset-items-container .preset-item');
                itemElements.forEach((el, index) => {
                    if (preset.items[index]) {
                        preset.items[index].part = el.dataset.part || null;
                    }
                });
                await db.promptPresets.put(preset);
                state.promptPresets = await db.promptPresets.toArray();
            }
        } catch (error) {
            console.error('保存part标签失败:', error);
        }
    }
}

// 【新增】更新预设条目的part符号显示
function updatePresetItemPartSymbols() {
    const itemElements = document.querySelectorAll('#preset-items-container .preset-item');
    itemElements.forEach(itemDiv => {
        const part = itemDiv.dataset.part;
        const nameSpan = itemDiv.querySelector('.preset-item-toggle span:not(.memory-switch-slider)');

        if (nameSpan) {
            let itemName = itemDiv.dataset.name || '未命名条目';

            // 移除旧的符号
            itemName = itemName.replace(/^[♡✧]\s*/, '');

            // 添加新的符号
            if (part === 'part1') {
                itemName = '♡ ' + itemName;
            } else if (part === 'part2') {
                itemName = '✧ ' + itemName;
            }

            nameSpan.textContent = itemName;
        }
    });
}

// 为条目绑定事件的辅助函数
function bindPresetItemEvents(itemDiv) {
    const container = document.getElementById('preset-items-container');

    // 向上移动按钮事件
    itemDiv.querySelector('.preset-item-move-up').addEventListener('click', () => {
        const prevItem = itemDiv.previousElementSibling;
        if (prevItem && prevItem.classList.contains('preset-item')) {
            container.insertBefore(itemDiv, prevItem);
        }
    });

    // 向下移动按钮事件
    itemDiv.querySelector('.preset-item-move-down').addEventListener('click', () => {
        const nextItem = itemDiv.nextElementSibling;
        if (nextItem && nextItem.classList.contains('preset-item')) {
            container.insertBefore(nextItem, itemDiv);
        }
    });

    // 编辑按钮事件 - 查看内容
    itemDiv.querySelector('.preset-item-edit-btn').addEventListener('click', () => {
        if (isPresetItemAddMode) return; // 如果在添加模式，不执行编辑

        const modal = document.getElementById('preset-content-modal');
        const contentDisplay = document.getElementById('preset-content-display');
        const nameInput = document.getElementById('preset-content-name-input');

        // 填充条目名称
        nameInput.value = itemDiv.dataset.name || '';

        const contentInput = document.createElement('textarea');
        contentInput.id = 'preset-content-edit-input';
        contentInput.value = itemDiv.dataset.content || '';
        contentInput.style.cssText = 'width: 100%; height: 500px; border: none; padding: 5px 1px 5px 5px; font-family: Monaco, Menlo, monospace; font-size: 14px; resize: none; box-sizing: border-box; overflow-y: scroll;';

        contentDisplay.innerHTML = '';
        contentDisplay.appendChild(contentInput);

        // 保存按钮处理
        const saveBtn = document.getElementById('preset-content-save-btn');
        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

        newSaveBtn.addEventListener('click', async () => {
            const newContent = contentInput.value;
            const newName = nameInput.value.trim();
            itemDiv.dataset.content = newContent;
            itemDiv.dataset.name = newName;

            // 【修复】更新名称时保留part标签符号
            const nameSpan = itemDiv.querySelector('.preset-item-toggle span:not(.memory-switch-slider)');
            if (nameSpan) {
                const currentText = nameSpan.textContent;
                let partSymbol = '';

                // 检查当前文本中是否有part符号，如果有则保留
                if (currentText.startsWith('♡ ')) {
                    partSymbol = '♡ ';
                } else if (currentText.startsWith('✧ ')) {
                    partSymbol = '✧ ';
                }

                nameSpan.textContent = partSymbol + (newName || '未命名条目');
            }

            if (currentEditingPresetId) {
                try {
                    const preset = await db.promptPresets.get(currentEditingPresetId);
                    if (preset && preset.items) {
                        const itemElements = document.querySelectorAll('#preset-items-container .preset-item');
                        const itemIndex = Array.from(itemElements).indexOf(itemDiv);
                        if (itemIndex >= 0 && preset.items[itemIndex]) {
                            preset.items[itemIndex].content = newContent;
                            preset.items[itemIndex].name = newName;
                            await db.promptPresets.put(preset);
                            state.promptPresets = await db.promptPresets.toArray();
                        }
                    }
                } catch (error) {
                    console.error('保存条目内容失败:', error);
                }
            }

            modal.style.display = 'none';
            document.body.style.overflow = '';
        }, { once: true });

        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    });

    // 删除按钮事件
    itemDiv.querySelector('.preset-item-delete-btn').addEventListener('click', () => {
        itemDiv.remove();
    });

    // 如果在添加模式，条目本身也可以点击
    itemDiv.addEventListener('click', (e) => {
        // 只有在点击条目本身（不是按钮）且在添加模式时才执行
        if (isPresetItemAddMode && !e.target.closest('button')) {
            addPresetItemAfter(itemDiv);
        }
        // 【新增】在part选择模式下，点击条目可以切换选中状态
        if (isPresetPartSelectionMode && !e.target.closest('button')) {
            togglePresetItemSelection(itemDiv);
        }
    });

    // 【新增】长按事件处理 - 进入part选择模式
    let longPressTimer = null;
    itemDiv.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // 只处理左键
        longPressTimer = setTimeout(() => {
            if (!isPresetPartSelectionMode) {
                enterPresetPartSelectionMode(itemDiv);
            }
        }, 500); // 500ms长按时间
    });

    itemDiv.addEventListener('mouseup', () => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
        }
    });

    itemDiv.addEventListener('mouseleave', () => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
        }
    });

    // 【新增】触摸设备长按事件处理
    let touchLongPressTimer = null;
    itemDiv.addEventListener('touchstart', (e) => {
        touchLongPressTimer = setTimeout(() => {
            if (!isPresetPartSelectionMode) {
                enterPresetPartSelectionMode(itemDiv);
            }
        }, 500); // 500ms长按时间
    });

    itemDiv.addEventListener('touchend', () => {
        if (touchLongPressTimer) {
            clearTimeout(touchLongPressTimer);
        }
    });

    itemDiv.addEventListener('touchcancel', () => {
        if (touchLongPressTimer) {
            clearTimeout(touchLongPressTimer);
        }
    });
}
// ▲▲▲ 预设条目添加模式结束 ▲▲▲

// 添加预设条目到UI
function addPresetItemToUI(content = '', enabled = true, index = null, name = '', characterId = null, part = null) {
    const container = document.getElementById('preset-items-container');

    // 检查是否需要插入分割线
    if (characterId !== null && container.children.length > 0) {
        const lastChild = container.lastChild;
        const lastCharacterId = lastChild.dataset.characterId;

        // 如果最后一个元素的characterId与当前不同，或者最后一个是分割线，需要插入分割线
        if (lastCharacterId !== undefined && lastCharacterId !== characterId.toString() && lastChild.className !== 'preset-item-divider') {
            const divider = document.createElement('div');
            divider.className = 'preset-item-divider';
            divider.innerHTML = `<div class="preset-item-divider-label">Character ID: ${characterId}</div>`;
            container.appendChild(divider);
        }
    }

    const itemDiv = document.createElement('div');
    itemDiv.className = 'preset-item';
    itemDiv.dataset.content = content; // 存储content到data属性
    itemDiv.dataset.name = name; // 存储name到data属性
    itemDiv.dataset.characterId = characterId; // 存储characterId到data属性
    // 【新增】存储part到data属性
    if (part) {
        itemDiv.dataset.part = part;
    }

    // 【新增】根据part显示符号
    let partSymbol = '';
    if (part === 'part1') {
        partSymbol = '♡ ';
    } else if (part === 'part2') {
        partSymbol = '✧ ';
    }

    itemDiv.innerHTML = `
        <div class="preset-item-header">
            <div class="preset-item-toggle">
                <label class="memory-switch">
                    <input type="checkbox" ${enabled ? 'checked' : ''}>
                    <span class="memory-switch-slider"></span>
                </label>
                <span style="font-weight: 500; font-size: 14px; color: #1E1E1E;">${partSymbol}${name || '未命名条目'}</span>
            </div>
            <div class="preset-item-actions">
                <button class="preset-item-edit-btn" title="查看内容">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/>
                        <path d="M20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                </button>
                <button class="preset-item-move-btn preset-item-move-up">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
                    </svg>
                </button>
                <button class="preset-item-move-btn preset-item-move-down">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/>
                    </svg>
                </button>
                <button class="preset-item-delete-btn">×</button>
            </div>
        </div>
    `;

    // 使用统一的绑定函数
    bindPresetItemEvents(itemDiv);

    container.appendChild(itemDiv);
}

// ▼▼▼ 【新增】导入预设功能 ▼▼▼
async function importPresetFromJSON() {
    const fileInput = document.getElementById('preset-import-file-input');
    fileInput.click();
}

document.getElementById('preset-import-file-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const text = await file.text();
        const jsonData = JSON.parse(text);

        // 检查是否有prompts字段
        if (!jsonData.prompts || !Array.isArray(jsonData.prompts)) {
            await showCustomAlert('错误', '该文件不是有效的预设JSON文件，缺少prompts字段');
            e.target.value = ''; // 重置文件输入
            return;
        }

        // 创建identifier到prompt的映射
        const promptMap = {};
        jsonData.prompts.forEach(prompt => {
            if (prompt.identifier) {
                promptMap[prompt.identifier] = prompt;
            }
        });

        // 收集所有在prompt_order中出现过的identifier
        const identifiersInOrder = new Set();
        if (jsonData.prompt_order && Array.isArray(jsonData.prompt_order)) {
            jsonData.prompt_order.forEach(charOrder => {
                if (charOrder.order && Array.isArray(charOrder.order)) {
                    charOrder.order.forEach(orderItem => {
                        identifiersInOrder.add(orderItem.identifier);
                    });
                }
            });
        }

        // 找出不在prompt_order中的prompts（未排序项）
        const unsortedPrompts = [];
        jsonData.prompts.forEach(prompt => {
            if (prompt.identifier && !identifiersInOrder.has(prompt.identifier)) {
                unsortedPrompts.push(prompt);
            }
        });

        // 开始组建items
        const items = [];

        // 先添加未排序的项，名称前加★标记
        unsortedPrompts.forEach(prompt => {
            items.push({
                content: prompt.content || '',
                name: '★ ' + (prompt.name || ''),
                enabled: prompt.enabled !== undefined ? prompt.enabled : true,
                identifier: prompt.identifier,
                characterId: null // 未排序项无characterId
            });
        });

        // 再按照prompt_order的顺序添加已排序的项（按character_id顺序）
        if (jsonData.prompt_order && Array.isArray(jsonData.prompt_order)) {
            jsonData.prompt_order.forEach(charOrder => {
                if (charOrder.order && Array.isArray(charOrder.order)) {
                    charOrder.order.forEach(orderItem => {
                        const prompt = promptMap[orderItem.identifier];
                        // 如果在prompts中找到，用prompts的数据；否则创建空内容项
                        if (prompt) {
                            items.push({
                                content: prompt.content || '',
                                name: prompt.name || '',
                                enabled: prompt.enabled !== undefined ? prompt.enabled : true,
                                identifier: prompt.identifier,
                                characterId: charOrder.character_id // 记录所属的character_id
                            });
                        } else {
                            // 在prompt_order中但不在prompts中的项，创建空内容项
                            items.push({
                                content: '',
                                name: orderItem.identifier,
                                enabled: orderItem.enabled !== undefined ? orderItem.enabled : true,
                                identifier: orderItem.identifier,
                                characterId: charOrder.character_id // 记录所属的character_id
                            });
                        }
                    });
                }
            });
        }

        if (items.length === 0) {
            await showCustomAlert('提示', '该文件中没有有效的预设项');
            e.target.value = ''; // 重置文件输入
            return;
        }

        // 创建新预设，名称为文件名（去掉.json后缀）
        const fileName = file.name.replace(/\.json$/i, '');
        const presetData = {
            name: fileName,
            items: items
        };

        // 保存到数据库
        const newPresetId = await db.promptPresets.add(presetData);
        state.promptPresets = await db.promptPresets.toArray();

        // 提示成功
        await showCustomAlert('成功', `已导入预设 "${fileName}"，包含 ${items.length} 个条目`);

        // 刷新预设列表
        await renderPresetList();

        // 重置文件输入
        e.target.value = '';

    } catch (error) {
        console.error('导入预设失败:', error);
        await showCustomAlert('错误', '导入预设失败: ' + error.message);
        e.target.value = ''; // 重置文件输入
    }
});
// ▲▲▲ 导入预设功能结束 ▲▲▲

// ▼▼▼ 【新增】预设内容模态框关闭事件 ▼▼▼
document.getElementById('preset-content-close-btn').addEventListener('click', () => {
    document.getElementById('preset-content-modal').style.display = 'none';
    document.body.style.overflow = ''; // 恢复滚动
});

document.getElementById('preset-content-cancel-btn').addEventListener('click', () => {
    document.getElementById('preset-content-modal').style.display = 'none';
    document.body.style.overflow = ''; // 恢复滚动
});

// 点击模态框外部关闭
document.getElementById('preset-content-modal').addEventListener('click', (e) => {
    if (e.target.id === 'preset-content-modal') {
        e.target.style.display = 'none';
        document.body.style.overflow = ''; // 恢复滚动
    }
});
// ▲▲▲ 预设内容模态框关闭事件结束 ▲▲▲

// ▼▼▼ 编辑API预设模态框事件监听 ▼▼▼
document.getElementById('edit-api-preset-close-btn').addEventListener('click', () => {
    document.getElementById('edit-api-preset-modal').style.display = 'none';
    window.currentEditingPresetId = null;
});

document.getElementById('edit-api-preset-cancel-btn').addEventListener('click', () => {
    document.getElementById('edit-api-preset-modal').style.display = 'none';
    window.currentEditingPresetId = null;
});

document.getElementById('edit-api-preset-save-btn').addEventListener('click', () => {
    window.saveEditedApiPreset();
});

document.getElementById('edit-preset-fetch-models-btn').addEventListener('click', () => {
    window.fetchModelsForEditPreset();
});

// 点击modal背景关闭
document.getElementById('edit-api-preset-modal').addEventListener('click', (e) => {
    if (e.target.id === 'edit-api-preset-modal') {
        e.target.style.display = 'none';
        window.currentEditingPresetId = null;
    }
});
// ▲▲▲ 编辑API预设模态框事件监听结束 ▲▲▲

// 获取预设应用到系统提示词的核心函数
async function applyPresetToSystemPrompt(chat, originalSystemPrompt) {
    if (!chat.presetId) {
        return originalSystemPrompt;
    }

    const preset = await db.promptPresets.get(chat.presetId);
    if (!preset || !preset.items || preset.items.length === 0) {
        return originalSystemPrompt;
    }

    // 只获取启用的条目
    const enabledItems = preset.items.filter(item => item.enabled);
    if (enabledItems.length === 0) {
        return originalSystemPrompt;
    }

    // 【新增】按part分类
    const part1Items = enabledItems.filter(item => item.part === 'part1');
    const part2Items = enabledItems.filter(item => item.part === 'part2');
    const untaggedItems = enabledItems.filter(item => !item.part);

    // 【新增】组合内容：part1 + 基础prompt + part2
    const part1Content = part1Items.map(item => item.content).join('\n\n');
    const part2Content = part2Items.map(item => item.content).join('\n\n');
    const untaggedContent = untaggedItems.map(item => item.content).join('\n\n');

    // 【新增】构建最终的systemPrompt
    let finalPrompt = originalSystemPrompt;

    // 如果有未标记的条目，按原逻辑放在最前面（向后兼容）
    if (untaggedContent) {
        finalPrompt = untaggedContent + '\n\n' + finalPrompt;
    }

    // part2内容插入到基础prompt之后
    if (part2Content) {
        finalPrompt = finalPrompt + '\n\n' + part2Content;
    }

    // part1内容插入到最前面
    if (part1Content) {
        finalPrompt = part1Content + '\n\n' + finalPrompt;
    }

    return finalPrompt;
}

// ▼▼▼ 【全新】"kk查岗"功能的所有核心函数 ▼▼▼

let activeKkCharId = null; // 用于追踪正在查看哪个角色的房屋

/**
 * 显示加载动画并设置指定的文字
 */
function showGenerationOverlay(text) {
    const overlay = document.getElementById('generation-overlay');
    const textElement = document.getElementById('generation-text');
    if (textElement) {
        textElement.textContent = text;
    }
    overlay.classList.add('visible');
}

/**
 * 根据prompt生成并加载图片(使用pollinations.ai免费API)
 */
function generateAndLoadImage(prompt) {
    return new Promise((resolve, reject) => {
        const encodedPrompt = encodeURIComponent(prompt);
        const seed = Math.floor(Math.random() * 100000);
        const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1024&height=640&seed=${seed}`;

        const img = new Image();
        img.src = imageUrl;

        img.onload = () => resolve(imageUrl);
        img.onerror = () => {
            console.warn(`主URL加载失败，尝试备用URL for: ${prompt}`);
            const fallbackUrl = `https://pollinations.ai/p/${encodedPrompt}?width=1024&height=640&seed=${seed}`;
            img.src = fallbackUrl;
            img.onload = () => resolve(fallbackUrl);
            img.onerror = () => reject(new Error('主域名和备用域名均加载失败'));
        };
    });
}

/**
 * 【总入口】打开"查岗"功能，显示角色选择列表
 */
async function openKkCheckin() {
    const listEl = document.getElementById('kk-char-selection-list');
    listEl.innerHTML = '';
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">还没有可以查岗的角色</p>';
    } else {
        characters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'character-select-item';
            item.dataset.chatId = char.id;
            item.innerHTML = `
                <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
                <span class="name">${char.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    showScreen('kk-char-selection-screen');
}

/**
 * 选择一个角色后，打开他/她的房屋视图
 */
async function openKkHouseView(charId) {
    activeKkCharId = charId;
    const chat = state.chats[charId];
    if (!chat) return;

    if (!chat.houseData) {
        const generatedData = await generateHouseData(charId);
        if (!generatedData) return;
        chat.houseData = generatedData;
        await db.chats.put(chat);
    }

    renderKkHouseView(chat.houseData);
    showScreen('kk-house-view-screen');
}

/**
 * 【AI核心】为指定角色生成所有房屋数据
 */
async function generateHouseData(charId) {
    const chat = state.chats[charId];
    showGenerationOverlay('正在努力寻找中...');

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');

        let worldBookContext = '';
        const usedWorldBooks = [];
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const filteredBooks = chat.settings.linkedWorldBookIds
                .map(id => state.worldBooks.find(b => b.id === id))
                .filter(book => book && book.name.includes(chat.name));

            console.log(`[查岗-生成房间] 角色"${chat.name}"绑定的世界书筛选结果:`);
            console.log(`  总共绑定: ${chat.settings.linkedWorldBookIds.length} 本`);
            console.log(`  符合条件(名称包含"${chat.name}"): ${filteredBooks.length} 本`);
            filteredBooks.forEach(book => {
                console.log(`    - ${book.name}`);
                usedWorldBooks.push(book.name);
            });

            worldBookContext = filteredBooks.length > 0
                ? '--- 世界观设定 (必须严格遵守) ---\\n' + filteredBooks.map(book => `[${book.name}]: ${book.content}`).join('\\n\\n')
                : '';
        }

        const recentHistory = chat.history.slice(-50).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\\n');

        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的专属NPC好友列表\\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\\n');
        } else {
            npcContext = '# 你的专属NPC好友列表\\n(你当前没有专属NPC，请虚构2-3个普通朋友)';
        }

        const systemPrompt = `
# 任务
你是一个顶级的场景设计师。请根据角色的人设和最近的聊天记录，为角色"${chat.name}"设计一个充满细节的住所。

# 角色信息
- 角色名: ${chat.name}
- 角色人设: ${chat.settings.aiPersona}
${worldBookContext}
- 最近的聊天记录:
${recentHistory}
${npcContext}

# 核心规则
1. 住所必须至少包含【客厅】和【卧室】
2. 每个区域内必须包含3-5个可以被"翻找"的具体地点
3. 你【必须】为【每一个】可翻找的物品预设好翻找后能找到的内容("content")
4. 【重要】你【必须】在某一个区域（如客厅、卧室、书房等）的items列表中添加一个名为"电脑"的物品，content可以写"这是一台笔记本电脑"或类似描述
5. 电脑设定:
   - "browser_history": 虚构3-5条普通浏览器搜索/浏览记录
   - "movies": 虚构2-3个在电脑D盘里下载的电影
   - "secret_folder": 必须包含 "fileName" 和 "content"，content必须明确写明里面是成人影片(AV)
   - "local_files": 虚构2-4个符合其性格的本地文件名，并为每一个文件都编写具体内容
   - "steam_games": 虚构3-5个Steam游戏及游玩时长

# JSON输出格式
{
  "location": "市中心的高级公寓",
  "description": "对这个住所的整体描述",
  "locationImagePrompt": "beautiful anime style apartment exterior, cinematic lighting",
  "areas": {
    "客厅": {
      "description": "客厅的详细描述",
      "imagePrompt": "anime style living room interior, cozy atmosphere",
      "items": [
        {"name": "沙发底下", "content": "找到了一些零食碎屑"},
        {"name": "电脑", "content": "这是一台性能不错的笔记本电脑"}
      ]
    },
    "卧室": { }
  },
  "computer": {
    "browser_history": [ "知乎-如何看待XX事件" ],
    "local_files": [
      {"fileName": "秘密日记.txt", "content": "今天又见到了那个人..."}
    ],
    "movies": ["电影A.mkv"],
    "secret_folder": {
        "fileName": "学习资料.zip",
        "content": "解压后发现里面是几部日本成人影片(AV)，文件名分别是 [FC2-PPV-123456]"
    },
    "steam_games": [
      {"name": "赛博朋克 2077", "playtime": "150 小时"}
    ]
  }
}
`;

        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(await response.text());

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\\s*|```$/g, '');
        const houseData = JSON.parse(rawContent);

        (async () => {
            try {
                const locationImageUrl = await generateAndLoadImage(houseData.locationImagePrompt);
                const areaImagePromises = Object.keys(houseData.areas).map(async (areaName) => {
                    const area = houseData.areas[areaName];
                    const imageUrl = await generateAndLoadImage(area.imagePrompt);
                    return { areaName, imageUrl };
                });

                const areaImages = await Promise.all(areaImagePromises);

                // 更新数据库
                const chatToUpdate = await db.chats.get(charId);
                if (chatToUpdate) {
                    chatToUpdate.houseData.locationImageUrl = locationImageUrl;
                    areaImages.forEach(({ areaName, imageUrl }) => {
                        chatToUpdate.houseData.areas[areaName].imageUrl = imageUrl;
                    });
                    await db.chats.put(chatToUpdate);

                    // 同步更新内存中的state
                    if (state.chats[charId]) {
                        state.chats[charId].houseData.locationImageUrl = locationImageUrl;
                        areaImages.forEach(({ areaName, imageUrl }) => {
                            state.chats[charId].houseData.areas[areaName].imageUrl = imageUrl;
                        });
                    }

                    // 如果用户还在查看这个角色的家,自动刷新整个视图
                    if (activeKkCharId === charId) {
                        const currentScreen = document.querySelector('.screen.active');
                        if (currentScreen && currentScreen.id === 'kk-house-view-screen') {
                            // 重新渲染整个房屋视图,这样就能看到新生成的图片了
                            renderKkHouseView(state.chats[charId].houseData);
                        }
                    }

                    console.log("所有房屋图片已在后台生成并保存！");
                }
            } catch (imgError) {
                console.error("后台图片生成失败:", imgError);
            }
        })();

        return houseData;

    } catch (error) {
        console.error("生成房屋数据失败:", error);
        await showCustomAlert('生成失败', `发生错误: ${error.message}`);
        return null;
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

/**
 * 渲染房屋总览视图
 */
function renderKkHouseView(houseData) {
    document.getElementById('kk-house-owner-name').textContent = `${state.chats[activeKkCharId].name}的家`;

    // 设置背景图片
    const bgElement = document.getElementById('kk-house-background');
    if (houseData.locationImageUrl && houseData.locationImageUrl !== 'undefined') {
        bgElement.style.backgroundImage = `url(${houseData.locationImageUrl})`;
    } else {
        bgElement.style.backgroundImage = '';
    }

    document.getElementById('kk-house-location').textContent = houseData.location;
    document.getElementById('kk-house-description').textContent = houseData.description;

    const areasContainer = document.getElementById('kk-house-areas');
    areasContainer.innerHTML = '';
    for (const areaName in houseData.areas) {
        const areaBtn = document.createElement('button');
        areaBtn.className = 'kk-area-button';
        areaBtn.textContent = areaName;
        areaBtn.onclick = () => openKkAreaView(areaName);
        areasContainer.appendChild(areaBtn);
    }
}

/**
 * 打开并渲染指定区域的探索视图
 */
function openKkAreaView(areaName) {
    const chat = state.chats[activeKkCharId];
    const areaData = chat.houseData.areas[areaName];
    if (!areaData) return;

    document.getElementById('kk-area-name').textContent = areaName;

    // 设置背景图片
    const bgElement = document.getElementById('kk-area-background');
    if (areaData.imageUrl && areaData.imageUrl !== 'undefined') {
        bgElement.style.backgroundImage = `url(${areaData.imageUrl})`;
    } else {
        bgElement.style.backgroundImage = '';
    }

    document.getElementById('kk-area-description').textContent = areaData.description;

    const itemsGrid = document.getElementById('kk-area-items-grid');
    itemsGrid.innerHTML = '';

    areaData.items.forEach(item => {
        const itemBtn = document.createElement('button');
        itemBtn.className = 'kk-item-button';
        itemBtn.textContent = item.name;
        itemBtn.onclick = () => handleRummage(areaName, item.name);
        itemsGrid.appendChild(itemBtn);
    });

    showScreen('kk-area-view-screen');
}

/**
 * 处理"翻找"动作
 */
function handleRummage(areaName, itemName) {
    if (itemName.toLowerCase() === '电脑' || itemName.toLowerCase() === 'computer') {
        openComputer();
        return;
    }

    const chat = state.chats[activeKkCharId];
    const area = chat.houseData.areas[areaName];
    const item = area.items.find(i => i.name === itemName);

    if (item && item.content) {
        showCustomAlert(`在"${itemName}"里`, item.content.replace(/\\n/g, '<br>'));
    } else {
        showCustomAlert(`在"${itemName}"里`, '仔细翻了翻，但什么特别的东西都没发现...');
    }
}

/**
 * ========== 监控功能相关函数 ==========
 */

/**
 * 打开监控视图
 */
async function openSurveillanceView(charId) {
    if (!charId) return;
    const chat = state.chats[charId];
    if (!chat || !chat.houseData) {
        alert("找不到角色的房屋数据，请先生成房屋。");
        return;
    }

    document.getElementById('kk-monitor-title').textContent = `${chat.name}的监控中心`;

    const fiveMinutes = 5 * 60 * 1000;
    const surveillance = chat.houseData.surveillanceData;

    if (!surveillance || !surveillance.feeds || (Date.now() - (surveillance.timestamp || 0) > fiveMinutes)) {
        try {
            const newSurveillanceData = await generateInitialSurveillanceFeeds(charId);
            if (newSurveillanceData) {
                chat.houseData.surveillanceData = {
                    timestamp: Date.now(),
                    characterLocation: newSurveillanceData.characterLocation,
                    feeds: newSurveillanceData.feeds
                };
                await db.chats.put(chat);
                renderSurveillanceView(chat.houseData.surveillanceData);
            } else {
                document.getElementById('kk-monitor-grid').innerHTML = '<p style="text-align:center; color: #8a8a8a;">无法生成监控画面。</p>';
            }
        } catch (error) {
             await showCustomAlert('生成失败', `生成监控画面时出错: ${error.message}`);
             return;
        }
    } else {
        console.log("从缓存加载监控画面。");
        renderSurveillanceView(surveillance);
    }

    showScreen('kk-monitor-screen');
}

/**
 * 调用AI为指定角色生成所有区域的初次监控画面
 */
async function generateInitialSurveillanceFeeds(charId) {
    const chat = state.chats[charId];
    showGenerationOverlay('正在接入监控信号...');

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');

        // 筛选世界书：只读取名称包含角色名的世界书
        const usedWorldBooks = [];
        const allLinkedBooks = await Promise.all(
            (chat.settings.linkedWorldBookIds || []).map(id => db.worldBooks.get(id))
        );
        const filteredBooks = allLinkedBooks.filter(book => book && book.name.includes(chat.name));

        console.log(`[查岗-生成监控] 角色"${chat.name}"绑定的世界书筛选结果:`);
        console.log(`  总共绑定: ${chat.settings.linkedWorldBookIds.length} 本`);
        console.log(`  符合条件(名称包含"${chat.name}"): ${filteredBooks.length} 本`);
        filteredBooks.forEach(book => {
            console.log(`    - ${book.name}`);
            usedWorldBooks.push(book.name);
        });

        const worldBookContext = filteredBooks
            .map(book => `\n## 世界书: ${book.name}\n${book.content}`)
            .join('');

        const recentHistory = chat.history.slice(-50).map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');

        const userPersona = state.chats[charId]?.settings?.myPersona || '一个普通的观察者。';

        const areaNames = Object.keys(chat.houseData.areas);

        const systemPrompt = `
<!-- 查岗-监控文字(1) -->
# 任务
你是一个全知的监控系统AI。你的任务是根据角色的人设和近期活动，为${chat.name}家中的【每一个区域】生成实时监控画面描述，并明确指出${chat.name}【当前所在】的区域。

# 角色与观察者信息
- 角色名: ${chat.name}（用第三人称"${chat.name}"或"他/她"称呼）
- 角色人设: ${chat.settings.aiPersona}
- 观察者(你): ${userPersona}
${worldBookContext || ''}
- 你和${chat.name}最近的聊天记录 (供你参考情景):
${recentHistory}

# 住所布局
${chat.name}当前的住所包含以下区域: ${areaNames.join('、 ')}

# 核心规则
1.  **视角**: 你的描述必须是【客观、冷静的第三人称视角】，就像一个真正的监控摄像头记录的画面。称呼${chat.name}时用第三人称"${chat.name}"或"他/她"，不要用"你"。
2.  **内容**: 描述【此时此刻】${chat.name}可能正在每个区域做什么。如果${chat.name}不在某个区域，就描述该区域的静态环境。
3.  **实时性**: 描述必须体现"现在正在发生"的感觉。
4.  **内心独白**: 如果${chat.name}在该区域，你【必须】加上${chat.name}当下真实的内心独白（用<i>标签包裹，例如：<i>内心独白内容</i>）。
5.  **格式要求**:
    - 描述必须分段，用<br>换行
    - 如果${chat.name}说话，引号内的对话要单独一行
    - 内心独白也要单独一行
6.  **【防八股文规则】**: 你【必须】遵守以下用词和描述规则，避免使用这些陈词滥调：
    - 禁用词汇：脊背、猛地、瞬间、轰地一下、像是一根针、石子、石头、湖面、涟漪、像是一把刀、深入骨髓（用"些许/轻微"替代）、一道惊雷、爆发、爆炸、炸开、无力感、疲惫感、麻木、绝望、灭顶、面无表情、过度、强烈、剧烈、极度、深深、震惊、惊慌、激动、紧张、紧绷、绷紧、突然、死死地、自我厌弃、自暴自弃、破罐子破摔、倦意、无力、脱力、疲惫、虚弱、虚脱、残酷、残忍、冷酷、生气、愤怒、羞愤、吼、睫毛、紧闭、滴出血来、长长地呼出一口气、抽干全身力气、锁骨、尾椎骨、喉结、修长、骨节分明、狂热、信徒、仪式、献祭、祭品、宗教、信仰、机械、机械式的、冰冷、冰凉、手术刀、解剖、荒唐、荒诞、荒谬、不易察觉、热辣辣、火辣辣、滚烫、发烫、滚热、热、烫、燃烧、握拳、握紧、攥紧、攥住、指尖、指节、xxx的手、血色、血压、上涌、血色尽褪、通红、展品、雕塑、精密、仪器、僵硬、僵住、一片空白、颤抖、颤音、直冲、直窜、冷静、审视、审判、打圈、打转、打着圈、打着转、电流、闪电、如释重负、如蒙大赦、前所未来、难以言喻、潮水、淹没、席卷、牙缝、紧咬、咬着、狡黠、挤了挤眼睛、眨了眨眼、教具、语气平淡、语气平静、陈述、事实
    - 用词替换：乐了→笑了笑；后背/背部→替代"脊背"
    - 禁用符号：！、！！、？！
    - 禁止描述：心跳/心动、紧张/害怕、向液体表面投入固体、羞愧/惭愧/内疚、环境、神态一惊一乍或变化陡然、疲惫无力、对手部进行形容修辞、"这不是xxxx，而是xxxx"句式、语气平淡/平静
7.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一个严格的JSON对象。
    -   该JSON对象必须包含一个顶级键 \`characterLocation\`，其值必须是${chat.name}当前所在的区域名字符串 (例如: "卧室")。
    -   该JSON对象还必须包含一个顶级键 \`feeds\`，其值是一个JSON对象，其中每个键是区域名，每个值是**另一个**JSON对象，包含以下两个字段:
        -   \`"description"\`: (字符串，可包含HTML标签<br>和<i>) 该区域的监控画面描述。用第三人称称呼${chat.name}。
        -   \`"isCharacterPresent"\`: (布尔值) ${chat.name}当前是否在该区域内（true 或 false）。

# JSON输出格式示例 (必须严格遵守):
{
  "characterLocation": "卧室",
  "feeds": {
    "客厅": {
      "description": "客厅里很安静，${chat.name}并不在这里。<br>电视屏幕是黑的，沙发上随意搭着一件外套。",
      "isCharacterPresent": false
    },
    "卧室": {
      "description": "${chat.name}正坐在床边，低头看着手机，手指快速地在屏幕上滑动。<br>\"又发消息过来了...\"<br><i>真烦，不想回复。</i>",
      "isCharacterPresent": true
    }
  }
}
`;

        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const surveillanceData = JSON.parse(rawContent);

        return surveillanceData;

    } catch (error) {
        console.error("生成监控画面失败:", error);
        throw error;
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

/**
 * 将监控数据渲染到屏幕上
 */
function renderSurveillanceView(surveillanceData) {
    const gridEl = document.getElementById('kk-monitor-grid');
    gridEl.innerHTML = '';
    const chat = state.chats[activeKkCharId];
    if (!chat) return;

    const { characterLocation, feeds } = surveillanceData;

    if (!feeds || Object.keys(feeds).length === 0) {
        gridEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">无法加载监控画面。</p>';
        return;
    }

    for (const areaName in feeds) {
        const feedData = feeds[areaName];
        const area = chat.houseData.areas[areaName];
        const isCharacterPresent = feedData.isCharacterPresent;

        const feedEl = document.createElement('div');
        feedEl.className = 'kk-monitor-item';
        feedEl.dataset.areaName = areaName;

        if (area && area.imageUrl) {
            feedEl.style.backgroundImage = `url(${area.imageUrl})`;
        } else {
            feedEl.style.backgroundColor = '#333';
        }

        if (areaName === characterLocation) {
            feedEl.classList.add('active-character-location');
        }

        const interactionControlsHtml = isCharacterPresent ? `
            <div class="monitor-interaction-controls">
                <button class="monitor-btn" data-action="reroll" title="重Roll">🔄</button>
                <button class="monitor-btn" data-action="continue" title="继续监控">➡️</button>
                <button class="monitor-btn" data-action="speak" title="对话">🎤</button>
            </div>` : '';

        feedEl.innerHTML = `
            <div class="monitor-header">
                <span>${areaName}</span>
                <div class="rec-dot"></div>
            </div>
            <div class="frosted-glass-panel">
                <div class="monitor-content-text">${feedData.description}</div>
                ${interactionControlsHtml}
            </div>
        `;

        gridEl.appendChild(feedEl);
    }
}

/**
 * 处理监控互动（重Roll、继续、对话）
 */
async function handleMonitorInteraction(areaName, action, feedElement) {
    const contentTextElement = feedElement.querySelector('.monitor-content-text');
    const currentContent = contentTextElement.textContent;

    if (action === 'speak') {
        const userInput = await showCustomPrompt(`对【${areaName}】喊话`, "请输入你想说的话：");
        if (userInput && userInput.trim()) {
            await generateMonitorDialogue(areaName, userInput, contentTextElement);
        }
    } else {
        const newContent = await generateMonitorUpdate(areaName, action === 'continue' ? currentContent : null, contentTextElement);
        if (newContent) {
            contentTextElement.innerHTML = newContent;
        }
    }
}

/**
 * 生成监控画面的"下一帧"或"重Roll"
 */
async function generateMonitorUpdate(areaName, context, textElement) {
    const chat = state.chats[activeKkCharId];
    if (!chat) return null;

    textElement.innerHTML = '<i>正在刷新信号...</i>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        textElement.innerHTML = '<i style="color: #ff8a80;">API未配置</i>';
        return null;
    }

    // 筛选世界书：只读取名称包含角色名的世界书
    const usedWorldBooks = [];
    const allLinkedBooks = await Promise.all(
        (chat.settings.linkedWorldBookIds || []).map(id => db.worldBooks.get(id))
    );
    const filteredBooks = allLinkedBooks.filter(book => book && book.name.includes(chat.name));

    console.log(`[查岗-重Roll监控] 角色"${chat.name}"绑定的世界书筛选结果:`);
    console.log(`  总共绑定: ${chat.settings.linkedWorldBookIds.length} 本`);
    console.log(`  符合条件(名称包含"${chat.name}"): ${filteredBooks.length} 本`);
    filteredBooks.forEach(book => {
        console.log(`    - ${book.name}`);
        usedWorldBooks.push(book.name);
    });

    const worldBookContext = filteredBooks
        .map(book => `\n## 世界书: ${book.name}\n${book.content}`)
        .join('');

    const prompt = `
<!-- 查岗-监控文字(2) -->
你是一个监控系统AI，正在观察${chat.name}在【${areaName}】区域的活动。
${context ? `上一帧画面是："${context}"` : '请重新生成一个全新的、与之前无关的随机事件。'}

请根据${chat.name}的人设【${chat.settings.aiPersona}】，生成下一秒发生的【动作或语言】。
${worldBookContext || ''}

# 格式要求
1. 你的描述必须是客观的第三人称视角，就像摄像头记录的一样。用第三人称称呼${chat.name}（"${chat.name}"或"他/她"），不要用"你"。
2. 你【必须】加上${chat.name}当下真实的内心独白（用<i>标签包裹，例如：<i>内心独白内容</i>）。
3. 描述必须分段，用<br>换行。
4. 如果${chat.name}说话，引号内的对话要单独一行。
5. 内心独白也要单独一行。

# 【防八股文规则】
你【必须】遵守以下用词和描述规则，避免使用这些陈词滥调：
- 禁用词汇：脊背、猛地、瞬间、轰地一下、像是一根针、石子、石头、湖面、涟漪、像是一把刀、深入骨髓（用"些许/轻微"替代）、一道惊雷、爆发、爆炸、炸开、无力感、疲惫感、麻木、绝望、灭顶、面无表情、过度、强烈、剧烈、极度、深深、震惊、惊慌、激动、紧张、紧绷、绷紧、突然、死死地、自我厌弃、自暴自弃、破罐子破摔、倦意、无力、脱力、疲惫、虚弱、虚脱、残酷、残忍、冷酷、生气、愤怒、羞愤、吼、睫毛、紧闭、滴出血来、长长地呼出一口气、抽干全身力气、锁骨、尾椎骨、喉结、修长、骨节分明、狂热、信徒、仪式、献祭、祭品、宗教、信仰、机械、机械式的、冰冷、冰凉、手术刀、解剖、荒唐、荒诞、荒谬、不易察觉、热辣辣、火辣辣、滚烫、发烫、滚热、热、烫、燃烧、握拳、握紧、攥紧、攥住、指尖、指节、xxx的手、血色、血压、上涌、血色尽褪、通红、展品、雕塑、精密、仪器、僵硬、僵住、一片空白、颤抖、颤音、直冲、直窜、冷静、审视、审判、打圈、打转、打着圈、打着转、电流、闪电、如释重负、如蒙大赦、前所未来、难以言喻、潮水、淹没、席卷、牙缝、紧咬、咬着、狡黠、挤了挤眼睛、眨了眨眼、教具、语气平淡、语气平静、陈述、事实
- 用词替换：乐了→笑了笑；后背/背部→替代"脊背"
- 禁用符号：！、！！、？！
- 禁止描述：心跳/心动、紧张/害怕、向液体表面投入固体、羞愧/惭愧/内疚、环境、神态一惊一乍或变化陡然、疲惫无力、对手部进行形容修辞、"这不是xxxx，而是xxxx"句式、语气平淡/平静

你的回复可以包含HTML标签（<br>和<i>），不要包含任何JSON或额外说明。
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: prompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9 })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
    } catch (error) {
        textElement.innerHTML = `<i style="color: #ff8a80;">信号中断: ${error.message}</i>`;
        return null;
    }
}

/**
 * 处理通过监控进行的对话
 */
async function generateMonitorDialogue(areaName, userInput, textElement) {
    const chat = state.chats[activeKkCharId];
    if (!chat) return;

    textElement.innerHTML = '<i>等待对方回应...</i>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        textElement.innerHTML = '<i style="color: #ff8a80;">麦克风故障: API未配置</i>';
        return;
    }

    // 筛选世界书：只读取名称包含角色名的世界书
    const usedWorldBooks = [];
    const allLinkedBooks = await Promise.all(
        (chat.settings.linkedWorldBookIds || []).map(id => db.worldBooks.get(id))
    );
    const filteredBooks = allLinkedBooks.filter(book => book && book.name.includes(chat.name));

    console.log(`[查岗-监控对话] 角色"${chat.name}"绑定的世界书筛选结果:`);
    console.log(`  总共绑定: ${chat.settings.linkedWorldBookIds.length} 本`);
    console.log(`  符合条件(名称包含"${chat.name}"): ${filteredBooks.length} 本`);
    filteredBooks.forEach(book => {
        console.log(`    - ${book.name}`);
        usedWorldBooks.push(book.name);
    });

    const worldBookContext = filteredBooks
        .map(book => `\n## 世界书: ${book.name}\n${book.content}`)
        .join('');

    const prompt = `
<!-- 查岗-监控文字(3) -->
# 任务
你是一个监控系统AI。${chat.name}正在【${areaName}】里。
突然，你（观察者）通过监控系统的扬声器对${chat.name}说了话。现在请以【第三人称视角】描述${chat.name}听到你的话之后的反应。

# ${chat.name}的人设
${chat.settings.aiPersona}
${worldBookContext || ''}

# 你通过监控说的话:
"${userInput}"

# 你的任务
请以【第三人称客观视角】，描述${chat.name}听到这句话后的【反应】。

# 格式要求
1. 用第三人称称呼${chat.name}（"${chat.name}"或"他/她"），不要用"你"。
2. 你的描述应该包含${chat.name}的【动作、说出的话、以及内心独白】。
3. 你【必须】加上${chat.name}当下真实的内心独白（用<i>标签包裹，例如：<i>内心独白内容</i>）。
4. 描述必须分段，用<br>换行。
5. 如果${chat.name}说话，引号内的对话要单独一行。
6. 内心独白也要单独一行。

# 【防八股文规则】
你【必须】遵守以下用词和描述规则，避免使用这些陈词滥调：
- 禁用词汇：脊背、猛地、瞬间、轰地一下、像是一根针、石子、石头、湖面、涟漪、像是一把刀、深入骨髓（用"些许/轻微"替代）、一道惊雷、爆发、爆炸、炸开、无力感、疲惫感、麻木、绝望、灭顶、面无表情、过度、强烈、剧烈、极度、深深、震惊、惊慌、激动、紧张、紧绷、绷紧、突然、死死地、自我厌弃、自暴自弃、破罐子破摔、倦意、无力、脱力、疲惫、虚弱、虚脱、残酷、残忍、冷酷、生气、愤怒、羞愤、吼、睫毛、紧闭、滴出血来、长长地呼出一口气、抽干全身力气、锁骨、尾椎骨、喉结、修长、骨节分明、狂热、信徒、仪式、献祭、祭品、宗教、信仰、机械、机械式的、冰冷、冰凉、手术刀、解剖、荒唐、荒诞、荒谬、不易察觉、热辣辣、火辣辣、滚烫、发烫、滚热、热、烫、燃烧、握拳、握紧、攥紧、攥住、指尖、指节、xxx的手、血色、血压、上涌、血色尽褪、通红、展品、雕塑、精密、仪器、僵硬、僵住、一片空白、颤抖、颤音、直冲、直窜、冷静、审视、审判、打圈、打转、打着圈、打着转、电流、闪电、如释重负、如蒙大赦、前所未来、难以言喻、潮水、淹没、席卷、牙缝、紧咬、咬着、狡黠、挤了挤眼睛、眨了眨眼、教具、语气平淡、语气平静、陈述、事实
- 用词替换：乐了→笑了笑；后背/背部→替代"脊背"
- 禁用符号：！、！！、？！
- 禁止描述：心跳/心动、紧张/害怕、向液体表面投入固体、羞愧/惭愧/内疚、环境、神态一惊一乍或变化陡然、疲惫无力、对手部进行形容修辞、"这不是xxxx，而是xxxx"句式、语气平淡/平静

你的回复可以包含HTML标签（<br>和<i>），不要包含任何JSON或额外说明。
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: prompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.8 })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const aiResponse = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();

        textElement.innerHTML = `"${userInput}" <i>(你通过监控说)</i><br><br>${aiResponse}`;
    } catch (error) {
        textElement.innerHTML = `<i style="color: #ff8a80;">通讯失败: ${error.message}</i>`;
    }
}

/**
 * 刷新所有监控画面（生成新状态）
 */
async function generateSurveillanceUpdate(charId) {
    const chat = state.chats[charId];
    if (!chat || !chat.houseData) return null;

    showGenerationOverlay('正在刷新所有监控...');

    const lastSurveillance = chat.houseData.surveillanceData;

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');

        // 筛选世界书：只读取名称包含角色名的世界书
        const usedWorldBooks = [];
        const allLinkedBooks = await Promise.all(
            (chat.settings.linkedWorldBookIds || []).map(id => db.worldBooks.get(id))
        );
        const filteredBooks = allLinkedBooks.filter(book => book && book.name.includes(chat.name));

        console.log(`[查岗-刷新所有监控] 角色"${chat.name}"绑定的世界书筛选结果:`);
        console.log(`  总共绑定: ${chat.settings.linkedWorldBookIds.length} 本`);
        console.log(`  符合条件(名称包含"${chat.name}"): ${filteredBooks.length} 本`);
        filteredBooks.forEach(book => {
            console.log(`    - ${book.name}`);
            usedWorldBooks.push(book.name);
        });

        const worldBookContext = filteredBooks
            .map(book => `\n## 世界书: ${book.name}\n${book.content}`)
            .join('');

        const systemPrompt = `
<!-- 查岗-监控文字(4) -->
# 任务
你是一个全知的监控系统AI。你的任务是基于${chat.name}的【上一个状态】，推断出【下一秒钟】${chat.name}可能做的行动，并更新所有监控区域的画面。${chat.name}可能会从一个房间移动到另一个房间。

# 角色信息
- 角色名: ${chat.name}（用第三人称"${chat.name}"或"他/她"称呼）
- 人设: ${chat.settings.aiPersona}
${worldBookContext || ''}

# 上一秒的监控状态 (重要参考)
${JSON.stringify(lastSurveillance, null, 2)}

# 核心规则
1.  **逻辑连贯**: 你的更新必须基于上一秒的状态，做出合乎逻辑的推断。例如，如果上一秒${chat.name}在卧室看手机，下一秒可能是继续看、放下手机准备睡觉，或是走出卧室去客厅。
2.  **角色移动**: ${chat.name}【有可能】移动到新的区域。你【必须】在 \`characterLocation\` 字段中准确指出${chat.name}的新位置。
3.  **状态更新**: 【所有】区域的画面描述都必须更新。如果${chat.name}进入了新区域，该区域的 \`isCharacterPresent\` 必须变为 \`true\`，旧区域的必须变为 \`false\`。
4.  **人称要求**: 用第三人称称呼${chat.name}（"${chat.name}"或"他/她"），不要用"你"。
5.  **内心独白**: 如果${chat.name}在该区域，你【必须】加上${chat.name}当下真实的内心独白（用<i>标签包裹）。
6.  **格式要求**:
    - 描述必须分段，用<br>换行
    - 如果${chat.name}说话，引号内的对话要单独一行
    - 内心独白也要单独一行
7.  **【防八股文规则】**: 你【必须】遵守以下用词和描述规则，避免使用这些陈词滥调：
    - 禁用词汇：脊背、猛地、瞬间、轰地一下、像是一根针、石子、石头、湖面、涟漪、像是一把刀、深入骨髓（用"些许/轻微"替代）、一道惊雷、爆发、爆炸、炸开、无力感、疲惫感、麻木、绝望、灭顶、面无表情、过度、强烈、剧烈、极度、深深、震惊、惊慌、激动、紧张、紧绷、绷紧、突然、死死地、自我厌弃、自暴自弃、破罐子破摔、倦意、无力、脱力、疲惫、虚弱、虚脱、残酷、残忍、冷酷、生气、愤怒、羞愤、吼、睫毛、紧闭、滴出血来、长长地呼出一口气、抽干全身力气、锁骨、尾椎骨、喉结、修长、骨节分明、狂热、信徒、仪式、献祭、祭品、宗教、信仰、机械、机械式的、冰冷、冰凉、手术刀、解剖、荒唐、荒诞、荒谬、不易察觉、热辣辣、火辣辣、滚烫、发烫、滚热、热、烫、燃烧、握拳、握紧、攥紧、攥住、指尖、指节、xxx的手、血色、血压、上涌、血色尽褪、通红、展品、雕塑、精密、仪器、僵硬、僵住、一片空白、颤抖、颤音、直冲、直窜、冷静、审视、审判、打圈、打转、打着圈、打着转、电流、闪电、如释重负、如蒙大赦、前所未来、难以言喻、潮水、淹没、席卷、牙缝、紧咬、咬着、狡黠、挤了挤眼睛、眨了眨眼、教具、语气平淡、语气平静、陈述、事实
    - 用词替换：乐了→笑了笑；后背/背部→替代"脊背"
    - 禁用符号：！、！！、？！
    - 禁止描述：心跳/心动、紧张/害怕、向液体表面投入固体、羞愧/惭愧/内疚、环境、神态一惊一乍或变化陡然、疲惫无力、对手部进行形容修辞、"这不是xxxx，而是xxxx"句式、语气平淡/平静
8.  **格式铁律**: 你的回复【必须】严格遵守与初始生成时完全相同的JSON格式。description字段可以包含HTML标签（<br>和<i>）。

现在，请生成下一秒的完整监控数据。
`;

        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(await response.text());

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        return JSON.parse(rawContent);

    } catch (error) {
        console.error("刷新监控画面失败:", error);
        await showCustomAlert('刷新失败', `发生错误: ${error.message}`);
        return null;
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

/**
 * ========== 监控功能结束 ==========
 */

/**
 * 打开电脑界面
 */
function openComputer() {
    const chat = state.chats[activeKkCharId];
    document.getElementById('kk-computer-header').querySelector('span').textContent = `${chat.name}的电脑`;

    const desktop = document.getElementById('kk-computer-desktop');
    const computerData = chat.houseData?.computer || {};
    const secretFolderName = computerData.secret_folder?.fileName || '加密文件夹';

    desktop.innerHTML = `
        <div class="kk-desktop-icon" id="kk-browser-icon" title="浏览器">
            <img src="https://i.postimg.cc/gc7tpbwp/浏览器图标.png" alt="Browser">
            <span>浏览器</span>
        </div>
        <div class="kk-desktop-icon" id="kk-movies-icon" title="电影">
            <img src="https://i.postimg.cc/gc7tpbwd/电影.png" alt="Movies">
            <span>电影</span>
        </div>
        <div class="kk-desktop-icon" id="kk-files-icon" title="私人文件">
            <img src="https://i.postimg.cc/9Xkg2H4h/48.png" alt="Files">
            <span>私人文件</span>
        </div>
        <div class="kk-desktop-icon" id="kk-secret-folder-icon" title="隐秘文件夹">
            <img src="https://i.postimg.cc/SQP14bXp/File_Dead_Big_Thumb.png" alt="Secret Folder">
            <span>${secretFolderName}</span>
        </div>
        <div class="kk-desktop-icon" id="kk-steam-icon" title="Steam">
            <img src="https://i.postimg.cc/xjZpQVkD/steam.png" alt="Steam">
            <span>Steam</span>
        </div>
    `;

    document.getElementById('kk-computer-modal').classList.add('visible');
}

/**
 * 打开文件浏览器
 */
function openFileExplorer() {
    const computerData = state.chats[activeKkCharId]?.houseData?.computer;
    const files = computerData?.local_files || [];
    const listEl = document.getElementById('kk-file-list');
    listEl.innerHTML = '';

    if (files.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">这个文件夹是空的</p>';
    } else {
        files.forEach(file => {
            const item = document.createElement('div');
            item.className = 'kk-file-item';
            item.textContent = file.fileName;
            item.style.cursor = 'pointer';
            item.dataset.fileName = file.fileName;
            item.dataset.fileContent = encodeURIComponent(file.content || '（文件内容为空）');
            listEl.appendChild(item);
        });
    }

    document.getElementById('kk-file-explorer-modal').classList.add('visible');
}

/**
 * 打开文件内容查看器
 */
function openFileViewer(fileName, fileContent) {
    document.getElementById('kk-file-viewer-title').textContent = fileName;
    document.getElementById('kk-file-viewer-content').textContent = decodeURIComponent(fileContent);
    document.getElementById('kk-file-viewer-modal').classList.add('visible');
}

/**
 * 关闭文件内容查看器
 */
function closeFileViewer() {
    document.getElementById('kk-file-viewer-modal').classList.remove('visible');
}

/**
 * 打开Steam游戏库弹窗
 */
function openSteamScreen() {
    renderSteamScreen();
    document.getElementById('kk-steam-modal').classList.add('visible');
}

/**
 * 渲染Steam游戏库列表
 */
function renderSteamScreen() {
    if (!activeKkCharId) return;
    const computerData = state.chats[activeKkCharId]?.houseData?.computer;
    const games = computerData?.steam_games || [];
    const listEl = document.getElementById('kk-steam-games-list');
    listEl.innerHTML = '';

    if (games.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">游戏库是空的</p>';
    } else {
        games.sort((a, b) => {
            const timeA = parseFloat(a.playtime) || 0;
            const timeB = parseFloat(b.playtime) || 0;
            return timeB - timeA;
        });

        games.forEach((game, index) => {
            const itemEl = document.createElement('div');
            itemEl.className = 'character-data-item';
            itemEl.innerHTML = `
                <div class="title">${game.name}</div>
                <div class="content">总游玩时长: ${game.playtime}</div>
                <button class="item-delete-btn" data-type="computer.steam_games" data-index="${index}" title="删除这个游戏记录">×</button>
            `;
            listEl.appendChild(itemEl);
        });
    }
}

/**
 * 【核心功能】处理"重新翻找"按钮
 */
async function handleResetKkHouse() {
    if (!activeKkCharId) return;

    const confirmed = await showCustomConfirm(
        '确认重新生成',
        '你确定要重新生成这个家吗？所有现有的区域和物品都将被覆盖，此操作不可撤销。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeKkCharId];
        const generatedData = await generateHouseData(activeKkCharId);
        if (generatedData) {
            chat.houseData = generatedData;
            await db.chats.put(chat);
            renderKkHouseView(chat.houseData);
            alert('一个全新的家已经生成！');
        }
    }
}

/**
 * 【核心功能】处理"继续翻找"按钮
 */
async function handleContinueKkSearch() {
    if (!activeKkCharId) return;
    const chat = state.chats[activeKkCharId];
    if (!chat || !chat.houseData) {
        alert('还没有为这个角色生成家，请先"重新翻找"一次。');
        return;
    }

    showGenerationOverlay('正在努力寻找中...');

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');

        let existingItemsContext = '# 已有物品\\n';
        for (const areaName in chat.houseData.areas) {
            const area = chat.houseData.areas[areaName];
            existingItemsContext += `## ${areaName}:\\n`;
            existingItemsContext += area.items.map(item => `- ${item.name}`).join('\\n') + '\\n';
        }

        const systemPrompt = `
# 任务
你是一个场景补充设计师。用户正在对角色"${chat.name}"的住所进行【补充翻找】。
请在不改变现有结构的基础上，为指定区域或电脑添加2-3个全新的物品或发现。

# 角色信息
- 人设: ${chat.settings.aiPersona}
- 已有房屋数据:
${JSON.stringify(chat.houseData, null, 2)}
${existingItemsContext}

# JSON输出格式
{
  "客厅": [
    {"name": "书架顶层", "content": "发现一本被遗忘的旧相册。"}
  ],
  "computer": {
    "local_files": [{"fileName": "一封未发送的邮件.eml", "content": "邮件内容..."}],
    "browser_history": ["P站-插画欣赏"],
    "movies": ["经典电影C.rmvb"],
    "steam_games": [{"name": "艾尔登法环", "playtime": "300 小时"}]
  }
}
`;
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(await response.text());

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\\s*|```$/g, '');
        const newItemsData = JSON.parse(rawContent);

        for (const key in newItemsData) {
            if (key === 'computer') {
                const computerUpdates = newItemsData.computer;
                for (const subKey in computerUpdates) {
                    if (!chat.houseData.computer[subKey]) {
                        chat.houseData.computer[subKey] = [];
                    }
                    if (Array.isArray(chat.houseData.computer[subKey]) && Array.isArray(computerUpdates[subKey])) {
                        chat.houseData.computer[subKey].push(...computerUpdates[subKey]);
                    }
                }
            }
            else if (chat.houseData.areas[key] && Array.isArray(newItemsData[key])) {
                chat.houseData.areas[key].items.push(...newItemsData[key]);
            }
        }

        await db.chats.put(chat);
        alert('翻找出了更多新东西！现在可以进入区域或电脑查看了。');

    } catch (error) {
        console.error("继续翻找失败:", error);
        await showCustomAlert('操作失败', `发生错误: ${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

// ▲▲▲ "kk查岗"核心函数结束 ▲▲▲

// init() 函数开始
        async function init() {

            // ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 【全新】论坛功能事件绑定
document.getElementById('forum-refresh-btn').addEventListener('click', openForumSettingsModal);
document.getElementById('cancel-forum-settings-btn').addEventListener('click', () => {
    document.getElementById('forum-settings-modal').classList.remove('visible');
});
document.getElementById('generate-forum-posts-btn').addEventListener('click', generateForumPosts);

// ▼▼▼ 请用这【一整块】全新的代码，完整替换掉旧的 forum-posts-container 事件监听器 ▼▼▼
document.getElementById('forum-posts-container').addEventListener('click', (e) => {
    const target = e.target;

    // --- 【核心修正】处理“文字图”的点击事件 ---
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        // 使用已经存在的 showCustomAlert 函数来显示描述
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完后直接返回，避免触发其他事件
    }

    // --- 处理点赞 (已有逻辑，保持不变) ---
    const likeBtn = target.closest('.like-btn');
    if (likeBtn) {
        (async () => {
            const postItem = likeBtn.closest('.forum-post-item');
            if (!postItem) return;
            const postId = parseInt(postItem.dataset.postId);
            const post = currentForumPosts.find(p => p.id === postId);
            if (!post) return;

            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname || '我';
            const userLikeIndex = post.likes.indexOf(userNickname);

            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
            }

            await db.forumPosts.put(post);
            renderForumPosts(currentForumPosts);
        })();
    }

    // --- 处理发送评论 (已有逻辑，保持不变) ---
    if (target.tagName === 'BUTTON' && target.previousElementSibling?.tagName === 'INPUT') {
        (async () => {
            const input = target.previousElementSibling;
            const commentText = input.value.trim();
            if (!commentText) return;

            const postItem = target.closest('.forum-post-item');
            if (!postItem) return;

            const postId = parseInt(postItem.dataset.postId);
            const post = currentForumPosts.find(p => p.id === postId);

            if (post) {
                const userComment = {
                    commenterName: state.qzoneSettings.nickname || '我',
                    commentText: commentText
                };
                if (!post.comments) post.comments = [];
                post.comments.push(userComment);
                post.isAwaitingReply = true;
                
                await db.forumPosts.put(post);

                input.value = '';
                renderForumPosts(currentForumPosts);

                await triggerAiForumReply(post, commentText);

                post.isAwaitingReply = false;
                await db.forumPosts.put(post);
                renderForumPosts(currentForumPosts);
            }
        })();
    }

    // --- 处理转发按钮点击 ---
    const forwardBtn = target.closest('.forward-btn');
    if (forwardBtn) {
        const postItem = forwardBtn.closest('.forum-post-item');
        if (!postItem) return;
        const postId = parseInt(postItem.dataset.postId);
        const post = currentForumPosts.find(p => p.id === postId);
        if (!post) return;
        
        // 打开转发目标选择模态框
        openForumShareTargetModal(post);
    }
});

// 在 init() 函数的事件监听器区域添加
document.getElementById('batch-add-sticker-btn').addEventListener('click', handleBatchAddStickers);

    // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
    applyTheme(savedTheme);
    // ▲▲▲ 粘贴结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲


    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

            window.showScreen = showScreen;
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();
            
            // 初始化线上/线下模式状态（页面加载时恢复所有聊天的状态）
            initializeOfflineModeStates();

            // 初始化未读动态计数
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代码添加结束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            applyGlobalChatBackground();
            applyChatListPaddingTop(); // <--- 在这里调用，保存后立即应用
            applyWaitReplyBtnStyle(); // 应用等待回复按钮自定义样式

isIOS();

applyAppIcons();

// ▼▼▼ 恢复Profile数据（在所有初始化完成后） ▼▼▼
restoreProfileData();
// ▲▲▲ 恢复Profile数据结束 ▲▲▲

// (程煜：初始化新的音频系统)
            initAudioContext(); 
            
            // (程煜：绑定这个“陷阱”v2.0，【不移除】，让它一直生效)
            document.body.addEventListener('click', unlockAudioContext);
            document.body.addEventListener('touchstart', unlockAudioContext); // 兼容触摸

            // ==========================================================
            // --- 各种事件监听器 ---
            // ==========================================================
// ▼▼▼ 在这里添加新的代码块 ▼▼▼
        // 在程序启动时从数据库加载已有的论坛帖子
        currentForumPosts = await db.forumPosts.toArray();
        if (currentForumPosts.length > 0) {
            console.log(`从数据库加载了 ${currentForumPosts.length} 条论坛帖子。`);
            renderForumPosts(currentForumPosts);
        }
        // ▲▲▲ 添加结束 ▲▲▲
            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            // ▼▼▼ 【修改】导出按钮现在打开选择面板而不是直接导出 ▼▼▼
document.getElementById('export-data-btn').addEventListener('click', () => {
    document.getElementById('export-options-modal').classList.add('visible');
});

// 导出对话框的事件处理
document.getElementById('close-export-modal')?.addEventListener('click', () => {
    document.getElementById('export-options-modal').classList.remove('visible');
});

document.getElementById('cancel-export-modal')?.addEventListener('click', () => {
    document.getElementById('export-options-modal').classList.remove('visible');
});

document.getElementById('confirm-export-modal')?.addEventListener('click', () => {
    executePartialExport();
});

// 点击对话框外部关闭
document.getElementById('export-options-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'export-options-modal') {
        document.getElementById('export-options-modal').classList.remove('visible');
    }
});
// ▲▲▲ 修改结束 ▲▲▲
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));

            // ▼▼▼ 新增：本地备份和恢复的事件监听器 ▼▼▼
            document.getElementById('save-local-backup-btn').addEventListener('click', saveLocalBackup);
            document.getElementById('restore-local-backup-btn').addEventListener('click', restoreLocalBackup);

            // 页面加载时恢复备份时间显示
            function initBackupStatusDisplay() {
                const lastBackupSuccess = localStorage.getItem('lastBackupSuccess');
                const statusEl = document.getElementById('local-backup-status');
                if (lastBackupSuccess && statusEl) {
                    statusEl.innerHTML = `<span class="backup-success-badge"><span class="checkmark-circle"></span><span> 备份成功 - ${lastBackupSuccess}</span></span>`;
                    statusEl.style.color = '#666';
                }
            }
            initBackupStatusDisplay();
            // ▲▲▲ 新增结束 ▲▲▲

            // 【记忆功能】记忆按钮事件监听器
            document.getElementById('memory-summary-btn').addEventListener('click', async () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];

                // 获取记忆内容并填充到文本框
                document.getElementById('memory-summary-textarea').value = chat.memorySummary || '';

                // 更新消息统计
                await updateMemoryStats(state.activeChatId);

                // 显示弹窗
                document.getElementById('memory-summary-modal').classList.add('visible');

                // 关闭+功能面板
                closePlusPanel();
            });

            document.getElementById('memory-summary-btn-group').addEventListener('click', async () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];

                // 获取记忆内容并填充到文本框
                document.getElementById('memory-summary-textarea').value = chat.memorySummary || '';

                // 更新消息统计
                await updateMemoryStats(state.activeChatId);

                // 显示弹窗
                document.getElementById('memory-summary-modal').classList.add('visible');

                // 关闭+功能面板
                closePlusPanel();
            });

            // 【记忆功能】强制总结按钮
            document.getElementById('force-summarize-btn').addEventListener('click', () => {
                if (!state.activeChatId) return;
                manualSummarizeMemory(state.activeChatId);
            });

            // 【记忆功能】删除记忆按钮
            document.getElementById('delete-summary-btn').addEventListener('click', async () => {
                const confirmed = await showCustomConfirm('删除记忆', '确定要删除所有记忆摘要吗？此操作无法撤销。');
                if (confirmed) {
                    const chat = state.chats[state.activeChatId];
                    chat.memorySummary = '';

                    // 同时将所有消息的isSummarized标记重置为false
                    chat.history.forEach(msg => {
                        if (msg.isSummarized !== undefined) {
                            msg.isSummarized = false;
                        }
                    });

                    await db.chats.put(chat);
                    document.getElementById('memory-summary-textarea').value = '';

                    // 更新消息统计
                    await updateMemoryStats(state.activeChatId);

                    await showCustomAlert('删除成功', '记忆已清空！');
                }
            });

            // 【回滚功能】回滚记忆按钮
            document.getElementById('rollback-summary-btn').addEventListener('click', async () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];

                // 检查是否有可回滚的状态
                if (!chat.lastMemorySummary && chat.lastMemorySummary !== '') {
                    await showCustomAlert('无法回滚', '没有可以回滚的记忆状态。');
                    return;
                }

                // 确认回滚操作
                const confirmed = await showCustomConfirm('确认回滚', '确定要将记忆回滚到上一次总结前的状态吗？当前的修改将会丢失。');
                if (!confirmed) return;

                // 执行回滚
                chat.memorySummary = chat.lastMemorySummary;
                document.getElementById('memory-summary-textarea').value = chat.lastMemorySummary;

                // 【关键修复】恢复消息的isSummarized标记状态
                if (chat.lastSummarizedMessageIds && chat.lastSummarizedMessageIds.length > 0) {
                    // 将上次总结的消息重新标记为未总结状态
                    chat.history.forEach(msg => {
                        const msgId = msg.id || msg.timestamp;
                        if (chat.lastSummarizedMessageIds.includes(msgId)) {
                            msg.isSummarized = false;
                        }
                    });
                }

                // 保存到数据库
                await db.chats.put(chat);

                // 更新统计信息
                await updateMemoryStats(state.activeChatId);

                await showCustomAlert('回滚成功', '记忆已回滚到上一次总结前的状态！');
            });

            // 【记忆功能】保存记忆按钮
            document.getElementById('save-summary-btn').addEventListener('click', async () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const newSummary = document.getElementById('memory-summary-textarea').value;

                chat.memorySummary = newSummary;
                await db.chats.put(chat);

                // 【新增】保存后立即重新校准Token计数
                await updateMemoryStats(state.activeChatId);

                document.getElementById('memory-summary-modal').classList.remove('visible');
            });

            // 礼物功能事件监听器
            document.getElementById('gift-btn-panel').addEventListener('click', () => {
                closePlusPanel(); // 先关闭功能面板
                // 单聊模式：隐藏接收对象选择
                document.getElementById('gift-recipient-group').style.display = 'none';
                document.getElementById('gift-modal').classList.add('visible');
            });
            document.getElementById('gift-btn-group-panel').addEventListener('click', () => {
                closePlusPanel(); // 先关闭功能面板
                // 群聊模式：显示接收对象选择并填充群成员
                const currentChat = state.chats[state.activeChatId];
                if (currentChat && currentChat.isGroup) {
                    populateGroupMembersForGift(currentChat);
                    document.getElementById('gift-recipient-group').style.display = 'block';
                }
                document.getElementById('gift-modal').classList.add('visible');
            });
            document.getElementById('cancel-gift-btn').addEventListener('click', () => {
                document.getElementById('gift-modal').classList.remove('visible');
                document.getElementById('gift-name-input').value = '';
                document.getElementById('gift-price-input').value = '';
            });
            document.getElementById('send-gift-btn').addEventListener('click', () => {
                const giftName = document.getElementById('gift-name-input').value.trim();
                const giftPrice = document.getElementById('gift-price-input').value.trim();
                const recipientSelect = document.getElementById('gift-recipient-select');
                const recipient = recipientSelect.style.display === 'none' ? null : recipientSelect.value;
                
                if (giftName && giftPrice) {
                    sendGiftMessage(giftName, giftPrice, recipient);
                    document.getElementById('gift-modal').classList.remove('visible');
                    document.getElementById('gift-name-input').value = '';
                    document.getElementById('gift-price-input').value = '';
                    document.getElementById('gift-recipient-group').style.display = 'none';
                }
            });
            
            // ▼▼▼ 请用这段【新代码】完整替换旧的 'back-to-list-btn' 事件监听器 ▼▼▼
document.getElementById('back-to-list-btn').addEventListener('click', () => { 
    // 【核心新增】在这里添加关闭面板的代码，确保退出时重置UI状态
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');
    const chatInterface = document.getElementById('chat-interface-screen');
    
    if (singlePanel) singlePanel.classList.remove('visible');
    if (groupPanel) groupPanel.classList.remove('visible');
    if (chatInterface) chatInterface.classList.remove('panel-expanded');

    // 原有的其他逻辑保持不变
    applyScopedCss('', '#chat-messages', 'custom-bubble-style');
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style');
    exitSelectionMode(); 
    state.activeChatId = null; 
    showScreen('chat-list-screen'); 
});
// ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 【新增】导入角色卡功能事件绑定 ▼▼▼
            document.getElementById('import-character-card-btn').addEventListener('click', () => {
                // 直接触发文件选择框，不显示确认弹窗
                document.getElementById('character-card-input').click();
            });

            document.getElementById('character-card-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    // 当用户选择了文件后，调用我们的总处理函数
                    handleCharacterImport(file);
                }
                // 清空选择，这样用户下次还能选择同一个文件
                event.target.value = null;
            });
            // ▲▲▲ 导入角色卡事件绑定结束 ▲▲▲

            document.getElementById('add-chat-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字'); if (name && name.trim()) { const newChatId = 'chat_' + Date.now(); 
const newChat = { 
    id: newChatId,
    name: name.trim(),
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    originalName: '', // 初始化真实姓名字段为空字符串
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    isGroup: false,                         relationship: {
                            status: 'friend', // 'friend', 'blocked_by_user', 'pending_user_approval'
                            blockedTimestamp: null,
                            applicationReason: ''
                        },
                        status: {
                            text: '在线',
                            lastUpdate: Date.now(),
                            isBusy: false
                        },
    settings: {
        aiPersona: '你是谁呀。',
        myPersona: '我是谁呀。',
        maxMemory: 10,
        aiAvatar: defaultAvatar,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
    // 【核心修改】新建聊天时，直接使用全局字体大小
    fontSize: state.globalSettings.fontSize || 13,
    customCss: '',
    linkedWorldBookIds: [],
    aiAvatarLibrary: [],
    },
    history: [],
    musicData: { totalTime: 0 },
    memorySummary: '', // 【记忆功能】新增字段：核心记忆摘要
    lastMemorySummary: '', // 【回滚功能】新增字段：上一次记忆摘要备份
    lastSummarizedMessageIds: [], // 【回滚功能】新增字段：上一次总结的消息ID列表
    diary: [],
displayStatus: {
    statusText: '在线',
    innerThought: '开始一段新的对话吧...'
},
statusHistory: [],
thoughtHistory: [],
// 【预设功能】分别为线下模式和监控模式设置预设ID
presetIdOffline: null,  // 线下模式使用的预设ID
presetIdMonitor: null   // 监控模式使用的预设ID
// ▲▲▲ 粘贴结束 ▲▲▲
};
state.chats[newChatId] = newChat; await db.chats.put(newChat); renderChatList(); } });

            // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);

// 【新增】群聊类型选择弹窗事件处理
document.getElementById('create-normal-group-btn').addEventListener('click', async () => {
    currentGroupChatType = 'normal';
    document.getElementById('group-chat-type-modal').classList.remove('visible');
    await proceedToContactPickerAfterTypeSelection();
});

document.getElementById('create-spectator-group-btn').addEventListener('click', async () => {
    currentGroupChatType = 'spectator';
    document.getElementById('group-chat-type-modal').classList.remove('visible');
    await proceedToContactPickerAfterTypeSelection();
});

document.getElementById('cancel-group-type-modal-btn').addEventListener('click', () => {
    document.getElementById('group-chat-type-modal').classList.remove('visible');
});


// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

document.getElementById('listen-together-btn-panel').addEventListener('click', handleListenTogetherClick);
document.getElementById('listen-together-btn-group-panel').addEventListener('click', handleListenTogetherClick);

// 模式切换按钮事件监听器
document.getElementById('mode-switch-btn').addEventListener('click', toggleMode);

// 点击面板背景关闭面板
document.getElementById('mode-selection-panel').addEventListener('click', (e) => {
    if (e.target.id === 'mode-selection-panel') {
        hideModeSelectionPanel();
    }
});

// 位置按钮事件监听器
document.getElementById('location-btn-panel').addEventListener('click', () => {
    closePlusPanel(); // 先关闭功能面板
    showLocationModal();
});
document.getElementById('location-btn-group-panel').addEventListener('click', () => {
    closePlusPanel(); // 先关闭功能面板
    showLocationModal();
});
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-from-url-btn').addEventListener('click', handleAddSongFromUrl);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);

            // ▼▼▼ 【新增】搜索功能事件监听 ▼▼▼
            document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

            document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
                document.getElementById('music-search-results-modal').classList.remove('visible');
            });

            document.getElementById('search-results-list').addEventListener('click', (e) => {
                const item = e.target.closest('.search-result-item');
                if (item && item.dataset.songJson) {
                    const songData = JSON.parse(item.dataset.songJson);
                    handleSearchResultClick(songData);
                }
            });
            // ▲▲▲ 搜索功能事件监听结束 ▲▲▲

            audioPlayer.addEventListener('ended', playNext);
            audioPlayer.addEventListener('pause', () => { if(musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
            audioPlayer.addEventListener('play', () => { if(musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => {
    const content = chatInput.value.trim();
    if (!content || !state.activeChatId) return;

    closePlusPanel();

    const chat = state.chats[state.activeChatId];

    // ▼▼▼ 全新添加：在发送新消息前，清除上一条的一次性指令 ▼▼▼
    const originalLength = chat.history.length;
    chat.history = chat.history.filter(msg => !msg.isOneTimeInstruction);
    // 如果有指令被清除了，就在这里提前更新一次数据库
    if (chat.history.length < originalLength) {
        await db.chats.put(chat);
        console.log('已清除上一条消息附带的一次性AI指令。');
    }
    // ▲▲▲ 添加结束 ▲▲▲

    // 【新增】用户发送消息时，清除所有模拟时间戳，恢复真实时间戳显示
    restoreRealTimestamps(chat);

    // --- 【核心修改】在这里添加 ---
    const msg = {
        role: 'user',
        content,
        timestamp: Date.now(),
        isOfflineMode: offlineMode.isOffline // 标记是否为线下模式消息
    };

    // 【全新】检查是否为HTML生成指令，如果是，则添加一个用于显示的特殊内容
    if (content.includes('【停止角色扮演') && content.includes('输出完整HTML')) {
        msg.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
    }

    // ▼▼▼ 【全新功能】检查消息是否被括号完全包围 ▼▼▼
    // 判断消息是否匹配 （内容） 的格式，且整个消息都被括号包围
    const bracketRegex = /^（[\s\S]*）$/;
    if (bracketRegex.test(content)) {
        msg.isHidden = true; // 标记为隐藏消息，不会在UI界面显示
    }
    // ▲▲▲ 括号检测结束 ▲▲▲

    // 检查当前是否处于引用回复模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
    }
    // --- 【修改结束】 ---

    // ▼▼▼ 【需求1】检查是否被拉黑，如果被拉黑则标注消息 ▼▼▼
    if (!chat.isGroup && chat.relationship && chat.relationship.status === 'blocked_by_ai') {
        msg.sentWhileBlocked = true; // 为消息添加被拉黑标记，AI会知道这是被拉黑后发送的消息
    }
    // ▲▲▲ 被拉黑标注结束 ▲▲▲

    // 【新增】旁观群聊中，用户消息不显示在UI上，转换为系统消息发送给AI
    if (chat.isGroup && chat.isSpectator) {
        // 不添加原始的user消息
        // 而是添加一条系统消息，让AI知道用户想说什么，但不显示在UI上
        const spectatorUserMsg = {
            role: 'system',
            content: `[给ai的元指令：${content}]`,
            timestamp: Date.now(),
            isHidden: true // 对用户隐藏
        };
        chat.history.push(spectatorUserMsg);
    } else {
        // 非旁观群聊：正常添加用户消息
        chat.history.push(msg);
    }

    // ▼▼▼ 你的新功能逻辑在这里 ▼▼▼
    // 检查是否满足所有条件：线下模式 + 非"停止"指令
    if (offlineMode.isOffline && !content.includes('停止角色扮演')) {
        // 创建一条对用户隐藏，但对AI可见的系统消息
        const hiddenSuffixMsg = {
            role: 'user', // 以用户身份发送
            content: '（每轮输出前，**首步务必生成<thinking>…</thinking>包裹的思考内容**，并且文末必须生成摘要）', // 你要求的文本
            timestamp: Date.now() + 1, // 确保时间戳在用户消息之后
            isHidden: true, // 关键！这条消息不会在聊天界面上显示
            isOfflineMode: true, // 保持模式一致
            isOneTimeInstruction: true // 【全新添加】阅后即焚标记
        };
        // 将这条隐藏消息也加入聊天记录
        chat.history.push(hiddenSuffixMsg);
    }
    // ▲▲▲ 新功能逻辑结束 ▲▲▲

    await db.chats.put(chat);
    // 【新增】旁观群聊中不显示用户消息
    if (!(chat.isGroup && chat.isSpectator)) {
        appendMessage(msg, chat);
    }
    renderChatList();
    chatInput.value = '';
    chatInput.style.height = 'auto';
    chatInput.focus();

    // --- 【核心修改】发送后，取消引用模式 ---
    cancelReplyMode();
});
            // ▼▼▼ 【全新修改】为"等待回复"按钮添加模式判断 ▼▼▼
            document.getElementById('wait-reply-btn').addEventListener('click', async () => {
                // 检查是否正处于"一起听"模式，并且当前聊天是听歌的聊天
                console.log('[DEBUG] wait-reply-btn clicked');
                console.log('[DEBUG] musicState.isActive:', musicState.isActive);
                console.log('[DEBUG] musicState.activeChatId:', musicState.activeChatId);
                console.log('[DEBUG] state.activeChatId:', state.activeChatId);
                console.log('[DEBUG] 一起听状态判断结果:', musicState.isActive && musicState.activeChatId === state.activeChatId);

                // 【新增】如果是监控模式，且输入框为空，自动发送时间戳消息
                const chat = state.chats[state.activeChatId];
                const chatInput = document.getElementById('chat-input');
                const inputIsEmpty = !chatInput.value.trim();

                // ▼▼▼ ▼▼▼ 核心修改区域开始 ▼▼▼ ▼▼▼
                if (offlineMode.isMonitorMode && inputIsEmpty && chat) {
                    // 获取当前时间，格式为 HH:MM
                    const now = new Date();
                    const hours = String(now.getHours()).padStart(2, '0');
                    const minutes = String(now.getMinutes()).padStart(2, '0');
                    const timeMessage = `（${hours}:${minutes}）`;

                    // 自动发送时间消息
                    const userMsg = {
                        role: 'user',
                        content: timeMessage,
                        timestamp: Date.now(), // 修复：统一使用 Date.now()
                        isHidden: true // 修复1：将此消息对UI隐藏
                    };

                    chat.history.push(userMsg);
                    await db.chats.put(chat);
                    // appendMessage(userMsg, chat); // 修复2：移除UI渲染

                    // 清空输入框
                    chatInput.value = '';
                    chatInput.style.height = 'auto';
                    
                    await triggerAiResponse(); // 修复3：触发AI响应
                }
                // ▲▲▲ ▲▲▲ 核心修改区域结束 ▲▲▲ ▲▲▲

                // 【新增】如果是旁观群聊，先发送系统提示，然后触发AI回复
                else if (chat && chat.isGroup && chat.isSpectator) {
                    console.log('[DEBUG] 进入旁观群聊回复模式');

                    // 向历史记录中添加系统提示消息（对用户隐藏）
                    const spectatorSystemMsg = {
                        role: 'system',
                        content: '[系统提示：用户不在群里，群里只有角色之间互相聊天，用户没有发送任何信息，并且也不要让他们知道用户正在看聊天记录。请继续群聊。]',
                        timestamp: Date.now(), // 修复：统一使用 Date.now()
                        isHidden: true  // 【新增】完全隐藏这条系统消息，不显示在UI上
                    };

                    chat.history.push(spectatorSystemMsg);

                    // 设置旁观模式标志
                    chat.isInSpectatorPropelMode = true;

                    // 保存数据库
                    await db.chats.put(chat);

                    // 触发AI回复
                    await triggerAiResponse();

                    // 清除标志
                    chat.isInSpectatorPropelMode = false;
                    await db.chats.put(chat);
                } else if (musicState.isActive && musicState.isPlaying && musicState.activeChatId === state.activeChatId) {
                    // 如果是在听歌中，则手动触发AI歌词评论员
                    console.log('[DEBUG] 进入歌词评论模式');
                    await triggerAiLyricCommentary(state.activeChatId);
                } else {
                    // 否则，执行原有的功能（触发AI通用回复）
                    console.log('[DEBUG] 进入普通回复模式');
                    await triggerAiResponse();
                }
            });
            // ▲▲▲ 修改结束 ▲▲▲
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('focus', () => { closePlusPanel(); });
// ▼▼▼ 请用这段【新代码】替换旧的 chat-messages 点击事件 ▼▼▼

// ▼▼▼ 请用这段【新代码】完整替换旧的 chatInput.addEventListener('input', ...) ▼▼▼
chatInput.addEventListener('input', () => {
    const hasText = chatInput.value.trim().length > 0;

    // 【最终修正版】高度调整逻辑
    if (hasText) {
        // 1. 关键：先将高度重置为auto，这样浏览器才能正确计算出clientHeight和scrollHeight
        chatInput.style.height = 'auto';

        // 2. 核心判断：只有当内容所需高度 > 当前可见高度时，才去增高
        //    这能精确判断文字是否已经换行
        if (chatInput.scrollHeight > chatInput.clientHeight) {
            chatInput.style.height = chatInput.scrollHeight + 'px';
        }
    } else {
        // 当输入框为空时，恢复其初始的自动高度
        chatInput.style.height = 'auto';
    }

    // 同样保留输入时自动关闭下拉面板的逻辑 (这部分不变)
    if (hasText) {
        if (singlePanel.classList.contains('visible')) {
            singlePanel.classList.remove('visible');
        }
        if (groupPanel.classList.contains('visible')) {
            groupPanel.classList.remove('visible');
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
            
            // 聊天背景上传事件监听器
            document.getElementById('chat-background-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newChatBackgroundBase64 = dataUrl; renderWallpaperScreen(); } });
            // ▼▼▼ 用这整块代码，替换旧的 save-wallpaper-btn 事件监听器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }
    
    // 保存聊天背景
    if (newChatBackgroundBase64) {
        state.globalSettings.chatBackground = newChatBackgroundBase64;
        changesMade = true;
    }

    // ▼▼▼ 在这里添加了缺失的代码 ▼▼▼
    const paddingTopValue = document.getElementById('chat-list-padding-top-input').value;
    state.globalSettings.chatListPaddingTop = parseInt(paddingTopValue) || 72;
    // ▲▲▲ 代码添加结束 ▲▲▲

    // ▼▼▼ 保存等待回复按钮样式 ▼▼▼
    const waitReplyBtnCustom = document.getElementById('wait-reply-btn-custom-input').value.trim();
    if (waitReplyBtnCustom) {
        state.globalSettings.waitReplyBtnCustom = waitReplyBtnCustom;
        changesMade = true;
        localStorage.setItem('waitReplyBtnCustom', waitReplyBtnCustom);
    }
    // ▲▲▲ 保存等待回复按钮样式结束 ▲▲▲

    // ▼▼▼ 保存加载动画 URL ▼▼▼
    const loadingAnimationUrl = document.getElementById('loading-animation-url-input').value.trim();
    console.log('尝试保存加载动画 URL:', loadingAnimationUrl);
    if (loadingAnimationUrl) {
        state.globalSettings.loadingAnimationUrl = loadingAnimationUrl;
        changesMade = true;
        // 同时存到 localStorage，这样加载屏幕能读到
        localStorage.setItem('customLoadingAnimationUrl', loadingAnimationUrl);
        console.log('已保存到 localStorage:', localStorage.getItem('customLoadingAnimationUrl'));
    }
    // ▲▲▲ 保存加载动画 URL 结束 ▲▲▲

    // 保存所有全局设置到数据库
    await db.globalSettings.put(state.globalSettings);

    // 应用所有更改
    if (changesMade) {
        applyGlobalWallpaper();
        applyGlobalChatBackground();
        newWallpaperBase64 = null;
        newChatBackgroundBase64 = null;
    }
    applyAppIcons(); // 重新应用所有图标
    applyChatListPaddingTop(); // <--- 关键！保存后立刻应用新的边距值
    applyWaitReplyBtnStyle(); // 应用等待回复按钮样式

    alert('外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 加载动画预览按钮 ▼▼▼
document.getElementById('preview-loading-animation-btn').addEventListener('click', () => {
    const url = document.getElementById('loading-animation-url-input').value.trim();
    if (!url) {
        alert('请先输入加载动画 URL');
        return;
    }

    // 创建预览屏幕
    const previewOverlay = document.createElement('div');
    previewOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #F7F7F7;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9998;
    `;

    const previewContent = document.createElement('div');
    previewContent.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    `;

    const spinner = document.createElement('div');
    spinner.style.cssText = `
        width: 100px;
        height: 100px;
        background-image: url("${url}");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        animation: page-loading-float 3s ease-in-out infinite;
    `;

    const closeBtn = document.createElement('button');
    closeBtn.textContent = '关闭预览';
    closeBtn.className = 'form-button';
    closeBtn.style.cssText = `
        margin-top: 20px;
    `;
    closeBtn.onclick = () => previewOverlay.remove();

    previewContent.appendChild(spinner);
    previewContent.appendChild(closeBtn);
    previewOverlay.appendChild(previewContent);
    document.body.appendChild(previewOverlay);
});
// ▲▲▲ 加载动画预览按钮结束 ▲▲▲

// ▼▼▼ 加载动画恢复默认按钮 ▼▼▼
document.getElementById('reset-loading-animation-btn').addEventListener('click', () => {
    document.getElementById('loading-animation-url-input').value = 'https://iili.io/KlDHDmX.png';
    alert('已恢复默认加载动画 URL');
});
// ▲▲▲ 加载动画恢复默认按钮结束 ▲▲▲

// ▼▼▼ 等待回复按钮预览功能 ▼▼▼
document.getElementById('preview-wait-reply-btn-style').addEventListener('click', () => {
    const customInput = document.getElementById('wait-reply-btn-custom-input').value.trim();
    if (!customInput) {
        alert('请先输入 SVG 代码或图片 URL');
        return;
    }

    const waitReplyBtn = document.getElementById('wait-reply-btn');
    if (!waitReplyBtn) return;

    // 判断是 SVG 还是 URL
    if (customInput.startsWith('<svg')) {
        waitReplyBtn.innerHTML = customInput;
        const svg = waitReplyBtn.querySelector('svg');
        if (svg) {
            svg.style.width = '35px';
            svg.style.height = '35px';
            svg.style.display = 'block';
        }
        showScreen('home-screen'); // 关闭外观设置页面
        alert('预览已应用，你可以去聊天界面看看效果。记得点"保存所有外观设置"才会永久保存。');
    } else if (customInput.startsWith('http://') || customInput.startsWith('https://')) {
        waitReplyBtn.innerHTML = `<img src="${customInput}" alt="等待回复" style="height: 35px;">`;
        showScreen('home-screen'); // 关闭外观设置页面
        alert('预览已应用，你可以去聊天界面看看效果。记得点"保存所有外观设置"才会永久保存。');
    } else {
        alert('输入格式不对。请输入完整的 SVG 代码（以 <svg 开头）或图片 URL（以 http:// 或 https:// 开头）');
    }
});
// ▲▲▲ 等待回复按钮预览功能结束 ▲▲▲

// ▼▼▼ 等待回复按钮恢复默认 ▼▼▼
document.getElementById('reset-wait-reply-btn-style').addEventListener('click', () => {
    const waitReplyBtn = document.getElementById('wait-reply-btn');
    if (waitReplyBtn) {
        // 恢复默认的图片
        waitReplyBtn.innerHTML = '<img src="https://i.postimg.cc/hjkGB1Yz/66424753ch46672e554ee2d87c2031f5.png" alt="等待回复" style="height: 35px;">';
    }
    // 清空输入框
    document.getElementById('wait-reply-btn-custom-input').value = '';
    // 清除保存的数据
    delete state.globalSettings.waitReplyBtnCustom;
    localStorage.removeItem('waitReplyBtnCustom');
    alert('已恢复默认样式');
});
// ▲▲▲ 等待回复按钮恢复默认结束 ▲▲▲

            document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
                state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim();
                state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
                state.apiConfig.model = document.getElementById('model-select').value;
                state.apiConfig.temperature = parseFloat(document.getElementById('temperature-slider').value) || 0.8;
                // ▼▼▼ 【Minimax TTS】保存minimax配置 ▼▼▼
                state.apiConfig.minimaxDomain = document.getElementById('minimax-domain-select').value;
                state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
                state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
                state.apiConfig.minimaxSpeechModel = document.getElementById('minimax-speech-model-select').value;
                // ▲▲▲ 【Minimax TTS】保存minimax配置 ▲▲▲
                await db.apiConfig.put(state.apiConfig);

                // ▼▼▼ 【新增】保存NovelAI API Key和Model ▼▼▼
                const novelaiKeyInput = document.getElementById('novelai-api-key');
                const novelaiModelSelect = document.getElementById('novelai-model');
                if (novelaiKeyInput) {
                    localStorage.setItem('novelai-api-key', novelaiKeyInput.value.trim());
                }
                if (novelaiModelSelect) {
                    localStorage.setItem('novelai-model', novelaiModelSelect.value);
                }
                console.log('✅ NovelAI配置已保存');
                // ▲▲▲ 【新增】保存NovelAI配置结束 ▲▲▲

                // ... (这里是你原来保存后台活动设置的代码，保持不变) ...
                const backgroundSwitch = document.getElementById('background-activity-switch');
                const intervalInput = document.getElementById('background-interval-input');
                const newEnableState = backgroundSwitch.checked;
                const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

                // 只有在用户“从关到开”时，才弹出警告 (这段逻辑在自动保存时不会触发 confirm，是安全的)
                if (newEnableState && !oldEnableState) {
                    const userConfirmed = confirm(
                        "【高费用警告】\n\n" +
                        "您正在启用“后台角色活动”功能。\n\n" +
                        "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
                        "但请注意：\n" +
                        "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
                        "您确定要开启吗？"
                    );

                    if (!userConfirmed) {
                        backgroundSwitch.checked = false; // 用户取消，把开关拨回去
                        return; // 阻止后续逻辑
                    }
                }

                state.globalSettings.enableBackgroundActivity = newEnableState;
                state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
                state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
                // ▼▼▼ 新增：保存通知音频URL ▼▼▼
                state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url').value.trim();
                // ▲▲▲ 新增：保存通知音频URL ▲▲▲
                await db.globalSettings.put(state.globalSettings);

                // ▼▼▼ 新增：预加载通知音频 ▼▼▼
                if (state.globalSettings.notificationSoundUrl) {
                    const audioUrl = state.globalSettings.notificationSoundUrl.trim();
                    if (audioUrl && audioUrl !== notificationAudioCache.url) {
                        // 音频URL改变了，需要重新预加载
                        try {
                            const preloadAudio = new Audio(audioUrl);
                            preloadAudio.preload = 'auto'; // 强制预加载
                            preloadAudio.volume = 1;
                            notificationAudioCache = {
                                url: audioUrl,
                                audio: preloadAudio
                            };
                            console.log('[API设置] 通知音频已预加载:', audioUrl);
                        } catch (error) {
                            console.warn('[API设置] 预加载通知音频失败:', error);
                        }
                    }
                }
                // ▲▲▲ 新增：预加载通知音频 ▲▲▲

                // 动态启动或停止模拟器
                stopBackgroundSimulation();
                if (state.globalSettings.enableBackgroundActivity) {
                    startBackgroundSimulation();
                    console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
                } else {
                    console.log("后台活动模拟已停止。");
                }
                // ... (后台活动设置的代码结束) ...

                // ▼▼▼ 【注释】在API设置页面不应该调用saveNovelAISettings，避免覆盖NovelAI modal里的设置 ▼▼▼
                // saveNovelAISettings();
                // ▲▲▲ 【注释】NovelAI设置应该在NovelAI modal里保存，而不是在这里被覆盖 ▲▲▲

                // alert('API设置已保存!'); // <--- 可以注释掉或删除这行，避免弹出两次提示
                // 刷新预设列表
                window.renderApiPresets();

                // --- ▼▼▼ 新增代码：保存后返回主屏幕 ▼▼▼ ---
                showScreen('home-screen');
                // --- ▲▲▲ 新增代码结束 ▲▲▲ ---
            });

// ▼▼▼ API预设功能开始 ▼▼▼
// 保存API预设
document.getElementById('save-api-preset-btn').addEventListener('click', async () => {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const model = document.getElementById('model-select').value;
    
    if (!proxyUrl || !apiKey) {
        return alert('请先填写反代地址和密钥！');
    }
    
    const presetName = prompt('请输入预设名称：', `预设_${new Date().toLocaleDateString()}`);
    if (!presetName) return;
    
    const preset = {
        id: Date.now().toString(),
        name: presetName,
        proxyUrl: proxyUrl,
        apiKey: apiKey,
        model: model || '',
        createdAt: Date.now()
    };
    
    // 保存到数据库
    await db.apiPresets.add(preset);
    
    // 更新state
    state.apiPresets.push(preset);
    
    // 刷新显示
    window.renderApiPresets();
    
    alert(`预设"${presetName}"已保存！`);
});

// 渲染预设列表
window.renderApiPresets = function() {
    const container = document.getElementById('api-presets-list');
    if (!state.apiPresets || state.apiPresets.length === 0) {
        container.innerHTML = '<p style="color: #666; font-size: 14px; text-align: center; padding: 10px;">暂无保存的预设</p>';
        return;
    }
    
    container.innerHTML = state.apiPresets.map(preset => `
        <div class="preset-item" style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin: 8px 0; background: #f9f9f9;">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                <div style="flex: 1; min-width: 0;">
                    <h4 style="margin: 0 0 5px 0; color: #333; font-size: 16px;">${preset.name}</h4>
                    <p style="margin: 0; color: #666; font-size: 12px; word-break: break-word;">
                        ${preset.model || '未选择模型'}
                    </p>
                </div>
                <div style="flex-shrink: 0; white-space: nowrap;">
                    <button class="preset-action-btn" onclick="applyApiPreset('${preset.id}')"
                            style="background: #007bff; color: white; border: none; padding: 5px 10px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        应用
                    </button>
                    <button class="preset-action-btn" onclick="editApiPreset('${preset.id}')"
                            style="background: #28a745; color: white; border: none; padding: 5px 10px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        编辑
                    </button>
                    <button class="preset-action-btn" onclick="deleteApiPreset('${preset.id}')"
                            style="background: #dc3545; color: white; border: none; padding: 5px 10px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        删除
                    </button>
                </div>
            </div>
        </div>
    `).join('');
}

// 应用预设
window.applyApiPreset = async function(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');

    document.getElementById('proxy-url').value = preset.proxyUrl;
    document.getElementById('api-key').value = preset.apiKey;

    // 【核心修改】应用预设后，立即调用拉取函数，并告诉它要选中哪个模型
    await fetchAndPopulateModels(preset.model);

    // alert(`已应用预设"${preset.name}"！请在模型列表加载完成后，点击"保存设置"来完成保存。`); // <--- 注释掉或删除这行提示

    // --- ▼▼▼ 新增代码：自动触发保存 ▼▼▼ ---
    console.log(`预设 "${preset.name}" 已应用，正在自动保存...`);
    // 使用 setTimeout 稍微延迟点击，确保模型列表选择可能已完成渲染
    setTimeout(() => {
        document.getElementById('save-api-settings-btn').click();
    }, 100); // 延迟100毫秒
    // --- ▲▲▲ 新增代码结束 ▲▲▲ ---
}

// 编辑预设 - 打开modal
window.editApiPreset = async function(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');

    // 存储当前编辑的预设ID到全局变量，便于保存时使用
    window.currentEditingPresetId = presetId;

    // 填充modal中的字段
    document.getElementById('edit-preset-name').value = preset.name || '';
    document.getElementById('edit-preset-proxy-url').value = preset.proxyUrl || '';
    document.getElementById('edit-preset-api-key').value = preset.apiKey || '';
    document.getElementById('edit-preset-model-select').value = preset.model || '';

    // 打开modal
    document.getElementById('edit-api-preset-modal').style.display = 'flex';
}

// 删除预设
window.deleteApiPreset = async function(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');
    
    if (!confirm(`确定要删除预设"${preset.name}"吗？`)) return;
    
    // 从数据库删除
    await db.apiPresets.delete(presetId);
    
    // 从state中移除
    const index = state.apiPresets.findIndex(p => p.id === presetId);
    if (index > -1) {
        state.apiPresets.splice(index, 1);
    }
    
    // 刷新显示
    window.renderApiPresets();
    
    alert(`预设"${preset.name}"已删除！`);
}

// 保存编辑的API预设
window.saveEditedApiPreset = async function() {
    const presetId = window.currentEditingPresetId;
    if (!presetId) return alert('找不到预设！');

    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');

    // 获取modal中的新值
    const newName = document.getElementById('edit-preset-name').value.trim();
    const newProxyUrl = document.getElementById('edit-preset-proxy-url').value.trim();
    const newApiKey = document.getElementById('edit-preset-api-key').value.trim();
    const newModel = document.getElementById('edit-preset-model-select').value;

    // 验证
    if (!newName) return alert('预设名称不能为空！');
    if (!newProxyUrl) return alert('反代地址不能为空！');
    if (!newApiKey) return alert('密钥不能为空！');

    // 更新预设
    preset.name = newName;
    preset.proxyUrl = newProxyUrl;
    preset.apiKey = newApiKey;
    preset.model = newModel || '';
    preset.updatedAt = Date.now();

    // 保存到数据库
    try {
        await db.apiPresets.put(preset);
        alert(`预设"${newName}"已更新！`);

        // 关闭modal
        document.getElementById('edit-api-preset-modal').style.display = 'none';

        // 刷新显示
        window.renderApiPresets();

        // 清空全局变量
        window.currentEditingPresetId = null;
    } catch (error) {
        alert(`保存失败: ${error.message}`);
    }
}

// 编辑预设modal中拉取模型
window.fetchModelsForEditPreset = async function() {
    const proxyUrl = document.getElementById('edit-preset-proxy-url').value.trim();
    const apiKey = document.getElementById('edit-preset-api-key').value.trim();

    if (!proxyUrl || !apiKey) return alert('请先填写反代地址和密钥');

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(apiKey)}` : `${proxyUrl}/v1/models`, isGemini ? undefined : { headers: { 'Authorization': `Bearer ${apiKey}` } });
        if (!response.ok) throw new Error('无法获取模型列表');
        const data = await response.json();
        let models = isGemini ? data.models : data.data;
        if (isGemini) {
            models = models.map((model) => {
                const parts = model.name.split('/');
                return {
                    id: parts.length > 1 ? parts[1] : model.name
                }
            })
        }
        const modelSelect = document.getElementById('edit-preset-model-select');
        modelSelect.innerHTML = '';
        models.forEach(model => {
            const option = document.createElement('option');
            option.value = model.id;
            option.textContent = model.id;
            modelSelect.appendChild(option);
        });
        alert('模型列表已更新');
    } catch (error) {
        alert(`拉取模型失败: ${error.message}`);
    }
}

// ▲▲▲ API预设功能结束 ▲▲▲

                    // gemini 密钥聚焦的时候显示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        // ▼▼▼ 第一步：创建一个可复用的函数来拉取和填充模型
async function fetchAndPopulateModels(modelToSelect = null) {
    const url = document.getElementById('proxy-url').value.trim();
    const key = document.getElementById('api-key').value.trim();
    if (!url || !key) return alert('请先填写反代地址和密钥');
    try {
        let isGemini = url === GEMINI_API_URL;
        const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : { headers: { 'Authorization': `Bearer ${key}` } });
        if (!response.ok) throw new Error('无法获取模型列表');
        const data = await response.json();
        let models = isGemini ? data.models : data.data;
        if (isGemini) {
            models = models.map((model) => {
                const parts = model.name.split('/');
                return {
                    id: parts.length > 1 ? parts[1] : model.name
                }
            })
        }
        const modelSelect = document.getElementById('model-select');
        modelSelect.innerHTML = '';
        models.forEach(model => {
            const option = document.createElement('option');
            option.value = model.id;
            option.textContent = model.id;
            // 如果传入了要选中的模型，就在这里选中它
            if (model.id === modelToSelect) {
                option.selected = true;
            }
            modelSelect.appendChild(option);
        });
        // 如果传入了模型但列表中没有完全匹配的，也尝试将下拉框的值设为它
        if (modelToSelect) {
            modelSelect.value = modelToSelect;
        }
        alert('模型列表已更新');
    } catch (error) {
        alert(`拉取模型失败: ${error.message}`);
    }
}

// 第二步：让“拉取模型”按钮调用这个新函数
document.getElementById('fetch-models-btn').addEventListener('click', () => fetchAndPopulateModels());
            // ▼▼▼ 【Minimax TTS】拉取语音模型按钮事件 ▼▼▼
            document.getElementById('fetch-minimax-speech-models-btn').addEventListener('click', fetchMinimaxSpeechModels);
            // ▲▲▲ 【Minimax TTS】拉取语音模型按钮事件 ▲▲▲
            document.getElementById('add-world-book-btn').addEventListener('click', () => { showUnifiedWorldBookModal(); });

            // 【新增】预设功能事件监听
            document.getElementById('import-preset-btn').addEventListener('click', importPresetFromJSON);
            document.getElementById('add-preset-btn').addEventListener('click', createNewPreset);
            document.getElementById('save-preset-btn').addEventListener('click', savePreset);
            document.getElementById('add-preset-item-btn').addEventListener('click', () => enterAddPresetItemMode());
            document.getElementById('custom-preset-library-btn').addEventListener('click', openCustomPresetLibraryManager);
            document.getElementById('preset-editor-back-btn').addEventListener('click', () => {
                showScreen('preset-manager-screen');
                renderPresetList();
            });

            // 【新增】预设条目添加选项模态框事件
            document.getElementById('add-preset-item-blank-btn').addEventListener('click', createBlankPresetItem);
            document.getElementById('add-preset-item-from-library-btn').addEventListener('click', showCustomPresetLibrary);
            document.getElementById('cancel-preset-item-add-btn').addEventListener('click', () => {
                document.getElementById('preset-item-add-modal').style.display = 'none';
                exitAddPresetItemMode();
                targetItemForAddition = null;
            });
            document.getElementById('preset-item-add-modal').addEventListener('click', (e) => {
                if (e.target.id === 'preset-item-add-modal') {
                    e.target.style.display = 'none';
                    exitAddPresetItemMode();
                    targetItemForAddition = null;
                }
            });

            // 【新增】自定义预设库选择模态框事件
            document.getElementById('custom-preset-select-close-btn').addEventListener('click', () => {
                document.getElementById('custom-preset-select-modal').style.display = 'none';
            });
            document.getElementById('custom-preset-select-cancel-btn').addEventListener('click', () => {
                document.getElementById('custom-preset-select-modal').style.display = 'none';
            });
            document.getElementById('custom-preset-select-modal').addEventListener('click', (e) => {
                if (e.target.id === 'custom-preset-select-modal') {
                    e.target.style.display = 'none';
                }
            });

            // 【新增】新条目part选择模态框事件
            document.getElementById('select-part1-btn').addEventListener('click', () => {
                if (window.pendingImportItem) {
                    selectPartForImportedItem('part1');
                } else {
                    selectPartForNewItem('part1');
                }
            });
            document.getElementById('select-part2-btn').addEventListener('click', () => {
                if (window.pendingImportItem) {
                    selectPartForImportedItem('part2');
                } else {
                    selectPartForNewItem('part2');
                }
            });
            document.getElementById('cancel-part-selection-btn').addEventListener('click', () => {
                const modal = document.getElementById('new-item-part-selection-modal');
                modal.style.display = 'none';
                targetItemForAddition = null;
                window.pendingImportItem = null;
            });
            document.getElementById('new-item-part-selection-modal').addEventListener('click', (e) => {
                if (e.target.id === 'new-item-part-selection-modal') {
                    e.target.style.display = 'none';
                    targetItemForAddition = null;
                    window.pendingImportItem = null;
                }
            });

            // 【全新】世界书多选模式的按钮事件
            document.getElementById('world-book-back-btn').addEventListener('click', () => {
                if (isWbSelectionMode) {
                    exitWbSelectionMode(); // 在多选模式下，返回按钮的功能是“取消”
                } else {
                    showScreen('home-screen'); // 正常模式下，返回主屏幕
                }
            });
            document.getElementById('wb-delete-btn').addEventListener('click', deleteSelectedWorldBooks);
            document.getElementById('chat-messages').addEventListener('click', (e) => { const aiImage = e.target.closest('.ai-generated-image'); if (aiImage) { const description = aiImage.dataset.description; if (description) showCustomAlert('照片描述', description); return; }  });
            
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
            function updateWorldBookSelectionDisplay() {
    const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input.wb-book-checkbox:checked');
    const displayText = document.querySelector('.selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else {
        // 【新逻辑】当二级分类全部绑定时，只显示二级分类名称
        const displayItems = [];
        const processedCategories = new Set();

        Array.from(checkedBoxes).forEach(cb => {
            const categoryId = cb.getAttribute('data-parent-category');

            // 如果该分类已经处理过，跳过
            if (processedCategories.has(categoryId)) {
                return;
            }

            // 获取该分类下的所有checkbox
            const allBooksInCategory = worldBookCheckboxesContainer.querySelectorAll(
                `input.wb-book-checkbox[data-parent-category="${categoryId}"]`
            );

            // 检查该分类下的所有书籍是否都被选中
            const allBooksBoundInCategory = Array.from(allBooksInCategory).every(box => box.checked);

            if (allBooksBoundInCategory) {
                // 如果该分类的所有书籍都被选中，显示分类名称
                const categoryHeader = worldBookCheckboxesContainer.querySelector(
                    `input.wb-category-checkbox[data-category-id="${categoryId}"]`
                );
                if (categoryHeader) {
                    const categoryName = categoryHeader.closest('.wb-category-header')?.querySelector('span:last-of-type')?.textContent || '';
                    if (categoryName) {
                        displayItems.push(categoryName);
                    }
                }
                processedCategories.add(categoryId);
            }
        });

        // 对于未被完全绑定的分类，显示具体的书籍名称
        Array.from(checkedBoxes).forEach(cb => {
            const categoryId = cb.getAttribute('data-parent-category');

            // 获取该分类下的所有checkbox
            const allBooksInCategory = worldBookCheckboxesContainer.querySelectorAll(
                `input.wb-book-checkbox[data-parent-category="${categoryId}"]`
            );

            // 检查该分类下的所有书籍是否都被选中
            const allBooksBoundInCategory = Array.from(allBooksInCategory).every(box => box.checked);

            // 只有当分类未被完全绑定时，才显示具体的书籍
            if (!allBooksBoundInCategory) {
                const bookName = cb.parentElement.textContent.trim();
                if (!displayItems.includes(bookName)) {
                    displayItems.push(bookName);
                }
            }
        });

        displayText.textContent = displayItems.join(', ');
    }
}
            // 【修复重复绑定Bug】线上世界书事件绑定 - 防止重复绑定
            if (!worldBookSelectBox.hasOnlineEventBound) {
                worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
                worldBookSelectBox.hasOnlineEventBound = true;
            }
            if (!document.getElementById('world-book-checkboxes-container').hasOnlineChangeEventBound) {
                document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
                document.getElementById('world-book-checkboxes-container').hasOnlineChangeEventBound = true;
            }
// 使用事件委托来处理所有点击和勾选事件，效率更高 - 防止重复绑定
if (!worldBookCheckboxesContainer.hasOnlineClickEventBound) {
    worldBookCheckboxesContainer.addEventListener('click', (e) => {
    // 处理自定义勾选框点击
    const customCheckbox = e.target.closest('.custom-checkbox');
    if (customCheckbox) {
        // 禁用的复选框不响应点击
        if (customCheckbox.classList.contains('disabled')) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        e.preventDefault();
        e.stopPropagation();
        const targetCheckboxId = customCheckbox.dataset.targetCheckbox;
        const targetCheckbox = document.getElementById(targetCheckboxId);
        if (targetCheckbox) {
            targetCheckbox.checked = !targetCheckbox.checked;
            customCheckbox.classList.toggle('checked', targetCheckbox.checked);
            // 触发change事件
            targetCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    // 处理书籍标签点击（label元素）
    const bookLabel = e.target.closest('.wb-book-container label');
    if (bookLabel && !e.target.closest('.custom-checkbox')) {
        e.preventDefault();
        e.stopPropagation();
        const checkbox = bookLabel.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.checked = !checkbox.checked;
            const customCheckbox = bookLabel.querySelector('.custom-checkbox');
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', checkbox.checked);
            }
            // 添加/移除label的checked类来控制背景色
            bookLabel.classList.toggle('checked', checkbox.checked);
            // 触发change事件
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    const header = e.target.closest('.wb-category-header');
    if (header && !e.target.matches('input[type="checkbox"]') && !e.target.closest('.custom-checkbox')) {
        // 处理"设定集"一级分类的特殊情况
        if (header.classList.contains('wb-setting-collection-header')) {
            const bookContainer = header.nextElementSibling;
            if (bookContainer && bookContainer.classList.contains('wb-setting-collection-container')) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        } else {
            // 处理普通二级分类
            const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
            if (categoryId) {
                const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
                if (bookContainer) {
                    header.classList.toggle('collapsed');
                    bookContainer.classList.toggle('collapsed');
                }
            }
        }
    }
});
    worldBookCheckboxesContainer.hasOnlineClickEventBound = true;
}

if (!worldBookCheckboxesContainer.hasOnlineChangeEventBound2) {
    // 【新增】辅助函数：更新分类标题背景
    const updateCategoryHeaderBackground = (categoryId, container) => {
        const allBookCheckboxes = container.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        const hasCheckedItems = Array.from(allBookCheckboxes).some(cb => cb.checked);

        // 通过找到分类checkbox，然后获取它的父header元素
        const categoryCheckbox = container.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
        if (categoryCheckbox) {
            const categoryHeader = categoryCheckbox.closest('.wb-category-header');
            if (categoryHeader) {
                if (hasCheckedItems) {
                    categoryHeader.classList.add('has-checked-items');
                } else {
                    categoryHeader.classList.remove('has-checked-items');
                }
            }
        }
    };

    worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;

    // 同步自定义勾选框的视觉状态
    const targetId = target.id;
    if (targetId) {
        const customCheckbox = worldBookCheckboxesContainer.querySelector(`[data-target-checkbox="${targetId}"]`);
        if (customCheckbox) {
            customCheckbox.classList.toggle('checked', target.checked);
        }

        // 同步label的背景色
        const label = target.closest('label');
        if (label && label.closest('.wb-book-container')) {
            label.classList.toggle('checked', target.checked);
        }
    }

    // 如果点击的是分类的"全选"复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            // 同步对应的自定义勾选框状态
            const customCheckbox = worldBookCheckboxesContainer.querySelector(`[data-target-checkbox="${cb.id}"]`);
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', isChecked);
            }
            // 同步label的背景色
            const label = cb.closest('label');
            if (label && label.closest('.wb-book-container')) {
                label.classList.toggle('checked', isChecked);
            }
        });
        // 【新增】更新分类标题背景
        updateCategoryHeaderBackground(categoryId, worldBookCheckboxesContainer);
    }

    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查它是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类"全选"复选框的状态
            if (categoryCheckbox) {
                categoryCheckbox.checked = allChecked;
                // 同步分类的自定义勾选框状态
                const categorycustomCheckbox = worldBookCheckboxesContainer.querySelector(`[data-target-checkbox="${categoryCheckbox.id}"]`);
                if (categorycustomCheckbox) {
                    categorycustomCheckbox.classList.toggle('checked', allChecked);
                }
            }
            // 【新增】更新分类标题背景
            updateCategoryHeaderBackground(categoryId, worldBookCheckboxesContainer);
        }
    }

    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplay();
});
    worldBookCheckboxesContainer.hasOnlineChangeEventBound2 = true;
}

// ▲▲▲ 粘贴结束 ▲▲▲

            // 线下世界书的交互逻辑在填充逻辑中已处理，这里只需要定义更新函数
            function updateWorldBookSelectionDisplayOffline() {
    const worldBookCheckboxesContainerOffline = document.getElementById('world-book-checkboxes-container-offline');
    const checkedBoxes = worldBookCheckboxesContainerOffline.querySelectorAll('input.wb-book-checkbox:checked');
    const displayText = document.querySelector('#world-book-link-group-offline .selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else {
        // 【新逻辑】当二级分类全部绑定时，只显示二级分类名称
        const displayItems = [];
        const processedCategories = new Set();

        Array.from(checkedBoxes).forEach(cb => {
            const categoryId = cb.getAttribute('data-parent-category');

            // 如果该分类已经处理过，跳过
            if (processedCategories.has(categoryId)) {
                return;
            }

            // 获取该分类下的所有checkbox
            const allBooksInCategory = worldBookCheckboxesContainerOffline.querySelectorAll(
                `input.wb-book-checkbox[data-parent-category="${categoryId}"]`
            );

            // 检查该分类下的所有书籍是否都被选中
            const allBooksBoundInCategory = Array.from(allBooksInCategory).every(box => box.checked);

            if (allBooksBoundInCategory) {
                // 如果该分类的所有书籍都被选中，显示分类名称
                const categoryHeader = worldBookCheckboxesContainerOffline.querySelector(
                    `input.wb-category-checkbox[data-category-id="${categoryId}"]`
                );
                if (categoryHeader) {
                    const categoryName = categoryHeader.closest('.wb-category-header')?.querySelector('span:last-of-type')?.textContent || '';
                    if (categoryName) {
                        displayItems.push(categoryName);
                    }
                }
                processedCategories.add(categoryId);
            }
        });

        // 对于未被完全绑定的分类，显示具体的书籍名称
        Array.from(checkedBoxes).forEach(cb => {
            const categoryId = cb.getAttribute('data-parent-category');

            // 获取该分类下的所有checkbox
            const allBooksInCategory = worldBookCheckboxesContainerOffline.querySelectorAll(
                `input.wb-book-checkbox[data-parent-category="${categoryId}"]`
            );

            // 检查该分类下的所有书籍是否都被选中
            const allBooksBoundInCategory = Array.from(allBooksInCategory).every(box => box.checked);

            // 只有当分类未被完全绑定时，才显示具体的书籍
            if (!allBooksBoundInCategory) {
                const bookName = cb.parentElement.textContent.trim();
                if (!displayItems.includes(bookName)) {
                    displayItems.push(bookName);
                }
            }
        });

        displayText.textContent = displayItems.join(', ');
    }
}

            // 全局点击监听已移到外层，避免重复绑定

// 【修复重复绑定Bug】全局点击监听器，只绑定一次
if (!window.hasGlobalMultiselectListener) {
    window.addEventListener('click', (e) => {
        const multiselects = document.querySelectorAll('.custom-multiselect');
        multiselects.forEach(multiselect => {
            if (!multiselect.contains(e.target)) {
                const container = multiselect.querySelector('.checkboxes-container');
                const selectBox = multiselect.querySelector('.select-box');
                if (container) container.classList.remove('visible');
                if (selectBox) selectBox.classList.remove('expanded');
            }
        });
    });
    window.hasGlobalMultiselectListener = true;
}

// ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    renderBubblePresets(); //
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;

    // --- 统一显示/隐藏控件 ---
    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('chat-remark-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
    // ▼▼▼ 【Minimax TTS】显示/隐藏语音ID配置 ▼▼▼
    document.getElementById('minimax-voice-id-group').style.display = isGroup ? 'none' : 'block';
    // ▲▲▲ 【Minimax TTS】显示/隐藏语音ID配置 ▲▲▲

    // 【核心修改1】根据是否为群聊，显示或隐藏"好友分组"区域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';


    // --- 加载表单数据 ---
    document.getElementById('chat-name-input').value = chat.name;
    // ▼▼▼ 在这里粘贴新代码（加载逻辑） ▼▼▼
    document.getElementById('chat-original-name-input').value = chat.originalName || ''; // 读取真实姓名
    document.getElementById('chat-remark-input').value = chat.remark || ''; // 读取用户备注
    console.log(`[聊天设置加载] 角色"${chat.name}"的备注:`, chat.remark);
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    // 【核心修改】加载新的记忆锚点
    document.getElementById('memory-anchor-input').value = chat.settings.memoryAnchor || 0;
    
    // 【全新添加】加载总结保留条数
    document.getElementById('summarize-reserve-input').value = chat.settings.summarizeReserveCount || 100;

    document.getElementById('cross-chat-memory-switch').checked = chat.settings.crossChatMemory || false;
    document.getElementById('active-reply-interval').value = chat.settings.activeReplyInterval || 0;

    // 【新增】加载后台活动设置
    const backgroundEnabled = chat.settings.backgroundActivityEnabled || false;
    const backgroundInterval = chat.settings.backgroundActivityInterval || 60;
    document.getElementById('background-activity-enabled-switch').checked = backgroundEnabled;
    document.getElementById('background-activity-interval-input').value = backgroundInterval;
    document.getElementById('background-interval-group').style.display = backgroundEnabled ? 'block' : 'none';

    // 【新增】加载朋友圈可见性设置
    if (!isGroup) {
        const momentsVisibilityEnabled = chat.settings.momentsVisibilityEnabled || false;
        const visibleCharacterIds = chat.settings.visibleCharacterIds || [];
        const customRelationship = chat.settings.customRelationship || '';

        document.getElementById('moments-visibility-switch').checked = momentsVisibilityEnabled;
        document.getElementById('custom-relationship-input').value = customRelationship;
        document.getElementById('moments-config-group').style.display = momentsVisibilityEnabled ? 'block' : 'none';

        // 生成可见角色列表（改为图片+名字，水平排列）
        const renderMomentsList = () => {
            const momentsList = document.getElementById('moments-characters-list');
            momentsList.innerHTML = '';
            momentsList.style.display = 'flex';
            momentsList.style.flexWrap = 'wrap';
            momentsList.style.gap = '10px';

            Object.values(state.chats).forEach(c => {
                if (!c.isGroup && c.id !== chat.id) {
                    const isSelected = visibleCharacterIds.includes(c.id);

                    const itemDiv = document.createElement('div');
                    itemDiv.dataset.characterId = c.id;
                    itemDiv.style.display = 'flex';
                    itemDiv.style.flexDirection = 'column';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.padding = '10px';
                    itemDiv.style.borderRadius = '8px';
                    itemDiv.style.cursor = 'pointer';
                    itemDiv.style.transition = 'background-color 0.2s';
                    itemDiv.style.backgroundColor = isSelected ? '#e8e8e8' : 'transparent';
                    itemDiv.style.minWidth = '70px';

                    // 头像
                    const avatar = document.createElement('img');
                    avatar.src = c.settings?.aiAvatar || defaultAvatar;
                    avatar.style.width = '50px';
                    avatar.style.height = '50px';
                    avatar.style.borderRadius = '50%';
                    avatar.style.marginBottom = '6px';
                    avatar.style.objectFit = 'cover';

                    // 角色名字
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = c.name;
                    nameSpan.style.fontSize = '12px';
                    nameSpan.style.textAlign = 'center';
                    nameSpan.style.wordBreak = 'break-word';
                    nameSpan.style.maxWidth = '70px';

                    // 点击事件：切换选中状态
                    itemDiv.addEventListener('click', () => {
                        if (visibleCharacterIds.includes(c.id)) {
                            // 如果已选中，移除
                            const idx = visibleCharacterIds.indexOf(c.id);
                            if (idx > -1) visibleCharacterIds.splice(idx, 1);
                        } else {
                            // 如果未选中，添加
                            visibleCharacterIds.push(c.id);
                        }
                        // 重新渲染列表
                        renderMomentsList();
                    });

                    itemDiv.appendChild(avatar);
                    itemDiv.appendChild(nameSpan);
                    momentsList.appendChild(itemDiv);
                }
            });
        };

        // 初始渲染
        renderMomentsList();
    }

    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        // ▼▼▼ 【Minimax TTS】加载minimaxVoiceId ▼▼▼
        document.getElementById('minimax-voice-id-input').value = chat.settings.minimaxVoiceId || '';

        // 🔥【新增】加载语速和语言设置
        const voiceSpeed = parseFloat(chat.settings.minimaxVoiceSpeed) || 1.0;
        document.getElementById('minimax-voice-speed-input').value = voiceSpeed;
        document.getElementById('minimax-voice-speed-value').textContent = voiceSpeed;
        document.getElementById('minimax-language-input').value = chat.settings.minimaxLanguage || '';
        // ▲▲▲ 【Minimax TTS】加载minimaxVoiceId ▲▲▲

        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果当前好友已经有分组，就默认选中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        });
    }
    
    // 加载世界书
// ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 获取所有分类和世界书
const categories = await db.worldBookCategories.toArray();
const books = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
const hasUncategorized = books.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组
const booksByCategoryId = books.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 将分类分为"设定集"和"普通分类"
const settingCategories = categories.filter(cat => cat.name.includes('的设定集'));
const normalCategories = categories.filter(cat => !cat.name.includes('的设定集'));

// 辅助函数：创建分类项目（用于普通分类和设定集内的二级分类）
// 所有通过此函数创建的分类都应该有复选框（可选中）
const createCategoryItem = (category) => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length === 0) return null;

    const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));

    const header = document.createElement('div');
    header.className = 'wb-category-header';

    // 所有二级分类都有复选框
    header.innerHTML = `
        <div class="custom-checkbox ${allInCategoryChecked ? 'checked' : ''}" data-target-checkbox="wb-category-${category.id}">
            <div class="custom-checkbox-circle"></div>
        </div>
        <input type="checkbox" class="wb-category-checkbox" id="wb-category-${category.id}" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
        <span class="arrow">▼</span>
        <span>${category.name}</span>
    `;

    const bookContainer = document.createElement('div');
    bookContainer.className = 'wb-book-container';
    bookContainer.dataset.containerFor = category.id;

    booksInCategory.forEach(book => {
        const isChecked = linkedIds.has(book.id);
        const label = document.createElement('label');
        if (isChecked) {
            label.classList.add('checked');
        }

        const customCheckbox = document.createElement('div');
        customCheckbox.className = `custom-checkbox ${isChecked ? 'checked' : ''}`;
        customCheckbox.setAttribute('data-target-checkbox', `wb-book-${book.id}`);

        const circle = document.createElement('div');
        circle.className = 'custom-checkbox-circle';
        customCheckbox.appendChild(circle);

        const hiddenCheckbox = document.createElement('input');
        hiddenCheckbox.type = 'checkbox';
        hiddenCheckbox.className = 'wb-book-checkbox';
        hiddenCheckbox.id = `wb-book-${book.id}`;
        hiddenCheckbox.value = book.id;
        hiddenCheckbox.setAttribute('data-parent-category', category.id);
        hiddenCheckbox.checked = isChecked;
        hiddenCheckbox.style.display = 'none';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = book.name;
        nameSpan.style.whiteSpace = 'nowrap';

        label.appendChild(customCheckbox);
        label.appendChild(hiddenCheckbox);
        label.appendChild(nameSpan);
        bookContainer.appendChild(label);
    });

    header.classList.add('collapsed');
    bookContainer.classList.add('collapsed');

    return { header, bookContainer };
};

// 先渲染"设定集"（一级分类）
if (settingCategories.length > 0) {
    // 创建"设定集"一级分类头部（不可选，无复选框）
    const settingHeader = document.createElement('div');
    settingHeader.className = 'wb-category-header wb-setting-collection-header';
    settingHeader.innerHTML = `
        <span class="arrow">▼</span>
        <span>设定集</span>
    `;
    settingHeader.classList.add('collapsed');

    const settingContentContainer = document.createElement('div');
    settingContentContainer.className = 'wb-book-container wb-setting-collection-container';
    settingContentContainer.dataset.containerFor = 'setting-collection';
    settingContentContainer.classList.add('collapsed');

    // 在"设定集"内放置所有二级分类
    settingCategories.forEach(category => {
        const categoryItem = createCategoryItem(category);
        if (categoryItem) {
            settingContentContainer.appendChild(categoryItem.header);
            settingContentContainer.appendChild(categoryItem.bookContainer);
        }
    });

    worldBookCheckboxesContainer.appendChild(settingHeader);
    worldBookCheckboxesContainer.appendChild(settingContentContainer);
}

// 再渲染"普通分类"
normalCategories.forEach(category => {
    const categoryItem = createCategoryItem(category);
    if (categoryItem) {
        worldBookCheckboxesContainer.appendChild(categoryItem.header);
        worldBookCheckboxesContainer.appendChild(categoryItem.bookContainer);
    }
});

updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

// 【新增】初始化所有分类标题的背景
const allCategoryHeaders = worldBookCheckboxesContainer.querySelectorAll('.wb-category-header');
allCategoryHeaders.forEach(header => {
    const categoryCheckbox = header.querySelector('input.wb-category-checkbox');
    if (categoryCheckbox) {
        const categoryId = categoryCheckbox.dataset.categoryId;
        const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        const hasCheckedItems = Array.from(allBookCheckboxes).some(cb => cb.checked);

        if (hasCheckedItems) {
            header.classList.add('has-checked-items');
        }
    }
});

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼



// ▼▼▼ 线下世界书填充逻辑（复制线上逻辑并修改容器ID） ▼▼▼
const worldBookCheckboxesContainerOffline = document.getElementById('world-book-checkboxes-container-offline');
worldBookCheckboxesContainerOffline.innerHTML = '';
const linkedIdsOffline = new Set(chat.settings.linkedWorldBookIdsOffline || []);

// 1. 获取所有分类和世界书（线下）
const categoriesOffline = await db.worldBookCategories.toArray();
const booksOffline = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个"虚拟分类"
const hasUncategorizedOffline = booksOffline.some(book => !book.categoryId);
if (hasUncategorizedOffline) {
    categoriesOffline.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组（线下）
const booksByCategoryIdOffline = booksOffline.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 将分类分为"设定集"和"普通分类"（线下）
const settingCategoriesOffline = categoriesOffline.filter(cat => cat.name.includes('的设定集'));
const normalCategoriesOffline = categoriesOffline.filter(cat => !cat.name.includes('的设定集'));

// 辅助函数：创建分类项目（线下版本）
const createCategoryItemOffline = (category) => {
    const booksInCategory = booksByCategoryIdOffline[category.id] || [];
    if (booksInCategory.length === 0) return null;

    const allInCategoryChecked = booksInCategory.every(book => linkedIdsOffline.has(book.id));

    const header = document.createElement('div');
    header.className = 'wb-category-header';
    header.innerHTML = `
        <div class="custom-checkbox ${allInCategoryChecked ? 'checked' : ''}" data-target-checkbox="wb-category-offline-${category.id}">
            <div class="custom-checkbox-circle"></div>
        </div>
        <input type="checkbox" class="wb-category-checkbox" id="wb-category-offline-${category.id}" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
        <span class="arrow">▼</span>
        <span>${category.name}</span>
    `;

    const bookContainer = document.createElement('div');
    bookContainer.className = 'wb-book-container';
    bookContainer.dataset.containerFor = category.id;

    booksInCategory.forEach(book => {
        const isChecked = linkedIdsOffline.has(book.id);
        const label = document.createElement('label');
        if (isChecked) {
            label.classList.add('checked');
        }

        const customCheckbox = document.createElement('div');
        customCheckbox.className = `custom-checkbox ${isChecked ? 'checked' : ''}`;
        customCheckbox.setAttribute('data-target-checkbox', `wb-book-offline-${book.id}`);

        const circle = document.createElement('div');
        circle.className = 'custom-checkbox-circle';
        customCheckbox.appendChild(circle);

        const hiddenCheckbox = document.createElement('input');
        hiddenCheckbox.type = 'checkbox';
        hiddenCheckbox.className = 'wb-book-checkbox';
        hiddenCheckbox.id = `wb-book-offline-${book.id}`;
        hiddenCheckbox.value = book.id;
        hiddenCheckbox.setAttribute('data-parent-category', category.id);
        hiddenCheckbox.checked = isChecked;
        hiddenCheckbox.style.display = 'none';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = book.name;
        nameSpan.style.whiteSpace = 'nowrap';

        label.appendChild(customCheckbox);
        label.appendChild(hiddenCheckbox);
        label.appendChild(nameSpan);
        bookContainer.appendChild(label);
    });

    header.classList.add('collapsed');
    bookContainer.classList.add('collapsed');

    return { header, bookContainer };
};

// 先渲染"设定集"（线下）
if (settingCategoriesOffline.length > 0) {
    const settingHeaderOffline = document.createElement('div');
    settingHeaderOffline.className = 'wb-category-header wb-setting-collection-header';
    settingHeaderOffline.innerHTML = `
        <span class="arrow">▼</span>
        <span>设定集</span>
    `;
    settingHeaderOffline.classList.add('collapsed');

    const settingContentContainerOffline = document.createElement('div');
    settingContentContainerOffline.className = 'wb-book-container wb-setting-collection-container';
    settingContentContainerOffline.dataset.containerFor = 'setting-collection';
    settingContentContainerOffline.classList.add('collapsed');

    settingCategoriesOffline.forEach(category => {
        const categoryItem = createCategoryItemOffline(category);
        if (categoryItem) {
            settingContentContainerOffline.appendChild(categoryItem.header);
            settingContentContainerOffline.appendChild(categoryItem.bookContainer);
        }
    });

    worldBookCheckboxesContainerOffline.appendChild(settingHeaderOffline);
    worldBookCheckboxesContainerOffline.appendChild(settingContentContainerOffline);
}

// 再渲染"普通分类"（线下）
normalCategoriesOffline.forEach(category => {
    const categoryItem = createCategoryItemOffline(category);
    if (categoryItem) {
        worldBookCheckboxesContainerOffline.appendChild(categoryItem.header);
        worldBookCheckboxesContainerOffline.appendChild(categoryItem.bookContainer);
    }
});

// 添加线下世界书的事件处理器 - 防止重复绑定
if (!worldBookCheckboxesContainerOffline.hasOfflineClickEventBound) {
    worldBookCheckboxesContainerOffline.addEventListener('click', (e) => {
    // 处理自定义勾选框点击
    const customCheckbox = e.target.closest('.custom-checkbox');
    if (customCheckbox) {
        // 禁用的复选框不响应点击
        if (customCheckbox.classList.contains('disabled')) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        e.preventDefault();
        e.stopPropagation();
        const targetCheckboxId = customCheckbox.dataset.targetCheckbox;
        const targetCheckbox = document.getElementById(targetCheckboxId);
        if (targetCheckbox) {
            targetCheckbox.checked = !targetCheckbox.checked;
            customCheckbox.classList.toggle('checked', targetCheckbox.checked);
            // 触发change事件
            targetCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    // 处理书籍标签点击（label元素）
    const bookLabel = e.target.closest('.wb-book-container label');
    if (bookLabel && !e.target.closest('.custom-checkbox')) {
        e.preventDefault();
        e.stopPropagation();
        const checkbox = bookLabel.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.checked = !checkbox.checked;
            const customCheckbox = bookLabel.querySelector('.custom-checkbox');
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', checkbox.checked);
            }
            // 添加/移除label的checked类来控制背景色
            bookLabel.classList.toggle('checked', checkbox.checked);
            // 触发change事件
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    const header = e.target.closest('.wb-category-header');
    if (header && !e.target.matches('input[type="checkbox"]') && !e.target.closest('.custom-checkbox')) {
        // 处理"设定集"一级分类的特殊情况
        if (header.classList.contains('wb-setting-collection-header')) {
            const bookContainer = header.nextElementSibling;
            if (bookContainer && bookContainer.classList.contains('wb-setting-collection-container')) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        } else {
            // 处理普通二级分类
            const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
            if (categoryId) {
                const bookContainer = worldBookCheckboxesContainerOffline.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
                if (bookContainer) {
                    header.classList.toggle('collapsed');
                    bookContainer.classList.toggle('collapsed');
                }
            }
        }
    }
});
    worldBookCheckboxesContainerOffline.hasOfflineClickEventBound = true;
}

if (!worldBookCheckboxesContainerOffline.hasOfflineChangeEventBound) {
    // 【新增】辅助函数：更新分类标题背景（线下模式）
    const updateCategoryHeaderBackgroundOffline = (categoryId, container) => {
        const allBookCheckboxes = container.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        const hasCheckedItems = Array.from(allBookCheckboxes).some(cb => cb.checked);

        // 通过找到分类checkbox，然后获取它的父header元素
        const categoryCheckbox = container.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
        if (categoryCheckbox) {
            const categoryHeader = categoryCheckbox.closest('.wb-category-header');
            if (categoryHeader) {
                if (hasCheckedItems) {
                    categoryHeader.classList.add('has-checked-items');
                } else {
                    categoryHeader.classList.remove('has-checked-items');
                }
            }
        }
    };

    worldBookCheckboxesContainerOffline.addEventListener('change', (e) => {
    const target = e.target;

    // 同步自定义勾选框的视觉状态
    const customCheckbox = worldBookCheckboxesContainerOffline.querySelector(`[data-target-checkbox="${target.id}"]`);
    if (customCheckbox) {
        customCheckbox.classList.toggle('checked', target.checked);
    }

    // 如果点击的是分类的"全选"复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const allBookCheckboxes = worldBookCheckboxesContainerOffline.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        const isChecked = target.checked;
        allBookCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            // 同步对应的自定义勾选框状态
            const customCheckbox = worldBookCheckboxesContainerOffline.querySelector(`[data-target-checkbox="${cb.id}"]`);
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', isChecked);
            }
            // 同步label的背景色
            const label = cb.closest('label');
            if (label && label.closest('.wb-book-container')) {
                label.classList.toggle('checked', isChecked);
            }
        });
        // 【新增】更新分类标题背景
        updateCategoryHeaderBackgroundOffline(categoryId, worldBookCheckboxesContainerOffline);
    }

    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        // 同步当前书籍label的背景色
        const label = target.closest('label');
        if (label && label.closest('.wb-book-container')) {
            label.classList.toggle('checked', target.checked);
        }

        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查it是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainerOffline.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainerOffline.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类"全选"复选框的状态
            if (categoryCheckbox) {
                categoryCheckbox.checked = allChecked;
                // 同步分类的自定义勾选框状态
                const categorycustomCheckbox = worldBookCheckboxesContainerOffline.querySelector(`[data-target-checkbox="${categoryCheckbox.id}"]`);
                if (categorycustomCheckbox) {
                    categorycustomCheckbox.classList.toggle('checked', allChecked);
                }
            }
            // 【新增】更新分类标题背景
            updateCategoryHeaderBackgroundOffline(categoryId, worldBookCheckboxesContainerOffline);
        }
    }

    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplayOffline();
});
    worldBookCheckboxesContainerOffline.hasOfflineChangeEventBound = true;
}
// ▲▲▲ 线下世界书填充逻辑结束 ▲▲▲

// 绑定线下世界书下拉栏点击事件
const worldBookSelectBoxOffline = document.querySelector('#world-book-link-group-offline .select-box');
if (worldBookSelectBoxOffline && !worldBookSelectBoxOffline.hasOfflineEventBound) {
    worldBookSelectBoxOffline.addEventListener('click', (e) => {
        e.stopPropagation();
        worldBookCheckboxesContainerOffline.classList.toggle('visible');
        worldBookSelectBoxOffline.classList.toggle('expanded');
    });
    worldBookSelectBoxOffline.hasOfflineEventBound = true;
}

updateWorldBookSelectionDisplayOffline(); // 更新顶部的已选数量显示

// 【新增】初始化所有分类标题的背景（线下模式）
const allCategoryHeadersOffline = worldBookCheckboxesContainerOffline.querySelectorAll('.wb-category-header');
allCategoryHeadersOffline.forEach(header => {
    const categoryCheckbox = header.querySelector('input.wb-category-checkbox');
    if (categoryCheckbox) {
        const categoryId = categoryCheckbox.dataset.categoryId;
        const allBookCheckboxes = worldBookCheckboxesContainerOffline.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        const hasCheckedItems = Array.from(allBookCheckboxes).some(cb => cb.checked);

        if (hasCheckedItems) {
            header.classList.add('has-checked-items');
        }
    }
});

    // 【新增】加载预设下拉框 - 分别加载线下模式和监控模式
    const presetSelectOffline = document.getElementById('preset-select-offline');
    const presetSelectMonitor = document.getElementById('preset-select-monitor');
    const presets = await db.promptPresets.toArray();

    // 加载线下模式预设下拉框
    presetSelectOffline.innerHTML = '<option value="">-- 不使用预设 --</option>';
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if (chat.presetIdOffline === preset.id) {
            option.selected = true;
        }
        presetSelectOffline.appendChild(option);
    });

    // 加载监控模式预设下拉框
    presetSelectMonitor.innerHTML = '<option value="">-- 不使用预设 --</option>';
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if (chat.presetIdMonitor === preset.id) {
            option.selected = true;
        }
        presetSelectMonitor.appendChild(option);
    });

    // 加载并更新所有预览相关控件 (主题选择器已删除)
    const fontSizeSlider = document.getElementById('font-size-slider');
    // 【核心修改】从全局设置读取字体大小
    fontSizeSlider.value = state.globalSettings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // 初始化滑块进度颜色
    updateSliderProgress(fontSizeSlider);
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview();

    // ▼▼▼ 加载NAI出图设置的显示/隐藏 ▼▼▼
    const naiCharacterSettingsGroup = document.getElementById('nai-character-settings-group');
    const groupNaiSettingsGroup = document.getElementById('group-nai-settings-group');
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';

    if (!isGroup && novelaiEnabled) {
        naiCharacterSettingsGroup.style.display = 'block';
        console.log('📖 单聊：显示NAI出图设置');
    } else {
        naiCharacterSettingsGroup.style.display = 'none';
    }

    if (isGroup && novelaiEnabled) {
        groupNaiSettingsGroup.style.display = 'block';
        console.log('📖 群聊：显示NAI出图设置');
    } else {
        groupNaiSettingsGroup.style.display = 'none';
    }
    // ▲▲▲ NAI出图设置加载结束 ▲▲▲

    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重构】★★★
        // 显示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

function openMemberEditor(memberId) {
    editingMemberId = memberId;
    const chat = state.chats[state.activeChatId];
    const member = chat.members.find(m => m.id === memberId);
    document.getElementById('member-name-input').value = member.groupNickname;
    document.getElementById('member-persona-input').value = member.persona;
    document.getElementById('member-avatar-preview').src = member.avatar;
    // 【新增】只在旁观群聊时显示主要角色开关
    const mainRoleSwitchGroup = document.getElementById('main-role-switch-group');
    const mainRoleCheckbox = document.getElementById('member-is-main-role-checkbox');
    if (chat.isSpectator) {
        mainRoleSwitchGroup.style.display = 'block';
        mainRoleCheckbox.checked = member.isMainRole || false;
    } else {
        mainRoleSwitchGroup.style.display = 'none';
    }
    document.getElementById('member-settings-modal').classList.add('visible');
}
            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
    if (!editingMemberId) return;
    const chat = state.chats[state.activeChatId];
    const member = chat.members.find(m => m.id === editingMemberId);

    // ★★★【核心重构】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵称
    member.persona = document.getElementById('member-persona-input').value;
    member.avatar = document.getElementById('member-avatar-preview').src;
    // 【新增】保存主要角色标记（仅旁观群聊）
    if (chat.isSpectator) {
        member.isMainRole = document.getElementById('member-is-main-role-checkbox').checked;
    }

    // 【新增】保存群聊数据到数据库
    await db.chats.put(chat);

    renderGroupMemberSettings(chat.members);
    document.getElementById('member-settings-modal').classList.remove('visible');
});
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    // 【修复1】保存当前的"正在输入中..."状态
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const isCurrentlyTyping = chat.isAwaitingReply || (chatHeaderTitle && chatHeaderTitle.classList.contains('typing-status'));

    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('备注名/群名不能为空！');
    chat.name = newName;

    // ▼▼▼ 在这里粘贴新代码（保存逻辑） ▼▼▼
    chat.originalName = document.getElementById('chat-original-name-input').value.trim(); // 保存真实姓名

    // ▼▼▼ 在这里开始修改 ▼▼▼
    const oldRemark = chat.remark || ''; // 1. 获取旧的用户备注
    chat.remark = document.getElementById('chat-remark-input').value.trim(); // 2. 保存新的用户备注
    const newRemark = chat.remark; // 3. 存储新备注以供比较
    // ▲▲▲ 修改结束 ▲▲▲

    chat.settings.theme = 'default'; // 固定使用默认主题

    // 【核心修改1】将字体大小保存到全局设置
    const newFontSize = parseInt(document.getElementById('font-size-slider').value);
    const oldGlobalFontSize = state.globalSettings.fontSize;
    state.globalSettings.fontSize = newFontSize;
    await db.globalSettings.put(state.globalSettings); // 保存全局设置

    // 【核心修改2】只有全局字体大小改变时，才更新所有聊天
    if (oldGlobalFontSize !== newFontSize) {
        const chatsToUpdate = [];
        for (const chatId in state.chats) {
            state.chats[chatId].settings.fontSize = newFontSize;
            chatsToUpdate.push(state.chats[chatId]);
        }
        // 批量更新所有聊天的字体大小
        await db.chats.bulkPut(chatsToUpdate);
    }

    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    // 保存线下世界书选择
    const checkedBooksOffline = document.querySelectorAll('#world-book-checkboxes-container-offline input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIdsOffline = Array.from(checkedBooksOffline).map(cb => cb.value);

    // 【新增】保存预设选择 - 分别保存线下模式和监控模式的预设
    const selectedPresetIdOffline = document.getElementById('preset-select-offline').value;
    const selectedPresetIdMonitor = document.getElementById('preset-select-monitor').value;
    chat.presetIdOffline = selectedPresetIdOffline ? parseInt(selectedPresetIdOffline) : null;
    chat.presetIdMonitor = selectedPresetIdMonitor ? parseInt(selectedPresetIdMonitor) : null;

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
            chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
            const selectedGroupId = document.getElementById('assign-group-select').value;
            chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
            // ▼▼▼ 【Minimax TTS】保存minimaxVoiceId ▼▼▼
            chat.settings.minimaxVoiceId = document.getElementById('minimax-voice-id-input').value.trim();

            // 🔥【新增】保存语速和语言设置
            chat.settings.minimaxVoiceSpeed = parseFloat(document.getElementById('minimax-voice-speed-input').value) || 1.0;
            chat.settings.minimaxLanguage = document.getElementById('minimax-language-input').value;
            // ▲▲▲ 【Minimax TTS】保存minimaxVoiceId ▲▲▲
        }

        // 【核心修改】保存新的记忆锚点
        chat.settings.memoryAnchor = parseInt(document.getElementById('memory-anchor-input').value) || 0;
        
        // 【全新添加】保存总结保留条数
        chat.settings.summarizeReserveCount = parseInt(document.getElementById('summarize-reserve-input').value) || 100;

        chat.settings.crossChatMemory = document.getElementById('cross-chat-memory-switch').checked;

        // 【新增】保存后台活动设置
        chat.settings.backgroundActivityEnabled = document.getElementById('background-activity-enabled-switch').checked;
        chat.settings.backgroundActivityInterval = parseInt(document.getElementById('background-activity-interval-input').value) || 60;
        if (chat.settings.backgroundActivityInterval < 30) {
            chat.settings.backgroundActivityInterval = 30; // 强制最小间隔为30秒
        }
        console.log(`💾 保存角色 "${chat.name}" 后台活动设置:`);
        console.log(`  - 开关状态: ${chat.settings.backgroundActivityEnabled}`);
        console.log(`  - 检测间隔: ${chat.settings.backgroundActivityInterval}秒`);

        // 【新增】保存朋友圈可见性设置
        chat.settings.momentsVisibilityEnabled = document.getElementById('moments-visibility-switch').checked;
        // 从列表中的灰色背景项读取选中的角色ID
        const selectedItems = document.querySelectorAll('#moments-characters-list > div[style*="rgb(232, 232, 232)"]');
        chat.settings.visibleCharacterIds = Array.from(selectedItems).map(item => item.dataset.characterId);
        chat.settings.customRelationship = document.getElementById('custom-relationship-input').value.trim();
        console.log(`💾 保存角色 "${chat.name}" 朋友圈可见性设置:`);
        console.log(`  - 开关状态: ${chat.settings.momentsVisibilityEnabled}`);
        console.log(`  - 可见角色: ${chat.settings.visibleCharacterIds.join(', ')}`);
        console.log(`  - 自定义关系: ${chat.settings.customRelationship}`);


        // 【修改】支持小数，并设置最小间隔为0.1小时
    const activeReplyIntervalInput = parseFloat(document.getElementById('active-reply-interval').value) || 0;
    if (activeReplyIntervalInput > 0 && activeReplyIntervalInput < 0.1) {
        chat.settings.activeReplyInterval = 0.1; // 强制最小间隔为0.1小时
    } else {
        chat.settings.activeReplyInterval = activeReplyIntervalInput;
    }
    // 【优化】立刻关闭模态框，不让用户等待
    chatSettingsModal.classList.remove('visible');
    // ▼▼▼ 在这里粘贴新代码 (就在 await db.chats.put(chat); 这一行 *之前*) ▼▼▼
    // 【新增】检查用户备注是否变更，并注入系统消息
    if (!chat.isGroup && newRemark !== oldRemark) {
        // AI的人设里，chat.name是它的名字。
        // oldRemark是用户之前对AI的备注，如果为空，则使用AI的名字
        // newRemark是用户新设置的备注，如果为空，也使用AI的名字
        const oldDisplayName = oldRemark || chat.name;
        const newDisplayName = newRemark || chat.name;

        // 1. 创建对用户可见的系统消息
        const remarkChangeMessage = {
            role: 'system',
            type: 'pat_message', // 使用居中灰色系统消息样式
            content: `你将“${oldDisplayName}”的备注修改为“${newDisplayName}”`,
            timestamp: Date.now()
        };
        chat.history.push(remarkChangeMessage);

        // 2. 创建对AI可见、对用户隐藏的上下文指令
        const hiddenInstruction = {
            role: 'system',
            content: `[系统提示：用户刚刚把你的备注从“${oldDisplayName}”修改为了“${newDisplayName}”。你的备注名现在是“${newDisplayName}”。]`,
            timestamp: Date.now() + 1, // 确保时间戳在后
            isHidden: true
        };
        chat.history.push(hiddenInstruction);
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    // 【优化】后台异步处理剩余的数据库操作和更新
    (async () => {
        await db.chats.put(chat);
        console.log(`[数据库保存完成] 角色"${chat.name}"的备注已保存到数据库:`, chat.remark);

        // 【新增】保存设置后更新Token计算显示
        await updateMemoryStats(state.activeChatId);

        applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');

        // 【新增】检查是否需要启动/停止后台模拟器
        const allChats = Object.values(state.chats);
        const hasAnyBackgroundEnabled = allChats.some(c => !c.isGroup && c.settings?.backgroundActivityEnabled);

        console.log(`🔄 检查模拟器状态...`);
        console.log(`  - 全局开关: ${state.globalSettings.enableBackgroundActivity}`);
        console.log(`  - 有角色开启: ${hasAnyBackgroundEnabled}`);
        console.log(`  - 当前模拟器ID: ${simulationIntervalId}`);

        if (hasAnyBackgroundEnabled || state.globalSettings.enableBackgroundActivity) {
            // 如果有任何角色开启了后台活动，或全局开关开启，则启动模拟器
            if (!simulationIntervalId) {
                console.log(`✅ 需要启动模拟器`);
                startBackgroundSimulation();
            } else {
                console.log(`✅ 模拟器已在运行，无需重启`);
            }
        } else {
            // 如果所有角色都关闭了后台活动，且全局开关也关闭，则停止模拟器
            console.log(`❌ 需要停止模拟器`);
            stopBackgroundSimulation();
        }

        renderChatInterface(state.activeChatId);
        renderChatList();

        // 【修复1】在renderChatInterface后恢复"正在输入中..."状态
        if (isCurrentlyTyping) {
            const updatedChatHeaderTitle = document.getElementById('chat-header-title');
            if (updatedChatHeaderTitle) {
                if (chat.isGroup) {
                    updatedChatHeaderTitle.textContent = '正在输入中...';
                } else {
                    updatedChatHeaderTitle.textContent = '对方正在输入...';
                }
                updatedChatHeaderTitle.classList.add('typing-status');
            }
        }
    })();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            
            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', (e) => { 
                e.stopPropagation(); 
                closePlusPanel(); 
                renderStickerPanel(); 
                stickerPanel.classList.add('visible'); 
            });
            
            // 点击面板外区域关闭表情面板
            document.addEventListener('click', (e) => {
                if (stickerPanel.classList.contains('visible') && 
                    !stickerPanel.contains(e.target) && 
                    !e.target.closest('.modal') && 
                    !e.target.closest('#custom-modal-overlay') &&
                    e.target.id !== 'sticker-upload-input') {
                    stickerPanel.classList.remove('visible');
                }
            });
            document.getElementById('add-sticker-btn').addEventListener('click', async () => { const url = await showCustomPrompt("添加表情(URL)", "请输入表情包的图片URL"); if (!url || !url.trim().startsWith('http')) return url && alert("请输入有效的URL (以http开头)"); const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：开心、疑惑)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: url.trim(), name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("表情名不能为空！"); });
            document.getElementById('upload-sticker-btn').addEventListener('click', (e) => { e.stopPropagation(); document.getElementById('sticker-upload-input').click(); });
            document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = async () => {
                    const base64Url = reader.result;
                    const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：好耶、疑惑)");
                    if (name && name.trim()) {
                        const id = 'sticker_' + Date.now();
                        const newSticker = {
                            id: id,
                            url: base64Url,
                            name: name.trim()
                        };

                        // 【新增】自动转换为 Blob 并缓存
                        try {
                            const blob = await convertToBlob(base64Url);
                            newSticker.blobData = blob;
                            console.log(`✅ 表情包 "${name}" 已转为 Blob，大小: ${blob.size} bytes`);
                        } catch (e) {
                            console.warn(`⚠️ Blob 转换失败，将使用原始 URL: ${e.message}`);
                        }

                        await db.userStickers.add(newSticker);
                        state.userStickers.push(newSticker);
                        renderStickerPanel();
                    } else if (name !== null) alert("表情名不能为空！");
                };
                event.target.value = null;
            });
            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            // ▼▼▼ 请用这段【新代码】替换旧的 'image-upload-input' 事件监听器 ▼▼▼
document.getElementById('image-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file || !state.activeChatId) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        const base64Url = e.target.result;
        const chat = state.chats[state.activeChatId];
        const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();

        // 【核心修复】上传并发送图片后，关闭功能面板
        closePlusPanel();
    };
    reader.readAsDataURL(file);
    event.target.value = null;
});
// ▲▲▲ 替换结束 ▲▲▲           
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; closePlusPanel(); const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
// ▼▼▼ 请用这段【新代码】替换旧的 'send-photo-btn' 事件监听器 ▼▼▼
document.getElementById('send-photo-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
    if (description && description.trim()) {
        const chat = state.chats[state.activeChatId];
        const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();

        // 【核心修复】在这里调用关闭面板的函数
        closePlusPanel();
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】外卖请求功能事件绑定 (已重构) ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');

// 1. 创建一个可复用的函数来处理外卖请求的点击
function handleWaimaiRequest() {
    waimaiModal.classList.add('visible');
    closePlusPanel(); // 打开弹窗后，立刻关闭功能面板
}

// 2. 让单聊和群聊的按钮都调用这个新函数
document.getElementById('send-waimai-request-btn').addEventListener('click', handleWaimaiRequest);
document.getElementById('send-waimai-request-btn-group').addEventListener('click', handleWaimaiRequest);

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('请输入商品信息！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('请输入有效的代付金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    // 【核心修正】在这里获取用户自己的昵称
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
            document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // ▼▼▼ 从这里开始替换 ▼▼▼
        
        // 1. 创建一个包含所有待删除消息时间戳的完整集合
        const timestampsToDelete = new Set(selectedMessages);

        // 2. 遍历用户选择的消息，查找需要联动删除的隐藏消息
        for (const timestamp of selectedMessages) {
            const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (msgIndex === -1) continue;

            const triggerMsg = chat.history[msgIndex];

            // 联动删除 "拍一拍" 相关的两条隐藏消息
            if (triggerMsg.type === 'pat_message' && triggerMsg.content.includes('拍了拍')) {
                // 检查后面紧邻的两条消息是否是我们的目标
                const hiddenMsg1 = chat.history[msgIndex + 1];
                const hiddenMsg2 = chat.history[msgIndex + 2];
                // 检查系统提示
                if (hiddenMsg1 && hiddenMsg1.isHidden && hiddenMsg1.role === 'system' && hiddenMsg1.content.includes('用户刚刚拍了拍你')) {
                    timestampsToDelete.add(hiddenMsg1.timestamp);
                }
                // 检查隐藏的用户消息
                if (hiddenMsg2 && hiddenMsg2.isHidden && hiddenMsg2.role === 'user' && hiddenMsg2.content === '你被拍了一下') {
                    timestampsToDelete.add(hiddenMsg2.timestamp);
                }
            }

            // 联动删除 "通话结束" 相关的两条隐藏消息
            if (triggerMsg.content && typeof triggerMsg.content === 'string' && triggerMsg.content.startsWith('通话结束，时长')) {
                 // 检查后面紧邻的两条消息
                const hiddenMsg1 = chat.history[msgIndex + 1];
                const hiddenMsg2 = chat.history[msgIndex + 2];
                // 检查通话汇报指令
                if (hiddenMsg1 && hiddenMsg1.isHidden && hiddenMsg1.role === 'system' && hiddenMsg1.content.includes('视频通话刚刚结束')) {
                    timestampsToDelete.add(hiddenMsg1.timestamp);
                }
                // 检查隐藏的用户消息
                if (hiddenMsg2 && hiddenMsg2.isHidden && hiddenMsg2.role === 'user' && hiddenMsg2.content === '（视频通话已结束，请根据视频通话内容继续聊天）') {
                    timestampsToDelete.add(hiddenMsg2.timestamp);
                }
            }
        }

        // 3. 使用包含了所有（可见与隐藏）待删除消息的完整集合，来执行最终的过滤
        const deletedMessages = chat.history.filter(msg => timestampsToDelete.has(msg.timestamp));
        chat.history = chat.history.filter(msg => !timestampsToDelete.has(msg.timestamp));

        // 【新增】检查删除的消息中是否有状态更新，如果有就回退状态
        handleStatusRollbackOnDelete(chat, deletedMessages);

        // 4. 【已修改】直接将更新后的chat对象存回数据库
        await db.chats.put(chat);

        // 5. 最后才更新UI
        renderChatInterface(state.activeChatId);

        // ▲▲▲ 替换到这里结束 ▲▲▲
    }
});

            const fontUrlInput = document.getElementById('font-url-input');
            // 优化字体预览：添加防抖功能，避免频繁调用
            let fontPreviewTimeout;
            fontUrlInput.addEventListener('input', () => {
                clearTimeout(fontPreviewTimeout);
                fontPreviewTimeout = setTimeout(() => {
                    applyCustomFont(fontUrlInput.value.trim(), true);
                }, 300); // 300ms 防抖延迟
            });
            document.getElementById('save-font-btn').addEventListener('click', async () => {
                const newFontUrl = fontUrlInput.value.trim();
                if (!newFontUrl) { alert("请输入有效的字体URL。"); return; }
                applyCustomFont(newFontUrl, false);
                state.globalSettings.fontUrl = newFontUrl;
                await db.globalSettings.put(state.globalSettings);
                alert('字体已保存并应用！');
            });
            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => {
                // 【新增】退出好友动态时清空新评论标记
                state.newCommentPostIds.clear();
                switchToChatListView('messages-view');
            });
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 【修正后】的“说说”按钮事件 ▼▼▼
document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
    // 1. 重置并获取模态框
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“说说”模式
    modal.dataset.mode = 'shuoshuo';
    
    // 3. 隐藏与图片/文字图相关的部分
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    
    // 4. 修改主输入框的提示语，使其更符合“说说”的场景
    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
    
    // 5. 准备并显示模态框
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
    }
    modal.classList.add('visible');
});

// ▼▼▼ 【修正后】的“动态”（图片）按钮事件 ▼▼▼
document.getElementById('create-post-btn').addEventListener('click', async () => {
    // 1. 重置并获取模态框
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“复杂动态”模式
    modal.dataset.mode = 'complex';
    
// 3. 确保与图片/文字图相关的部分是可见的
modal.querySelector('.post-mode-switcher').style.display = 'flex';
// 显式激活“上传图片”模式...
modal.querySelector('#image-mode-content').classList.add('active');
// ...同时确保“文字图”模式是隐藏的
modal.querySelector('#text-image-mode-content').classList.remove('active');
    
    // 4. 恢复主输入框的默认提示语
    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';

    // 5. 准备并显示模态框（与“说说”按钮的逻辑相同）
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
    }
    modal.classList.add('visible');
});
            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上传成功！');
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

// --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到图片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '删除照片',
            '确定要删除这张照片吗？此操作不可恢复。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已删除。');
        }
    } 
    else if (photoThumb) {
        // 这就是恢复的图片点击放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢复图片查看器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢复键盘左右箭头和ESC键的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 【最终修正版】的“发布”按钮事件，已修复权限漏洞 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;
    
    // --- 1. 获取通用的可见性设置 ---
    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    
    if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
    }

    let newPost = {};
    const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',
        // 【重要】在这里就把权限信息存好
        visibleGroupIds: visibleGroupIds,
    };

    // --- 2. 根据模式构建不同的 post 对象 ---
    if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
            alert('说说内容不能为空哦！');
            return;
        }
        newPost = {
            ...basePostData,
            type: 'shuoshuo',
            content: content,
        };

    } else { // 处理 'complex' 模式 (图片/文字图)
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
            const imageUrl = document.getElementById('post-image-preview').src;
            const imageDescription = document.getElementById('post-image-description').value.trim();
            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                alert('请先添加一张图片再发布动态哦！');
                return;
            }
            if (!imageDescription) {
                alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'image_post',
                publicText: publicText,
                imageUrl: imageUrl,
                imageDescription: imageDescription,
            };
        } else { // 文字图模式
            const hiddenText = document.getElementById('post-hidden-text').value.trim();
            if (!hiddenText) {
                alert('请输入文字图描述！');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'text_image',
                publicText: publicText,
                hiddenContent: hiddenText,
            };
        }
    }

    // --- 3. 保存到数据库 ---
    const newPostId = await db.qzonePosts.add(newPost);
    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（无文字内容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

    // --- 4. 【核心修正】带有权限检查的通知循环 ---
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue; // 跳过群聊

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;

        // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
        if (!postVisibleGroups || postVisibleGroups.length === 0) {
            shouldNotify = true;
        } 
        // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
            shouldNotify = true;
        }

        // 只有满足条件的角色才会被通知
        if (shouldNotify) {
            const historyMessage = {
                role: 'system',
                content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。你现在可以对这条动态进行评论了。]`,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
        }
    }
    // --- 修正结束 ---

    await renderQzonePosts();
    modal.classList.remove('visible');
    alert('动态发布成功！');
});

// ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 绑定所有滑动事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// --- 绑定所有点击事件 ---
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;

    // --- 新增：处理评论删除按钮 ---
    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;

        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;

        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;

        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm(
            '删除评论',
            `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`,
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 从数组中移除该评论
            post.comments.splice(commentIndex, 1);
            // 更新数据库
            await db.qzonePosts.update(postId, { comments: post.comments });
            // 重新渲染列表以反映更改
            await renderQzonePosts();
            alert('评论已删除。');
        }
        return; // 处理完后直接返回
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) {
            showPostActions(parseInt(container.dataset.postId));
        }
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-container');
        if (!container) return;
        
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;

        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });

        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
        
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) {
                         await db.chats.put(chat);
                     }
                 }
                 await renderQzonePosts();
                 alert('动态已删除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    // ▼▼▼ 请用这个【新版本】替换旧的 sendBtn 判断逻辑 ▼▼▼
const sendBtn = target.closest('.comment-send-btn');
if (sendBtn) {
    // 使用一个立即执行的异步函数来处理整个流程
    (async () => {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;

        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();

        if (!commentText || isNaN(postId)) return;

        const post = await db.qzonePosts.get(postId);
        if (!post) return;

        // 1. 添加用户的评论
        if (!post.comments) post.comments = [];
        // 【修改】添加replyTo信息，用于区分是直接评论还是回复某人
        // 【修复】只有在"回复提示框"可见时，才认为用户主动选择了回复某人
        const replyToPromptEl = postContainer.querySelector('.comment-reply-to');
        const isReplyingToSomeone = replyToPromptEl && replyToPromptEl.style.display === 'flex';
        const replyingToCommenter = isReplyingToSomeone ? postContainer.dataset.replyingToCommenter : null;
        const replyingToTimestamp = isReplyingToSomeone ? postContainer.dataset.replyingToTimestamp : null;  // 【新增】获取具体回复的那条评论的时间戳

        const newUserComment = {
            commenterName: state.qzoneSettings.nickname,
            text: commentText,
            timestamp: Date.now(),
            replyTo: replyingToCommenter || null
        };

        // 【核心修改】使用时间戳精准定位被回复的那条评论
        if (replyingToCommenter && replyingToTimestamp) {
            console.log('[调试] 准备插入用户评论');
            console.log('[调试] replyingToCommenter:', replyingToCommenter);
            console.log('[调试] replyingToTimestamp:', replyingToTimestamp, typeof replyingToTimestamp);
            console.log('[调试] 当前所有评论:', post.comments.map((c, i) => `[${i}] ${c.commenterName} (${c.timestamp})`));

            let insertIndex = -1;
            // 找到具体那条被回复的评论（通过时间戳），直接插在它后面
            for (let i = 0; i < post.comments.length; i++) {
                console.log(`[调试] 检查第${i}条: ${post.comments[i].timestamp} === ${parseInt(replyingToTimestamp)} ? ${post.comments[i].timestamp === parseInt(replyingToTimestamp)}`);
                if (post.comments[i].timestamp === parseInt(replyingToTimestamp)) {
                    insertIndex = i + 1;
                    console.log(`[调试] 找到了！将插入到位置 ${insertIndex}`);
                    break;
                }
            }
            if (insertIndex !== -1) {
                post.comments.splice(insertIndex, 0, newUserComment);
                console.log('[调试] 插入成功，新的评论顺序:', post.comments.map(c => c.commenterName));
            } else {
                console.log('[调试] 没找到目标评论，追加到末尾');
                post.comments.push(newUserComment);
            }
        } else {
            // 如果没有 replyTo，直接追加到末尾
            post.comments.push(newUserComment);
        }

        // 2. 保存用户评论到数据库
        await db.qzonePosts.update(postId, { comments: post.comments });
        commentInput.value = '';
        // 【修改】清除回复状态
        postContainer.dataset.replyingToCommenter = null;
        postContainer.dataset.replyingToTimestamp = null;  // 【新增】清除时间戳
        const replyToDiv = postContainer.querySelector('.comment-reply-to');
        if (replyToDiv) replyToDiv.style.display = 'none';

        // 3. 判断是否需要AI回复
        const needsAiReply = post.authorId !== 'user';

        // 4. 刷新界面（如果需要AI回复，此时会显示加载动画）
        await renderQzonePosts(needsAiReply ? postId : null);

        // 5. 如果需要，则调用API并等待其完成
        if (needsAiReply) {
            await triggerAiPostReply(post, commentText);

            // 6. 保存AI的新评论到数据库
            await db.qzonePosts.update(postId, { comments: post.comments });

            // 7. 再次刷新界面，显示AI的回复并移除加载动画
            await renderQzonePosts();
        }
    })();
    return; // 结束事件处理
}
// ▲▲▲ 替换结束 ▲▲▲
});
// ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

            // 绑定动态页和收藏页的返回按钮
            document.getElementById('qzone-back-btn').addEventListener('click', () => {
                // 【新增】退出好友动态时清空新评论标记
                state.newCommentPostIds.clear();
                switchToChatListView('messages-view');
            });
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

            // 收藏页搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();

                // 控制清除按钮的显示/隐藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    // 如果搜索框为空，根据选中的角色显示收藏
                    const activeChatBtn = document.querySelector('.char-btn-active');
                    if (activeChatBtn && activeChatBtn.dataset.chatId !== 'all') {
                        const filtered = allFavoriteItems.filter(item => item.chatId === activeChatBtn.dataset.chatId);
                        displayFilteredFavorites(filtered);
                    } else {
                        displayFilteredFavorites(allFavoriteItems);
                    }
                    return;
                }

                // 【修改】筛选逻辑，加入角色选择器的影响
                const activeChatBtn = document.querySelector('.char-btn-active');
                const selectedChatId = activeChatBtn?.dataset.chatId;

                const filteredItems = allFavoriteItems.filter(item => {
                    // 如果选中了某个角色（非"全部收藏"），则只搜索该角色的收藏
                    // 【核心修复】重写角色过滤逻辑
                    if (selectedChatId && selectedChatId !== 'all') {
                        // 1. 如果是聊天消息，检查 item.chatId
                        if (item.type === 'chat_message' && item.chatId !== selectedChatId) {
                            return false; // 过滤掉不匹配的聊天消息
                        }
                        // 2. 如果是QZone动态，检查 item.content.authorId
                        if (item.type === 'qzone_post' && (!item.content || item.content.authorId !== selectedChatId)) {
                            return false; // 过滤掉不匹配的动态
                        }
                        // (如果两个if都没命中，说明是匹配的，继续往下走到搜索逻辑)
                    }

                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }

                    // 同时搜索内容和作者，并且不区分大小写
                    return contentToSearch.toLowerCase().includes(searchTerm) ||
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按钮的点击事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                // 【修改】根据选中的角色显示收藏
                const activeChatBtn = document.querySelector('.char-btn-active');
                if (activeChatBtn && activeChatBtn.dataset.chatId !== 'all') {
                    const filtered = allFavoriteItems.filter(item => item.chatId === activeChatBtn.dataset.chatId);
                    displayFilteredFavorites(filtered);
                } else {
                    displayFilteredFavorites(allFavoriteItems);
                }
                searchInput.focus();
            });

            // ▲▲▲ 代码检查结束 ▲▲▲

            // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
            
            // 为聊天界面的批量收藏按钮绑定事件
                        // 为聊天界面的批量收藏按钮绑定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引进行查询
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 这是收藏操作发生的时间
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                } else {
                    await showCustomAlert('提示', '选中的消息均已收藏过。');
                }
                
                exitSelectionMode();
            });

            // 收藏页面的"编辑"按钮事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
            const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 进入编辑模式 ---
                    // 【修改】显示✓图标（确认icon）
                    favoritesEditBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                    favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                    mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                } else {
                    // --- 退出编辑模式 ---
                    // 【修改】恢复为原始的编辑铅笔 SVG 按钮
                    favoritesEditBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>';
                    favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                    mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                    // 退出时清空所有选择
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                }
            });

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏列表的点击选择事件 (事件委托)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完就退出，不继续执行选择逻辑
    }
    
    // 如果不在选择模式，则不执行后续的选择操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的选择逻辑，保持不变 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切换选择状态
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部删除按钮的计数
    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
});

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏页面批量删除按钮事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除', 
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');
        
        // 【核心修正1】从前端缓存中也移除被删除的项
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最后，再退出编辑模式
        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
    }
});

// ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
// 【修改】检查全局开关或任意角色的独立开关
const hasAnyBackgroundEnabled = Object.values(state.chats).some(chat => !chat.isGroup && chat.settings?.backgroundActivityEnabled);
if (state.globalSettings.enableBackgroundActivity || hasAnyBackgroundEnabled) {
    startBackgroundSimulation();
    console.log("后台活动模拟已自动启动。");
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

// --- 统一处理所有影响预览的控件的事件 ---

// 1. 监听主题选择 (已删除)

// 2. 监听字体大小滑块
const fontSizeSlider = document.getElementById('font-size-slider');

// 更新滑块进度的函数
function updateSliderProgress(slider) {
    const progress = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
    slider.style.background = `linear-gradient(to right, #000 0%, #000 ${progress}%, #ddd ${progress}%, #ddd 100%)`;
}

fontSizeSlider.addEventListener('input', () => {
    // a. 实时更新数值显示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新滑块进度颜色
    updateSliderProgress(fontSizeSlider);
    // c. 更新预览
    updateSettingsPreview();
});

// 3. 监听自定义CSS输入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 【全新】监听CSS展开编辑器的实时输入，并同步到预览
    const expandedCssEditor = document.querySelector('#css-editor-expanded .expanded-textarea');
    if (expandedCssEditor) {
        expandedCssEditor.addEventListener('input', () => {
            // 1. 将大编辑器的内容实时同步回小输入框，确保保存功能正常
            customCssInputForPreview.value = expandedCssEditor.value;
            // 2. 手动调用预览更新函数
            updateSettingsPreview();
        });
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

// 4. 监听重置按钮 (已删除)

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天设置里的分组列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次点击以重新打开
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
// 消息操作菜单的按钮事件（取消按钮已移除，通过点击外部关闭）
// ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在这里添加新代码 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// 【全新】为“向下全选”按钮绑定点击事件
document.getElementById('selection-select-below-btn').addEventListener('click', handleSelectBelow);
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修复】在关闭菜单前，先捕获时间戳
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕获到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 动态操作菜单的按钮事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然后再打开成员管理屏幕
    openMemberManagementScreen();
});

// ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【已恢复】移除成员的事件
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢复】从好友列表添加的事件
    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

// 绑定单聊和群聊的发起按钮
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// ▼▼▼ 【新增】语音通话按钮事件绑定 ▼▼▼
document.getElementById('voice-call-btn').addEventListener('click', handleInitiateVoiceCall);
document.getElementById('group-voice-call-btn').addEventListener('click', handleInitiateVoiceCall);
// ▲▲▲ 语音通话按钮事件绑定结束 ▲▲▲

// 绑定"挂断"按钮
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// ▼▼▼ 【新增】语音通话挂断按钮 ▼▼▼
document.getElementById('voice-hang-up-btn').addEventListener('click', endVoiceCall);
// ▲▲▲ 语音通话挂断按钮结束 ▲▲▲

// 绑定"取消呼叫"按钮
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    if (voiceCallState.isAwaitingResponse) {
        voiceCallState.isAwaitingResponse = false;
    } else {
        videoCallState.isAwaitingResponse = false;
    }
    showScreen('chat-interface-screen');
});

// 【全新】绑定"加入通话"按钮
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 【新增】语音通话"加入通话"按钮 ▼▼▼
document.getElementById('voice-join-call-btn').addEventListener('click', handleUserVoiceJoinCall);
// ▲▲▲ 语音通话"加入通话"按钮结束 ▲▲▲

// ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的"拒绝"按钮
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();

    // 【新增】判断是视频通话还是语音通话
    const isVoiceCall = voiceCallState.isAwaitingResponse;
    const callState = isVoiceCall ? voiceCallState : videoCallState;
    const callType = isVoiceCall ? '语音通话' : '视频通话';

    const chat = state.chats[callState.activeChatId];
    if (!chat) return;

    if (callState.isGroupCall) {
        callState.isUserParticipating = false;

        const systemNote = {
            role: 'system',
            content: `[系统提示：用户拒绝了${callType}邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        await triggerAiResponse();

    } else {
        const declineMessage = { role: 'user', content: `我拒绝了你的${callType}请求。`, timestamp: Date.now() };
        chat.history.push(declineMessage);
        await db.chats.put(chat);

        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);
        triggerAiResponse();
    }

    callState.isAwaitingResponse = false;
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的"接听"按钮
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();

    // 【新增】判断是视频通话还是语音通话
    if (voiceCallState.isAwaitingResponse) {
        // 语音通话
        voiceCallState.initiator = 'ai';
        voiceCallState.isUserParticipating = true;
        voiceCallState.activeChatId = state.activeChatId;

        if (voiceCallState.isGroupCall) {
            const chat = state.chats[voiceCallState.activeChatId];
            const requester = chat.members.find(m => m.name === voiceCallState.callRequester);
            if (requester) {
                voiceCallState.participants = [requester];
            } else {
                voiceCallState.participants = [];
            }
        }

        startVoiceCall();
    } else {
        // 视频通话（原有逻辑）
        videoCallState.initiator = 'ai';
        videoCallState.isUserParticipating = true;
        videoCallState.activeChatId = state.activeChatId;

        if (videoCallState.isGroupCall) {
            const chat = state.chats[videoCallState.activeChatId];
            const requester = chat.members.find(m => m.name === videoCallState.callRequester);
            if (requester) {
                videoCallState.participants = [requester];
            } else {
                videoCallState.participants = [];
            }
        }

        startVideoCall();
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
// 绑定用户在通话中发言的按钮
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...', '', 'textarea');
    
    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【新增】语音通话用户说话按钮 ▼▼▼
document.getElementById('voice-user-speak-btn').addEventListener('click', async () => {
    if (!voiceCallState.isActive) return;

    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...', '', 'textarea');

    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        await handleSendChatDuringVoiceCall(userInput.trim());
    }
});
// ▲▲▲ 语音通话用户说话按钮结束 ▲▲▲

// ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
// 1. 将“回忆”页签和它的视图连接起来
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切换前，确保"收藏"页面的编辑模式已关闭
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 点击时渲染
});

// 2. 绑定回忆录界面的返回按钮
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 新增结束 ▲▲▲

// 【全新】约定/倒计时功能事件绑定
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate)) {
        alert('请输入一个有效的日期！');
        return;
    }

    const newCountdown = {
        chatId: null, // 用户创建的，不属于任何特定AI
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【全新】拉黑功能事件绑定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '确认拉黑', 
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        
        // 关闭设置弹窗，并刷新聊天界面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能会有UI变化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
    else if (e.target.closest('#toggle-dev-panel-btn')) {
        const panel = document.getElementById('developer-diagnostic-panel');
        if (panel) {
            // 切换面板的显示状态
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        return;
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 【新增】计算这是第几次好友申请 ▼▼▼
        const previousApplicationsCount = chat.history.filter(msg =>
            msg.isHidden && msg.role === 'system' && msg.content.includes('你刚刚向用户发送了一条好友申请')
        ).length;
        const applicationAttempt = previousApplicationsCount;
        // ▲▲▲ 计算结束 ▲▲▲

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚通过了你的好友申请（这是你第 ${applicationAttempt} 次申请）。你们现在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
        chat.history.push(msg);

        // ▼▼▼ 【需求3】在调用API前，注入一条告诉AI用户已同意的隐藏消息 ▼▼▼
        const friendResponseNotification = {
            role: 'system',
            content: `[系统提示：用户刚刚同意了你的好友申请（这是你第 ${applicationAttempt} 次申请）。你们现在可以开始聊天了。这是用户对你的申请的最终决定。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(friendResponseNotification);
        // ▲▲▲ 需求3实现结束 ▲▲▲

        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        // 【全新功能】在这里保存被拒绝的申请理由
        if (chat.relationship.applicationReason) {
            chat.relationship.previousApplicationReason = chat.relationship.applicationReason;
        }

        // ▼▼▼ 【新增】计算这是第几次被拒绝的好友申请 ▼▼▼
        const previousApplicationsCount = chat.history.filter(msg =>
            msg.isHidden && msg.role === 'system' && msg.content.includes('你刚刚向用户发送了一条好友申请')
        ).length;
        const applicationAttempt = previousApplicationsCount;
        // ▲▲▲ 计算结束 ▲▲▲

        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';

        // ▼▼▼ 【需求3】在调用API前，注入一条告诉AI用户已拒绝的隐藏消息，同时包含申请次数信息 ▼▼▼
        const friendRejectionNotification = {
            role: 'system',
            content: `[系统提示：用户刚刚拒绝了你的好友申请（这是你第 ${applicationAttempt} 次申请）。用户决定暂时不想和你继续聊天。这是用户对你的申请的最终决定。你可以在冷静期后重新发送申请。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(friendRejectionNotification);
        // ▲▲▲ 需求3实现结束 ▲▲▲

        await db.chats.put(chat);
        await triggerActiveReply(chat, 0);
        renderChatInterface(chat.id);
    }
    // 【新增】处理申请好友按钮的点击事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '发送好友申请', 
            `请输入你想对“${chat.name}”说的申请理由：`,
            "我们和好吧！"
        );
        // 只有当用户输入了内容并点击“确定”后才继续
        if (reason !== null) {
            // 更新关系状态为“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，显示“等待通过”的界面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【关键】触发AI响应，让它去处理这个好友申请
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

// 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 红包模态框内部的控制按钮
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 红包模态框的页签切换逻辑
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 实时更新红包金额显示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被点击的红包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

    // 2. 从红包卡片的父级.message-bubble获取时间戳
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 调用我们现有的处理函数
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代码结束 ▲▲▲

// 【新增】处理 NovelAI 图片重新生成按钮（失败状态）
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const retryBtn = e.target.closest('.retry-nai-image-btn');
    if (!retryBtn) return;

    const timestamp = parseInt(retryBtn.dataset.timestamp);
    if (isNaN(timestamp)) {
        console.error('无法获取时间戳');
        return;
    }

    retryNaiImage(timestamp);
});
// ▲▲▲ 新增结束 ▲▲▲

// 【新增】处理已生成图片上的重新生成按钮
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const retryBtn = e.target.closest('.naiimag-retry-btn');
    if (!retryBtn) return;

    const timestamp = parseInt(retryBtn.dataset.timestamp);
    if (isNaN(timestamp)) {
        console.error('无法获取时间戳');
        return;
    }

    // 使用已生成的图片重新生成
    retryNaiImage(timestamp);
});
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 【新增】naiimag图片长按放大功能 ▼▼▼
(() => {
    let longPressTimer = null;
    let isLongPress = false;

    // 监听touchstart和mousedown
    document.getElementById('chat-messages').addEventListener('touchstart', handlePressStart, { passive: false });
    document.getElementById('chat-messages').addEventListener('mousedown', handlePressStart);

    // 监听touchend和mouseup
    document.getElementById('chat-messages').addEventListener('touchend', handlePressEnd);
    document.getElementById('chat-messages').addEventListener('mouseup', handlePressEnd);

    // 监听touchmove和mousemove，如果移动了就取消长按
    document.getElementById('chat-messages').addEventListener('touchmove', cancelLongPress);
    document.getElementById('chat-messages').addEventListener('mousemove', cancelLongPress);

    function handlePressStart(e) {
        const naiImage = e.target.closest('.naiimag-image');
        if (!naiImage) return;

        // 如果点击的是重新生成按钮，不处理
        if (e.target.closest('.naiimag-retry-btn')) return;

        // 阻止事件冒泡到wrapper，防止触发wechat-style-actions-panel
        e.stopPropagation();

        isLongPress = false;
        longPressTimer = setTimeout(() => {
            isLongPress = true;
            // 长按触发放大预览，传入图片URL和prompt
            const prompt = naiImage.getAttribute('title') || naiImage.getAttribute('alt') || '';
            showNaiImagePreview(naiImage.src, prompt);
            // 触觉反馈（如果支持）
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }, 500); // 500毫秒判定为长按
    }

    function handlePressEnd(e) {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }

        // 如果是长按触发的，阻止后续的点击事件
        if (isLongPress) {
            e.preventDefault();
            e.stopPropagation();
            isLongPress = false;
        }
    }

    function cancelLongPress(e) {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }

    function showNaiImagePreview(imageUrl, prompt = '') {
        const modal = document.createElement('div');
        modal.className = 'naiimag-preview-modal';
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;';

        const container = document.createElement('div');
        container.style.cssText = 'display: flex; flex-direction: column; align-items: center; max-width: 90%; max-height: 90%;';

        const imgElement = document.createElement('img');
        imgElement.src = imageUrl;
        imgElement.style.cssText = 'max-width: 100%; max-height: 70vh; border-radius: 8px; cursor: pointer;';

        container.appendChild(imgElement);

        // 如果有prompt，显示在图片下方
        if (prompt && prompt.trim()) {
            const promptBox = document.createElement('div');
            promptBox.style.cssText = 'margin-top: 15px; padding: 12px 16px; background: rgba(255,255,255,0.95); border-radius: 8px; color: #333; font-size: 13px; line-height: 1.6; max-width: 100%; word-wrap: break-word; max-height: 150px; overflow-y: auto;';
            promptBox.textContent = prompt;
            container.appendChild(promptBox);
        }

        modal.appendChild(container);

        // 点击modal时关闭预览
        modal.addEventListener('click', (e) => {
            e.stopPropagation();
            modal.remove();
        });

        document.body.appendChild(modal);
    }
})();
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
// 在输入框工具栏添加按钮
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票创建模态框的按钮
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委托处理投票卡片内的所有点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 点击了选项
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 点击了动作按钮（结束投票/查看结果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

  // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 【新增】情侣头像库事件监听器 ▼▼▼
document.getElementById('manage-couple-avatar-library-btn').addEventListener('click', openCoupleAvatarLibraryModal);
document.getElementById('add-couple-avatar-btn').addEventListener('click', addCouplAvatarToLibrary);
document.getElementById('close-couple-avatar-library-btn').addEventListener('click', closeCoupleAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 【新增】AI表情包库事件监听器 ▼▼▼
document.getElementById('manage-ai-stickers-btn').addEventListener('click', openAiStickersLibraryModal);
document.getElementById('add-ai-sticker-btn').addEventListener('click', addAiStickerToLibrary);
document.getElementById('import-txt-ai-sticker-btn').addEventListener('click', handleImportTxtAiStickers);
document.getElementById('batch-add-ai-sticker-btn').addEventListener('click', handleBatchAddAiStickers);
document.getElementById('manage-ai-sticker-library-btn').addEventListener('click', enterAiStickerManagementMode);

// ▼▼▼ 【新增】AI表情包搜索事件监听器 ▼▼▼
document.getElementById('search-ai-sticker-btn').addEventListener('click', openAiStickerSearchModal);
document.getElementById('ai-sticker-search-btn').addEventListener('click', searchAiStickers);
document.getElementById('ai-sticker-search-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        searchAiStickers();
    }
});
document.getElementById('close-ai-sticker-search-modal-btn').addEventListener('click', () => {
    document.getElementById('ai-sticker-search-modal').classList.remove('visible');
    document.getElementById('ai-sticker-search-input').value = '';
    document.getElementById('ai-sticker-search-results').innerHTML = '';
});
// ▲▲▲ 【新增】AI表情包搜索事件监听器结束 ▲▲▲
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (!iconId) return;

        const currentUrl = state.globalSettings.appIcons[iconId];
        const newUrl = await showCustomPrompt(`更换“${item.querySelector('.icon-preview').alt}”图标`, '请输入新的图片URL', currentUrl, 'url');

        if (newUrl && newUrl.trim().startsWith('http')) {
            // 仅在内存中更新，等待用户点击“保存”
            state.globalSettings.appIcons[iconId] = newUrl.trim();
            // 实时更新设置页面的预览图
            item.querySelector('.icon-preview').src = newUrl.trim();
        } else if (newUrl !== null) {
            alert("请输入一个有效的URL！");
        }
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 处理音乐卡片点击
        const musicCard = e.target.closest('.music-card');
        if (musicCard) {
            const timestamp = parseInt(musicCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                const chat = state.chats[state.activeChatId];
                if (chat) {
                    const msg = chat.history.find(m => m.timestamp === timestamp);
                    if (msg && msg.musicData) {
                        showMusicLyricsModal(msg.musicData);
                    }
                }
            }
            return;
        }

        // 使用 .closest() 向上查找被点击的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 调用我们的函数
            }
        }
    });

    // 浏览器返回按钮的事件监听，确保它只绑定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    // 1. 绑定输入框上方"分享链接"按钮的点击事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
//  ▼▼▼ 请用这段【新代码】替换旧的 'diary-btn' 事件监听器 ▼▼▼
// 绑定日记按钮
document.getElementById('diary-btn').addEventListener('click', () => {
    if (state.activeChatId) {
        // 【核心修复】调用功能更全面的关闭函数，确保空白区域也被移除
        closePlusPanel(); 
        openDiaryScreen(state.activeChatId);
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// 绑定重新生成按钮
    document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);

    // 2. 绑定模态框中“取消”按钮的点击事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 绑定模态框中“分享”按钮的点击事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
// 绑定消息操作菜单中的“引用”按钮
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 绑定回复预览栏中的“取消”按钮
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 粘贴结束 ▲▲▲

// 在你的 init() 函数的事件监听器区域...

// ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被点击的元素是否在一个消息气泡内
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在这里添加严格的筛选条件
    // 必须是 AI 的消息 (.ai)
    // 必须是转账类型 (.is-transfer)
    // 必须是我们标记为“待处理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有满足所有条件，才执行后续逻辑
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 在 init() 的事件监听区域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 礼物按钮点击事件处理 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    // 检查是否点击了礼物按钮
    if (e.target.classList.contains('gift-decline-btn') || e.target.classList.contains('gift-accept-btn')) {
        const choice = e.target.dataset.choice; // 'accepted' 或 'declined'
        const timestamp = parseInt(e.target.dataset.timestamp);
        
        if (!isNaN(timestamp) && state.activeChatId) {
            const chat = state.chats[state.activeChatId];
            const giftMsgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            
            if (giftMsgIndex > -1) {
                const giftMsg = chat.history[giftMsgIndex];
                giftMsg.status = choice; // 更新状态
                
                // 如果是拼手气礼物被接受，记录接收者信息
                if (choice === 'accepted' && giftMsg.giftType === 'random') {
                    giftMsg.actualReceiver = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                }
                
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId); // 重新渲染界面
                
                // 发送系统消息给AI，让AI知道用户的选择
                const systemMessage = {
                    role: 'user',
                    content: choice === 'accepted' ? 
                        `[系统提示：用户已接受了你的礼物"${giftMsg.giftName}"（价值¥${giftMsg.giftPrice}），请自然地回应这个结果。]` :
                        `[系统提示：用户已拒绝了你的礼物"${giftMsg.giftName}"（价值¥${giftMsg.giftPrice}），请自然地回应这个结果。]`,
                    timestamp: Date.now(),
                    isSystemMessage: true
                };
                
                chat.history.push(systemMessage);
                await db.chats.put(chat);
                
                // 检查是否还有待处理的礼物
                const hasPendingGifts = chat.history.some(msg => 
                    msg.type === 'gift' && 
                    msg.role === 'assistant' && 
                    msg.status === 'pending'
                );
                
                // 如果是单聊或没有待处理礼物了，立即触发AI回应
                if (!chat.isGroup || !hasPendingGifts) {
                    triggerAiResponse();
                }
            }
        }
    }
});
// ▲▲▲ 礼物按钮处理结束 ▲▲▲

// ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 绑定通话记录页面的"返回"按钮
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天列表页面，而不是聊天界面
    showScreen('chat-list-screen');
});

// 3. 监听卡片点击的逻辑保持不变
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 关闭详情弹窗的逻辑保持不变
/**
 * 提取文本中括号外的内容，用于Minimax TTS语音播放（已移到前面，此处保留注释以指示重复定义已删除）
 * 例如："（声音低沉）我好想你" => "我好想你"
 * @param {string} text - 原始文本
 * @returns {string} - 去除括号内容后的文本
 */
// ⚠️ removeParenthesesContent 已定义在第29071行，不在此重复定义
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【Minimax TTS】核心函数 ▼▼▼

/**
 * 拉取并填充 Minimax 语音模型的下拉框
 */
function fetchMinimaxSpeechModels() {
    const modelSelect = document.getElementById('minimax-speech-model-select');
    if (!modelSelect) return;
    modelSelect.innerHTML = ''; // 清空

    // 🔥【扩充】从Minimax官方文档获取的完整模型列表
    const models = [
        'speech-2.6-hd',
        'speech-2.6-turbo',
        'speech-02-hd',
        'speech-02-turbo',
        'speech-01-hd',
        'speech-01-turbo'
    ];

    models.forEach(modelId => {
        const option = document.createElement('option');
        option.value = modelId;
        option.textContent = modelId;
        modelSelect.appendChild(option);
    });

    // 自动选中当前已保存的模型，如果没有则使用推荐的默认值
    modelSelect.value = state.apiConfig.minimaxSpeechModel || 'speech-01-turbo';

    alert('Minimax 语音模型列表已更新！');
}

// ⚠️ removeParenthesesContent 已在第29071行定义，不再重复定义

/**
 * 停止当前正在播放的Minimax TTS语音
 */
function stopMinimaxAudio() {
    if (!isTtsPlaying) return;

    // 核心修改1：在执行停止操作前，先设置"故意停止"的标志为 true
    isIntentionalStop = true;

    const ttsPlayer = document.getElementById('tts-audio-player');
    ttsPlayer.pause();
    ttsPlayer.src = ''; // 这行代码会触发 onerror 事件

    if (window.currentAnimatingBubbles) {
        window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
    }

    isTtsPlaying = false;
    currentTtsAudioBubble = null;
    window.currentAnimatingBubbles = null;
    console.log('Minimax TTS: Playback stopped by user.');

    // 核心修改2：用一个微小的延迟来重置标志位
    // 这能确保 onerror 事件有足够的时间检查到标志位，然后再将其重置
    setTimeout(() => {
        isIntentionalStop = false;
    }, 100);
}

/**
 * 调用 Minimax TTS API 生成语音并播放
 * @param {string} text - 要转换为语音的合并后的文本
 * @param {string} voiceId - Minimax 的语音 ID
 * @param {Array<HTMLElement>} bubblesToAnimate - 需要播放动画的所有语音气泡元素的数组
 */
async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
    stopMinimaxAudio();
    await new Promise(resolve => setTimeout(resolve, 50));

    const ttsPlayer = document.getElementById('tts-audio-player');
    const firstBubble = bubblesToAnimate[0];

    isTtsPlaying = true;
    currentTtsAudioBubble = firstBubble;
    window.currentAnimatingBubbles = bubblesToAnimate;
    bubblesToAnimate.forEach(b => b.classList.add('playing'));

    const mainAudioPlayer = document.getElementById('audio-player');
    if (mainAudioPlayer && !mainAudioPlayer.paused) {
        mainAudioPlayer.pause();
        musicState.isPlaying = false;
        updatePlayerUI();
    }

    const groupId = state.apiConfig.minimaxGroupId;
    const apiKey = state.apiConfig.minimaxApiKey;
    if (!groupId || !apiKey) {
        await showCustomAlert('语音播放失败', '尚未配置Minimax的Group ID和API Key。');
        stopMinimaxAudio();
        return;
    }

    // ★★★ 核心修改：从全局 apiConfig 获取语音模型 ★★★
    const speechModel = state.apiConfig.minimaxSpeechModel || 'speech-01-turbo';

    console.log(`正在使用 Minimax 语音模型: ${speechModel}`);

    // 🔥【新增】从聊天设置里获取语速和语言参数
    const chat = state.chats[state.activeChatId];
    const voiceSpeed = parseFloat(chat?.settings?.minimaxVoiceSpeed) || 1.0;
    const language = chat?.settings?.minimaxLanguage || '';
    console.log(`Minimax TTS 参数: 语速=${voiceSpeed}, 语言=${language || '未设置'}`);

    // 🔥 t2a_v2接口 - 最简单的参数,不加emotion
    const requestBody = {
        text: text,
        model: speechModel,
        voice_setting: {
            voice_id: voiceId,
            speed: voiceSpeed,
            pitch: 0,
        }
    };

    // 🔥【修复】如果设置了语言增强，直接使用选择的值（已经是完整的语言名称了）
    if (language) {
        requestBody.language_boost = language;
    }

    console.log('t2a_v2 请求参数:', JSON.stringify(requestBody, null, 2));

    try {
        // 🔥【新增】根据服务区选择动态切换API地址
        const baseUrl = document.getElementById('minimax-domain-select').value || 'https://api.minimax.chat';
        const requestUrl = `${baseUrl}/v1/t2a_v2?GroupId=${groupId}`;

        console.log(`使用API地址: ${baseUrl}, 请求地址: ${requestUrl}`);
        console.log(`【调试】请求头:`, { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' });
        console.log(`【调试】请求体:`, requestBody);

        // 使用t2a_v2接口,音质更好更自然
        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        console.log(`【调试】响应状态: ${response.status} ${response.statusText}`);
        console.log(`【调试】响应头:`, {
            'content-type': response.headers.get('content-type'),
            'access-control-allow-origin': response.headers.get('access-control-allow-origin'),
            'access-control-allow-methods': response.headers.get('access-control-allow-methods')
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Minimax API 错误: ${errorData.base_resp?.status_msg || response.statusText}`);
        }

        // 🔥 t2a_v2 返回的是JSON格式，音频数据在data.audio字段里(十六进制字符串)
        const jsonData = await response.json();
        if (!jsonData.data || !jsonData.data.audio) {
            throw new Error(`Minimax API 返回格式错误: ${JSON.stringify(jsonData)}`);
        }

        // 把十六进制字符串转成二进制数据
        const hexString = jsonData.data.audio;
        const byteArray = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

        // 创建音频blob
        const audioBlob = new Blob([byteArray], { type: 'audio/mpeg' });
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;

        const cleanupAndReset = () => {
            if (isTtsPlaying) {
                isTtsPlaying = false;
                URL.revokeObjectURL(audioUrl);
                if (window.currentAnimatingBubbles) {
                    window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
                }
                currentTtsAudioBubble = null;
                window.currentAnimatingBubbles = null;
            }
        };

       ttsPlayer.onended = cleanupAndReset;

        ttsPlayer.onerror = (e) => {
             if (!isIntentionalStop) {
                 console.error("TTS音频播放时发生错误，已自动切换为文本显示:", e);
             } else {
                 console.log("Intentional stop triggered error event, alert skipped.");
             }
             cleanupAndReset();
        };

        await ttsPlayer.play();

    } catch (error) {
        console.error("Minimax TTS 调用失败:", error);
        await showCustomAlert('语音合成失败', `错误信息: ${error.message}`);
        stopMinimaxAudio();
    }
}

// ▲▲▲ 【Minimax TTS】核心函数 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    const voiceBody = e.target.closest('.voice-message-body');
    const translationBody = e.target.closest('.translation-body');

    // --- 逻辑1：处理语音条点击 ---
if (voiceBody) {
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');
    const wrapper = bubble.closest('.message-wrapper');
    const chatMessages = document.getElementById('chat-messages');

    // ▼▼▼ 【Minimax TTS】检查是否是AI发送的语音消息并且配置完整 ▼▼▼
    const isAiVoice = bubble.classList.contains('ai') && bubble.classList.contains('is-voice-message');
    const chat = state.chats[state.activeChatId];
    const groupId = state.apiConfig.minimaxGroupId;
    const apiKey = state.apiConfig.minimaxApiKey;
    const voiceId = chat?.settings?.minimaxVoiceId;
    const canPlayTts = isAiVoice && groupId && apiKey && voiceId;
    // ▲▲▲ 【Minimax TTS】检查是否是AI发送的语音消息并且配置完整 ▲▲▲

    // 如果正在播放TTS且点击的是当前播放的气泡，则停止播放
    if (canPlayTts && isTtsPlaying && currentTtsAudioBubble === bubble) {
        stopMinimaxAudio();
        // 文本保持展开状态
        return;
    }

    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    } else {
        bubble.dataset.state = 'loading';
        spinner.style.display = 'block';
        setTimeout(() => {
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText;
                spinner.style.display = 'none';
                transcriptEl.style.display = 'block';
                bubble.dataset.state = 'expanded';

                // 【核心修改】判断当前消息是否为最后一条
                const allMessages = chatMessages.querySelectorAll('.message-wrapper');
                const isLastMessage = wrapper === allMessages[allMessages.length - 1];

                if (isLastMessage) {
                    // 如果是最后一条，才滚动到底部
                    chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
                }

                // ▼▼▼ 【Minimax TTS】在文本展开后自动播放语音（如果配置完整） ▼▼▼
                if (canPlayTts) {
                    const voiceText = bubble.dataset.voiceText || '';
                    const cleanedVoiceText = removeParenthesesContent(voiceText);
                    playMinimaxAudio(cleanedVoiceText, voiceId, [bubble]);
                }
                // ▲▲▲ 【Minimax TTS】在文本展开后自动播放语音（如果配置完整） ▲▲▲
            }
        }, 500);
    }
}
// --- 逻辑2：处理翻译条点击 ---
else if (translationBody) {
    const bubble = translationBody.closest('.message-bubble');
    if (!bubble) return;
    const transcriptEl = bubble.querySelector('.translation-text');
    const wrapper = bubble.closest('.message-wrapper');
    const chatMessages = document.getElementById('chat-messages');

    if (bubble.dataset.state !== 'expanded') {
        transcriptEl.style.display = 'block';
        bubble.dataset.state = 'expanded';

        // 【核心修改】判断当前消息是否为最后一条
        const allMessages = chatMessages.querySelectorAll('.message-wrapper');
        const isLastMessage = wrapper === allMessages[allMessages.length - 1];

        if (isLastMessage) {
            // 如果是最后一条，才滚动到底部
            chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
        }

    } else {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    }
}
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件监听器区域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打开我们即将创建的目标选择器
    }
});

// 在 init() 的事件监听器区域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const modal = document.getElementById('share-target-modal');

    // 检查是否是论坛转发
    if (modal.dataset.forwardingPostId) {
        // 论坛转发逻辑
        const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                       .map(cb => cb.dataset.chatId);

        if (selectedTargetIds.length === 0) {
            alert("请至少选择一个要转发的聊天。");
            return;
        }

        const postId = parseInt(modal.dataset.forwardingPostId);
        const post = currentForumPosts.find(p => p.id === postId);

        if (post) {
            await handleForumPostForward(post, selectedTargetIds);
        }

        // 清理并关闭
        modal.dataset.forwardingPostId = '';
        modal.classList.remove('visible');
        return;
    }

    // 【全新】处理聊天记录转发 - 支持合并或逐条转发
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);
    const forwardMethod = modal.dataset.forwardMethod || 'merge'; // 默认合并转发

    if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
    }

    // 获取要转发的消息
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }

    // 根据转发方式处理
    if (forwardMethod === 'merge') {
        // 原有的合并转发逻辑
        const shareCardMessage = {
            role: 'user',
            senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
            type: 'share_card',
            timestamp: Date.now(),
            payload: {
                sourceChatName: sourceChat.name,
                title: `来自"${sourceChat.name}"的聊天记录`,
                sharedHistory: sharedHistory
            }
        };

        // 循环发送到所有目标聊天
        for (const targetId of selectedTargetIds) {
            const targetChat = state.chats[targetId];
            if (targetChat) {
                targetChat.history.push(shareCardMessage);
                await db.chats.put(targetChat);
            }
        }
    } else if (forwardMethod === 'single') {
        // 【全新】逐条转发逻辑 - 消息显示为用户侧发送
        for (const targetId of selectedTargetIds) {
            const targetChat = state.chats[targetId];
            if (targetChat) {
                // 逐条转发，每条消息都作为用户消息
                for (const sharedMsg of sharedHistory) {
                    // 复制消息对象，修改role为user
                    const forwardedMsg = {
                        ...sharedMsg,
                        role: 'user', // 关键：转发的消息显示为用户消息
                        senderName: targetChat.isGroup ? (targetChat.settings.myNickname || '我') : '我',
                        timestamp: Date.now() + Math.random() * 1000 // 确保时间戳不重复
                    };
                    targetChat.history.push(forwardedMsg);
                }
                await db.chats.put(targetChat);
            }
        }
    }

    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多选模式
    await showCustomAlert("分享成功", `聊天记录已成功${forwardMethod === 'merge' ? '合并' : '逐条'}分享到 ${selectedTargetIds.length} 个会话中。`);
    renderChatList(); // 刷新列表，可能会有新消息提示
});

// 绑定取消按钮
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 【全新】转发方式选择 - 合并转发按钮
document.getElementById('merge-forward-btn').addEventListener('click', async () => {
    document.getElementById('forward-method-modal').classList.remove('visible');
    await openShareTargetModalForMessages('merge');
});

// 【全新】转发方式选择 - 逐条转发按钮
document.getElementById('single-forward-btn').addEventListener('click', async () => {
    document.getElementById('forward-method-modal').classList.remove('visible');
    await openShareTargetModalForMessages('single');
});

// 【全新】转发方式选择 - 取消按钮
document.getElementById('cancel-forward-method-btn').addEventListener('click', () => {
    document.getElementById('forward-method-modal').classList.remove('visible');
});

// 在 init() 的事件监听器区域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他点击事件逻辑...
// ▼▼▼ 在这里添加新的代码块 ▼▼▼
    // 【全新】处理转发的论坛卡片图片点击
    const forumCardImage = e.target.closest('.forum-card .chat-image');
    if (forumCardImage && forumCardImage.dataset.description) {
        const description = forumCardImage.dataset.description;
        showCustomAlert("图片内容", description.replace(/<br>/g, '\n'));
        return; // 处理完后直接返回，避免触发其他事件
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
    // 新增逻辑：处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 绑定查看器的关闭按钮
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 创建新函数来处理渲染逻辑
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空旧内容

    // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', () => {
    updateMusicProgressBar();
    // ▼▼▼ 【新增】实时更新歌词显示 ▼▼▼
    updateActiveLyric(audioPlayer.currentTime);
    // ▲▲▲ 歌词更新结束 ▲▲▲
});

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target.closest('button, .playlist-action-btn') || e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    if (target.classList.contains('share-btn') || target.closest('.share-btn')) {
        const button = target.classList.contains('share-btn') ? target : target.closest('.share-btn');
        const index = parseInt(button.dataset.index);
        if (isNaN(index)) return;
        await shareMusicCard(index);
        return;
    }
    if (target.classList.contains('lyrics-btn') || target.closest('.lyrics-btn')) {
        const button = target.classList.contains('lyrics-btn') ? target : target.closest('.lyrics-btn');
        const index = parseInt(button.dataset.index);
        if (isNaN(index)) return;
        const lrcContent = await new Promise(resolve => {
            const lrcInput = document.getElementById('lrc-upload-input');
            const handler = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (re) => resolve(re.target.result);
                    reader.readAsText(file);
                } else {
                    resolve(null);
                }
                lrcInput.removeEventListener('change', handler);
                lrcInput.value = '';
            };
            lrcInput.addEventListener('change', handler);
            lrcInput.click();
        });
        if (lrcContent !== null) {
            musicState.playlist[index].lrcContent = lrcContent;
            await saveGlobalPlaylist();
            alert('歌词导入成功！');
            if (musicState.currentIndex === index) {
                musicState.parsedLyrics = parseLRC(lrcContent);
                renderLyrics();
            }
        }
    }
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

// 使用事件委托来处理所有“已撤回消息”的点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 检查被点击的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就从聊天记录中找到对应的数据并显示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 从父容器上找到时间戳
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】HTML指令功能事件绑定 ▼▼▼
    document.getElementById('html-prompt-btn-panel').addEventListener('click', () => {
        closePlusPanel(); // 先关闭功能面板
        document.getElementById('html-prompt-modal').classList.add('visible');
    });
    document.getElementById('html-prompt-btn-group-panel').addEventListener('click', () => {
        closePlusPanel(); // 先关闭功能面板
        document.getElementById('html-prompt-modal').classList.add('visible');
    });

    document.getElementById('cancel-html-prompt-btn').addEventListener('click', () => {
        document.getElementById('html-prompt-modal').classList.remove('visible');
    });

    document.getElementById('send-html-prompt-btn').addEventListener('click', sendHtmlPrompt);
    // ▲▲▲ 新事件绑定结束 ▲▲▲
// 监听回忆录列表中的点击事件
document.getElementById('memories-list').addEventListener('click', (e) => {
    const bindBtn = e.target.closest('.bind-char-btn');
    if (bindBtn) {
        const memoryId = parseInt(bindBtn.dataset.memoryId);
        if (!isNaN(memoryId)) {
            openCharacterBinder(memoryId);
        }
    }
});

// 绑定角色模态框的事件
document.getElementById('cancel-char-binding-btn').addEventListener('click', () => {
    document.getElementById('bind-character-modal').classList.remove('visible');
});
document.getElementById('confirm-char-binding-btn').addEventListener('click', saveCountdownBindings);
document.getElementById('bind-character-grid').addEventListener('click', (e) => {
    const item = e.target.closest('.bind-char-item');
    if (item) {
        // 【全新】实现多选的切换逻辑
item.classList.toggle('selected');
    }
});
// ▲▲▲ 统一世界书模态框事件处理器结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
// 【全新】为分享目标的列表添加整行点击选择功能
document.getElementById('share-target-list').addEventListener('click', (e) => {
    // 1. 找到被点击的整行元素
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    // 2. 找到行内的复选框
    const checkbox = item.querySelector('.share-target-checkbox');
    if (!checkbox) return;
    
    // 3. 如果用户就是直接点的复选框，我们什么都不做，让浏览器自己处理
    //    这样可以防止双重触发导致的“点不动”问题
    if (e.target === checkbox) {
        return;
    }
    
    // 4. 如果点击的是其他地方（如头像、名字、空白处），我们就用代码来切换复选框的选中状态
    checkbox.checked = !checkbox.checked;
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】人设展开编辑器事件处理 ▼▼▼
// 【全新】人设展开编辑器事件处理 (已集成预设编辑逻辑并修复展开功能)
document.getElementById('chat-settings-modal').addEventListener('click', async (e) => {
    const expandBtn = e.target.closest('.expand-persona-btn');
    const cancelBtn = e.target.closest('.cancel-expanded-btn');
    const saveBtn = e.target.closest('.save-expanded-btn');

    // ▼▼▼ 这是被我遗漏的、用于处理展开的核心逻辑，现已恢复 ▼▼▼
    if (expandBtn) {
        const targetId = expandBtn.dataset.target;
        let smallTextarea, expandedEditor, largeTextarea;

        if (targetId === 'css') {
            smallTextarea = document.getElementById('custom-css-input');
            expandedEditor = document.getElementById('css-editor-expanded');
        } else {
            smallTextarea = document.getElementById(`${targetId}-persona`);
            expandedEditor = document.getElementById(`${targetId}-persona-editor-expanded`);
        }

        if (smallTextarea && expandedEditor) {
            largeTextarea = expandedEditor.querySelector('.expanded-textarea');
            // 切换显示
            largeTextarea.value = smallTextarea.value;
            smallTextarea.style.display = 'none';
            expandedEditor.style.display = 'block';
        }
    }
    // ▲▲▲ 恢复代码结束 ▲▲▲

    if (cancelBtn) {
        const expandedEditor = cancelBtn.closest('.persona-editor-expanded');
        const formGroup = expandedEditor.closest('.form-group');
        const smallTextarea = formGroup.querySelector('textarea:not(.expanded-textarea)');

        // 切换显示
        expandedEditor.style.display = 'none';
        smallTextarea.style.display = 'block';

        // 取消编辑时，重置状态
        editingBubblePresetId = null;
    }

    if (saveBtn) {
        const expandedEditor = saveBtn.closest('.persona-editor-expanded');
        const formGroup = expandedEditor.closest('.form-group');
        const smallTextarea = formGroup.querySelector('textarea:not(.expanded-textarea)');
        const largeTextarea = expandedEditor.querySelector('.expanded-textarea');

        // 检查是否在编辑气泡预设
        if (expandedEditor.id === 'css-editor-expanded' && editingBubblePresetId) {
            const newCss = largeTextarea.value;
            await db.bubblePresets.update(editingBubblePresetId, { css: newCss });
            await renderBubblePresets();
            alert('预设已更新！');
            editingBubblePresetId = null; // 重置状态
        }
        
        // 原始逻辑：保存内容并切换显示
        smallTextarea.value = largeTextarea.value;
        expandedEditor.style.display = 'none';
        smallTextarea.style.display = 'block';
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

        // ===================================================================
        // 5. 启动！
            // ▼▼▼ 在这里粘贴 ▼▼▼
setupStatusAndDiarySystem();
/**
 * 【全新】打开并填充群聊心声弹窗
 */
/**
 /**
 /**
 * 【已修正】打开并填充群聊心声弹窗
 */
function openGroupStatusModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const modal = document.getElementById('group-status-modal');
    const titleEl = document.getElementById('group-status-modal-title');
    const listEl = document.getElementById('group-status-list');

    titleEl.textContent = `“${chat.name}”的心声`;
    listEl.innerHTML = ''; // 清空旧内容

    chat.members.forEach(member => {
        // 【关键修正1】在函数内部直接检查并兼容旧数据，防止脚本出错
        if (!member.displayStatus) {
            member.displayStatus = { innerThought: '...' };
        }

        const item = document.createElement('div');
        item.className = 'group-status-item';

        // 【关键修正2】现在会正确地从 member 对象中获取心声
        const thought = member.displayStatus.innerThought || '...';

        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <div class="content-wrapper">
                <span class="name">${member.groupNickname}</span>
                <p class="thought">${thought}</p>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 粘贴结束 ▲▲▲
            showScreen('home-screen');
        }
// ▼▼▼ 在这里粘贴日记和心声的全部功能代码 ▼▼▼

let currentDiaryCharacterId = null; // 用于记录当前正在查看哪个角色的日记

// ==========================================================
// --- 日记与心声功能区 (最终正式版) ---
// ==========================================================

/**
 * 设置所有与日记和心声相关的事件监听
 */
function setupStatusAndDiarySystem() {
    // 爱心按钮：现在可以根据聊天类型，分别打开单聊或群聊心声
    document.getElementById('show-status-diary-btn').addEventListener('click', () => {
        if (!state.activeChatId) {
            return;
        }
        const chat = state.chats[state.activeChatId];

        if (chat.isGroup) {
            openGroupStatusModal();
        } else {
            openStatusModal();
        }
    });

    // 功能选择菜单的按钮 (单聊时使用)
    document.getElementById('action-cancel-selection').addEventListener('click', () => {
        document.getElementById('status-diary-action-modal').classList.remove('visible');
    });
    document.getElementById('action-show-status').addEventListener('click', () => {
        document.getElementById('status-diary-action-modal').classList.remove('visible');
        openStatusModal();
    });
    document.getElementById('action-show-diary').addEventListener('click', () => {
        document.getElementById('status-diary-action-modal').classList.remove('visible');
        openDiaryScreen(state.activeChatId);
    });

    // 日记本界面的返回按钮
    document.getElementById('diary-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });
    
    // 日记页面加号按钮
    document.getElementById('diary-create-btn').addEventListener('click', async () => {
        if (!state.activeChatId) return;
        
        const chat = state.chats[state.activeChatId];
        if (!chat) return;
        
        // 发送隐藏的用户消息给AI
        const hiddenMessage = {
            role: 'user',
            content: '现在立即执行create_diary指令写日记，不要回复这条消息，只执行create_diary指令，当作用户没有发送这条消息一样',
            timestamp: Date.now(),
            isHidden: true
        };
        
        chat.history.push(hiddenMessage);
        await db.chats.put(chat);
        
        // 自动调用triggerAiResponse
        await triggerAiResponse();
    });

    // 日记编辑模态框的按钮
    document.getElementById('cancel-diary-edit-btn').addEventListener('click', () => {
        document.getElementById('edit-diary-modal').classList.remove('visible');
    });
    document.getElementById('save-diary-edit-btn').addEventListener('click', saveDiaryEdit);

    // 日记列表的事件委托，处理编辑和删除
    document.getElementById('diary-list').addEventListener('click', (e) => {
        const editBtn = e.target.closest('.diary-edit-btn');
        const deleteBtn = e.target.closest('.diary-delete-btn');
        if (editBtn) {
            openDiaryEditModal(editBtn.dataset.id);
        }
        if (deleteBtn) {
            deleteDiaryEntry(deleteBtn.dataset.id);
        }
    });

    // 监听日记编辑框的输入，更新字数统计
    const diaryTextInput = document.getElementById('diary-text-input');
    const diaryCharCounter = document.getElementById('diary-char-counter');
    diaryTextInput.addEventListener('input', () => {
        const count = diaryTextInput.value.length;
        diaryCharCounter.textContent = `${count} / 150`;
    });

}

/**
 * 打开并填充“心声”弹窗 (单聊)
 */
function openStatusModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    document.getElementById('status-modal-thought').textContent = chat.displayStatus?.innerThought || '...';
    document.getElementById('status-modal-jottings').textContent = chat.displayStatus?.randomJottings || '...';
    document.getElementById('status-modal').classList.add('visible');
}

/**
 * 【最终正式版】打开并填充群聊心声弹窗
 */
function openGroupStatusModal() {
    try {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.isGroup) return;

        const modal = document.getElementById('group-status-modal');
        const listEl = document.getElementById('group-status-list');
        listEl.innerHTML = '';

        if (!chat.members || chat.members.length === 0) {
             listEl.innerHTML = '<p>这个群还没有成员哦。</p>';
        } else {
            chat.members.forEach(member => {
                if (!member) {
                    console.error("发现一个空的成员对象，已跳过。");
                    return;
                }
                if (!member.displayStatus) {
                    member.displayStatus = { innerThought: '...', randomJottings: '...' };
                }
                const item = document.createElement('div');
                item.className = 'thought-content';
                const heartfeltVoice = member.displayStatus.innerThought || '...';
                const randomJottings = member.displayStatus.randomJottings || '...';

                item.innerHTML = `
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px;">
        <img src="${member.avatar || defaultGroupMemberAvatar}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; flex-shrink: 0;">
        <div style="font-weight: 600; color: #1E1E1E;">${member.groupNickname || member.originalName || '未知成员'}</div>
    </div>
    <div class="voice">
        <div class="label">
            <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
            心声
        </div>
        <p class="text">${heartfeltVoice}</p>
    </div>
    <div style="height: 6px;"></div>
    <div class="jottings">
        <div class="label">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
            散记
        </div>
        <p class="text">${randomJottings}</p>
    </div>
`;
                listEl.appendChild(item);
            });
        }

        modal.classList.add('visible');

    } catch (error) {
        // 在正式版中，我们将错误信息打印到控制台，而不是用弹窗打扰用户
        console.error("【严重错误】打开群聊心声弹窗时发生崩溃:", error);
    }
}


/**
 * 打开指定角色的日记本界面
 */
function openDiaryScreen(characterId) {
    currentDiaryCharacterId = characterId;
    const character = state.chats[characterId];
    if (!character) return;
    document.getElementById('diary-screen-title').textContent = `${character.name}的日记`;
    renderDiaryList();
    showScreen('diary-screen');
}

/**
 * 渲染日记列表
 */
function renderDiaryList() {
    const character = state.chats[currentDiaryCharacterId];
    const container = document.getElementById('diary-list');
    container.innerHTML = '';

    if (!character || !character.diary || character.diary.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">日记本还是空的呢...</p>';
        return;
    }

    [...character.diary].reverse().forEach(entry => {
        const card = document.createElement('div');
        card.className = 'diary-card';
        const date = new Date(entry.timestamp);
        const dateString = `${date.getFullYear()}年${String(date.getMonth() + 1).padStart(2, '0')}月${String(date.getDate()).padStart(2, '0')}日 ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;        
        card.innerHTML = `
            <div class="card-header">
                <span class="date">${dateString}</span>
                <div class="actions">
                    <button class="diary-edit-btn" data-id="${entry.id}" title="编辑">✏️</button>
                    <button class="diary-delete-btn" data-id="${entry.id}" title="删除">🗑️</button>
                </div>
            </div>
            <div class="card-body">${entry.content}</div>
        `;
        container.appendChild(card);
    });
}

/**
 * 打开日记编辑弹窗
 */
function openDiaryEditModal(diaryId) {
    const character = state.chats[currentDiaryCharacterId];
    const entry = character.diary.find(d => d.id === diaryId);
    if (!entry) return;

    const modal = document.getElementById('edit-diary-modal');
    modal.dataset.editingId = entry.id;
    const textInput = document.getElementById('diary-text-input');
    textInput.value = entry.content;
    document.getElementById('diary-char-counter').textContent = `${entry.content.length} / 150`;
    modal.classList.add('visible');
}

/**
 * 保存对日记的修改
 */
async function saveDiaryEdit() {
    const modal = document.getElementById('edit-diary-modal');
    const diaryId = modal.dataset.editingId;
    const newContent = document.getElementById('diary-text-input').value.trim();

    if (!newContent) {
        alert('日记内容不能为空哦。');
        return;
    }

    const character = state.chats[currentDiaryCharacterId];
    const entryIndex = character.diary.findIndex(d => d.id === diaryId);

    if (entryIndex > -1) {
        character.diary[entryIndex].content = newContent;
        await db.chats.put(character); // 保存到数据库
        renderDiaryList();
        modal.classList.remove('visible');
        alert('日记已更新');
    }
}

/**
 * 删除一条日记
 */
async function deleteDiaryEntry(diaryId) {
    const confirmed = await showCustomConfirm(
        '删除日记',
        '真的要撕掉这一页日记吗？',
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        const character = state.chats[currentDiaryCharacterId];
        character.diary = character.diary.filter(d => d.id !== diaryId);
        await db.chats.put(character); // 保存到数据库
        renderDiaryList();
        alert('一页回忆随风去啦...');
    }
}

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为群聊面板中的复用按钮绑定与单聊相同的功能
document.getElementById('send-photo-btn-group').addEventListener('click', () => document.getElementById('send-photo-btn').click());
document.getElementById('upload-image-btn-group').addEventListener('click', () => document.getElementById('upload-image-btn').click());
document.getElementById('transfer-btn-group').addEventListener('click', () => document.getElementById('transfer-btn').click());
// ▼▼▼ 请用这段【新代码】替换旧的 'send-waimai-request-btn' 事件监听器 ▼▼▼
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {waimaiModal.classList.add('visible');// 【核心修复】打开外卖弹窗后，立刻关闭功能面板closePlusPanel();
});
// 将 .click() 修改为直接调用函数
document.getElementById('share-link-btn-group').addEventListener('click', () => openShareLinkModal());document.getElementById('regenerate-btn-group').addEventListener('click', () => document.getElementById('regenerate-btn').click());

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为“保存预设”按钮绑定点击事件
document.getElementById('save-bubble-preset-btn').addEventListener('click', saveCurrentBubbleCssAsPreset);

// 【全新】使用事件委托处理“应用”、“编辑”和“删除”按钮的点击
document.getElementById('bubble-presets-list').addEventListener('click', async (e) => {
    const target = e.target;
    const presetId = parseInt(target.dataset.id);

    if (isNaN(presetId)) return;

    // 如果点击的是“应用”按钮
    if (target.classList.contains('apply-btn')) {
        const preset = await db.bubblePresets.get(presetId);
        if (preset) {
            const cssInput = document.getElementById('custom-css-input');
            cssInput.value = preset.css;
            updateSettingsPreview(); // 应用后立即更新预览
        }
    }

    // 如果点击的是“编辑”按钮
    if (target.classList.contains('edit-btn')) {
        handleEditBubblePreset(presetId);
    }

    // 如果点击的是“删除”按钮
    if (target.classList.contains('delete-btn')) {
        const confirmed = await showCustomConfirm('删除预设', '确定要删除这个气泡预设吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.bubblePresets.delete(presetId);
            await renderBubblePresets(); // 删除后立即刷新列表
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// ▼▼▼ 请用这段【新代码】替换旧的 plusBtn 事件监听器 ▼▼▼

// ▼▼▼ 请用这段【新代码】替换从 “// 【全新】为“+”号按钮添加点击事件” 开始的那整块代码 ▼▼▼

// 【全新增强版】为"+"号按钮添加点击事件，根据聊天类型显示不同面板
const plusBtn = document.getElementById('chat-plus-btn');
const singlePanel = document.getElementById('chat-plus-panel-single');
const groupPanel = document.getElementById('chat-plus-panel-group');

if (plusBtn && singlePanel && groupPanel) {
    plusBtn.addEventListener('click', () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 根据是否为群聊，决定要操作哪个面板
    const targetPanel = chat.isGroup ? groupPanel : singlePanel;
    const otherPanel = chat.isGroup ? singlePanel : groupPanel;

    // 获取聊天界面容器和消息区域
    const chatInterface = document.getElementById('chat-interface-screen');
    const messagesContainer = document.getElementById('chat-messages');

    // 切换目标面板的显示状态
    const isCurrentlyVisible = targetPanel.classList.contains('visible');
    targetPanel.classList.toggle('visible');
    
    // 根据面板状态调整聊天界面
    if (!isCurrentlyVisible) {
        // 面板即将展开
    chatInterface.classList.add('panel-expanded');
    
    // 【核心修正】恢复滚动逻辑，但移除 behavior: 'smooth'
    if (messagesContainer && messagesContainer.scrollHeight > messagesContainer.clientHeight) {
        // 立即滚动到底部，为接下来的CSS动画准备好视觉位置
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
} else {
        // 面板即将收起
        chatInterface.classList.remove('panel-expanded');
    }
    
    // 确保另一个面板总是隐藏的
    if (otherPanel.classList.contains('visible')) {
        otherPanel.classList.remove('visible');
        // 如果另一个面板被关闭，也需要检查是否还有面板展开
        if (!targetPanel.classList.contains('visible')) {
            chatInterface.classList.remove('panel-expanded');
        }
    }
    });
}

// ▼▼▼ 面板滑动翻页功能 ▼▼▼
// ▼▼▼ 请用这个【修正后】的函数，完整替换您现有的旧版本 ▼▼▼
function initializePanelSwipe() {
    const panels = [singlePanel, groupPanel];
    
    panels.forEach(panel => {
        if (!panel) return;
        
        const container = panel.querySelector('.plus-panel-container');
        const pagesContainer = panel.querySelector('.plus-panel-pages');
        const dots = panel.querySelectorAll('.pagination-dot');
        const pages = panel.querySelectorAll('.plus-panel-page');
        
        if (!container || !pagesContainer || !dots.length || !pages.length) return;
        
        let currentPage = 1;
        let startX = 0;
        let startY = 0; // 新增：记录起始Y坐标
        let isDragging = false;
        let swipeDirection = null; // 新增：记录滑动方向

        function updatePage(pageNumber) {
            currentPage = pageNumber;
            const translateX = (pageNumber - 1) * -50;
            pagesContainer.style.transform = `translateX(${translateX}%)`;
            dots.forEach((dot, index) => dot.classList.toggle('active', index + 1 === pageNumber));
            pages.forEach((page, index) => page.classList.toggle('active', index + 1 === pageNumber));
        }

        function handleStart(clientX, clientY) {
            startX = clientX;
            startY = clientY; // 新增
            isDragging = true;
            swipeDirection = null; // 重置方向
            pagesContainer.style.transition = 'none';
        }

        function handleMove(clientX, clientY) {
            if (!isDragging) return;

            const deltaX = clientX - startX;
            const deltaY = clientY - startY; // 新增

            // --- 核心修改1：判断滑动方向 ---
            if (swipeDirection === null) {
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) { // 超过阈值才判断
                    swipeDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                }
            }

            // --- 核心修改2：只有水平滑动时才阻止默认行为并移动面板 ---
            if (swipeDirection === 'horizontal') {
                event.preventDefault(); // 在这里才阻止！
                const currentTransform = (currentPage - 1) * -50;
                const newTransform = currentTransform + (deltaX / container.offsetWidth) * 50;
                const maxTransform = Math.max(-100, Math.min(0, newTransform));
                pagesContainer.style.transform = `translateX(${maxTransform}%)`;
            }
        }

        function handleEnd(clientX) {
            if (!isDragging) return;
            isDragging = false;
            pagesContainer.style.transition = 'transform 0.3s ease';

            if (swipeDirection === 'horizontal') {
                const deltaX = clientX - startX;
                const threshold = 50; // 滑动超过50像素才翻页

                if (deltaX < -threshold) {
                    // 向左滑动，下一页
                    if (currentPage < 3) {
                        updatePage(currentPage + 1);
                    } else {
                        updatePage(currentPage); // 已在最后一页，弹回
                    }
                } else if (deltaX > threshold) {
                    // 向右滑动，上一页
                    if (currentPage > 1) {
                        updatePage(currentPage - 1);
                    } else {
                        updatePage(currentPage); // 已在第一页，弹回
                    }
                } else {
                    updatePage(currentPage); // 滑动不够，弹回
                }
            } else {
                 updatePage(currentPage); // 垂直滑动或点击，弹回
            }
        }

        // --- 触摸事件（移动端）---
        container.addEventListener('touchstart', (e) => {
            // --- 核心修改3：不再在这里调用 e.preventDefault() ---
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
            // 将 event 传给 handleMove
            handleMove(e.touches[0].clientX, e.touches[0].clientY, e);
        }, { passive: false });

        container.addEventListener('touchend', (e) => {
            handleEnd(e.changedTouches[0].clientX);
        });

        // --- 鼠标事件（桌面端，逻辑保持基本不变）---
        container.addEventListener('mousedown', (e) => {
             e.preventDefault();
             handleStart(e.clientX, e.clientY);
        });
         document.addEventListener('mousemove', (e) => {
             if (isDragging) {
                 handleMove(e.clientX, e.clientY, e);
             }
         });
         document.addEventListener('mouseup', (e) => {
             if (isDragging) {
                 handleEnd(e.clientX);
             }
         });

        // 点击指示器切换页面
        dots.forEach((dot, index) => {
            dot.addEventListener('click', () => {
                updatePage(index + 1);
            });
        });
    });
}

// ▼▼▼ 打开IndexedDB（全局函数，支持Promise）▼▼▼
function openDatabaseAsync() {
    return new Promise((resolve, reject) => {
        // 先尝试直接打开数据库，看看是否已经存在
        const request = indexedDB.open('phoneDatabase');

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            // 只在必要时创建objectStore
            if (!db.objectStoreNames.contains('worldEvents')) {
                db.createObjectStore('worldEvents', { keyPath: 'id' });
            }
        };

        request.onsuccess = () => {
            resolve(request.result);
        };

        request.onerror = () => {
            reject(request.error);
        };
    });
}
// ▲▲▲ openDatabaseAsync函数结束 ▲▲▲

// ▼▼▼ 大世界事件模态框事件处理 ▼▼▼
function initializeWorldEventModal() {
    const worldEventBtn = document.getElementById('world-event-btn');
    const worldEventModal = document.getElementById('world-event-modal');
    const worldEventInput = document.getElementById('world-event-input');
    const generateBtn = document.getElementById('world-event-generate-btn');

    if (!worldEventBtn || !worldEventModal) return;

    // 点击图标打开模态框
    worldEventBtn.addEventListener('click', async () => {
        // 先关闭面板
        const chatInterface = document.getElementById('chat-interface-screen');
        const singlePanel = document.getElementById('chat-plus-panel-single');
        const groupPanel = document.getElementById('chat-plus-panel-group');

        singlePanel.classList.remove('visible');
        groupPanel.classList.remove('visible');
        chatInterface.classList.remove('panel-expanded');
        scrollToBottom();

        worldEventModal.classList.add('visible');
        // 加载该聊天的大世界事件数据
        const activeChatId = state.activeChatId;
        if (activeChatId && worldEventInput) {
            const savedEvents = await getWorldEventsByChat(activeChatId);
            if (savedEvents) {
                worldEventInput.value = savedEvents;
                console.log('已加载聊天 ' + activeChatId + ' 的大世界事件');
            } else {
                // 如果没有保存的事件，清空输入框（避免显示其他角色的数据）
                worldEventInput.value = '';
                console.log('聊天 ' + activeChatId + ' 暂无大世界事件');
            }
        }
    });

    // 点击模态框外部关闭（关闭时自动保存）
    worldEventModal.addEventListener('click', async (e) => {
        if (e.target === worldEventModal) {
            // 关闭前自动保存输入框的内容
            if (worldEventInput && worldEventInput.value && worldEventInput.value.trim()) {
                const activeChatId = state.activeChatId;
                if (activeChatId) {
                    try {
                        await saveWorldEventsToDatabase(activeChatId, worldEventInput.value.trim());
                        console.log('模态框关闭时自动保存大世界事件');
                    } catch (error) {
                        console.warn('模态框关闭时保存大世界事件失败:', error);
                    }
                }
            }
            worldEventModal.classList.remove('visible');
        }
    });

    // 点击生成按钮
    if (generateBtn) {
        generateBtn.addEventListener('click', async () => {
            await generateWorldEvents();
        });
    }


    // 大世界事件生成函数
    async function generateWorldEvents() {
        try {
            const activeChatId = state.activeChatId;
            const chat = state.chats[activeChatId];

            if (!activeChatId || !chat) {
                alert('请先选择一个聊天');
                return;
            }

            generateBtn.disabled = true;
            generateBtn.textContent = '生成中...';

            const systemPrompt = buildWorldEventPrompt(chat);
            console.log('🌍 发送给AI的Prompt:\n', systemPrompt);

            const messagesPayload = [
                { role: 'user', content: '生成5条大世界事件，按格式直接输出，不要任何解释性语句。' }
            ];

            const { proxyUrl, apiKey, selectedModel, model: configModel } = state.apiConfig;
            const model = selectedModel || configModel || state.apiConfig.model || 'gpt-3.5-turbo';
            const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';

            console.log('🌍 API配置检查 - model:', model, 'proxyUrl:', proxyUrl, 'apiKey:', apiKey ? '已设置' : '未设置');

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = isGemini ? toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini) : null;

            console.log(`🌡️ [大世界事件API] 使用的温度值: ${parseFloat(state.apiConfig.temperature) || 0.8}`);
            console.log(`💬 [大世界事件API] messagesPayload:`, messagesPayload);

            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                })
            });

            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    errorMsg += ` - ${await response.text()}`;
                }
                throw new Error(errorMsg);
            }

            const data = await response.json();
            const generatedEvents = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            console.log('🌍 API返回的内容:', generatedEvents);

            if (worldEventInput) {
                worldEventInput.value = generatedEvents;
            }

            await saveWorldEventsToDatabase(activeChatId, generatedEvents);

            generateBtn.disabled = false;
            generateBtn.textContent = '生成';

        } catch (error) {
            console.error('生成大世界事件失败:', error);
            alert('生成失败: ' + error.message);
            generateBtn.disabled = false;
            generateBtn.textContent = '生成';
        }
    }

    // 构建大世界事件prompt（参考单聊prompt）
    function buildWorldEventPrompt(chat) {
        // 【核心记忆上下文】- 参照单聊的处理方式
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `## 【核心记忆】
${chat.memorySummary.trim()}
`;
        }

        // 获取世界书内容（参照单聊的处理方式，过滤掉名字带"表情包"的世界书）
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                // 过滤掉名字带"表情包"的世界书
                if (!worldBook || !worldBook.content || worldBook.name.includes('表情包')) {
                    return '';
                }
                return `## 世界书: ${worldBook.name}\n${worldBook.content}`;
            }).filter(Boolean).join('\n\n');
            if (linkedContents) {
                worldBookContent = `\n${linkedContents}\n`;
            }
        }

        // 获取记忆锚点（从哪条消息开始计算历史）
        const memoryAnchor = chat.settings.memoryAnchor || 0;

        // 获取所有相关的历史消息（最近的历史记录）
        const historySlice = chat.history.slice(memoryAnchor);

        // 应用8条消息规则：只取最近8条消息的完整内容，更早的消息用摘要
        const recentMessages = historySlice.slice(-8);
        const recentMessageTimestamps = new Set(recentMessages.map(msg => msg.timestamp));

        let allMemories = '';
        if (historySlice.length > 0) {
            const memoryTexts = historySlice.map(msg => {
                let sender = '未知';
                if (msg.role === 'user') {
                    sender = chat.settings.myNickname || '用户';
                } else if (msg.senderName) {
                    sender = msg.senderName;
                } else {
                    sender = chat.name;
                }

                let content;

                // 处理特殊消息类型（参照单聊的处理方式）
                if (msg.type === 'user_photo') {
                    content = `[用户发送了一张照片，内容是：'${msg.content}']`;
                } else if (msg.type === 'voice_message') {
                    content = `[用户发来一条语音消息，内容是：'${msg.content}']`;
                } else if (msg.type === 'transfer') {
                    content = `[用户转账：${msg.amount}元，备注：${msg.note}]`;
                } else if (msg.type === 'gift') {
                    content = `[用户赠送礼物：${msg.giftName}，价值${msg.giftPrice}元]`;
                } else if (msg.type === 'waimai_request') {
                    content = `[用户外卖代付请求：${msg.productInfo}，金额${msg.amount}元]`;
                } else if (msg.meaning) {
                    content = `[表情：${msg.meaning}]`;
                } else if (msg.type === 'ai_image') {
                    content = `[AI发送了一张图片：${msg.content}]`;
                } else if (msg.type === 'sticker') {
                    content = `[表情包：${msg.meaning || '(无描述)'}]`;
                } else {
                    // 普通消息：对超过8条之外的AI消息，优先使用摘要
                    if (msg.role === 'assistant' && !recentMessageTimestamps.has(msg.timestamp)) {
                        content = extractAbstractContent(extractMessageContent(msg)) || extractMessageContent(msg);
                    } else {
                        content = extractMessageContent(msg);
                    }
                }

                const truncatedContent = String(content || '').substring(0, 300);
                const msgTime = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '时间未知';
                return `(${msgTime}) ${sender}: ${truncatedContent}`;
            }).join('\n');

            if (memoryTexts) {
                allMemories = memoryTexts;
            }
        }

        if (!allMemories) {
            allMemories = '无历史记录';
        }

        // 构建系统提示词
        const systemPrompt = `你是${chat.name}所在世界的叙述者。你需要生成该世界独立运转的事件。

# 你的核心角色设定 (Persona)：

 ${chat.name}
${chat.settings.aiPersona}

## 对话者的角色设定（用户身份）：
${chat.settings.myPersona}

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。
${worldBookContent}

## 【与用户的对话历史】
下面是你与用户的核心记忆和近期对话历史，对话历史发生的时间点在核心记忆之后，你必须仔细参考：
${coreMemoryContext}
${allMemories}


## 【世界运行规则】
1. 世界独立存在并持续运转，事件与角色目标优先，用户仅为其中一部分
2. 一切角色出场、行动与事件发展须基于世界逻辑与角色自身动机，不得为剧情或用户刻意调整
3. 世界事件在后台连续存在，角色可通过环境、公告、街景、新闻、社交动态等感知变化并作出自然反应
4. 环境状态(天气、节日氛围、时间痕迹)持续保留，形成自然的生活节奏与时序变化

## 【事件推进机制 - 核心铁律】
【绝对禁止】重复生成已经在"对话历史"或"核心记忆"中出现过的事件、情节、话题或场景。
【强制要求】每次生成的事件必须在时间线上向后推进，创造新的剧情节点和话题可能性。

具体执行标准：
1. 生成前必读：仔细阅读上方"对话历史"和"核心记忆"中已经发生的所有事件、情节、对话话题
2. 严格避免重复：
   - 禁止生成已经讨论过的话题（如：已聊过"今天天气很好"，则不能再生成类似天气闲聊事件）
   - 禁止重复已发生的情节（如：已经约过咖啡，则不能再生成类似约咖啡事件）
   - 禁止重复相同场景（如：已经在公园遇见过，则应换其他场所或推进后续）
3. 动态向后推进：
   - 基于已有剧情，生成"接下来会发生什么"而不是"重新发生一次"
   - 事件应能推动角色关系变化、情节深化或引入新话题
   - 每个事件都要对后续聊天产生实质性的话题价值
4. 时间连续性：
   - 事件时间点必须在最近一条对话之后
   - 体现时间流逝带来的变化（天气转变、季节推移、节日临近等）
5. 剧情延伸性：
   - 可以是已有事件的后续发展（如：昨天约了咖啡 → 今天讨论咖啡店的新菜单）
   - 可以是角色状态的自然变化（如：考试结束 → 成绩公布 → 庆祝/反思）
   - 可以是全新但合理的独立事件（符合世界逻辑和角色日常）

【自检问题】生成前必须回答：
- 这个事件在对话历史/核心记忆中是否已经发生过类似的？
- 这个事件能否为接下来的聊天提供新话题？
- 这个事件是否在时间线上向后推进了剧情？
如有任何一项回答为"否"，则必须重新构思事件。

## 【世界事件机制】
每轮生成5条独立世界事件，遵循宏观→中观→微观三层结构，每个结构都要有事件：
- 宏观：国家/势力/世界级事件
- 中观：城镇/组织/社区/环境变化
- 微观：局部空间、自然/社会日常

概率机制：
- 日常琐事高频
- 重大事件低频
- 偶遇极低频

每个事件需标注：
- 感知强度(高/中/低)
- 潜在影响类型(行动/心理/语言/日常调整)

角色依据距离、信息来源与兴趣决定是否感知并作出反应：
- 高强度 → 必然或高度可能改变行动
- 中强度 → 引起停留或轻微行为调整
- 低强度 → 仅形成短暂心理关注

节日、纪念日、生日属于中观/微观层事件，随时间自然生成并影响氛围。
每轮需明确日期、昼夜状态与周末/工作日，节日前后氛围逐步累积→当天高潮→节后淡化。

## 【角色独立性与行为逻辑】
- 角色按自身性格、职业、学业与作息独立运作，可在无用户参与下推动剧情
- 行动受现实约束(时间、距离、交通、成本)，不得出现超现实或非逻辑行为
- 情绪与语言必须符合角色性格与事件逻辑，避免突兀或为剧情服务
- 信息获取、传播与认知须在合理范围内，禁止全知视角
- 角色允许闲逛、观察、思考、旁观他人事件，以展现生活化与心理层反应

节日/生日行为链(必须执行)：
  - 触发条件：世界事件、公告、社交动态等含节日或熟人生日信息
  - 执行链：察觉 → 决策 → 准备 → 执行 → 当天体现
  - 行动内容：出行、购买、布置、祝福等，须受现实条件约束
  - 角色根据性格与关系强度选择庆祝、敷衍或忽略，但心理/行为反应不可缺失
  - 节日前后状态需体现筹备→当天→淡化的节奏

时间敏感性落地：
  - 角色需记忆日期与节日并主动规划
  - 昼夜影响作息与外出
  - 环境或新闻触发计划更新与行动调整

## 【输出要求】
【严格执行】生成顺序：① 世界事件 → ② 角色行动 → ③ 与用户交集

生成前必须说明当前时间、日期与昼夜状态。

环境因素(天气、季节、节日、作息)须对衣着、出行与互动产生显著影响，否则输出无效。

每轮事件中必须包含至少一个"日常琐事"层级事件，与天气或时间段叠加形成生活化节奏。

角色行动应基于兴趣与目标，自然体现停留、观察或思考，不得为剧情牵引。

互动触发规则：
  - 出场与交集必须概率合理
  - 偶遇仅在日程重合且社会逻辑成立时出现
  - 陌生人交集极少且短暂
  - 节日与昼夜环境可微调遇见概率

违规自修正：
  - 若角色为剧情或用户而违背自身逻辑 → 替换为合理动机
  - 若环境与天气未影响行动 → 强制添加生活化反应
  - 若节日链未执行 → 自动补全节日察觉与行为片段
  - 若角色行动无现实约束(时间/距离/体力/金钱) → 调整为合理执行方案
  - 若世界事件、角色行动与用户交集混写 → 拆分为独立模块重新生成

## 【强制输出前自检流程（必须在内心自问自答）】
1. 每个事件的描述是否体现了真实的世界逻辑，而不是为了推动剧情或迎合用户？
2. 角色在这些事件中的反应是否符合TA的人设和动机，而不是被动地为剧情服务？
3. 我生成的事件是否避免了不平等关系隐喻（如支配/服从、攻略/通关、物化等）？


## 【输出格式】
【事件X】(宏观/中观/微观)
标题：[事件标题]
感知强度：[高/中/低]
影响类型：[影响类型]
描述：[事件描述，200字以内]

---

请直接输出生成5条事件，不要有任何解释性语句。`;

        return systemPrompt;
    }

    // 构建世界书内容（简化版）
    function buildWorldBookContent(worldBookData) {
        if (!worldBookData || !Array.isArray(worldBookData)) return '无世界书';
        return worldBookData.map(item => item.content || item.description || '').join('\n');
    }

    // 保存大世界事件到数据库
    async function saveWorldEventsToDatabase(chatId, events) {
        try {
            // 打开IndexedDB
            const db = await openDatabaseAsync();
            const transaction = db.transaction(['worldEvents'], 'readwrite');
            const objectStore = transaction.objectStore('worldEvents');

            // 生成事件ID（基于聊天ID）
            const eventId = `world_events_${chatId}`;

            // 创建事件记录
            const eventRecord = {
                id: eventId,
                chatId: chatId,
                content: events,
                timestamp: Date.now(),
                characterName: state.chats[chatId]?.characterName || 'Unknown'
            };

            // 保存到数据库（如果已存在则覆盖）
            await new Promise((resolve, reject) => {
                const request = objectStore.put(eventRecord);  // 使用 put 而不是 add，这样可以覆盖
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });

            console.log('大世界事件已保存到数据库 - chatId:', chatId);
        } catch (error) {
            console.error('保存大世界事件到数据库失败:', error);
            throw error;
        }
    }

    // 从数据库获取指定聊天的最新大世界事件
    async function getWorldEventsByChat(chatId) {
        try {
            const db = await openDatabaseAsync();
            const transaction = db.transaction(['worldEvents'], 'readonly');
            const objectStore = transaction.objectStore('worldEvents');

            // 查询所有记录，然后过滤出属于这个chatId的最新记录
            return new Promise((resolve, reject) => {
                const request = objectStore.getAll();
                request.onsuccess = () => {
                    const allEvents = request.result;
                    // 过滤出属于当前chatId的事件，并按时间戳倒序排列
                    const chatEvents = allEvents
                        .filter(event => event.chatId === chatId)
                        .sort((a, b) => b.timestamp - a.timestamp);

                    if (chatEvents.length > 0) {
                        // 返回最新的事件内容
                        resolve(chatEvents[0].content);
                    } else {
                        resolve(null);
                    }
                };
                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('从数据库获取大世界事件失败:', error);
            return null;
        }
    }
}

// 页面加载时初始化
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        initializeWorldEventModal();
        // 【核心】初始化NovelAI设置
        loadNovelAISettings();
    });
} else {
    initializeWorldEventModal();
    // 【核心】初始化NovelAI设置
    loadNovelAISettings();
}
// ▲▲▲ 大世界事件模态框事件处理结束 ▲▲▲

// ▼▼▼ 【全新添加】更强大的Base64解码器，用于处理特殊字符 ▼▼▼
/**
 * 解码包含Unicode字符的Base64字符串
 * @param {string} str - Base64编码的字符串
 * @returns {string} - 解码后的UTF-8字符串
 */
function decodeBase64Unicode(str) {
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【最终终极版】PNG/JPG角色卡导入核心功能 (v4.1 - 增强调试与修复) ▼▼▼

/**
 * 从图片文件中提取并解析角色数据（兼容PNG/JPG，支持zTXt解压）
 * @param {File} file - 用户选择的图片文件
 * @returns {Promise<object|null>} - 解析后的角色JSON数据，或在失败时返回null
 */
function extractCharacterDataFromImage(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const buffer = event.target.result;
            const view = new DataView(buffer);

            const isPng = view.byteLength > 8 && view.getUint32(0) === 0x89504E47 && view.getUint32(4) === 0x0D0A1A0A;
            
            try {
                if (isPng) {
                    console.log("检测到PNG文件，开始解析数据块...");
                    let offset = 8;
                    while (offset < view.byteLength) {
                        const length = view.getUint32(offset);
                        const type = String.fromCharCode(view.getUint8(offset + 4), view.getUint8(offset + 5), view.getUint8(offset + 6), view.getUint8(offset + 7));
                        
                        // 为调试添加日志，显示找到的数据块
                        console.log(`找到数据块: ${type}, 长度: ${length}`);

                        if (type === 'tEXt' || type === 'zTXt') {
                            const dataOffset = offset + 8;
                            const chunkData = new Uint8Array(buffer, dataOffset, length);
                            
                            const separatorIndex = Array.from(chunkData).indexOf(0);
                            if (separatorIndex > 0) {
                                const key = new TextDecoder('latin1').decode(chunkData.slice(0, separatorIndex));
                                
                                if (key === 'chara') {
                                    console.log("成功匹配到 'chara' 键!");
                                    let text;
                                    try {
                                        if (type === 'tEXt') {
                                            const valueData = chunkData.slice(separatorIndex + 1);
                                            text = new TextDecoder('latin1').decode(valueData);
                                        } else { // zTXt
                                            console.log("检测到 zTXt 压缩数据，正在使用 pako 解压...");
                                            const valueData = chunkData.slice(separatorIndex + 2);
                                            const decompressed = pako.inflate(valueData);
                                            text = new TextDecoder('utf-8').decode(decompressed);
                                        }
                                        
                                        const decodedData = decodeBase64Unicode(text);
                                        const charData = JSON.parse(decodedData);
                                        console.log("成功解析出角色数据！", charData);
                                        resolve(charData);
                                        return;
                                    } catch(e) {
                                        console.error(`解析 'chara' 数据时出错 (${type}):`, e);
                                        // 不停止，继续寻找下一个可能的chara块
                                    }
                                }
                            }
                        }
                        offset += 12 + length; // 移动到下一个数据块
                    }
                } else {
                    console.log("检测到非PNG文件(可能是JPG)，开始启发式扫描...");
                    const text = new TextDecoder('latin1').decode(buffer);
                    let startIndex = text.indexOf('ey'); // 'ey' 是 many base64 encoded JSONs start with
                    while(startIndex !== -1) {
                        const potentialB64 = text.substring(startIndex);
                        try {
                            const decodedData = decodeBase64Unicode(potentialB64);
                            if (decodedData.trim().startsWith('{')) {
                                const charData = JSON.parse(decodedData);
                                if (charData.name && (charData.description || charData.persona)) {
                                    console.log("成功在JPG中启发式扫描到角色数据！");
                                    resolve(charData);
                                    return;
                                }
                            }
                        } catch (e) { /* 忽略解析错误并继续 */ }
                        startIndex = text.indexOf('ey', startIndex + 1);
                    }
                }
                
                console.log("扫描完成，未在图片中找到有效的角色数据。");
                resolve(null);

            } catch (error) {
                console.error("解析角色卡时发生严重错误:", error);
                resolve(null);
            }
        };
        reader.onerror = () => {
            console.error("读取文件失败");
            resolve(null);
        };
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 【最终兼容版 v4 - 完美世界书导入】处理角色卡导入的主要逻辑
 * @param {File} file - 用户选择的图片文件
 */
async function handleCharacterCardImport(file) {
    if (!file) return;
    if (!state.activeChatId) {
        alert("请先进入一个聊天窗口再导入角色卡！");
        return;
    }

    const rawCharData = await extractCharacterDataFromImage(file);
    
    // 步骤 1: 智能定位核心数据 (兼容TavernAI V2卡和旧版卡)
    const charData = rawCharData?.data ? rawCharData.data : rawCharData;
    const persona = charData?.persona || charData?.description;

    if (!charData || !persona) {
        await showCustomAlert('导入失败', '无法从此图片中读取有效的角色数据。请确保这是一个标准的PNG角色卡。\n\n提示：你可以使用“角色卡诊断工具”来查看图片内部的原始数据。');
        return;
    }

    const chat = state.chats[state.activeChatId];
    
    // 步骤 2: 更新人设
    chat.settings.aiPersona = persona;
    const personaTextarea = document.getElementById('ai-persona');
    if(personaTextarea) personaTextarea.value = persona;
    
    let worldBooksImported = 0;
    let characterNameForCategory = charData.name || "导入角色"; // 使用角色卡的名字作为分类名

    // ================== 【全新、更健壮的世界书解析逻辑】 ==================

    // 检查是否存在符合你提供的 character_book 格式的数据
    if (charData.character_book && Array.isArray(charData.character_book.entries)) {
        const bookData = charData.character_book;
        const entries = bookData.entries;

        if (entries.length > 0) {
            // 步骤 3: 检查或创建以角色名命名的分类
            let category = await db.worldBookCategories.where('name').equals(characterNameForCategory).first();
            let categoryId;
            if (!category) {
                // 如果分类不存在，就创建一个新的
                categoryId = await db.worldBookCategories.add({ name: characterNameForCategory });
            } else {
                categoryId = category.id;
            }

            const booksToUpdate = [];
            for (const entry of entries) {
                // 智能获取条目名称: 优先使用 "name" 字段，如果没有，则使用 "comment" 字段
                const bookName = entry.name || entry.comment;
                const bookContent = entry.content;

                // 【核心过滤】: 必须同时有名称和有效内容才进行导入
                if (!bookName || !bookContent || !bookContent.trim()) {
                    continue; // 跳过无效条目
                }

                // 检查这个条目是否已存在于此分类中
                const existingBook = await db.worldBooks.where({ name: bookName, categoryId: categoryId }).first();
                
                if (existingBook) {
                    // 如果已存在，则更新内容
                    existingBook.content = bookContent;
                    booksToUpdate.push(existingBook);
                } else {
                    // 如果不存在，则创建新条目
                    booksToUpdate.push({
                        id: 'wb_' + Date.now() + '_' + Math.random().toString(16).slice(2),
                        name: bookName,
                        content: bookContent,
                        categoryId: categoryId // 关联到新建的分类
                    });
                }
            }

            if (booksToUpdate.length > 0) {
                await db.worldBooks.bulkPut(booksToUpdate);
                worldBooksImported = booksToUpdate.length;

                // 更新内存中的 state.worldBooks，确保数据同步
                for (const book of booksToUpdate) {
                    const existingIndex = state.worldBooks.findIndex(wb => wb.id === book.id);
                    if (existingIndex > -1) {
                        state.worldBooks[existingIndex] = book;
                    } else {
                        state.worldBooks.push(book);
                    }
                }
            }
        }
    }
    
    // ================== 【世界书解析逻辑结束】 ==================

    await db.chats.put(chat);
    
    let successMessage = `角色 “${charData.name || '未知'}” 的人设已成功导入！`;
    if (worldBooksImported > 0) {
        successMessage += `\n\n同时，成功导入了 ${worldBooksImported} 条世界书条目到 “${characterNameForCategory}” 分类下。`;
        // 如果当前就在世界书页面，则立即刷新
        if(document.getElementById('world-book-screen').classList.contains('active')) {
            await renderWorldBookScreen();
        }
    }
    
    await showCustomAlert('导入成功', successMessage);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
/**
 * 【辅助函数】将解析好的世界书条目保存到数据库
 * @param {Array} booksToImport - 包含{name, content}对象的数组
 * @param {number|null} categoryId - 目标分类的ID，如果为null则为未分类
 * @returns {Promise<number>} - 成功导入/更新的条目数量
 */
async function saveWorldBookEntries(booksToImport, categoryId) {
    const booksToUpdate = [];
    for (const newBook of booksToImport) {
        // 根据是否有categoryId，查询条件不同
        const query = categoryId ? { name: newBook.name, categoryId: categoryId } : { name: newBook.name, categoryId: null };
        const existingBook = await db.worldBooks.where(query).first();
        
        if (existingBook) {
            existingBook.content = newBook.content;
            booksToUpdate.push(existingBook);
        } else {
            booksToUpdate.push({
                id: 'wb_' + Date.now() + '_' + Math.random().toString(16).slice(2),
                name: newBook.name,
                content: newBook.content,
                categoryId: categoryId // 应用传入的分类ID
            });
        }
    }

    if (booksToUpdate.length > 0) {
        await db.worldBooks.bulkPut(booksToUpdate);
        // 同步内存中的 state
        for (const book of booksToUpdate) {
            const existingIndex = state.worldBooks.findIndex(wb => wb.id === book.id);
            if (existingIndex > -1) {
                state.worldBooks[existingIndex] = book;
            } else {
                state.worldBooks.push(book);
            }
        }
    }
    return booksToUpdate.length;
}

/**
 * 【辅助函数】弹出模态框，让用户选择分类
 * @param {Array} parsedBooks - 已从文件解析出的书籍对象数组
 * @returns {Promise<{choice: string, name?: string}|null>} - 用户的选择
 */
async function promptForCategoryChoice(parsedBooks) {
    return new Promise(async (resolve) => {
        const modal = document.getElementById('import-wb-category-modal');
        const input = document.getElementById('import-new-category-name');
        const categorySelect = document.getElementById('import-existing-category');
        const confirmBtn = document.getElementById('confirm-import-new-category');
        const confirmExistingBtn = document.getElementById('confirm-import-existing-category');
        const uncategorizedBtn = document.getElementById('import-uncategorized');
        const cancelBtn = document.getElementById('cancel-wb-import');

        // 尝试从文件名或内容中获取一个建议的分类名
        const bookTitle = parsedBooks[0]?.name || "新分类";
        input.value = bookTitle;

        // 从数据库加载现存分类
        const existingCategories = await db.worldBookCategories.toArray();

        // 填充下拉菜单
        categorySelect.innerHTML = '<option value="">-- 选择分类 --</option>';
        existingCategories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            categorySelect.appendChild(option);
        });

        // 使用 .cloneNode(true) 来移除旧的事件监听器，防止重复触发
        const cleanConfirmBtn = confirmBtn.cloneNode(true);
        const cleanConfirmExistingBtn = confirmExistingBtn.cloneNode(true);
        const cleanUncategorizedBtn = uncategorizedBtn.cloneNode(true);
        const cleanCancelBtn = cancelBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(cleanConfirmBtn, confirmBtn);
        confirmExistingBtn.parentNode.replaceChild(cleanConfirmExistingBtn, confirmExistingBtn);
        uncategorizedBtn.parentNode.replaceChild(cleanUncategorizedBtn, uncategorizedBtn);
        cancelBtn.parentNode.replaceChild(cleanCancelBtn, cancelBtn);

        // 为新按钮绑定事件
        cleanConfirmBtn.onclick = () => {
            const categoryName = input.value.trim();
            if (!categoryName) {
                alert('分类名称不能为空！');
                return;
            }
            modal.classList.remove('visible');
            resolve({ choice: 'new', name: categoryName });
        };

        cleanConfirmExistingBtn.onclick = () => {
            const selectedCategoryId = categorySelect.value;
            if (!selectedCategoryId) {
                alert('请选择一个分类！');
                return;
            }
            const selectedCategory = existingCategories.find(cat => cat.id == selectedCategoryId);
            modal.classList.remove('visible');
            resolve({ choice: 'existing', categoryId: selectedCategoryId, categoryName: selectedCategory.name });
        };

        cleanUncategorizedBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve({ choice: 'uncategorized' });
        };

        cleanCancelBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(null); // 用户取消
        };

        modal.classList.add('visible');
    });
}

/**
 * 【全新重构版】处理独立的 .json 或 .txt 世界书文件导入
 * @param {File} file - 用户选择的文件
 */
async function handleWorldBookImport(file) {
    const fileName = file.name;
    const fileExtension = fileName.split('.').pop().toLowerCase();
    const reader = new FileReader();

    reader.onload = async (event) => {
        let parsedBooks = [];

        try {
            // 步骤 1: 解析文件内容
            if (fileExtension === 'json') {
                const fileContent = event.target.result;
                const data = JSON.parse(fileContent);
                if (data && data.entries && typeof data.entries === 'object') {
                    for (const entry of Object.values(data.entries)) {
                        const bookName = entry.comment;
                        const bookContent = entry.content;
                        if (bookName && bookContent && bookContent.trim()) {
                            parsedBooks.push({ name: bookName, content: bookContent });
                        }
                    }
                }
            } else if (fileExtension === 'txt') {
                const fileContent = event.target.result;
                const bookName = fileName.replace(/\.[^/.]+$/, '');
                if (fileContent && fileContent.trim()) {
                    parsedBooks.push({ name: bookName, content: fileContent });
                }
            } else if (fileExtension === 'docx') {
                // 使用 mammoth.js 解析 docx 文件
                const arrayBuffer = event.target.result;
                const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                const bookName = fileName.replace(/\.[^/.]+$/, '');
                if (result.value && result.value.trim()) {
                    parsedBooks.push({ name: bookName, content: result.value });
                }
            }

            if (parsedBooks.length === 0) {
                await showCustomAlert('导入提示', '文件中没有找到可以导入的有效世界书条目。');
                return;
            }

            // 步骤 2: 弹出模态框，等待用户选择
            closeUnifiedModal(); // 先关闭主管理面板
            const userChoice = await promptForCategoryChoice(parsedBooks);

            if (!userChoice) { // 用户点击了取消
                return;
            }

            // 步骤 3: 根据用户选择，执行保存
            let categoryId = null;
            let categoryName = "未分类";

            if (userChoice.choice === 'new') {
                categoryName = userChoice.name;
                let category = await db.worldBookCategories.where('name').equals(categoryName).first();
                if (!category) {
                    categoryId = await db.worldBookCategories.add({ name: categoryName });
                } else {
                    categoryId = category.id;
                }
            } else if (userChoice.choice === 'existing') {
                categoryId = userChoice.categoryId;
                categoryName = userChoice.categoryName;
            }

            const importedCount = await saveWorldBookEntries(parsedBooks, categoryId);

            // 步骤 4: 提供最终反馈
            await showCustomAlert('导入成功', `已成功导入/更新 ${importedCount} 条世界书条目到 "${categoryName}" 分类中。`);
            await renderWorldBookScreen();

        } catch (error) {
            console.error("导入世界书失败:", error);
            await showCustomAlert('导入失败', `处理文件时发生错误: ${error.message}`);
        }
    };

    reader.onerror = async () => {
        await showCustomAlert('导入失败', '读取文件时发生错误。');
    };

    // 对于 docx 文件使用 readAsArrayBuffer，对于其他文件使用 readAsText
    if (fileExtension === 'docx') {
        reader.readAsArrayBuffer(file);
    } else {
        reader.readAsText(file);
    }
}
// ▲▲▲ JavaScript功能函数定义区结束 ▲▲▲
// 初始化滑动功能
if (singlePanel && groupPanel) {
    initializePanelSwipe();
}

// ▼▼▼ 添加点击聊天消息区域时关闭面板的功能 ▼▼▼
const chatMessagesEl = document.getElementById('chat-messages');
if (chatMessagesEl) {
    chatMessagesEl.addEventListener('click', () => {
        const chatInterface = document.getElementById('chat-interface-screen');
        const singlePanel = document.getElementById('chat-plus-panel-single');
        const groupPanel = document.getElementById('chat-plus-panel-group');
        
        // 检查是否有面板展开
        if (singlePanel && groupPanel && (singlePanel.classList.contains('visible') || groupPanel.classList.contains('visible'))) {
            // 关闭所有面板
            singlePanel.classList.remove('visible');
            groupPanel.classList.remove('visible');
            if (chatInterface) chatInterface.classList.remove('panel-expanded');
        }
    });
}

// ▼▼▼ 请将这段【新代码】粘贴到 plusBtn 事件监听器的下方 ▼▼▼

// 【全新修正】为所有 class="modal" 的弹窗添加通用的外部点击关闭功能
document.getElementById('phone-screen').addEventListener('click', (e) => {
    // 检查点击的目标是否是弹窗的蒙层本身 (class 包含 'modal' 和 'visible')
    if (e.target.classList.contains('modal') && e.target.classList.contains('visible')) {
        // 如果是，就将其关闭
        e.target.classList.remove('visible');
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 【全新增强版】点击聊天消息区域时，自动收起所有功能面板
document.getElementById('chat-messages').addEventListener('click', () => {
    if (singlePanel.classList.contains('visible')) {
        singlePanel.classList.remove('visible');
    }
    if (groupPanel.classList.contains('visible')) {
        groupPanel.classList.remove('visible');
    }
});

// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 统一世界书模态框事件处理器 ▼▼▼
        document.getElementById('unified-modal-close').addEventListener('click', closeUnifiedModal);
        document.getElementById('unified-modal-done').addEventListener('click', () => {
            // Check which view is currently visible and perform appropriate action
            const createBookView = document.getElementById('unified-create-book');
            if (createBookView && createBookView.style.display !== 'none') {
                // If in create book view, save the book
                saveUnifiedBook();
            } else {
                // Otherwise just close the modal
                closeUnifiedModal();
            }
        });
        document.getElementById('unified-add-category-btn').addEventListener('click', addUnifiedCategory);

        // 世界书内容搜索功能
        const wbSearchInput = document.getElementById('wb-content-search');
        const wbSearchBtn = document.getElementById('wb-search-btn');
        const wbSearchClearBtn = document.getElementById('wb-search-clear');
        const wbContentTextarea = document.getElementById('unified-book-content');

        // 搜索框输入事件 - 只控制清除按钮显示
        wbSearchInput.addEventListener('input', function() {
            const searchText = this.value.trim();

            // 显示或隐藏清除按钮
            if (searchText) {
                wbSearchClearBtn.style.display = 'block';
            } else {
                wbSearchClearBtn.style.display = 'none';
                wbContentTextarea.classList.remove('wb-highlight');
            }
        });

        // 搜索按钮点击事件
        wbSearchBtn.addEventListener('click', function() {
            const searchText = wbSearchInput.value.trim();
            if (searchText) {
                searchInTextarea(searchText);
            }
        });

        // 支持回车键搜索
        wbSearchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const searchText = this.value.trim();
                if (searchText) {
                    searchInTextarea(searchText);
                }
            }
        });

        // 清除按钮点击事件
        wbSearchClearBtn.addEventListener('click', function() {
            wbSearchInput.value = '';
            wbSearchClearBtn.style.display = 'none';
            wbContentTextarea.classList.remove('wb-highlight');
        });

        // 搜索函数
        function searchInTextarea(searchText) {
            const content = wbContentTextarea.value;

            if (!searchText || !content) {
                wbContentTextarea.classList.remove('wb-highlight');
                return;
            }

            // 查找第一个匹配的位置
            const index = content.toLowerCase().indexOf(searchText.toLowerCase());

            if (index !== -1) {
                // 添加高亮效果
                wbContentTextarea.classList.add('wb-highlight');

                // 计算到匹配位置的行数
                const beforeText = content.substring(0, index);
                const lines = beforeText.split('\n');
                const lineNumber = lines.length - 1;

                // 聚焦textarea
                wbContentTextarea.focus();

                // 设置光标位置到匹配的文本
                wbContentTextarea.setSelectionRange(index, index + searchText.length);

                // 滚动到该行
                // 计算每行的大概高度
                const lineHeight = parseInt(window.getComputedStyle(wbContentTextarea).lineHeight) || 20;
                wbContentTextarea.scrollTop = lineNumber * lineHeight;
            } else {
                wbContentTextarea.classList.remove('wb-highlight');
            }
        }

        // 菜单项点击事件
        document.querySelectorAll('.unified-menu-item').forEach(item => {
            item.addEventListener('click', () => {
                const action = item.getAttribute('data-action');
                if (action) {
                    showUnifiedView(action);
                }
            });
        });
        
        // 使用事件委托处理动态生成的删除分类和编辑分类按钮
        document.getElementById('unified-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                if (!isNaN(categoryId)) {
                    deleteUnifiedCategory(categoryId);
                }
            } else if (e.target.classList.contains('category-edit-btn') || e.target.closest('.category-edit-btn')) {
                const btn = e.target.closest('.category-edit-btn');
                const categoryId = parseInt(btn.dataset.id);
                const categoryRow = btn.closest('.category-item-row');
                const groupName = categoryRow.querySelector('.group-name');
                if (!isNaN(categoryId)) {
                    handleCategoryEdit(categoryId, groupName.textContent, categoryRow, btn);
                }
            }
        });
        
        // 键盘快捷键支持
        document.getElementById('unified-new-category-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addUnifiedCategory();
            }
        });
        
        document.getElementById('unified-book-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('unified-book-content').focus();
            }
        });
        
        // 点击模态框背景关闭
        document.getElementById('world-book-unified-modal').addEventListener('click', (e) => {
            if (e.target.id === 'world-book-unified-modal') {
                closeUnifiedModal();
            }
        });
        // ▲▲▲ 统一世界书模态框事件处理器结束 ▲▲▲
        
        // 微信风格操作面板按钮区域点击事件：让整个按钮区域都可以点击
        document.addEventListener('click', (e) => {
            const actionBtn = e.target.closest('.wechat-action-btn');
            if (actionBtn) {
                const button = actionBtn.querySelector('button');
                if (button && !e.target.matches('button')) {
                    // 如果点击的不是button本身，就触发button的点击事件
                    e.preventDefault();
                    button.click();
                    return;
                }
            }
        });

        // 全局点击事件监听器：实现点击外部关闭微信风格操作面板
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('wechat-style-actions-panel');
            if (!panel || panel.style.display === 'none' || panel.style.opacity === '0') {
                return; // 面板不可见时直接返回
            }
            
            // 如果面板刚显示，忽略此次点击（防止长按松手时立即关闭面板）
            if (window.panelJustShown) {
                return;
            }
            
            // 检查点击的目标是否是面板本身或面板内部的元素
            if (panel.contains(e.target)) {
                // 点击了面板内部，但如果是按钮，先让按钮事件处理完再关闭面板
                const clickedButton = e.target.closest('button');
                if (clickedButton && clickedButton.id) {
                    // 延迟关闭面板，让按钮事件先执行
                    setTimeout(() => {
                        hideMessageActions();
                    }, 50);
                }
                return;
            } else {
                // 点击了面板外部，隐藏面板
                hideMessageActions();
            }
        });

        // 全局点击事件监听器：点击其他地方隐藏重roll按钮
        document.addEventListener('click', (e) => {
            // 如果没有激活的重roll按钮，直接返回
            if (!currentActiveRerollBtn) return;
            
            // 如果点击的是AI气泡或重roll按钮本身，不隐藏
            const clickedAiBubble = e.target.closest('.call-message-bubble.ai-speech');
            const clickedRerollBtn = e.target.closest('.reroll-btn');
            
            if (clickedAiBubble || clickedRerollBtn) {
                return;
            }
            
            // 点击了其他地方，隐藏重roll按钮
            hideAllRerollButtons();
        });
        // ▼▼▼ 【已移除】角色卡导入功能事件绑定已移至消息列表页面 ▼▼▼
            // ▲▲▲ 添加结束 ▲▲▲
            // ▼▼▼ 【全新】角色卡诊断工具事件绑定 ▼▼▼
document.getElementById('open-card-diagnostic-tool').addEventListener('click', () => {
    document.getElementById('card-diagnostic-modal').classList.add('visible');
    document.getElementById('diagnostic-output').textContent = '等待上传文件...';
});

document.getElementById('close-diagnostic-modal-btn').addEventListener('click', () => {
    document.getElementById('card-diagnostic-modal').classList.remove('visible');
});

document.getElementById('diagnostic-card-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    const outputEl = document.getElementById('diagnostic-output');
    if (file) {
        outputEl.textContent = '正在读取和分析文件...';
        const diagnosticResult = await diagnoseCharacterCard(file);
        outputEl.textContent = diagnosticResult;
    }
    event.target.value = null; // 为下次上传重置
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】世界书独立导入功能事件绑定 ▼▼▼
const worldBookImportInput = document.getElementById('world-book-import-input');

// 使用事件委托，为新的菜单项绑定事件
document.getElementById('unified-main-menu').addEventListener('click', (e) => {
    const menuItem = e.target.closest('.unified-menu-item');
    if (menuItem && menuItem.dataset.action === 'import-book') {
        worldBookImportInput.click(); // 点击菜单项时，触发隐藏的文件选择器
    }
});

// 监听文件选择器的变化
worldBookImportInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        handleWorldBookImport(file);
    }
    event.target.value = null; // 重置，以便下次可以选择相同的文件
});
// ▲▲▲ 新事件绑定结束 ▲▲▲

// 【全新】为“刷新记忆锚点”按钮绑定事件
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.closest('#refresh-memory-anchor-btn')) {
        const chat = state.chats[state.activeChatId];
        if (!chat) return;

        // 计算已总结消息的数量
        const summarizedCount = chat.history.filter(msg => msg.isSummarized).length;
        
        const anchorInput = document.getElementById('memory-anchor-input');
        // 将锚点设置为已总结数量，这样AI就会从第一条未总结的消息开始读取
        anchorInput.value = summarizedCount; 
        
        alert(`记忆锚点已刷新到第 ${summarizedCount} 条消息之后。请点击"保存"以生效。`);
    }
});

// 【新增】后台活动开关的事件监听
document.getElementById('background-activity-enabled-switch').addEventListener('change', function() {
    const intervalGroup = document.getElementById('background-interval-group');
    intervalGroup.style.display = this.checked ? 'block' : 'none';
});

// 【新增】朋友圈可见性开关的事件监听
document.getElementById('moments-visibility-switch').addEventListener('change', function() {
    const configGroup = document.getElementById('moments-config-group');
    configGroup.style.display = this.checked ? 'block' : 'none';
});

// 【新增】测试后台活动按钮的事件监听
document.getElementById('test-background-activity-btn').addEventListener('click', function() {
    const currentChatId = state.activeChatId;
    if (!currentChatId) {
        alert('请先选择一个角色');
        return;
    }

    const chat = state.chats[currentChatId];
    if (!chat || chat.isGroup) {
        alert('只能测试单聊角色的后台活动');
        return;
    }

    if (!chat.settings?.backgroundActivityEnabled) {
        alert('请先开启该角色的后台活动检测');
        return;
    }

    console.log(`🧪 手动测试: 强制触发角色 "${chat.name}" 的后台活动...`);
    triggerInactiveAiAction(currentChatId);

    // 给用户反馈
    const btn = this;
    const originalText = btn.textContent;
    btn.textContent = '✅ 已触发，请查看控制台';
    btn.disabled = true;
    setTimeout(() => {
        btn.textContent = originalText;
        btn.disabled = false;
    }, 3000);
});

// ========== 【查手机功能】JavaScript代码开始 ==========
// 存储手机数据的全局变量
let phoneData = {
    chats: [],
    shoppingCart: [],
    memos: [],
    browserHistory: [],
    photoAlbum: [],
    bank: { balance: 0, transactions: [] },
    trajectory: [],
    appUsage: []
};

// 保存手机数据到本地存储
function savePhoneData() {
    try {
        localStorage.setItem('phoneData', JSON.stringify(phoneData));
    } catch (error) {
        console.error('保存手机数据失败:', error);
    }
}

// 从本地存储加载手机数据
function loadPhoneData() {
    try {
        const saved = localStorage.getItem('phoneData');
        if (saved) {
            phoneData = JSON.parse(saved);
        }
    } catch (error) {
        console.error('加载手机数据失败:', error);
    }
}

// 查手机按钮事件监听器
document.getElementById('phone-check-btn').addEventListener('click', function() {
    // 【核心修正】调用通用的面板关闭函数，确保UI正确重置
    closePlusPanel();

    // 显示手机界面
    showScreen('phone-interface-screen');
    initPhoneInterface();
});

// 初始化手机界面
function initPhoneInterface() {
    const phoneHome = document.getElementById('phone-home');
    phoneHome.innerHTML = `
        <div class="phone-app-grid">
            <div class="phone-app-item" data-app="wechat">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path fill="#07C160" d="M19.5,2H4.5A2.5,2.5,0,0,0,2,4.5v10A2.5,2.5,0,0,0,4.5,17H7v3.5L10.5,17h9A2.5,2.5,0,0,0,22,14.5v-10A2.5,2.5,0,0,0,19.5,2ZM8,11.5A1.5,1.5,0,1,1,9.5,10,1.5,1.5,0,0,1,8,11.5Zm5,0A1.5,1.5,0,1,1,14.5,10,1.5,1.5,0,0,1,13,11.5Z"/>
                    </svg>
                </div>
                <div class="phone-app-label">微信</div>
            </div>
            <div class="phone-app-item" data-app="shopping">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path fill="#FF6B35" d="M17,18a2,2,0,1,1-2,2,2,2,0,0,1,2-2M1,2H4.27l.94,2H20a1,1,0,0,1,.95,1.3l-2.73,7.27A2,2,0,0,1,16.5,14H8.1L7.2,12H16V10H8.55l-.29-1.45L6,3.63,5.27,2H1M7,18a2,2,0,1,1-2,2,2,2,0,0,1,2-2Z"/>
                    </svg>
                </div>
                <div class="phone-app-label">购物车</div>
            </div>
            <div class="phone-app-item" data-app="memo">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" fill="#ffc107"/>
                    </svg>
                </div>
                <div class="phone-app-label">备忘录</div>
            </div>
            <div class="phone-app-item" data-app="browser">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M16.36,14C16.44,13.34 16.5,12.68 16.5,12C16.5,11.32 16.44,10.66 16.36,10H19.74C19.9,10.64 20,11.31 20,12C20,12.69 19.9,13.36 19.74,14M14.59,19.56C15.19,18.45 15.65,17.25 15.97,16H18.92C17.96,17.65 16.43,18.93 14.59,19.56M14.34,14H9.66C9.56,13.34 9.5,12.68 9.5,12C9.5,11.32 9.56,10.65 9.66,10H14.34C14.43,10.65 14.5,11.32 14.5,12C14.5,12.68 14.43,13.34 14.34,14M12,19.96C11.17,18.76 10.5,17.43 10.09,16H13.91C13.5,17.43 12.83,18.76 12,19.96M8,8H5.08C6.03,6.34 7.57,5.06 9.4,4.44C8.8,5.55 8.35,6.75 8,8M5.08,16H8C8.35,17.25 8.8,18.45 9.4,19.56C7.57,18.93 6.03,17.65 5.08,16M4.26,14C4.1,13.36 4,12.69 4,12C4,11.31 4.1,10.64 4.26,10H7.64C7.56,10.66 7.5,11.32 7.5,12C7.5,12.68 7.56,13.34 7.64,14M12,4.03C12.83,5.23 13.5,6.57 13.91,8H10.09C10.5,6.57 11.17,5.23 12,4.03M18.92,8H15.97C15.65,6.75 15.19,5.55 14.59,4.44C16.43,5.07 17.96,6.34 18.92,8M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" fill="#4285f4"/>
                    </svg>
                </div>
                <div class="phone-app-label">浏览器</div>
            </div>
            <div class="phone-app-item" data-app="photos">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M8.5,13.5L11,16.5L14.5,12L19,18H5M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19Z" fill="#34a853"/>
                    </svg>
                </div>
                <div class="phone-app-label">相册</div>
            </div>
            <div class="phone-app-item" data-app="wallet">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M21,7H3A1,1 0 0,0 2,8V16A3,3 0 0,0 5,19H19A3,3 0 0,0 22,16V8A1,1 0 0,0 21,7M20,16A1,1 0 0,1 19,17H5A1,1 0 0,1 4,16V9H20V16M18,12A1,1 0 0,0 17,13A1,1 0 0,0 18,14A1,1 0 0,0 19,13A1,1 0 0,0 18,12Z" fill="#1976d2"/>
                    </svg>
                </div>
                <div class="phone-app-label">钱包</div>
            </div>
            <div class="phone-app-item" data-app="location">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,2C15.31,2 18,4.66 18,7.95C18,12.41 12,19 12,19S6,12.41 6,7.95C6,4.66 8.69,2 12,2M12,6A2,2 0 0,0 10,8A2,2 0 0,0 12,10A2,2 0 0,0 14,8A2,2 0 0,0 12,6M20,19C20,21.21 16.42,23 12,23C7.58,23 4,21.21 4,19C4,17.71 5.22,16.56 7.11,15.94L7.75,16.9C6.67,17.19 6,17.81 6,18.5C6,19.38 8.69,20.5 12,20.5C15.31,20.5 18,19.38 18,18.5C18,17.81 17.33,17.19 16.25,16.9L16.89,15.94C18.78,16.56 20,17.71 20,19Z" fill="#ea4335"/>
                    </svg>
                </div>
                <div class="phone-app-label">足迹</div>
            </div>
            <div class="phone-app-item" data-app="usage">
                <div class="phone-app-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M17,13H11V7H12.5V11.5H17V13Z" fill="#ff9800"/>
                    </svg>
                </div>
                <div class="phone-app-label">使用记录</div>
            </div>
        </div>
    `;

    // 添加app点击事件
    document.querySelectorAll('.phone-app-item').forEach(app => {
        app.addEventListener('click', function() {
            const appName = this.dataset.app;
            openPhoneApp(appName);
        });
    });

    // 加载已保存的手机数据
    loadPhoneData();

    // 初始化返回按钮事件监听器
    setupPhoneBackButtons();

    // 显示主界面
    showPhoneView('phone-home');
}

// 手机界面按钮事件监听器
document.getElementById('phone-back-btn').addEventListener('click', function() {
    showScreen('chat-interface-screen');
});

document.getElementById('phone-clear-btn').addEventListener('click', function() {
    if (confirm('确定要清空所有手机数据吗？此操作不可恢复。')) {
        // 清空数据
        phoneData = {
            chats: [],
            shoppingCart: [],
            memos: [],
            browserHistory: [],
            photoAlbum: [],
            bank: { balance: 0, transactions: [] },
            trajectory: [],
            appUsage: []
        };

        // 如果当前在某个app界面，刷新显示
        const activeView = document.querySelector('.phone-view.active');
        if (activeView) {
            const viewId = activeView.id;
            switch(viewId) {
                case 'phone-wechat':
                    renderWechatList();
                    break;
                case 'phone-shopping':
                    renderShoppingList();
                    break;
                case 'phone-memo':
                    renderMemoList();
                    break;
                case 'phone-browser':
                    renderBrowserHistory();
                    break;
                case 'phone-photos':
                    renderPhotoAlbum();
                    break;
                case 'phone-wallet':
                    renderWallet();
                    break;
                case 'phone-location':
                    renderLocationHistory();
                    break;
                case 'phone-usage':
                    renderAppUsage();
                    break;
            }
        }

        // 保存清空后的数据
        savePhoneData();

        alert('手机数据已清空');
    }
});

document.getElementById('phone-refresh-btn').addEventListener('click', function() {
    refreshPhoneData();
});

// 打开特定app
function openPhoneApp(appName) {
    switch(appName) {
        case 'wechat':
            showPhoneView('phone-wechat');
            renderWechatList();
            break;
        case 'shopping':
            showPhoneView('phone-shopping');
            renderShoppingList();
            break;
        case 'memo':
            showPhoneView('phone-memo');
            renderMemoList();
            break;
        case 'browser':
            showPhoneView('phone-browser');
            renderBrowserHistory();
            break;
        case 'photos':
            showPhoneView('phone-photos');
            renderPhotoAlbum();
            break;
        case 'wallet':
            showPhoneView('phone-wallet');
            renderWallet();
            break;
        case 'location':
            showPhoneView('phone-location');
            renderLocationHistory();
            break;
        case 'usage':
            showPhoneView('phone-usage');
            renderAppUsage();
            break;
        default:
            console.log('打开app:', appName);
            alert('该功能正在开发中...');
    }
}

// 显示指定的手机界面视图
function showPhoneView(viewId) {
    // 隐藏所有视图
    document.querySelectorAll('.phone-view').forEach(view => {
        view.classList.remove('active');
    });

    // 显示指定视图
    const targetView = document.getElementById(viewId);
    if (targetView) {
        targetView.classList.add('active');
    }

    // 设置返回按钮事件监听器
    setupPhoneBackButtons();
}

// 设置手机界面事件监听器
function setupPhoneBackButtons() {
    // 移除之前的监听器（避免重复绑定）
    document.removeEventListener('click', handlePhoneEvents);

    // 添加事件委托监听器
    document.addEventListener('click', handlePhoneEvents);
}

// 处理手机界面内所有点击事件
function handlePhoneEvents(event) {
    // 处理返回按钮
    if (event.target.classList.contains('phone-app-back') ||
        event.target.closest('.phone-app-back')) {

        console.log('返回按钮被点击');
        event.preventDefault();
        event.stopPropagation();

        // 从详情页面返回到对应的应用界面
        const currentView = document.querySelector('.phone-view.active');
        if (currentView) {
            const viewId = currentView.id;
            switch(viewId) {
                case 'phone-wechat-chat':
                    showPhoneView('phone-wechat');
                    break;
                case 'phone-browser-detail':
                    showPhoneView('phone-browser');
                    break;
                case 'phone-photo-detail':
                    showPhoneView('phone-photos');
                    break;
                case 'phone-memo-detail':
                    showPhoneView('phone-memo');
                    break;
                default:
                    showPhoneView('phone-home');
            }
        }
        return;
    }

    // 处理数据项点击事件
    const actionElement = event.target.closest('[data-action]');
    if (actionElement) {
        const action = actionElement.getAttribute('data-action');
        const index = parseInt(actionElement.getAttribute('data-index'));

        console.log('执行动作:', action, '索引:', index);
        event.preventDefault();
        event.stopPropagation();

        switch(action) {
            case 'openBrowserDetail':
                openBrowserDetail(index);
                break;
            case 'openPhotoDetail':
                openPhotoDetail(index);
                break;
            case 'openWechatChat':
                openWechatChat(index);
                break;
            case 'openMemoDetail':
                openMemoDetail(index);
                break;
        }
    }
}

// 渲染微信聊天列表
// 【新代码块开始】
function renderWechatList() {
    const content = document.getElementById('wechat-content');

    if (!phoneData.chats || phoneData.chats.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                暂无聊天记录<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div class="wechat-chat-list">';

    phoneData.chats.forEach((chat, index) => {
        const contactName = chat.contactName;
        const avatarUrl = chat.avatarUrl;
        const hasMessages = chat.messages && chat.messages.length > 0;
        const lastMessage = hasMessages ? chat.messages[chat.messages.length - 1].content : '暂无消息';

        const avatarHtml = `<div class="wechat-avatar"><img src="${avatarUrl}" style="width: 100%; height: 100%; border-radius: 8px; object-fit: cover;"></div>`;

        html += `
            <div class="wechat-chat-item" ${hasMessages ? `data-action="openWechatChat" data-index="${index}"` : ''}>
                ${avatarHtml}
                <div class="wechat-chat-info">
                    <div class="wechat-contact-name">${contactName}</div>
                    <div class="wechat-last-message">${lastMessage.substring(0, 30)}${lastMessage.length > 30 ? '...' : ''}</div>
                </div>
            </div>
        `;
    });

    html += '</div>';
    content.innerHTML = html;
}
// 【新代码块结束】
// 【新代码块结束】

// 打开微信聊天详情
// 【新代码块开始】
function openWechatChat(chatIndex) {
    const chat = phoneData.chats[chatIndex];
    if (!chat || !chat.messages || chat.messages.length === 0) {
        return;
    }

    document.getElementById('wechat-chat-title').textContent = chat.contactName;

    const content = document.getElementById('wechat-chat-content');
    let html = '<div class="wechat-message-list">';

    const currentAiName = state.chats[state.activeChatId].name;
    const userRemarkName = phoneData.chats[0].contactName; // 第一个聊天总是用户

    chat.messages.forEach(message => {
        // 【核心修改3】判断发送者并获取头像
        const isSentByAi = message.sender === currentAiName;
        const avatarUrl = message.avatarUrl;
        const avatarHtml = `<img src="${avatarUrl}" style="width: 35px; height: 35px; border-radius: 6px; object-fit: cover; flex-shrink: 0;">`;

        html += `
            <div class="wechat-message ${isSentByAi ? 'sent' : ''}">
                ${avatarHtml}
                <div class="wechat-message-content">
                    ${message.content}
                </div>
            </div>
        `;
    });

    html += '</div>';
    content.innerHTML = html;

    showPhoneView('phone-wechat-chat');
}
// 【新代码块结束】

// 生成头像颜色
function generateAvatarColor(name) {
    const colors = [
        '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24',
        '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe',
        '#fd79a8', '#e84393', '#00b894', '#00cec9'
    ];

    let hash = 0;
    for (let i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }

    return colors[Math.abs(hash) % colors.length];
}

// API调用函数 - 参考callAIForActiveReply
// 【改进】增强错误诊断，区分不同的失败原因
async function callPhoneDataAPI(prompt) {
            try {
                const { proxyUrl, apiKey, model } = state.apiConfig;

                // 【配置验证】检查API配置是否完整
                if (!proxyUrl || !apiKey || !model) {
                    const missingItems = [];
                    if (!proxyUrl) missingItems.push('反代地址');
                    if (!apiKey) missingItems.push('密钥');
                    if (!model) missingItems.push('模型');
                    throw new Error(`【配置错误】缺少：${missingItems.join('、')}。请在API设置中完整配置。`);
                }

                // 【地址格式验证】验证代理地址格式
                if (!proxyUrl.startsWith('http://') && !proxyUrl.startsWith('https://')) {
                    throw new Error(`【配置错误】反代地址格式不正确，必须以 http:// 或 https:// 开头。当前值：${proxyUrl}`);
                }

                // 【密钥验证】检查密钥是否真的非空
                const selectedKey = getRandomValue(apiKey);
                if (!selectedKey || selectedKey.trim() === '') {
                    throw new Error(`【配置错误】所有密钥都为空。请检查API设置中的密钥配置。`);
                }

                // 为了最大的兼容性，我们统一使用OpenAI格式进行请求，绝大多数中转站都支持
                const systemPrompt = prompt;
                const messagesPayload = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请根据上述要求生成手机数据，严格按照JSON格式返回。' }
                ];

                const requestUrl = proxyUrl.endsWith('/') ? `${proxyUrl}v1/chat/completions` : `${proxyUrl}/v1/chat/completions`;
                console.log(`[查手机API] 发送请求到: ${requestUrl}`);

                let response;
                try {
                    response = await fetch(requestUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${selectedKey}` // 使用随机密钥函数以支持轮询
                        },
                        body: JSON.stringify({
                                model: model,
                                messages: messagesPayload,
                                temperature: parseFloat(state.apiConfig.temperature) || 0.7,
                                max_tokens: 60000, // 保留最大token限制以防内容过长
                                response_format: { type: "json_object" } // <-- 全新添加的优化参数
                            }),
                            mode: 'cors'
                    });
                } catch (fetchError) {
                    // 【网络诊断】区分网络问题
                    if (fetchError.name === 'TypeError' && fetchError.message.includes('Failed to fetch')) {
                        // TypeError: Failed to fetch 通常表示网络问题、CORS 或地址错误
                        const diagnosis = `
【网络连接错误】可能的原因：
1. 网络连接不稳定（请检查网络）
2. 反代地址无法访问（请检查地址是否正确：${proxyUrl}）
3. CORS 跨域问题（反代服务器没有设置正确的 CORS 头）
4. 如果使用 HTTP 反代地址，页面可能是 HTTPS（浏览器会阻止混合内容）

建议：
- 确保反代地址可以在浏览器中直接访问
- 查看浏览器控制台的 Network 标签，查看请求是否被 CORS 阻止
- 如果问题持续，请尝试更换反代服务器或检查网络设置`;
                        throw new Error(diagnosis);
                    }
                    throw fetchError;
                }

                // 【服务器响应检查】
                if (!response.ok) {
                    // 尝试解析API返回的错误信息以提供更详细的反馈
                    let errorDetails = `【服务器错误】HTTP ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error?.message) {
                            errorDetails += `\n服务器提示：${errorData.error.message}`;
                        } else {
                            errorDetails += `\n响应内容：${JSON.stringify(errorData)}`;
                        }
                    } catch (parseError) {
                        // 如果错误响应不是JSON格式，尝试获取文本
                        try {
                            const errorText = await response.text();
                            if (errorText) {
                                errorDetails += `\n响应内容：${errorText.substring(0, 200)}`;
                            }
                        } catch (e) {
                            // 无法解析错误内容
                        }
                    }

                    // 【HTTP状态诊断】
                    if (response.status === 401 || response.status === 403) {
                        errorDetails += '\n\n【认证错误】密钥可能过期或无效，请检查 API 密钥。';
                    } else if (response.status === 429) {
                        errorDetails += '\n\n【限流错误】请求过于频繁，请稍候几秒后重试。';
                    } else if (response.status === 500 || response.status === 502 || response.status === 503) {
                        errorDetails += '\n\n【服务器故障】API 服务器暂时不可用，请稍候后重试。';
                    } else if (response.status === 400) {
                        errorDetails += '\n\n【请求格式错误】可能是模型名称错误或请求参数不兼容。';
                    }

                    throw new Error(errorDetails);
                }

                // 【响应解析】
                let data;
                try {
                    data = await response.json();
                } catch (parseError) {
                    throw new Error(`【响应解析错误】API 返回的内容不是有效的 JSON 格式。可能是反代地址错误或服务器返回了错误页面。`);
                }

                // 【响应内容验证】
                if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                    throw new Error(`【响应验证错误】API 返回了空的回应或格式不正确。响应结构：${JSON.stringify(Object.keys(data))}`);
                }
                const responseText = data.choices[0].message.content;

                console.log(`[查手机API] 成功获取响应，内容长度: ${responseText.length}`);
                return { success: true, response: responseText };
            } catch (error) {
                console.error('API调用失败:', error);
                // 【用户友好的错误信息】
                const userMessage = error.message.includes('【')
                    ? error.message
                    : `【未知错误】${error.message}\n请检查浏览器控制台获取更多信息。`;
                return { success: false, error: userMessage };
            }
        }

// 渲染购物车列表
function renderShoppingList() {
    const content = document.getElementById('shopping-content');

    if (!phoneData.shoppingCart || phoneData.shoppingCart.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                购物车为空<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div>';
    phoneData.shoppingCart.forEach(item => {
        // 生成星级评价HTML
        const rating = item.rating || 5;
        const stars = '⭐'.repeat(rating) + (rating < 5 ? '☆'.repeat(5 - rating) : '');
        const review = item.review || '暂无评价';

        html += `
            <div class="shopping-item">
                <div class="shopping-item-info">
                    <div class="shopping-item-name">${item.name}</div>
                    <div class="shopping-item-reason">💭${item.reason || '未记录'}</div>
                    <div class="shopping-item-review">
                        <div>${stars}</div>
                        <div>${review}</div>
                    </div>
                </div>
                <div class="shopping-item-price">¥${item.price}</div>
            </div>
        `;
    });
    html += '</div>';
    content.innerHTML = html;
}

// 渲染备忘录列表
function renderMemoList() {
    const content = document.getElementById('memo-content');

    if (!phoneData.memos || phoneData.memos.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                暂无备忘录<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div>';
    phoneData.memos.forEach((memo, index) => {
        html += `
            <div class="memo-item" data-action="openMemoDetail" data-index="${index}">
                <div class="memo-title">${memo.title}</div>
                <div class="memo-preview">${memo.content.substring(0, 50)}${memo.content.length > 50 ? '...' : ''}</div>
            </div>
        `;
    });
    html += '</div>';
    content.innerHTML = html;
}
// 【全新添加】打开备忘录详情
function openMemoDetail(index) {
    const memo = phoneData.memos[index];
    if (!memo) return;

    document.getElementById('memo-detail-title').textContent = memo.title;
    document.getElementById('memo-detail-content').textContent = memo.content;
    showPhoneView('phone-memo-detail');
}
// 渲染浏览器历史记录
function renderBrowserHistory() {
    const content = document.getElementById('phone-browser-list');

    if (!phoneData.browserHistory || phoneData.browserHistory.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                暂无浏览记录<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div>';
    phoneData.browserHistory.forEach((item, index) => {
        // 兼容新旧数据格式
        const title = item.title || item.query || '未知标题';
        const preview = item.content || item.result || '暂无内容';

        html += `
            <div class="browser-item" data-action="openBrowserDetail" data-index="${index}">
                <div class="browser-query">${title}</div>
                <div class="browser-preview">${preview.substring(0, 60)}${preview.length > 60 ? '...' : ''}</div>
            </div>
        `;
    });
    html += '</div>';
    content.innerHTML = html;
}

// 打开浏览器详情
function openBrowserDetail(index) {
    const item = phoneData.browserHistory[index];
    if (!item) return;

    // 兼容新旧数据格式
    const title = item.title || item.query || '未知标题';
    const content = item.content || item.result || '暂无内容';
    const url = item.url || '';

    document.getElementById('browser-detail-title').textContent = title;
    document.getElementById('browser-detail-content').innerHTML = `
        <h3 style="margin-bottom: 15px; color: #1c1c1e;">${title}</h3>
        <div style="line-height: 1.6; color: #333;">${content}</div>
    `;
    showPhoneView('phone-browser-detail');
}

// 渲染相册
function renderPhotoAlbum() {
    const content = document.getElementById('photos-content');

    if (!phoneData.photoAlbum || phoneData.photoAlbum.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                相册为空<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div class="photos-grid">';
    phoneData.photoAlbum.forEach((photo, index) => {
        html += `
            <div class="photo-item" data-action="openPhotoDetail" data-index="${index}">
                📷
            </div>
        `;
    });
    html += '</div>';
    content.innerHTML = html;
}

// 打开照片详情
function openPhotoDetail(index) {
    const photo = phoneData.photoAlbum[index];
    if (!photo) return;

    // 兼容新旧数据格式
    const description = photo.description || photo.hiddenContent || '无描述';
    const date = photo.date || '未知时间';

    document.getElementById('photo-detail-content').innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <div style="width: 200px; height: 200px; background: #f0f0f0; border-radius: 12px; margin: 0 auto; display: flex; align-items: center; justify-content: center; font-size: 48px; color: #999;">
                📷
            </div>
            ${photo.date ? `<div style="margin-top: 10px; font-size: 12px; color: #999;">${date}</div>` : ''}
        </div>
        <div style="padding: 20px; background: #f8f9fa; border-radius: 12px; line-height: 1.6;">
            <h4 style="margin-bottom: 10px; color: #1c1c1e;">照片描述</h4>
            <p style="color: #333; margin: 0;">${description}</p>
        </div>
    `;
    showPhoneView('phone-photo-detail');
}

// 渲染钱包
function renderWallet() {
    const content = document.getElementById('wallet-content');

    if (!phoneData.bank) {
        content.innerHTML = `
            <div class="phone-empty">
                钱包数据不可用<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = `
        <div class="wallet-balance">
            <div class="wallet-balance-title">账户余额</div>
            <div class="wallet-balance-amount">¥${phoneData.bank.balance || 0}</div>
        </div>
    `;

    if (phoneData.bank.transactions && phoneData.bank.transactions.length > 0) {
        html += '<div class="wallet-transactions">';
        phoneData.bank.transactions.forEach(transaction => {
            const isIncome = transaction.type === '收入';
            html += `
                <div class="wallet-transaction">
                    <div class="wallet-transaction-desc">${transaction.description}</div>
                    <div class="wallet-transaction-amount ${isIncome ? 'income' : 'expense'}">
                        ${isIncome ? '+' : '-'}¥${transaction.amount}
                    </div>
                </div>
            `;
        });
        html += '</div>';
    }

    content.innerHTML = html;
}

// 渲染位置历史
function renderLocationHistory() {
    const content = document.getElementById('location-content');

    if (!phoneData.trajectory || phoneData.trajectory.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                暂无足迹记录<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div>';
    phoneData.trajectory.forEach(item => {
        html += `
            <div class="location-item">
                <div class="location-time">${item.time}</div>
                <div class="location-place">${item.location}</div>
                <div class="location-activity">${item.activity}</div>
            </div>
        `;
    });
    html += '</div>';
    content.innerHTML = html;
}

// 渲染应用使用记录
function renderAppUsage() {
    const content = document.getElementById('usage-content');

    if (!phoneData.appUsage || phoneData.appUsage.length === 0) {
        content.innerHTML = `
            <div class="phone-empty">
                暂无使用记录<br>
                <small style="color: #999; margin-top: 10px; display: block;">请点击右上角刷新按钮获取数据</small>
            </div>
        `;
        return;
    }

    let html = '<div>';
    phoneData.appUsage.forEach(item => {
        html += `
            <div class="usage-item">
                <div class="usage-app-name">${item.appName}</div>
                <div class="usage-duration">${item.duration}</div>
            </div>
        `;
    });
    html += '</div>';
    content.innerHTML = html;
}

// 【新代码块开始】
/**
 * 【查手机宽松JSON解析】专为手机数据生成API的JSON格式修复
 * 使用栈式匹配提取嵌套字段，支持格式不规范的JSON
 * @param {string} jsonString - 可能畸形的JSON字符串
 * @returns {Object|null} - 解析出的对象，或null
 */
function lenientParsePhoneJSON(jsonString) {
    if (!jsonString || typeof jsonString !== 'string') {
        return null;
    }

    const trimmed = jsonString.trim();

    // 【步骤1】尝试修复最基础的格式问题（只修复字符串外的问题）
    let repaired = trimmed;

    // 修复1：移除可能的代码块标记
    repaired = repaired.replace(/^```json\s*/, '').replace(/\s*```$/, '');

    // 修复2：修复【字符串外部】的缺逗号（只修复最安全的情况）
    // 只修复 }{ 和 ][ 这两种明确的缺逗号情况
    repaired = repaired.replace(/\}\s*\{/g, '},{');
    repaired = repaired.replace(/\]\s*\[/g, '],[');

    // 修复3：修复闭合括号前的多余逗号
    repaired = repaired.replace(/,\s*\}/g, '}');
    repaired = repaired.replace(/,\s*\]/g, ']');

    // 【步骤2】尝试严格解析修复后的JSON
    try {
        return JSON.parse(repaired);
    } catch (e) {
        console.warn('[查手机宽松模式] 自动修复失败，尝试手动提取结构...');
    }

    // 【步骤3】手动提取核心字段（使用栈式匹配处理嵌套）
    try {
        const result = {};

        // 用栈式匹配提取顶级字段的完整值
        const extractFieldValue = (fieldName, str) => {
            // 先找到字段名的位置
            const fieldPattern = new RegExp(`"${fieldName}"\\s*:`, 'i');
            const fieldMatch = str.match(fieldPattern);
            if (!fieldMatch) {
                return undefined;
            }

            // 从冒号后面开始，用栈式匹配提取值
            const startPos = fieldMatch.index + fieldMatch[0].length;
            let pos = startPos;
            let braceCount = 0;
            let bracketCount = 0;
            let inString = false;
            let escapeNext = false;
            let valueStart = -1;

            // 跳过冒号后的空格
            while (pos < str.length && /\s/.test(str[pos])) {
                pos++;
            }

            valueStart = pos;

            // 逐字扫描，用栈计数来找完整值
            while (pos < str.length) {
                const char = str[pos];

                // 处理转义
                if (escapeNext) {
                    escapeNext = false;
                    pos++;
                    continue;
                }
                if (char === '\\') {
                    escapeNext = true;
                    pos++;
                    continue;
                }

                // 处理字符串状态
                if (char === '"') {
                    inString = !inString;
                    pos++;
                    continue;
                }

                if (!inString) {
                    if (char === '{') {
                        braceCount++;
                    } else if (char === '}') {
                        braceCount--;
                    } else if (char === '[') {
                        bracketCount++;
                    } else if (char === ']') {
                        bracketCount--;
                    } else if (char === ',' && braceCount === 0 && bracketCount === 0) {
                        // 找到了字段值的结束位置
                        break;
                    }
                }

                pos++;

                // 如果所有计数都回到0，说明完整的值已经结束
                if (braceCount === 0 && bracketCount === 0 && pos > valueStart) {
                    const nextChar = str[pos];
                    if (nextChar === ',' || nextChar === '}' || nextChar === ']' || !nextChar) {
                        break;
                    }
                }
            }

            // 提取字段值
            if (valueStart >= 0 && pos > valueStart) {
                const valueStr = str.substring(valueStart, pos).trim();
                try {
                    return JSON.parse(valueStr);
                } catch (e) {
                    // 即使parse失败，也尝试返回字符串值（可能是简单值）
                    if (valueStr.startsWith('"') && valueStr.endsWith('"')) {
                        try {
                            return JSON.parse(valueStr);
                        } catch {
                            return undefined;
                        }
                    }
                    return undefined;
                }
            }

            return undefined;
        };

        // 提取所有顶级字段
        const fields = ['userRemarkName', 'chats', 'shoppingCart', 'memos', 'browserHistory', 'photoAlbum', 'bank', 'trajectory', 'appUsage'];
        for (const field of fields) {
            const value = extractFieldValue(field, repaired);
            if (value !== undefined) {
                result[field] = value;
            }
        }

        // 【验证】必须至少提取到重要字段，否则认为失败
        const hasImportantFields = result.chats || result.shoppingCart || result.memos || result.bank;
        if (hasImportantFields) {
            console.log(`[查手机宽松模式] 成功通过手动提取恢复了 ${Object.keys(result).length} 个字段`);
            return result;
        } else {
            console.warn('[查手机宽松模式] 提取失败：缺少关键字段');
            return null;
        }
    } catch (e) {
        console.error('[查手机宽松模式] 手动提取也失败:', e);
    }

    return null;
}

async function refreshPhoneData() {
    if (!state.activeChatId) {
        alert('请先选择一个聊天对象');
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) {
        alert('聊天对象不存在');
        return;
    }

    // 显示加载状态
    const refreshBtn = document.getElementById('phone-refresh-btn');
    const originalHTML = refreshBtn.innerHTML;
    refreshBtn.innerHTML = '<div class="phone-loading-spinner"></div>';
    refreshBtn.disabled = true;

    try {
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `\n# 【核心记忆】以下是你们之间的核心记忆摘要，是下面聊天历史记录之前发生的核心历史事件，记录了重要的互动历史和关系发展\n${chat.memorySummary.trim()}\n`;
        }

        // 获取时间信息
        const currentTime = new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });

        
        
        // 【修改】读取与单聊相同数量的聊天记录，并应用8条消息规则
        const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
        const contextMessages = chat.history.slice(memoryAnchor);

        // 【新增】实现8条消息规则 - 计算最近8条消息的时间戳
        const recentMessages = contextMessages.slice(-8);
        const recentMessageTimestamps = recentMessages.map(msg => msg.timestamp);

        const recentHistory = contextMessages
            .map(msg => {
                const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                let content;

                // 【核心逻辑】对线下模式AI消息应用8条消息规则
                if (msg.role === 'assistant' && !recentMessageTimestamps.includes(msg.timestamp)) {
                    // 超过8条的线下模式AI消息，只读取abstract内容
                    if (typeof msg.content === 'string') {
                        const abstractContent = extractAbstractContent(msg.content);
                        content = abstractContent || msg.content; // 如果没有abstract标签，使用完整内容
                    } else {
                        content = msg.content;
                    }
                } else {
                    // 8条消息以内的所有消息，或用户消息，或线上模式消息，读取完整内容
                    content = msg.content;
                }

                return `${sender}: ${content}`;
            })
            .join('\n');
// ▼▼▼ 【全新添加】为“查手机”功能添加符合规则的世界书读取逻辑 ▼▼▼
let worldBookContent = '';
// 安全检查，确保聊天设置和世界书链接ID存在
if (chat.settings && chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
    const characterName = chat.name; // 获取当前角色的名字

    const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
        // 从state中找到完整的世界书对象
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        
        // 【核心过滤条件】
        // 1. 必须找到这本书 (worldBook)
        // 2. 这本书必须有内容 (worldBook.content)
        // 3. 【新】这本书的名字 (worldBook.name) 必须包含当前角色的名字 (characterName)
        if (worldBook && worldBook.content && worldBook.name.includes(characterName)) {
            // 如果满足所有条件，则格式化并返回其内容
            return `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`;
        }
        
        // 如果不满足条件，返回null
        return null; 
    }).filter(Boolean).join(''); // .filter(Boolean) 会优雅地移除所有null的条目

    if (linkedContents) {
        worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
    }
}
// ▲▲▲ 新增代码结束 ▲▲▲
        // 【核心修改1：Prompt重构】
        const promptText = `你正在进行一场深度角色扮演，现在扮演一个名为"${chat.name}"的角色。基于你们的聊天历史、关系发展和你的人设，请生成符合你角色特征的手机数据内容。

# 你的核心角色设定 (Persona)：

${chat.settings.aiPersona}

##  世界观法则 (World Book)
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

${worldBookContent}
# 对话者的角色设定：
${chat.settings.myPersona}



# 当前时间情景：
- 当前时间: ${currentTime}

${coreMemoryContext}
# 你们的聊天历史记录 (以下是核心记忆之后的聊天记录，完整参考):
${recentHistory}

# 【【【核心任务要求】】】
你需要根据以上所有信息，生成符合你角色特征和你们关系发展的手机数据。

# 【【【足迹(trajectory)生成特殊规则】】】
1.  你【必须】参考“当前时间情景”中的当前时间点。
2.  生成的足迹记录【绝对不能】超过这个当前时间。
3.  足迹的时间跨度【必须超过24小时】，例如，应包含“昨天”和“今天”的活动。

# 【【【JSON输出格式要求】】】
你的回复【必须严格】按照以下JSON格式，不要添加任何额外说明或注释。

{
  "userRemarkName": "【你给用户的备注名，必须基于你们的关系和你的人设】",
  "chats": [
    {
      "contactName": "【虚构联系人的名字，必须符合你的社交圈】",
      "avatarUrl": "【https://i.postimg.cc/xTsrfr5b/IMG-6775.png】",
      "messages": [
        {"sender": "联系人名", "content": "对话内容..."},
        {"sender": "${chat.name}", "content": "你的回复...【核心铁律：这条消息的sender必须是你自己，即'${chat.name}'】"}
      ]
    }
  ],
  "shoppingCart": [
    {"name": "商品名称", "price": "价格数字", "reason": "购买原因", "rating": 5, "review": "商品收货后的评价文字"}
  ],
  "memos": [
    {"title": "备忘录标题", "content": "详细内容", "date": "创建日期"}
  ],
  "browserHistory": [
    {"title": "搜索或浏览标题", "content": "网页内容摘要"}
  ],
  "photoAlbum": [
    {"description": "照片的详细描述", "date": "拍摄时间"}
  ],
  "bank": {
    "balance": "余额数字",
    "transactions": [
      {"date": "日期", "type": "收入/支出", "amount": "金额", "description": "交易描述", "balance": "余额"}
    ]
  },
  "trajectory": [
    {"time": "时间", "location": "地点", "activity": "活动描述", "duration": "停留时长"}
  ],
  "appUsage": [
    {"appName": "应用名", "duration": "使用时长", "category": "应用类型"}
  ]
}

# 生成指导原则
1. **聊天记录**：你生成的虚构聊天，必须包含至少5个不同联系人，每个联系人至少8条对话，体现真实的聊天节奏和你的说话风格。
**【【【发送者铁律】】】**：每一段对话中，消息的\`sender\`字段【必须】在"虚构联系人名"和你的名字"${chat.name}"之间【交替出现】，以模拟真实的来回对话。绝对禁止所有消息都由同一个人发送。
2. **购物车数据**：每个商品【必须包含】：name(商品名)、price(价格)、reason(购买原因，基于角色的个性和需求)、rating(1-5星级评分)、review(商品收货后的评价文字，要符合角色的真实看法)。【禁止】包含store字段。
3. 其他所有数据生成不得少于9条，并且都应该基于你的核心角色设定、与用户的关系史以及聊天记录来生成，保持高度的个性化和一致性。`;

        const apiResponse = await callPhoneDataAPI(promptText);

        if (apiResponse.success && apiResponse.response) {
            try {
                let jsonData;
                const responseText = apiResponse.response.trim();
                const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/);
                const jsonContent = jsonMatch ? jsonMatch[1] : responseText;

                // 【方案1】尝试严格JSON解析
                try {
                    jsonData = JSON.parse(jsonContent);
                } catch (strictParseError) {
                    // 【方案2】严格解析失败，使用宽松模式解析
                    console.warn('[查手机] 严格JSON解析失败，尝试宽松模式...');
                    const lenientResult = lenientParsePhoneJSON(jsonContent);
                    if (lenientResult && typeof lenientResult === 'object') {
                        jsonData = lenientResult;
                    } else {
                        throw strictParseError; // 宽松模式也失败，抛出原始错误
                    }
                }

                if (jsonData && typeof jsonData === 'object') {
                    // 【核心修改2：数据拼接与头像注入】
                    const myNickname = chat.settings.myNickname || '我';
                    const userRemarkName = jsonData.userRemarkName || myNickname;
                    
                    const realUserChat = {
                        contactName: userRemarkName,
                        avatarUrl: chat.settings.myAvatar || defaultAvatar, // 用户的头像
                        messages: chat.history
                            .filter(msg => !msg.isHidden)
                            .slice(-20)
                            .map(msg => ({
                                sender: msg.role === 'user' ? userRemarkName : chat.name,
                                content: msg.content,
                                avatarUrl: msg.role === 'user' ? (chat.settings.myAvatar || defaultAvatar) : (chat.settings.aiAvatar || defaultAvatar)
                            }))
                    };

                    // 为AI生成的虚构聊天也注入AI自己的头像
                    const fictionalChats = (jsonData.chats || []).map(fChat => {
                        fChat.messages.forEach(msg => {
                            if (msg.sender === chat.name) {
                                msg.avatarUrl = chat.settings.aiAvatar || defaultAvatar;
                            } else {
                                msg.avatarUrl = fChat.avatarUrl; // 使用AI生成的虚构联系人头像
                            }
                        });
                        return fChat;
                    });

                    const finalChats = [realUserChat, ...fictionalChats];

                    phoneData = {
                        chats: finalChats,
                        shoppingCart: jsonData.shoppingCart || [],
                        memos: jsonData.memos || [],
                        browserHistory: jsonData.browserHistory || [],
                        photoAlbum: jsonData.photoAlbum || [],
                        bank: jsonData.bank || { balance: 0, transactions: [] },
                        trajectory: jsonData.trajectory || [],
                        appUsage: jsonData.appUsage || []
                    };
                    
                    savePhoneData();
                    alert('手机数据刷新成功！');
                } else {
                    throw new Error('返回的数据格式不正确');
                }
            } catch (parseError) {
                console.error('解析响应失败:', parseError);
                console.log('API响应:', apiResponse.response);
                alert('数据解析失败，请重试');
            }
        } else {
            throw new Error(apiResponse.error || '调用API失败');
        }
    } catch (error) {
        console.error('刷新手机数据失败:', error);

        // 【简化错误提示】网络错误显示简洁，其他错误显示详细
        let alertMessage;
        if (error.message.includes('【网络连接错误】')) {
            // 网络问题只显示简单提示，详细信息已在控制台输出
            alertMessage = '刷新失败：网络连接问题，请检查网络或更换反代服务器';
        } else {
            // 其他错误显示完整信息
            alertMessage = error.message.includes('【')
                ? error.message
                : '刷新失败: ' + error.message;
        }
        alert(alertMessage);
    } finally {
        refreshBtn.innerHTML = originalHTML;
        refreshBtn.disabled = false;
    }
}
// 【新代码块结束】
// ========== 【查手机功能】JavaScript代码结束 ==========
// ▼▼▼ 【全新】表情包操作事件绑定 ▼▼▼
document.getElementById('sticker-actions-panel').addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡关闭面板
    const targetId = e.target.id;
    if (targetId === 'edit-sticker-meaning-btn') {
        handleEditStickerMeaning();
    }
    if (targetId === 'delete-sticker-btn') {
        handleDeleteSingleSticker();
    }
    if (targetId === 'batch-delete-stickers-btn') {
        enterStickerSelectionMode();
    }
    // 任何操作后都隐藏菜单
    hideStickerActions();
});

// 批量删除模式的控制按钮
document.getElementById('cancel-sticker-selection-btn').addEventListener('click', exitStickerSelectionMode);
document.getElementById('delete-selected-stickers-btn').addEventListener('click', deleteSelectedStickers);

// 全局点击监听，用于关闭表情操作菜单
document.addEventListener('click', (e) => {
    const panel = document.getElementById('sticker-actions-panel');
    if (panel && panel.style.display !== 'none' && !panel.contains(e.target)) {
        hideStickerActions();
    }
});
// ▲▲▲ 新事件绑定结束 ▲▲▲

// ==========================================
// 【自动刷新系统】事件绑定和功能函数
// ==========================================

// 【新增】打开自动刷新设置
function openAutoRefreshSettings() {
    console.log('🔓 打开自动刷新设置...');

    const modal = document.getElementById('autorefresh-settings-modal');
    const enabled = document.getElementById('autorefresh-enabled');
    const interval = document.getElementById('autorefresh-interval');
    const status = document.getElementById('autorefresh-status');

    // 【调试】验证所有元素是否正确找到
    console.log('元素验证:');
    console.log('  modal:', modal ? '✓ 找到' : '❌ 未找到');
    console.log('  enabled:', enabled ? '✓ 找到' : '❌ 未找到');
    console.log('  interval:', interval ? '✓ 找到' : '❌ 未找到');
    console.log('  status:', status ? '✓ 找到' : '❌ 未找到');

    if (!modal || !enabled || !interval || !status) {
        console.error('❌ 某些元素未找到，无法打开设置');
        alert('设置页面加载失败，请刷新页面后重试');
        return;
    }

    // 从 state 中恢复设置
    enabled.checked = state.autoRefreshSettings.enabled;
    interval.value = state.autoRefreshSettings.interval;
    console.log(`当前设置: 启用=${enabled.checked}, 间隔=${interval.value}分钟`);

    updateAutoRefreshStatus();

    modal.style.display = 'flex';
    console.log('✓ 自动刷新设置已打开');
}

// 【新增】关闭自动刷新设置
function closeAutoRefreshSettings() {
    const modal = document.getElementById('autorefresh-settings-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// 【新增】更新自动刷新状态显示
function updateAutoRefreshStatus() {
    const status = document.getElementById('autorefresh-status');
    const enabled = document.getElementById('autorefresh-enabled');
    const interval = document.getElementById('autorefresh-interval');

    if (enabled.checked) {
        status.textContent = `自动刷新已启用（每 ${interval.value} 分钟刷新一次）`;
        status.style.color = '#4a90e2';
        status.style.backgroundColor = '#e8f4f8';
    } else {
        status.textContent = '自动刷新已禁用';
        status.style.color = 'var(--text-secondary)';
        status.style.backgroundColor = '#f9f9f9';
    }
}

// 【新增】保存自动刷新设置
function saveAutoRefreshSettings() {
    try {
        console.log('💾 开始保存自动刷新设置...');

        const enabled = document.getElementById('autorefresh-enabled').checked;
        const intervalValue = parseInt(document.getElementById('autorefresh-interval').value);
        const intervalMs = intervalValue * 60 * 1000; // 转换为毫秒

        console.log(`启用状态: ${enabled}, 间隔: ${intervalValue} 分钟`);

        // 停止已有的定时器
        if (state.autoRefreshSettings.timerId) {
            clearInterval(state.autoRefreshSettings.timerId);
            state.autoRefreshSettings.timerId = null;
            console.log('已清除旧定时器');
        }

        // 更新状态
        state.autoRefreshSettings.enabled = enabled;
        state.autoRefreshSettings.interval = intervalValue;

        // 如果启用，则启动定时器
        if (enabled) {
            console.log(`⏰ 自动刷新已启用，每 ${intervalValue} 分钟自动刷新一次`);
            state.autoRefreshSettings.timerId = setInterval(async () => {
                console.log('⏰ 触发自动刷新...');
                await triggerNPCRefresh(true);  // 【修复】传递 true 表示自动刷新，不显示 alert
            }, intervalMs);
        } else {
            console.log('⏰ 自动刷新已禁用');
        }

        // 保存到本地存储（使用异步处理但不阻塞UI）
        // 【修复】使用正确的 Dexie 格式：id 字段作为主键
        db.globalSettings.put({
            id: 'autoRefreshSettings',  // 改为 id 字段（globalSettings 表的主键）
            enabled: state.autoRefreshSettings.enabled,
            interval: state.autoRefreshSettings.interval
        }).then(() => {
            console.log('✓ 自动刷新设置已成功保存到本地存储');
        }).catch(error => {
            console.error('❌ 保存到本地存储失败:', error);
        });

        closeAutoRefreshSettings();
        console.log('✓ 自动刷新设置已保存，模态框已关闭');
    } catch (error) {
        console.error('❌ 保存设置时出错:', error);
        alert('保存设置失败：' + error.message);
    }
}

// 【新增】加载自动刷新设置
async function loadAutoRefreshSettings() {
    try {
        console.log('📂 加载自动刷新设置...');
        // 【修复】使用正确的 Dexie 格式：直接访问 id 字段
        const settings = await db.globalSettings.get('autoRefreshSettings');

        console.log('加载结果:', settings);

        // 【修复】直接从 settings 对象读取字段，不需要 .value
        if (settings && settings.enabled !== undefined) {
            state.autoRefreshSettings.enabled = settings.enabled || false;
            state.autoRefreshSettings.interval = settings.interval || 5;

            console.log(`✓ 自动刷新设置已加载: 启用=${state.autoRefreshSettings.enabled}, 间隔=${state.autoRefreshSettings.interval}分钟`);

            // 如果启用，启动定时器
            if (state.autoRefreshSettings.enabled) {
                const interval = state.autoRefreshSettings.interval * 60 * 1000;
                state.autoRefreshSettings.timerId = setInterval(async () => {
                    console.log('⏰ 触发自动刷新...');
                    await triggerNPCRefresh(true);  // 【修复】传递 true 表示自动刷新，不显示 alert
                }, interval);
                console.log(`✓ 自动刷新已恢复运行（每 ${state.autoRefreshSettings.interval} 分钟）`);
            }
        } else {
            console.log('ℹ️ 未找到自动刷新设置记录，使用默认值');
        }
    } catch (error) {
        console.warn('⚠️ 加载自动刷新设置失败:', error);
    }
}

// ==========================================
// 【NPC管理系统】事件绑定和功能函数
// ==========================================

// 初始化NPC管理系统
function initNPCSystem() {
    try {
        // 【关键修改】先绑定所有事件监听器（同步代码）
        const npcSettingsBtn = document.getElementById('qzone-npc-settings-btn');
        const npcModalClose = document.getElementById('npc-modal-close');
        const npcCancelBtn = document.getElementById('npc-cancel-btn');
        const npcForm = document.getElementById('npc-form');
        const qzoneRefreshBtn = document.getElementById('qzone-refresh-btn');
        const npcAvatarUploadBtn = document.getElementById('npc-avatar-upload-btn');
        // 【新增】自动刷新设置按钮
        const autorefreshBtn = document.getElementById('qzone-autorefresh-btn');
        const autorefreshModal = document.getElementById('autorefresh-settings-modal');
        const autorefreshEnabled = document.getElementById('autorefresh-enabled');
        const autorefreshInterval = document.getElementById('autorefresh-interval');
        const autorefreshIntervalDisplay = document.getElementById('autorefresh-interval-display');
        const autorefreshStatus = document.getElementById('autorefresh-status');
        const autorefreshSaveBtn = document.getElementById('autorefresh-save-btn');
        const autorefreshCancelBtn = document.getElementById('autorefresh-cancel-btn');
        const autorefreshModalClose = document.getElementById('autorefresh-modal-close');

        if (npcSettingsBtn) {
            npcSettingsBtn.addEventListener('click', openNPCManager);
            console.log('✓ NPC设置按钮事件已绑定');
        }
        if (npcModalClose) npcModalClose.addEventListener('click', closeNPCManager);
        if (npcCancelBtn) npcCancelBtn.addEventListener('click', () => switchNPCTab('list'));
        if (npcForm) npcForm.addEventListener('submit', saveNPC);
        if (qzoneRefreshBtn) {
            qzoneRefreshBtn.addEventListener('click', triggerNPCRefresh);
            console.log('✓ 刷新按钮事件已绑定');
        }

        // 【新增】自动刷新设置事件监听器
        if (autorefreshBtn) {
            autorefreshBtn.addEventListener('click', openAutoRefreshSettings);
            console.log('✓ 自动刷新设置按钮事件已绑定');
        }
        if (autorefreshSaveBtn) {
            autorefreshSaveBtn.addEventListener('click', () => {
                console.log('🔘 保存按钮被点击');
                saveAutoRefreshSettings();
            });
            console.log('✓ 自动刷新保存按钮事件已绑定');
        }
        if (autorefreshCancelBtn) {
            autorefreshCancelBtn.addEventListener('click', closeAutoRefreshSettings);
            console.log('✓ 自动刷新取消按钮事件已绑定');
        }
        if (autorefreshModalClose) {
            autorefreshModalClose.addEventListener('click', closeAutoRefreshSettings);
            console.log('✓ 自动刷新模态框关闭按钮事件已绑定');
        }
        if (autorefreshInterval) {
            autorefreshInterval.addEventListener('input', (e) => {
                autorefreshIntervalDisplay.textContent = e.target.value + '分钟';
            });
            console.log('✓ 自动刷新间隔滑块事件已绑定');
        }
        if (autorefreshEnabled) {
            autorefreshEnabled.addEventListener('change', () => {
                console.log('🔘 启用复选框被改变');
                updateAutoRefreshStatus();
            });
            console.log('✓ 自动刷新启用复选框事件已绑定');
        }

        // 选项卡切换
        document.querySelectorAll('.npc-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                switchNPCTab(tabName);
            });
        });

        // 设置头像上传处理
        if (npcAvatarUploadBtn) {
            npcAvatarUploadBtn.addEventListener('click', () => {
                document.getElementById('npc-avatar-input').click();
            });
        }

        // 直接处理NPC头像上传
        const npcAvatarInput = document.getElementById('npc-avatar-input');
        if (npcAvatarInput) {
            npcAvatarInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const preview = document.getElementById('npc-avatar-preview');
                        if (preview) preview.src = reader.result;
                    };
                    reader.onerror = (err) => console.error('文件读取失败:', err);
                    reader.readAsDataURL(file);
                    event.target.value = null;
                }
            });
        }

        console.log('✓ NPC系统事件绑定完成');

        // 【异步操作】从数据库加载NPC数据并渲染
        loadNPCDataAndRender();

    } catch (error) {
        console.error('NPC系统初始化异常:', error);
    }
}

// 异步加载NPC数据
async function loadNPCDataAndRender() {
    try {
        const npcList = await db.customNPCs.toArray();
        state.customNPCs = npcList || [];
        console.log(`✓ 已加载 ${state.customNPCs.length} 个NPC`);
        renderNPCList();
    } catch (error) {
        console.error('加载NPC数据失败:', error);
        state.customNPCs = [];
    }
}

// 打开NPC管理器
async function openNPCManager() {
    const modal = document.getElementById('npc-manager-modal');
    console.log('📍 openNPCManager 被调用');
    console.log('📍 modal element:', modal);

    if (modal) {
        console.log('📍 Modal的当前class:', modal.className);
        console.log('📍 Modal的当前display:', window.getComputedStyle(modal).display);

        modal.classList.add('visible');

        console.log('📍 添加visible后的class:', modal.className);
        console.log('📍 添加visible后的display:', window.getComputedStyle(modal).display);
        console.log('✓ Modal已添加visible类');
    } else {
        console.error('❌ 找不到npc-manager-modal元素！');
    }

    renderCharacterList();
    await renderNPCList();
}

// 关闭NPC管理器
function closeNPCManager() {
    document.getElementById('npc-manager-modal').classList.remove('visible');
    resetNPCForm();
}

// 【新增】渲染角色列表
function renderCharacterList() {
    const container = document.getElementById('character-list-container');
    console.log('📋 renderCharacterList 被调用, 容器:', !!container);

    if (!container) {
        console.warn('❌ character-list-container 不存在');
        return;
    }

    // 获取所有非群聊角色
    let characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    console.log(`📋 找到 ${characters.length} 个非群聊角色`);

    // 【新增】过滤：只显示有相关世界书的角色（世界书名称包含角色名）
    characters = characters.filter(chat => {
        const hasRelatedWorldBook = state.worldBooks.some(wb =>
            wb.name && wb.name.includes(chat.name)
        );
        if (!hasRelatedWorldBook) {
            console.log(`📋 角色 "${chat.name}" 没有相关世界书，已过滤`);
        }
        return hasRelatedWorldBook;
    });

    console.log('📋 所有角色:', Object.keys(state.chats).map(id => {
        const chat = state.chats[id];
        return `${chat.name} (isGroup: ${chat.isGroup})`;
    }));

    if (characters.length === 0) {
        console.log('📋 没有有相关世界书的角色，显示空状态');
        document.getElementById('character-empty-state').style.display = 'block';
        container.innerHTML = '';
        return;
    }

    console.log('📋 渲染 ' + characters.length + ' 个有相关世界书的角色');
    document.getElementById('character-empty-state').style.display = 'none';

    container.innerHTML = characters.map(chat => {
        // 获取头像 - 优先级：settings.aiAvatar > avatar > 默认头像
        const avatarUrl = chat.settings?.aiAvatar || chat.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';

        return `
        <div class="character-list-item" data-char-id="${chat.id}" style="
            padding: 10px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        ">
            <img src="${avatarUrl}" style="
                width: 40px;
                height: 40px;
                border-radius: 50%;
                object-fit: cover;
                background-color: #f0f0f0;
                flex-shrink: 0;
            " onerror="this.src='https://files.catbox.moe/q6z5fc.jpeg'">
            <div style="flex: 1; min-width: 0;">
                <div style="font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${chat.name}
                </div>
            </div>
            <button class="character-worldbook-btn" style="
                background: none;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 12px;
                cursor: pointer;
                color: var(--text-secondary);
                flex-shrink: 0;
            ">⚙️</button>
        </div>
    `;
    }).join('');

    // 绑定点击事件
    container.querySelectorAll('.character-worldbook-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const charId = btn.closest('.character-list-item').dataset.charId;
            openCharacterWorldBookModal(charId);
        });
    });
}

// 【新增】打开角色世界书设置模态框
function openCharacterWorldBookModal(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    console.log(`📖 打开角色 ${chat.name} 的世界书设置`);

    // 筛选：只显示名字包含角色名的世界书
    const filteredWorldBooks = state.worldBooks.filter(wb =>
        wb.name && wb.name.includes(chat.name)
    );

    console.log(`📖 为 ${chat.name} 筛选到 ${filteredWorldBooks.length} 本世界书`);

    // 获取当前保存的世界书绑定
    const characterWorldBookIds = chat.settings?.characterWorldBookIds || [];
    const npcWorldBookIds = chat.settings?.npcWorldBookIds || [];

    // 创建模态框容器
    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'character-worldbook-modal-overlay';
    modalOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: flex-end;
        z-index: 10000;
    `;

    // 创建模态框内容
    const modalContent = document.createElement('div');
    modalContent.id = 'character-worldbook-modal-content';
    modalContent.style.cssText = `
        width: 100%;
        max-height: 90vh;
        background-color: white;
        border-radius: 16px 16px 0 0;
        display: flex;
        flex-direction: column;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        animation: slideUp 0.3s ease-out;
    `;

    // 头部
    const header = document.createElement('div');
    header.style.cssText = `
        padding: 16px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
    `;
    header.innerHTML = `
        <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">
            ${chat.name} 的世界书设置
        </div>
        <button id="close-worldbook-modal" style="
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
        ">&times;</button>
    `;

    // 内容区域（可滚动）
    const scrollContainer = document.createElement('div');
    scrollContainer.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 24px;
    `;

    // 第一部分：角色自己的世界书
    const section1 = document.createElement('div');
    section1.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 12px;
    `;
    section1.innerHTML = `
        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">
            📖 角色自己的世界书（用于角色回复用户）
        </div>
        <div id="character-worldbook-list" style="display: flex; flex-direction: column; gap: 8px;">
            ${filteredWorldBooks.length === 0
                ? `<div style="color: var(--text-secondary); font-size: 13px;">暂无相关世界书</div>`
                : filteredWorldBooks.map(wb => `
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; border-radius: 6px; transition: background-color 0.2s;">
                        <input type="checkbox" class="character-worldbook-checkbox" data-wb-id="${wb.id}" data-type="character" ${characterWorldBookIds.includes(wb.id) ? 'checked' : ''} style="cursor: pointer; width: 18px; height: 18px;">
                        <span style="flex: 1; font-size: 13px; color: var(--text-primary);">${wb.name}</span>
                    </label>
                `).join('')
            }
        </div>
    `;

    // 第二部分：NPC回复用的世界书
    const section2 = document.createElement('div');
    section2.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 12px;
    `;
    section2.innerHTML = `
        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">
            🤖 NPC回复用的世界书（所有关联NPC使用）
        </div>
        <div id="npc-worldbook-list" style="display: flex; flex-direction: column; gap: 8px;">
            ${filteredWorldBooks.length === 0
                ? `<div style="color: var(--text-secondary); font-size: 13px;">暂无相关世界书</div>`
                : filteredWorldBooks.map(wb => `
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; border-radius: 6px; transition: background-color 0.2s;">
                        <input type="checkbox" class="npc-worldbook-checkbox" data-wb-id="${wb.id}" data-type="npc" ${npcWorldBookIds.includes(wb.id) ? 'checked' : ''} style="cursor: pointer; width: 18px; height: 18px;">
                        <span style="flex: 1; font-size: 13px; color: var(--text-primary);">${wb.name}</span>
                    </label>
                `).join('')
            }
        </div>
    `;

    scrollContainer.appendChild(section1);
    scrollContainer.appendChild(section2);

    // 底部按钮
    const footer = document.createElement('div');
    footer.style.cssText = `
        padding: 16px;
        border-top: 1px solid var(--border-color);
        display: flex;
        gap: 12px;
        flex-shrink: 0;
    `;
    footer.innerHTML = `
        <button id="cancel-worldbook-modal" style="
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: white;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        ">取消</button>
        <button id="save-worldbook-modal" style="
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background-color: var(--accent-color);
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        ">保存</button>
    `;

    // 组装模态框
    modalContent.appendChild(header);
    modalContent.appendChild(scrollContainer);
    modalContent.appendChild(footer);
    modalOverlay.appendChild(modalContent);
    document.body.appendChild(modalOverlay);

    // 绑定事件
    const closeModal = () => {
        modalOverlay.style.animation = 'slideDown 0.3s ease-in forwards';
        setTimeout(() => {
            document.body.removeChild(modalOverlay);
        }, 300);
    };

    document.getElementById('close-worldbook-modal').addEventListener('click', closeModal);
    document.getElementById('cancel-worldbook-modal').addEventListener('click', closeModal);

    // 保存事件
    document.getElementById('save-worldbook-modal').addEventListener('click', async () => {
        // 收集选中的世界书ID
        const selectedCharacterWBs = Array.from(
            document.querySelectorAll('.character-worldbook-checkbox:checked')
        ).map(cb => cb.dataset.wbId);

        const selectedNPCWBs = Array.from(
            document.querySelectorAll('.npc-worldbook-checkbox:checked')
        ).map(cb => cb.dataset.wbId);

        console.log(`💾 保存 ${chat.name} 的世界书绑定`);
        console.log(`  - 角色世界书: ${selectedCharacterWBs.length} 本`);
        console.log(`  - NPC世界书: ${selectedNPCWBs.length} 本`);

        // 更新 state 中的数据
        if (!chat.settings) chat.settings = {};
        chat.settings.characterWorldBookIds = selectedCharacterWBs;
        chat.settings.npcWorldBookIds = selectedNPCWBs;

        // 保存到数据库
        try {
            await db.chats.update(chatId, {
                settings: chat.settings
            });
            console.log(`✅ 世界书绑定保存成功`);

            // 显示成功提示
            const successMsg = document.createElement('div');
            successMsg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: #1E1E1E;
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10001;
                animation: fadeInOut 2s ease-in-out;
            `;
            successMsg.textContent = '✅ 保存成功';
            document.body.appendChild(successMsg);

            setTimeout(() => {
                document.body.removeChild(successMsg);
                closeModal();
            }, 2000);
        } catch (error) {
            console.error(`❌ 保存世界书绑定失败:`, error);
            alert('保存失败，请重试');
        }
    });

    // 点击背景关闭
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
            closeModal();
        }
    });
}

// 切换NPC选项卡
function switchNPCTab(tabName) {
    console.log(`📍 切换到选项卡: ${tabName}`);

    // 更新选项卡按钮样式
    document.querySelectorAll('.npc-tab-btn').forEach(btn => {
        btn.classList.remove('npc-tab-active');
        if (btn.dataset.tab === tabName) {
            btn.classList.add('npc-tab-active');
            btn.style.borderBottomColor = '#1E1E1E';
            btn.style.color = '#1E1E1E';
        } else {
            btn.style.borderBottomColor = 'transparent';
            btn.style.color = 'var(--text-secondary)';
        }
    });

    // 更新内容显示
    document.querySelectorAll('.npc-tab-content').forEach(content => {
        content.style.display = 'none';
    });

    // 【修改】支持多种标签页ID格式：characters-tab, npc-list-tab, npc-create-tab
    let tabId;
    if (tabName === 'characters') {
        tabId = 'characters-tab';
    } else {
        tabId = `npc-${tabName}-tab`;
    }

    const tabElement = document.getElementById(tabId);
    console.log(`📍 查找tab元素: ${tabId}, 找到:`, !!tabElement);

    if (tabElement) {
        tabElement.style.display = 'flex';  // 改为flex以支持flex布局
        console.log(`✓ 已显示 ${tabId}`);
    } else {
        console.error(`❌ 找不到tab元素: ${tabId}`);
    }

    // 切换到角色列表标签时渲染角色列表
    if (tabName === 'characters') {
        console.log('📍 初始化角色列表');
        renderCharacterList();
    }

    // 切换到创建标签时处理表单
    if (tabName === 'create') {
        console.log('📍 初始化创建表单');

        // 【关键修改】只在非编辑模式下重置表单
        if (!currentEditingNPCId) {
            console.log('  → 创建模式：重置表单');
            resetNPCForm();
        } else {
            console.log(`  → 编辑模式：保留现有数据`);
        }

        renderNPCFormCharacterList();
    }
}

// 【重命名】渲染角色列表（用于NPC创建表单中选择关联角色）
function renderNPCFormCharacterList() {
    const container = document.getElementById('npc-characters-container');
    if (!container) {
        console.warn('❌ npc-characters-container 不存在');
        return;
    }
    container.innerHTML = '';

    // 添加用户选项
    const userCheckbox = document.createElement('label');
    userCheckbox.className = 'npc-character-checkbox';
    userCheckbox.innerHTML = `
        <input type="checkbox" name="npc-character" value="user">
        <span class="npc-character-checkbox-label">用户（你自己）</span>
    `;
    container.appendChild(userCheckbox);

    // 添加所有非群聊的角色
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    characters.forEach(chat => {
        const label = document.createElement('label');
        label.className = 'npc-character-checkbox';
        label.innerHTML = `
            <input type="checkbox" name="npc-character" value="${chat.id}">
            <span class="npc-character-checkbox-label">${chat.name}</span>
        `;
        container.appendChild(label);
    });
}

// 渲染NPC列表
async function renderNPCList() {
    const container = document.getElementById('npc-list-container');
    const emptyState = document.getElementById('npc-empty-state');

    if (state.customNPCs.length === 0) {
        container.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }

    emptyState.style.display = 'none';
    container.innerHTML = '';

    state.customNPCs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'npc-list-item';

        // 获取关联角色的名称
        const charNames = npc.associatedCharacters
            .map(charId => {
                if (charId === 'user') return '用户';
                return state.chats[charId]?.name || charId;
            })
            .join(', ');

        item.innerHTML = `
            <img class="npc-list-item-avatar" src="${npc.avatar}" alt="${npc.name}">
            <div class="npc-list-item-info">
                <div class="npc-list-item-name">${npc.name}</div>
                <div class="npc-list-item-chars">关联角色：${charNames}</div>
            </div>
            <div class="npc-list-item-actions">
                <button class="npc-list-item-btn" data-npc-id="${npc.id}">编辑</button>
                <button class="npc-list-item-btn delete" data-npc-id="${npc.id}">删除</button>
            </div>
        `;

        // 编辑按钮
        item.querySelector(`button:not(.delete)`).addEventListener('click', () => {
            editNPC(npc.id);
        });

        // 删除按钮
        item.querySelector('button.delete').addEventListener('click', () => {
            deleteNPC(npc.id);
        });

        container.appendChild(item);
    });
}

// 【全局变量】用于追踪当前编辑的NPC
let currentEditingNPCId = null;

// 重置NPC表单
function resetNPCForm() {
    const form = document.getElementById('npc-form');
    if (form) form.reset();

    const preview = document.getElementById('npc-avatar-preview');
    if (preview) preview.src = 'https://files.catbox.moe/q6z5fc.jpeg';

    document.querySelectorAll('input[name="npc-character"]').forEach(cb => cb.checked = false);

    // 重置编辑状态
    currentEditingNPCId = null;
    updateSaveButtonText();
}

// 更新保存按钮文字
function updateSaveButtonText() {
    const btn = document.getElementById('npc-save-btn');
    if (btn) {
        btn.textContent = currentEditingNPCId ? '更新NPC' : '保存NPC';
    }
}

// 保存/更新NPC
async function saveNPC(e) {
    e.preventDefault();

    try {
        const name = document.getElementById('npc-name-input').value.trim();
        const persona = document.getElementById('npc-persona-input').value.trim();
        const avatar = document.getElementById('npc-avatar-preview').src;

        if (!name || !persona || !avatar) {
            alert('请填写所有必填项');
            return;
        }

        const associatedCharacters = Array.from(
            document.querySelectorAll('input[name="npc-character"]:checked')
        ).map(cb => cb.value);

        if (associatedCharacters.length === 0) {
            alert('请至少选择一个关联角色');
            return;
        }

        if (currentEditingNPCId) {
            // 【更新模式】更新现有NPC
            const existingIndex = state.customNPCs.findIndex(n => n.id === currentEditingNPCId);
            if (existingIndex !== -1) {
                const updatedNPC = {
                    ...state.customNPCs[existingIndex],
                    name,
                    persona,
                    avatar,
                    associatedCharacters
                };

                state.customNPCs[existingIndex] = updatedNPC;
                await db.customNPCs.update(currentEditingNPCId, updatedNPC);

                alert('NPC已更新！');
                console.log(`✓ NPC ${name} 已更新`);
            }
        } else {
            // 【创建模式】创建新NPC
            const npc = {
                id: Date.now(),
                name,
                persona,
                avatar,
                associatedCharacters
            };

            await db.customNPCs.add(npc);
            state.customNPCs.push(npc);

            alert('NPC已保存！');
            console.log(`✓ 新NPC ${name} 已创建`);
        }

        resetNPCForm();
        switchNPCTab('list');
        await renderNPCList();
    } catch (error) {
        console.error('保存NPC失败:', error);
        alert('保存失败: ' + error.message);
    }
}

// 编辑NPC
async function editNPC(npcId) {
    const npc = state.customNPCs.find(n => n.id === npcId);
    if (!npc) return;

    console.log(`📝 编辑NPC: ${npc.name}`);

    // 设置编辑模式
    currentEditingNPCId = npcId;

    // 填充表单
    document.getElementById('npc-name-input').value = npc.name;
    document.getElementById('npc-persona-input').value = npc.persona;
    document.getElementById('npc-avatar-preview').src = npc.avatar;

    // 选中关联角色
    document.querySelectorAll('input[name="npc-character"]').forEach(cb => {
        cb.checked = npc.associatedCharacters.includes(cb.value);
    });

    // 更新按钮文字
    updateSaveButtonText();

    // 切换到编辑视图（仍然叫'create'，但现在是编辑模式）
    switchNPCTab('create');
}

// 删除NPC
async function deleteNPC(npcId) {
    if (!confirm('确定要删除这个NPC吗？')) return;

    await db.customNPCs.delete(npcId);
    state.customNPCs = state.customNPCs.filter(n => n.id !== npcId);

    await renderNPCList();
    alert('NPC已删除');
}

// 触发NPC评论刷新
async function triggerNPCRefresh(isAutoRefresh = false) {
    // 【修复P2】初始化检查：确保NPC系统已初始化且有NPC存在
    if (!state.customNPCs || state.customNPCs.length === 0) {
        console.warn('⚠️ 没有可用的NPC，请先添加NPC');
        // 【修复】仅在手动刷新时弹出提示，自动刷新时静默
        if (!isAutoRefresh) {
            alert('请先添加NPC后再刷新');
        }
        return;
    }

    // 【修复P0】并发控制：防止重复调用
    if (state.isNPCRefreshing) {
        console.warn('⚠️ NPC刷新进行中，请稍候...');
        // 【修复】仅在手动刷新时弹出提示，自动刷新时静默
        if (!isAutoRefresh) {
            alert('NPC刷新进行中，请稍候...');
        }
        return;
    }

    state.isNPCRefreshing = true;
    const btn = document.getElementById('qzone-refresh-btn');
    const originalHTML = btn.innerHTML;
    // 【修复】仅在手动刷新时禁用按钮和显示旋转动画
    if (!isAutoRefresh) {
        btn.disabled = true;
        btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="animation: spin 1s linear infinite;"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0114.85-3.36M20.49 15a9 9 0 01-14.85 3.36"></path></svg>';
    }

    console.log(`${ isAutoRefresh ? '⏰' : '🔄'} ${isAutoRefresh ? '自动' : '手动'}刷新NPC...`);
    console.log('📊 NPC数量:', state.customNPCs.length);

    try {
        // 【优化】获取所有最近的帖子（不限数量，后续按需筛选）
        const allPosts = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
        console.log('📝 数据库中共有帖子数:', allPosts.length);

        if (allPosts.length === 0) {
            if (!isAutoRefresh) {
                alert('暂无帖子，无法评论');
            }
            return;
        }

        let commentCount = 0;
        let postCount = 0;
        // 【新增】收集所有本次刷新新增评论的标识
        state.newCommentPostIds.clear();

        // 为每个NPC调用一次API
        for (const npc of state.customNPCs) {
            console.log(`\n🤖 处理NPC: ${npc.name}`);
            console.log(`  📌 关联角色: ${npc.associatedCharacters.join('、')}`);

            // 【修改】随机20%概率发帖
            if (Math.random() < 0.2) {
                console.log(`  📤 NPC ${npc.name} 发帖...`);
                await generateNPCPost(npc);
                postCount++;
            }

            // 【优化】为当前NPC单独筛选关联角色发布的最近10条帖子
            const relevantPostsForNpc = allPosts.filter(post =>
                npc.associatedCharacters.includes(post.authorId)
            ).slice(0, 10);  // 只取最近10条

            console.log(`  💬 NPC ${npc.name} 必须评论... (获取到 ${relevantPostsForNpc.length} 条关联帖子)`);

            if (relevantPostsForNpc.length === 0) {
                console.log(`  ⚠️ NPC ${npc.name} 没有找到任何关联角色的帖子`);
                continue;
            }

            // 【修改】处理新的返回值格式
            const result = await generateNPCCommentsForPosts(npc, relevantPostsForNpc);
            commentCount += result.successCount;
            // 【新增】将新评论的标识合并到总集合中
            result.newCommentIds.forEach(commentId => state.newCommentPostIds.add(commentId));
        }

        console.log(`✅ ${isAutoRefresh ? '自动' : '手动'}刷新完成！新增评论：${commentCount}，新增帖子：${postCount}`);
        // 【新增】更新未读评论计数并保存
        state.qzoneSettings.unreadCommentsCount = (state.qzoneSettings.unreadCommentsCount || 0) + commentCount;
        await saveQzoneSettings();

        // 【修复】仅在手动刷新时弹出提示，自动刷新时静默
        if (!isAutoRefresh) {
            alert(`刷新完成！\n新增评论：${commentCount}\n新增帖子：${postCount}`);
        }
        await renderQzonePosts();
        // 【新增】刷新完成后实时更新返回按钮和底部导航的未读指示器
        updateBackBtnQzoneIndicator();
        updateQzoneBottomNavIndicator();
    } catch (error) {
        console.error('NPC刷新失败:', error);
        // 【修复】仅在手动刷新时弹出提示，自动刷新时静默
        if (!isAutoRefresh) {
            alert('刷新失败：' + error.message);
        }
    } finally {
        state.isNPCRefreshing = false;
        // 【修复】仅在手动刷新时恢复按钮状态
        if (!isAutoRefresh) {
            btn.innerHTML = originalHTML;
            btn.disabled = false;
        }
        console.log('✓ NPC刷新完成');
    }

    // 添加旋转动画CSS
    if (!document.getElementById('spin-style')) {
        const style = document.createElement('style');
        style.id = 'spin-style';
        style.textContent = `@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }`;
        document.head.appendChild(style);
    }
}

// 【新函数】一次性为NPC生成所有相关帖子的评论
async function generateNPCCommentsForPosts(npc, recentPosts) {
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            console.warn('❌ API配置不完整');
            return 0;
        }

        // 【优化】传入的 recentPosts 已经是筛选后的关联帖子，直接使用
        // （如果调用者没有预筛选，这里再补充一次筛选作为防御）
        let relevantPosts = recentPosts;
        if (recentPosts.length > 0 && !npc.associatedCharacters.includes(recentPosts[0].authorId)) {
            relevantPosts = recentPosts.filter(post => npc.associatedCharacters.includes(post.authorId));
        }

        if (relevantPosts.length === 0) {
            console.log(`  ✓ NPC ${npc.name} 没有关联的帖子`);
            return 0;
        }

        console.log(`  📋 准备为 ${relevantPosts.length} 条关联帖子生成评论`);

        // 【改进】计算最后NPC活跃时间戳（仅从关联帖子中获取，避免时间戳参考错误）
        let lastNPCActivityTime = 0;
        relevantPosts.forEach(post => {
            if (post.comments) {
                post.comments.forEach(comment => {
                    if (comment.commenterName === npc.name && comment.timestamp) {
                        lastNPCActivityTime = Math.max(lastNPCActivityTime, comment.timestamp);
                    }
                });
            }
        });

        // 【改进】为每条帖子构建完整的信息，包括内容和评论，标记新评论
        // 【修复】构建可评论的帖子列表和不可评论的帖子列表
        const postsFormatted = relevantPosts.map((post, idx) => {
            // 【修复】获取作者名字，支持普通角色、用户、NPC
            let authorName = '';
            if (post.authorId === 'user') {
                authorName = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorName = state.chats[post.authorId].name;
            } else if (post.authorId.startsWith('npc_')) {
                const npcId = post.authorId.substring(4);
                const tempNpc = state.customNPCs.find(n => n.id.toString() === npcId);
                authorName = tempNpc ? tempNpc.name : '未知NPC';
            } else {
                authorName = post.authorName || '未知';
            }
            let postInfo = `【帖子${idx + 1}】${authorName}发布：\n${post.content}`;

            // 检查NPC是否已评论过这条帖子
            const npcCommentedBefore = post.comments && post.comments.some(c => c.commenterName === npc.name);

            // 添加现有评论信息
            if (post.comments && post.comments.length > 0) {
                postInfo += `\n【现有评论】`;
                post.comments.forEach(comment => {
                    const isNew = comment.timestamp && comment.timestamp > lastNPCActivityTime;
                    const marker = isNew ? '【新】' : '';
                    const isNPCComment = comment.commenterName === npc.name ? '【你的评论】' : '';
                    // 【修复需求3】为评论者添加身份标记，让AI正确识别用户和角色
                    let identityTag = '';
                    if (comment.commenterName === state.qzoneSettings.nickname) {
                        identityTag = '【用户】';
                    } else if (comment.commenterName !== npc.name) {
                        // 检查是否是AI角色（包括普通角色）
                        const isAiChar = Object.values(state.chats).some(chat => chat.name === comment.commenterName);
                        const isOtherNPC = state.customNPCs.some(n => n.name === comment.commenterName);
                        if (isAiChar) {
                            identityTag = '【角色】';
                        } else if (isOtherNPC) {
                            identityTag = '【其他NPC】';
                        }
                    }
                    postInfo += `\n- ${marker}${isNPCComment}${identityTag}${comment.commenterName}：${comment.text}`;
                });
            }

            // 【修复问题2】重新评论条件判断：必须满足以下之一
            // 1. NPC之前没评论过
            // 2. NPC之前评论过，但现在有新评论（来自其他人或其他角色）
            // 3. NPC之前评论过，但有别人回复了NPC自己的评论
            if (npcCommentedBefore && post.comments) {
                // 【关键修复】检查是否有其他人的评论（不是NPC自己，也不是帖子作者自己的评论）
                const hasNewOthersComments = post.comments.some(c => {
                    if (c.commenterName === npc.name) return false;  // 排除NPC自己
                    if (!c.timestamp) return false;  // 排除没有时间戳的
                    // 只要有其他人的评论，都认为是新评论
                    return true;
                });

                // 检查是否有人回复了NPC的评论
                let hasReplyToNPC = post.comments.some(c => c.replyTo === npc.name);

                if (!hasNewOthersComments && !hasReplyToNPC) {
                    postInfo += `\n【⚠️ 已处理过，暂无新回复，不可再次评论】`;
                }
            }

            return postInfo;
        }).join('\n\n');

        // 【新增】收集NPC所有关联角色的npcWorldBookIds，去重后获取世界书内容
        let npcWorldBooksContext = '';
        if (npc.associatedCharacters && npc.associatedCharacters.length > 0) {
            const allNPCWorldBooks = new Set();

            npc.associatedCharacters.forEach(charId => {
                const char = state.chats[charId];
                if (char && char.settings && char.settings.npcWorldBookIds) {
                    char.settings.npcWorldBookIds.forEach(wbId => {
                        allNPCWorldBooks.add(wbId);
                    });
                }
            });

            // 获取世界书内容并组织
            if (allNPCWorldBooks.size > 0) {
                npcWorldBooksContext = '\n【世界书背景设定】\n';
                allNPCWorldBooks.forEach(wbId => {
                    const wb = state.worldBooks.find(w => w.id === wbId);
                    if (wb) {
                        npcWorldBooksContext += `## ${wb.name}\n${wb.content}\n\n`;
                    }
                });
            }
        }

        // 构建完整的PROMPT
        const currentTime = new Date().toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });

        // 【优化】根据帖子数量动态调整评论数量要求
        // 【用户需求】：小于4条 → 全部评论，大于等于4条 → 4-6条评论
        let minComments, maxComments, commentRange;
        if (relevantPosts.length < 4) {
            // 小于4条：全部评论
            minComments = relevantPosts.length;
            maxComments = relevantPosts.length;
            commentRange = `${minComments}`;
            console.log(`  📊 关联帖子 ${relevantPosts.length} 条(<4)，将全部评论`);
        } else {
            // 4条及以上：4-6条评论
            minComments = 4;
            maxComments = Math.min(6, relevantPosts.length);
            commentRange = minComments === maxComments ? `${minComments}` : `${minComments}-${maxComments}`;
            console.log(`  📊 关联帖子 ${relevantPosts.length} 条(≥4)，选择评论 ${commentRange} 条`);
        }

        // 【修复P1】改进PROMPT指导，确保AI正确理解re-engagement逻辑
        const prompt = `你是一个名为"${npc.name}"的角色。
【你的人设】
${npc.persona}${npcWorldBooksContext}

【当前时间】
${currentTime}

【你看到的最近动态】
${postsFormatted}

【评论判断规则】
1. 标记说明：
   - 【新】= 这是新增加的评论
   - 【你的评论】= 这是你之前发的评论
   - 【⚠️ 已处理过，暂无新回复，不可再次评论】= 你之前评论过这条动态，但没有新的回复，严格禁止再次评论
   - 【用户】= 这是用户（真实人类）发的评论
   - 【角色】= 这是其他AI角色发的评论
   - 【其他NPC】= 这是其他NPC发的评论

2. re-engagement规则（重要！）：
   - ❌ 如果某条动态标记了【⚠️ 已处理过，暂无新回复，不可再次评论】，你必须跳过它，绝对不能再次评论
   - ✅ 如果某条动态有【新】标记的评论，即使你已经评论过，也可以选择重新参与讨论
   - ✅ 总共有${relevantPosts.length}条动态，请只评论你真正感兴趣的${commentRange}条

【任务】
请你自己判断，为上面列出的动态中最感兴趣的${commentRange}条各生成一条评论。
- 每条评论应该20-80字，简短自然，像真实朋友圈评论一样
- 评论要有个人特色、体现你的人设和性格，可以用表情符号
- 不要长篇大论，避免过度表达
- 回复的动态编号必须是有效的（1到${relevantPosts.length}）
- 必须选择${commentRange}条动态来评论
- 输出格式为JSON数组，每个元素包含"postIndex"（帖子编号1-开始）、"comment"（评论内容）和可选的"replyTo"（如果你想回复某条评论）
- 示例格式：
  - 直接评论帖子：{"postIndex":1,"comment":"不错呀"}
  - 回复其他评论：{"postIndex":1,"comment":"同意","replyTo":"某人"}
- 输出只包含JSON数组，不要其他文字`;

        console.log(`  🔄 调用API为 ${npc.name} 生成评论...`);

        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: prompt }],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                stream: false
            })
        });

        if (!response.ok) {
            console.error(`  ❌ API响应错误: ${response.status}`);
            return 0;
        }

        const data = await response.json();
        const responseText = data.choices?.[0]?.message?.content || '';

        console.log(`  📝 API返回内容: ${responseText.substring(0, 100)}...`);

        // 解析JSON格式的评论
        try {
            // 【修复P1】使用非贪心匹配和验证确保JSON格式正确
            const jsonMatches = responseText.match(/\[[\s\S]*?\]/g);
            if (!jsonMatches || jsonMatches.length === 0) {
                console.warn('  ⚠️ 未找到JSON数组格式');
                return 0;
            }

            let commentsArray = [];
            // 使用第一个JSON数组（最可能是正确的）
            try {
                commentsArray = JSON.parse(jsonMatches[0]);
                if (!Array.isArray(commentsArray)) {
                    console.warn('  ⚠️ JSON不是数组格式');
                    return 0;
                }
            } catch (parseError) {
                console.warn('  ⚠️ 第一个JSON解析失败，尝试其他数组:', parseError);
                // 尝试其他匹配的JSON
                for (let i = 1; i < jsonMatches.length; i++) {
                    try {
                        commentsArray = JSON.parse(jsonMatches[i]);
                        if (Array.isArray(commentsArray)) break;
                    } catch (e) {
                        continue;
                    }
                }
                if (commentsArray.length === 0) {
                    return 0;
                }
            }

            // 【修复建议实施】验证评论数量是否符合要求
            if (commentsArray.length < minComments || commentsArray.length > maxComments) {
                console.warn(`  ⚠️ API返回了${commentsArray.length}条评论，不符合${commentRange}条的要求`);
                if (commentsArray.length > maxComments) {
                    console.log(`  → 已截断为前${maxComments}条`);
                    commentsArray = commentsArray.slice(0, maxComments);
                } else if (commentsArray.length < minComments && relevantPosts.length > 1) {
                    console.warn(`  → 少于${minComments}条评论，建议检查PROMPT或AI响应`);
                }
            }

            let successCount = 0;
            let invalidCount = 0;
            // 【新增】收集本次新增评论的标识（格式: postId_commenterName）
            const newCommentIds = new Set();

            for (const comment of commentsArray) {
                const postIdx = comment.postIndex - 1; // 转换为0-based索引
                if (postIdx >= 0 && postIdx < relevantPosts.length) {
                    const post = relevantPosts[postIdx];
                    if (!post.comments) post.comments = [];

                    post.comments.push({
                        commenterName: npc.name,
                        text: comment.comment,
                        timestamp: Date.now(),
                        replyTo: comment.replyTo || null  // 【修改】添加replyTo字段，用于标识回复对象
                    });

                    // 保存到数据库
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    successCount++;
                    // 【新增】记录这条新评论的标识（用于在UI上标记红点）
                    newCommentIds.add(`${post.id}_${npc.name}`);
                    console.log(`  ✓ 成功添加评论到帖子 ${comment.postIndex}`);
                } else {
                    // 【修复P0】记录无效索引
                    invalidCount++;
                    console.warn(`  ⚠️ 帖子索引${comment.postIndex}超出范围(最多${relevantPosts.length}条)`);
                }
            }

            if (invalidCount > 0) {
                console.warn(`  ⚠️ ${invalidCount}条评论因索引超出范围被忽略，请检查PROMPT限制`);
            }

            console.log(`  ✅ NPC ${npc.name} 添加了 ${successCount} 条评论`);
            // 【新增】返回对象，包含成功数和新评论的标识集合
            return { successCount, newCommentIds };

        } catch (e) {
            console.error('  ❌ 解析评论JSON失败:', e);
            // 【修改】返回一致的对象格式
            return { successCount: 0, newCommentIds: new Set() };
        }

    } catch (error) {
        console.error(`❌ 为NPC ${npc.name} 生成评论失败:`, error);
        // 【修改】返回一致的对象格式
        return { successCount: 0, newCommentIds: new Set() };
    }
}

// 【旧函数】生成NPC单条评论（保留备用）
async function generateNPCComment(npc, post) {
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) return;

        const authorChat = state.chats[post.authorId];
        if (!authorChat) return;

        // 构建上下文
        const worldBooks = getCharacterWorldBooks(authorChat);
        const currentTime = new Date().toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });

        const prompt = `你是一个名为"${npc.name}"的角色，人设如下：
${npc.persona}

你看到了${authorChat.name}发布的一条动态，内容如下：
${post.content}

请生成一条自然、符合你人设的评论（20-80字），简短自然，像真实朋友圈评论一样，直接输出评论内容即可。`;

        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: prompt }],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                stream: false
            })
        });

        if (!response.ok) return;

        const data = await response.json();
        const commentText = data.choices?.[0]?.message?.content || '';

        if (commentText) {
            if (!post.comments) post.comments = [];
            post.comments.push({
                commenterName: npc.name,
                text: commentText,
                timestamp: Date.now()
            });

            await db.qzonePosts.update(post.id, { comments: post.comments });
        }
    } catch (error) {
        console.error('生成NPC评论失败:', error);
    }
}

// 生成NPC帖子
async function generateNPCPost(npc) {
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) return;

        const currentTime = new Date().toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });

        // 【修改】支持三种动态类型：纯文字、图文、说说
        const prompt = `你是一个名为"${npc.name}"的角色，人设如下：
${npc.persona}

当前时间：${currentTime}

请发布一条符合你人设的动态。可以选择以下三种类型之一：
1. 纯文字动态（最常见）：{"postType": "shuoshuo", "content": "你的动态文字内容"}
2. 图文动态（带图片和文案）：{"postType": "text_image", "publicText": "公开文案（可选）", "hiddenContent": "图片具体描述"}

建议优先选择纯文字动态（70%概率），因为这是最自然的发帖方式。

输出格式必须是有效的JSON对象，包含postType和相应的内容字段。`;

        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: prompt }],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                stream: false
            })
        });

        if (!response.ok) return;

        const data = await response.json();
        const responseText = data.choices?.[0]?.message?.content || '';

        try {
            // 【改进】使用非贪心匹配，确保正确解析JSON
            const jsonMatch = responseText.match(/\{[\s\S]*?\}/);
            if (jsonMatch) {
                const postData = JSON.parse(jsonMatch[0]);

                // 【验证】确保postType有效
                const validPostTypes = ['shuoshuo', 'text_image'];
                if (!validPostTypes.includes(postData.postType)) {
                    console.warn(`⚠️ 无效的postType: ${postData.postType}`);
                    return;
                }

                const newPost = {
                    type: postData.postType,
                    content: postData.content || '',
                    publicText: postData.publicText || '',
                    hiddenContent: postData.hiddenContent || '',
                    authorId: 'npc_' + npc.id,
                    authorName: npc.name,
                    authorAvatar: npc.avatar,
                    timestamp: Date.now(),
                    comments: [],
                    likes: []
                };

                await db.qzonePosts.add(newPost);
                console.log(`  ✓ NPC ${npc.name} 发布了${postData.postType === 'shuoshuo' ? '纯文字' : '图文'}动态`);
            }
        } catch (e) {
            console.error('解析NPC帖子JSON失败:', e);
        }
    } catch (error) {
        console.error('生成NPC帖子失败:', error);
    }
}

// 获取角色的世界书（只包含标题含角色名的）
function getCharacterWorldBooks(chat) {
    const linkedIds = offlineMode.isOffline
        ? chat.settings.linkedWorldBookIdsOffline || []
        : chat.settings.linkedWorldBookIds || [];

    return linkedIds
        .map(id => state.worldBooks.find(wb => wb.id === id))
        .filter(wb => wb && wb.name && wb.name.includes(chat.name))
        .map(wb => `## ${wb.name}\n${wb.content}`)
        .join('\n\n');
}

// ▼▼▼ 【新增】导入角色卡处理函数 ▼▼▼

/**
 * 主导入函数 - 处理PNG和JSON格式的角色卡
 */
async function handleCharacterImport(file) {
    if (!file) return;

    try {
        let characterData;
        let avatarBase64;

        if (file.name.toLowerCase().endsWith('.png')) {
            // 如果是PNG文件，调用PNG解析函数
            const result = await parseCharPng(file);
            characterData = result.characterData;
            avatarBase64 = result.avatarBase64;
        } else if (file.name.toLowerCase().endsWith('.json')) {
            // 如果是JSON文件，调用JSON解析函数
            characterData = await parseCharJson(file);
            // JSON卡通常不包含图片，我们给一个默认头像
            avatarBase64 = defaultAvatar;
        } else if (file.name.toLowerCase().endsWith('.docx') || file.name.toLowerCase().endsWith('.doc')) {
            // 如果是DOCX文件，调用DOCX解析函数
            characterData = await parseCharDocx(file);
            avatarBase64 = defaultAvatar;
        } else if (file.name.toLowerCase().endsWith('.txt')) {
            // 如果是TXT文件，调用TXT解析函数
            characterData = await parseCharTxt(file);
            avatarBase64 = defaultAvatar;
        } else {
            alert('不支持的文件格式，请选择 .png、.json、.docx 或 .txt 文件。');
            return;
        }

        if (characterData) {
            // 成功解析出数据后，调用创建函数
            await createCharacterFromData(characterData, avatarBase64);
        }

    } catch (error) {
        console.error("导入角色卡失败:", error);
        alert(`导入失败: ${error.message}`);
    }
}

/**
 * 解析SillyTavern的PNG角色卡
 */
async function parseCharPng(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const arrayBuffer = e.target.result;
            const dataView = new DataView(arrayBuffer);

            if (dataView.getUint32(0) !== 0x89504E47 || dataView.getUint32(4) !== 0x0D0A1A0A) {
                return reject(new Error('文件不是一个有效的PNG图片。'));
            }

            let offset = 8;
            let characterJson = null;

            while (offset < dataView.byteLength) {
                const length = dataView.getUint32(offset);
                const type = String.fromCharCode(
                    dataView.getUint8(offset + 4),
                    dataView.getUint8(offset + 5),
                    dataView.getUint8(offset + 6),
                    dataView.getUint8(offset + 7)
                );

                if (type === 'tEXt') {
                    const chunkData = new Uint8Array(arrayBuffer, offset + 8, length);

                    // ★★★★★【核心乱码修复代码】★★★★★
                    let text = '';
                    for (let i = 0; i < chunkData.length; i++) {
                        text += String.fromCharCode(chunkData[i]);
                    }

                    const keyword = 'chara' + String.fromCharCode(0);
                    if (text.startsWith(keyword)) {
                        const base64Data = text.substring(keyword.length);
                        try {
                            const binaryString = atob(base64Data);

                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }

                            const decodedJsonString = new TextDecoder('utf-8').decode(bytes);

                            characterJson = JSON.parse(decodedJsonString);
                            break;
                        } catch (e) {
                            return reject(new Error('解析图片内嵌的角色数据失败，可能是数据损坏。'));
                        }
                    }
                    // ★★★★★【核心代码结束】★★★★★
                }

                if (type === 'IEND') break;
                offset += 12 + length;
            }

            if (characterJson) {
                const imageReader = new FileReader();
                imageReader.onload = (imgEvent) => {
                    resolve({
                        characterData: characterJson,
                        avatarBase64: imgEvent.target.result
                    });
                };
                imageReader.onerror = () => reject(new Error('读取图片作为头像失败。'));
                imageReader.readAsDataURL(file);
            } else {
                reject(new Error('在这张PNG图片中没有找到SillyTavern角色数据。'));
            }
        };
        reader.onerror = () => reject(new Error('读取PNG文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 解析JSON角色卡
 */
async function parseCharJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder('utf-8');
                const jsonString = textDecoder.decode(arrayBuffer);
                const data = JSON.parse(jsonString);
                resolve(data.data || data);
            } catch (error) {
                reject(new Error('解析JSON文件失败，请检查文件格式或编码。'));
            }
        };
        reader.onerror = () => reject(new Error('读取JSON文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 解析DOCX文件（Word文档）
 */
async function parseCharDocx(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const arrayBuffer = e.target.result;
                // 使用mammoth库解析DOCX文件
                const result = await mammoth.extractRawText({arrayBuffer: arrayBuffer});
                const text = result.value || '';

                // 构造一个虚拟的角色数据对象
                const characterData = {
                    name: file.name.replace(/\.(docx|doc)$/i, '') || '未命名角色',
                    description: text || '该角色没有描述。'
                };

                resolve(characterData);
            } catch (error) {
                reject(new Error('解析DOCX文件失败: ' + error.message));
            }
        };
        reader.onerror = () => reject(new Error('读取DOCX文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 解析TXT文件（纯文本）
 */
async function parseCharTxt(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder('utf-8');
                const text = textDecoder.decode(arrayBuffer);

                // 构造一个虚拟的角色数据对象
                const characterData = {
                    name: file.name.replace(/\.txt$/i, '') || '未命名角色',
                    description: text || '该角色没有描述。'
                };

                resolve(characterData);
            } catch (error) {
                reject(new Error('解析TXT文件失败: ' + error.message));
            }
        };
        reader.onerror = () => reject(new Error('读取TXT文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 创建角色 - 包含世界书导入逻辑
 */
async function createCharacterFromData(data, avatarBase64) {
    const charData = data.data || data;
    const characterName = charData.name ? charData.name.trim() : '未命名角色';

    const newChatId = 'chat_' + Date.now();
    const newChat = {
        id: newChatId,
        name: characterName,
        originalName: '', // 导入的角色卡备注名默认为空
        isGroup: false,
        isPinned: false,
        history: [],
        unreadCount: 0,
        musicData: { totalTime: 0 },
        npcLibrary: [],
        relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
        status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
        weiboDms: [],
        loversSpaceData: null,
        settings: {
            aiPersona: charData.description || '该角色没有描述。',
            myPersona: '我是谁呀。',
            maxMemory: 10,
            aiAvatar: avatarBase64,
            myAvatar: defaultAvatar,
            background: '',
            theme: 'default',
            fontSize: state.globalSettings.fontSize || 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarLibrary: [],
            stickerLibrary: [],
            summary: {
                enabled: false,
                mode: 'auto',
                count: 20,
                prompt: '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。',
                lastSummaryIndex: -1
            },
            linkedMemories: [],
            offlineMode: {
                enabled: false,
                prompt: '',
                style: '',
                wordCount: 300,
                presets: []
            },
            timePerceptionEnabled: true,
            customTime: '',
            isCoupleAvatar: false,
            coupleAvatarDescription: '',
            weiboProfession: '',
            weiboInstruction: '',
            visualVideoCallEnabled: false,
            charVideoImage: '',
            userVideoImage: '',
            petAdopted: false,
            pet: null,
        },
        characterPhoneData: {
            lastGenerated: null,
            chats: {},
            shoppingCart: [],
            memos: [],
            browserHistory: [],
            photoAlbum: [],
            bank: { balance: 0, transactions: [] },
            trajectory: [],
            appUsage: [],
            diary: []
        }
    };

    await db.chats.put(newChat);
    state.chats[newChatId] = newChat;

    console.log("开始检测世界书数据...");
    let worldBookFound = false;
    let importedCategoryId = null;

    // 策略一：最高优先级 - character_book 格式
    if (charData.character_book && charData.character_book.entries && Array.isArray(charData.character_book.entries) && charData.character_book.entries.length > 0) {
        console.log(`检测到最新的 character_book 格式 (${charData.character_book.entries.length}条)，开始导入...`);
        const newCategory = { name: characterName + '的设定集' };
        importedCategoryId = await db.worldBookCategories.add(newCategory);
        await saveWorldBookEntriesFromArray(charData.character_book.entries, importedCategoryId);
        worldBookFound = true;
    }

    // 策略二：兼容旧的 world_entries 格式
    else if (charData.world_entries && Array.isArray(charData.world_entries) && charData.world_entries.length > 0) {
        console.log(`检测到旧版 world_entries 格式 (${charData.world_entries.length}条)，开始导入...`);
        const newCategory = { name: characterName + '的设定集' };
        importedCategoryId = await db.worldBookCategories.add(newCategory);
        await saveWorldBookEntriesFromArray(charData.world_entries, importedCategoryId);
        worldBookFound = true;
    }

    // 策略三：兼容更旧的 data.world 格式
    else if (data.world && typeof data.world === 'string' && data.world.trim()) {
        console.log("检测到外层 world 字段格式，开始导入...");
        const newCategory = { name: characterName + '的设定集' };
        importedCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(data.world, importedCategoryId);
        worldBookFound = true;
    }

    // 策略四：最后兼容手段 - world_info
    else if (charData.world_info && typeof charData.world_info === 'string' && charData.world_info.trim()) {
        console.log("检测到旧版 world_info 字段格式，开始导入...");
        const newCategory = { name: characterName + '的设定集' };
        importedCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(charData.world_info, importedCategoryId);
        worldBookFound = true;
    }

    if (!worldBookFound) {
        console.log("诊断：在此角色卡中未找到任何可识别的世界书字段。");
    }

    // ▼▼▼ 【新增】自动绑定导入的世界书到聊天（线上+线下） ▼▼▼
    if (worldBookFound && importedCategoryId !== null) {
        // 获取该分类下的所有世界书，且 enabled 不为 false
        const worldBooksInCategory = state.worldBooks.filter(wb => wb.categoryId === importedCategoryId && wb.enabled !== false);

        if (worldBooksInCategory.length > 0) {
            // 获取这些世界书的ID
            const bookIds = worldBooksInCategory.map(wb => wb.id);

            // 同时绑定到线上和线下模式
            newChat.settings.linkedWorldBookIds = bookIds;
            newChat.settings.linkedWorldBookIdsOffline = bookIds;

            // 更新数据库
            await db.chats.put(newChat);
            state.chats[newChatId] = newChat;

            console.log(`已将 ${bookIds.length} 个世界书自动绑定到角色 "${characterName}"（线上+线下模式）`);
        }
    }
    // ▲▲▲ 自动绑定逻辑结束 ▲▲▲

    await renderChatList();
    await showCustomAlert('导入成功！', `角色"${characterName}"已成功创建！`);
}

/**
 * 从数组直接保存世界书条目
 */
async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
    const newBooks = [];

    for (const entry of entriesArray) {
        const entryName = (entry.comment && entry.comment.trim())
                          ? entry.comment.trim()
                          : (entry.keys && entry.keys.length > 0 ? entry.keys.join(', ') : '未命名条目');

        // 只要有名称和内容，不管 enabled 和 selective 字段，全部导入
        if (entryName !== '未命名条目' && entry.content && entry.content.trim()) {
            newBooks.push({
                id: 'wb_' + Date.now() + Math.random(),
                name: entryName,
                content: entry.content,
                categoryId: categoryId
            });
        }
    }

    if (newBooks.length > 0) {
        await db.worldBooks.bulkAdd(newBooks);
        const allBooks = await db.worldBooks.toArray();
        state.worldBooks = allBooks;
        console.log(`成功导入 ${newBooks.length} 个世界书条目到分类ID: ${categoryId}`);
    }
}

/**
 * 解析并保存世界书（用于旧格式的字符串内容）
 */
async function parseAndSaveWorldBooks(worldContent, categoryId) {
    const newBooks = [];
    const lines = worldContent.split('\n');
    let currentEntry = null;

    for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // 简单的格式识别：以 # 开头为条目标题
        if (trimmed.startsWith('#')) {
            if (currentEntry && currentEntry.content.trim()) {
                newBooks.push({
                    id: 'wb_' + Date.now() + Math.random(),
                    name: currentEntry.name,
                    content: currentEntry.content.trim(),
                    categoryId: categoryId
                });
            }
            currentEntry = { name: trimmed.replace(/^#+\s*/, ''), content: '' };
        } else if (currentEntry) {
            currentEntry.content += line + '\n';
        }
    }

    if (currentEntry && currentEntry.content.trim()) {
        newBooks.push({
            id: 'wb_' + Date.now() + Math.random(),
            name: currentEntry.name,
            content: currentEntry.content.trim(),
            categoryId: categoryId
        });
    }

    if (newBooks.length > 0) {
        await db.worldBooks.bulkAdd(newBooks);
        const allBooks = await db.worldBooks.toArray();
        state.worldBooks = allBooks;
        console.log(`成功解析并导入 ${newBooks.length} 个世界书条目`);
    }
}

// ▲▲▲ 导入角色卡处理函数结束 ▲▲▲

// 初始化NPC系统
initNPCSystem();

// 【新增】加载自动刷新设置
loadAutoRefreshSettings();

// ▼▼▼ Profile 相关的事件监听和初始化 ▼▼▼
// 添加事件监听：监听home-screen内的可编辑元素点击
document.getElementById('home-screen').addEventListener('click', async (e) => {
    const editableText = e.target.closest('.editable-text');
    if (editableText) {
        handleEditText(editableText);
        return;
    }

    const editableImage = e.target.closest('.editable-image');
    if (editableImage) {
        handleEditImage(editableImage);
        return;
    }
});

// 恢复Profile数据
function restoreProfileData() {
    if (!state.globalSettings.widgetData) return;

    const data = state.globalSettings.widgetData;

    // 恢复文本内容
    if (data['profile-username']) {
        const elem = document.getElementById('profile-username');
        if (elem) elem.textContent = data['profile-username'];
    }
    if (data['profile-sub-username']) {
        const elem = document.getElementById('profile-sub-username');
        if (elem) elem.textContent = data['profile-sub-username'];
    }
    if (data['profile-bio']) {
        const elem = document.getElementById('profile-bio');
        if (elem) elem.textContent = data['profile-bio'];
    }
    if (data['profile-location']) {
        const elem = document.getElementById('profile-location');
        if (elem) elem.innerHTML = data['profile-location'];
    }

    // 恢复图片URL
    if (data['profile-banner-img']) {
        const elem = document.getElementById('profile-banner-img');
        if (elem) elem.src = data['profile-banner-img'];
    }
    if (data['profile-avatar-img']) {
        const elem = document.getElementById('profile-avatar-img');
        if (elem) elem.src = data['profile-avatar-img'];
    }

    // ▼▼▼ 恢复Desktop Widget数据 ▼▼▼
    // 恢复widget-text-1
    if (data['widget-text-1']) {
        const elem = document.getElementById('widget-text-1');
        if (elem) elem.textContent = data['widget-text-1'];
    }

    // 恢复widget-avatar-1
    if (data['widget-avatar-1']) {
        const elem = document.getElementById('widget-avatar-1');
        if (elem) elem.src = data['widget-avatar-1'];
    }

    // 恢复widget-text-2
    if (data['widget-text-2']) {
        const elem = document.getElementById('widget-text-2');
        if (elem) elem.textContent = data['widget-text-2'];
    }

    // 恢复widget-avatar-2
    if (data['widget-avatar-2']) {
        const elem = document.getElementById('widget-avatar-2');
        if (elem) elem.src = data['widget-avatar-2'];
    }

    // 恢复widget-text-3
    if (data['widget-text-3']) {
        const elem = document.getElementById('widget-text-3');
        if (elem) elem.textContent = data['widget-text-3'];
    }
    // ▲▲▲ Desktop Widget数据恢复结束 ▲▲▲

    // ▼▼▼ 恢复音乐组件数据 ▼▼▼
    if (data['music-cover-img']) {
        const elem = document.getElementById('music-cover-img');
        if (elem) elem.src = data['music-cover-img'];
    }
    if (data['music-title']) {
        const elem = document.getElementById('music-title');
        if (elem) elem.textContent = data['music-title'];
    }
    if (data['music-widget-label']) {
        const elem = document.getElementById('music-widget-label');
        if (elem) elem.textContent = data['music-widget-label'];
    }
    // ▲▲▲ 音乐组件数据恢复结束 ▲▲▲

    // ▼▼▼ 恢复小卡片组件数据 ▼▼▼
    if (data['mini-card-img']) {
        const elem = document.getElementById('mini-card-img');
        if (elem) elem.src = data['mini-card-img'];
    }
    if (data['mini-card-text']) {
        const elem = document.getElementById('mini-card-text');
        if (elem) elem.textContent = data['mini-card-text'];
    }
    // ▲▲▲ 小卡片组件数据恢复结束 ▲▲▲
}

// ▲▲▲ Profile 相关初始化结束 ▲▲▲

// ▼▼▼ ========== NovelAI 核心函数定义 ========== ▼▼▼

// 加载NovelAI设置
function loadNovelAISettings(skipMainPanelInputs = false) {
    // 加载基本设置
    const settings = localStorage.getItem('novelai-settings');
    console.log('[DEBUG] loadNovelAISettings - localStorage中的数据:', settings);
    if (settings) {
        const data = JSON.parse(settings);
        console.log('[DEBUG] loadNovelAISettings - 解析后的数据:', data);
        console.log('[DEBUG] loadNovelAISettings - uc_preset:', data.uc_preset);
        document.getElementById('nai-resolution').value = data.resolution || '1024x1024';
        document.getElementById('nai-steps').value = data.steps || 28;
        document.getElementById('nai-cfg-scale').value = data.cfg_scale || 5;
        document.getElementById('nai-sampler').value = data.sampler || 'k_euler_ancestral';
        document.getElementById('nai-seed').value = data.seed || -1;
        const ucPresetSelect = document.getElementById('nai-uc-preset');
        const ucPresetValue = String(data.uc_preset !== undefined ? data.uc_preset : 1);
        ucPresetSelect.value = ucPresetValue;
        console.log('[DEBUG] loadNovelAISettings - 设置后nai-uc-preset的值:', ucPresetSelect.value);
        console.log('[DEBUG] loadNovelAISettings - 验证，DOM中的实际值:', document.getElementById('nai-uc-preset').value);
        document.getElementById('nai-quality-toggle').checked = data.quality_toggle !== false;
        document.getElementById('nai-smea').checked = data.smea !== false;
        document.getElementById('nai-smea-dyn').checked = data.smea_dyn === true;
        document.getElementById('nai-default-positive').value = data.default_positive || 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style';
        document.getElementById('nai-default-negative').value = data.default_negative || 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry';
        document.getElementById('nai-cors-proxy').value = data.cors_proxy !== undefined ? data.cors_proxy : 'https://corsproxy.io/?';
        if (data.cors_proxy === 'custom') {
            document.getElementById('nai-custom-proxy-group').style.display = 'block';
            document.getElementById('nai-custom-proxy-url').value = data.custom_proxy_url || '';
        }
    } else {
        console.log('[DEBUG] loadNovelAISettings - localStorage中没有保存的数据');
    }

    // 【核心】只在页面初始化时加载主面板的API Key和Model，打开设置弹窗时跳过
    if (!skipMainPanelInputs) {
        const isEnabled = localStorage.getItem('novelai-enabled') === 'true';
        document.getElementById('novelai-switch').checked = isEnabled;
        document.getElementById('novelai-details').style.display = isEnabled ? 'block' : 'none';

        const apiKey = localStorage.getItem('novelai-api-key');
        if (apiKey) {
            document.getElementById('novelai-api-key').value = apiKey;
        }

        const model = localStorage.getItem('novelai-model');
        if (model) {
            document.getElementById('novelai-model').value = model;
        }
    }
}

// 保存NovelAI设置
function saveNovelAISettings() {
    const settings = {
        resolution: document.getElementById('nai-resolution').value,
        steps: parseInt(document.getElementById('nai-steps').value),
        cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
        sampler: document.getElementById('nai-sampler').value,
        seed: parseInt(document.getElementById('nai-seed').value),
        uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
        quality_toggle: document.getElementById('nai-quality-toggle').checked,
        smea: document.getElementById('nai-smea').checked,
        smea_dyn: document.getElementById('nai-smea-dyn').checked,
        default_positive: document.getElementById('nai-default-positive').value,
        default_negative: document.getElementById('nai-default-negative').value,
        cors_proxy: document.getElementById('nai-cors-proxy').value,
        custom_proxy_url: document.getElementById('nai-custom-proxy-url').value
    };
    console.log('[DEBUG] saveNovelAISettings - 保存前的值:', settings);
    console.log('[DEBUG] saveNovelAISettings - uc_preset:', settings.uc_preset);
    localStorage.setItem('novelai-settings', JSON.stringify(settings));
    console.log('[DEBUG] saveNovelAISettings - 已保存到localStorage');

    // 【核心】同时保存开关状态、API Key 和 Model
    localStorage.setItem('novelai-enabled', document.getElementById('novelai-switch').checked ? 'true' : 'false');
    localStorage.setItem('novelai-api-key', document.getElementById('novelai-api-key').value.trim());
    localStorage.setItem('novelai-model', document.getElementById('novelai-model').value);
}

// 重置NovelAI设置
function resetNovelAISettings() {
    localStorage.removeItem('novelai-settings');
    loadNovelAISettings();
}

// 获取NovelAI设置
function getNovelAISettings() {
    const defaultSettings = {
        resolution: '1024x1024',
        steps: 28,
        cfg_scale: 5,
        sampler: 'k_euler_ancestral',
        seed: -1,
        uc_preset: 1,
        quality_toggle: true,
        smea: true,
        smea_dyn: false,
        default_positive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
        default_negative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
        cors_proxy: 'https://corsproxy.io/?',
        custom_proxy_url: ''
    };

    const saved = localStorage.getItem('novelai-settings');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            // 确保所有数值类型正确
            parsed.steps = parsed.steps !== undefined ? parseInt(parsed.steps) : 28;
            parsed.cfg_scale = parsed.cfg_scale !== undefined ? parseFloat(parsed.cfg_scale) : 5;
            parsed.seed = parsed.seed !== undefined ? parseInt(parsed.seed) : -1;
            parsed.uc_preset = parsed.uc_preset !== undefined ? parseInt(parsed.uc_preset) : 1;
            return {...defaultSettings, ...parsed};
        } catch (e) {
            return defaultSettings;
        }
    }
    return defaultSettings;
}

// 保存角色NAI提示词（持久化到 characterNaiPrompts 表）
async function saveCharacterNAIPrompts() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const chatId = state.activeChatId;

    if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {};
    }

    const positivePrompt = document.getElementById('character-nai-positive').value.trim();
    const negativePrompt = document.getElementById('character-nai-negative').value.trim();

    // 同步到 chat.settings.naiSettings（内存）
    chat.settings.naiSettings.characterPositivePrompt = positivePrompt;
    chat.settings.naiSettings.characterNegativePrompt = negativePrompt;

    console.log('💾 保存角色NAI提示词');
    console.log('   chatId:', chatId);
    console.log('   characterPositivePrompt:', positivePrompt);
    console.log('   characterNegativePrompt:', negativePrompt);

    // 保存到 chats 表（用于向后兼容）
    await db.chats.put(chat);

    // 【新增】同时保存到 characterNaiPrompts 表（专属表，确保持久化）
    await db.characterNaiPrompts.put({
        chatId: chatId,
        characterName: chat.name,
        characterPositivePrompt: positivePrompt,
        characterNegativePrompt: negativePrompt,
        updatedAt: new Date().toISOString()
    });

    console.log('✅ 角色NAI提示词已保存到数据库');
}

// 【新增】从数据库加载角色NAI提示词
async function loadCharacterNAIPrompts(chatId) {
    try {
        const prompts = await db.characterNaiPrompts.get(chatId);
        if (prompts) {
            console.log('📖 从数据库加载角色NAI提示词:', prompts);
            return {
                positive: prompts.characterPositivePrompt || '',
                negative: prompts.characterNegativePrompt || ''
            };
        }
    } catch (e) {
        console.warn('⚠️ 加载角色NAI提示词失败:', e);
    }
    return { positive: '', negative: '' };
}

// 获取角色NAI提示词配置（支持系统配置和角色专属配置）
function getCharacterNAIPrompts(chatId) {
    // 获取系统默认配置
    const systemSettings = getNovelAISettings();

    // 如果没有指定角色ID或角色不存在，返回系统配置
    if (!chatId || !state.chats[chatId]) {
        console.log('⚠️ 【NAI提示词】没有角色，使用系统配置');
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }

    const chat = state.chats[chatId];
    const naiSettings = chat.settings.naiSettings || {};

    // 如果角色有独立配置（正面提示词不为空），就用角色配置
    if (naiSettings.characterPositivePrompt) {
        console.log('🎯 【NAI提示词】使用角色专属配置 - ' + chat.name);
        console.log('   ✅ 正面提示词:', naiSettings.characterPositivePrompt);
        console.log('   ✅ 负面提示词:', naiSettings.characterNegativePrompt || '(空)');

        return {
            positive: naiSettings.characterPositivePrompt,
            negative: naiSettings.characterNegativePrompt || '',
            source: 'character'
        };
    } else {
        console.log('📋 【NAI提示词】使用系统默认配置（' + chat.name + '未设置专属提示词）');
        console.log('   正面:', systemSettings.default_positive || '(空)');
        console.log('   负面:', systemSettings.default_negative || '(空)');

        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
}

// 生成NovelAI图像 - 完整版（来自index.html）
async function generateNovelAIImage() {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    const prompt = document.getElementById('nai-test-prompt').value.trim();

    if (!apiKey) {
        alert('请先配置NovelAI API Key！');
        return;
    }

    if (!prompt) {
        alert('请输入提示词！');
        return;
    }

    const settings = getNovelAISettings();
    const negativePrompt = document.getElementById('nai-test-negative').value.trim();

    // 📋 调试输出：完整的 NovelAI 生成设置
    console.log('%c🎨 NovelAI 生成设置详情', 'color: #FF6B6B; font-size: 14px; font-weight: bold;');
    console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #FF6B6B;');
    console.log('%c模型配置：', 'color: #4ECDC4; font-weight: bold;');
    console.log('  • NovelAI 模型:', model);
    console.log('%c分辨率与采样：', 'color: #4ECDC4; font-weight: bold;');
    console.log('  • 分辨率 (Resolution):', settings.resolution);
    console.log('  • 步数 (Steps):', settings.steps);
    console.log('  • CFG Scale:', settings.cfg_scale);
    console.log('  • 采样器 (Sampler):', settings.sampler);
    console.log('  • 随机种子 (Seed):', settings.seed);
    console.log('%c高级选项：', 'color: #4ECDC4; font-weight: bold;');
    console.log('  • UC Preset:', settings.uc_preset);
    console.log('  • Quality Toggle:', settings.quality_toggle);
    console.log('  • SMEA:', settings.smea);
    console.log('  • SMEA Dynamic:', settings.smea_dyn);
    console.log('%c代理设置：', 'color: #4ECDC4; font-weight: bold;');
    console.log('  • CORS 代理:', settings.cors_proxy);
    console.log('  • 自定义代理 URL:', settings.custom_proxy_url);
    console.log('%c正面提示词 (Positive Prompt)：', 'color: #95E1D3; font-weight: bold;');
    console.log(prompt);
    console.log('%c负面提示词 (Negative Prompt)：', 'color: #F38181; font-weight: bold;');
    console.log(negativePrompt || '(使用默认)');
    console.log('%c默认正面提示词：', 'color: #AAF683; font-weight: bold;');
    console.log(settings.default_positive);
    console.log('%c默认负面提示词：', 'color: #FFD700; font-weight: bold;');
    console.log(settings.default_negative);
    console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #FF6B6B;');

    const statusDiv = document.getElementById('nai-test-status');
    const resultDiv = document.getElementById('nai-test-result');
    const errorDiv = document.getElementById('nai-test-error');
    const generateBtn = document.getElementById('nai-generate-btn');

    statusDiv.style.display = 'block';
    resultDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    generateBtn.disabled = true;
    generateBtn.textContent = '生成中...';

    try {
        const [width, height] = settings.resolution.split('x').map(Number);

        // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
        let requestBody;

        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 使用新格式 (params_version: 3)
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    params_version: 3,  // V4必须使用版本3
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras',  // V4使用karras
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                    // V4专用提示词格式
                    v4_prompt: {
                        caption: {
                            base_caption: prompt,
                            char_captions: []
                        },
                        use_coords: false,
                        use_order: true
                    },
                    // V4专用负面提示词格式
                    v4_negative_prompt: {
                        caption: {
                            base_caption: negativePrompt,
                            char_captions: []
                        },
                        legacy_uc: false
                    },
                    negative_prompt: negativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                    // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                }
            };
        } else {
            // V3 及更早版本使用旧格式
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: negativePrompt
                }
            };
        }

        console.log('📤 发送请求到 NovelAI API');
        console.log('📊 使用模型:', model);

        // ★★★ 根据模型选择不同的API端点 ★★★
        let apiUrl;

        // V4/V4.5 模型使用流式端点
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 默认使用流式端点
            apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
        } else {
            // V3 及更早版本使用标准端点
            apiUrl = 'https://image.novelai.net/ai/generate-image';
        }

        let corsProxy = settings.cors_proxy;

        // 如果选择了自定义代理，使用自定义URL
        if (corsProxy === 'custom') {
            corsProxy = settings.custom_proxy_url || '';
        }

        // 如果有代理，添加到URL前面
        if (corsProxy && corsProxy !== '') {
            apiUrl = corsProxy + encodeURIComponent(apiUrl);
        }

        // ★★★ Chrome浏览器专用处理：避免headers中包含非ISO-8859-1字符 ★★★
        const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
        let fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify(requestBody)
        };

        // 针对Chrome浏览器：确保所有header值都是纯ASCII
        if (isChrome) {
            console.log('🔧 检测到Chrome浏览器，启用headers兼容性处理');
            const cleanHeaders = {};
            for (const [key, value] of Object.entries(fetchOptions.headers)) {
                // 确保header值只包含ASCII字符（ISO-8859-1兼容）
                cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, '');
            }
            fetchOptions.headers = cleanHeaders;
        }

        const response = await fetch(apiUrl, fetchOptions);

        console.log('Response status:', response.status);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('API错误响应:', errorText);
            throw new Error(`API请求失败 (${response.status}): ${errorText}`);
        }

        // NovelAI API返回的是ZIP文件，需要解压
        const contentType = response.headers.get('content-type');
        console.log('Content-Type:', contentType);

        // 检查是否为 SSE 流式响应
        let zipBlob;
        if (contentType && contentType.includes('text/event-stream')) {
            console.log('检测到 SSE 流式响应，开始解析...');
            statusDiv.textContent = '正在接收流式数据...';

            // 读取整个流
            const text = await response.text();
            console.log('收到 SSE 数据，大小:', text.length);

            // 解析 SSE 格式，提取最后的 data: 行
            const lines = text.trim().split('\n');
            let base64Data = null;

            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); // 移除 'data: ' 前缀

                    // 尝试解析 JSON
                    try {
                        const jsonData = JSON.parse(dataContent);

                        // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('✅ 找到 final 事件的图片数据');
                            break;
                        }

                        // 兼容其他格式
                        if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('从 JSON.data 中提取图片数据');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('从 JSON.image 中提取图片数据');
                            break;
                        }
                    } catch (e) {
                        // 如果不是 JSON，直接作为 base64 数据
                        base64Data = dataContent;
                        console.log('直接使用 base64 数据');
                        break;
                    }
                }
            }

            if (!base64Data) {
                throw new Error('无法从 SSE 响应中提取图片数据');
            }

            // V4.5 流式端点返回的是 PNG base64，不是 ZIP
            // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');

            if (isPNG || isJPEG) {
                console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                // 将 base64 转为 Blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                console.log('图片 Blob 创建成功，大小:', imageBlob.size);

                // 直接显示图片
                const imageUrl = URL.createObjectURL(imageBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                console.log('✅ 图片显示成功！🎨');
                return;
            }

            // 否则当作 ZIP 处理
            console.log('当作 ZIP 文件处理...');
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            zipBlob = new Blob([bytes]);
            console.log('ZIP Blob 大小:', zipBlob.size);

        } else {
            // 非流式响应，直接读取
            zipBlob = await response.blob();
            console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
        }

        // NovelAI始终返回ZIP格式，需要解压
        try {
            // 检查JSZip是否已加载
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip库未加载，请刷新页面重试');
            }

            statusDiv.textContent = '正在解压图片...';

            // 解压ZIP文件
            const zip = await JSZip.loadAsync(zipBlob);
            console.log('ZIP文件内容:', Object.keys(zip.files));

            // 查找第一个图片文件（通常是image_0.png）
            let imageFile = null;
            for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                    imageFile = zip.files[filename];
                    console.log('找到图片文件:', filename);
                    break;
                }
            }

            if (!imageFile) {
                throw new Error('ZIP文件中未找到图片');
            }

            // 提取图片数据
            const imageBlob = await imageFile.async('blob');
            console.log('提取的图片大小:', imageBlob.size);

            // 创建图片URL并显示
            const imageUrl = URL.createObjectURL(imageBlob);
            console.log('生成的图片URL:', imageUrl);

            document.getElementById('nai-result-image').src = imageUrl;
            statusDiv.style.display = 'none';
            resultDiv.style.display = 'block';

        } catch (zipError) {
            console.error('ZIP解压失败:', zipError);
            // 如果解压失败，尝试直接作为图片显示
            console.log('尝试直接作为图片显示...');

            if (zipBlob.type.startsWith('image/')) {
                const imageUrl = URL.createObjectURL(zipBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
            } else {
                throw new Error('图片格式处理失败: ' + zipError.message);
            }
        }

    } catch (error) {
        console.error('NovelAI生成失败:', error);
        statusDiv.style.display = 'none';
        errorDiv.style.display = 'block';
        errorDiv.textContent = '生成失败: ' + error.message;
    } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = '生成图像';
    }
}

// 【新增】重新生成失败的 NovelAI 图片
async function retryNaiImage(timestamp) {
    if (!state.activeChatId) {
        alert('请先进入聊天窗口');
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) {
        alert('聊天不存在');
        return;
    }

    // 找到失败的消息
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) {
        alert('消息不存在');
        return;
    }

    const msg = chat.history[msgIndex];
    // 【修改】允许重新生成失败的图片 或 已成功生成的图片
    if (msg.type !== 'naiimag') {
        alert('只能重新生成 NovelAI 图片');
        return;
    }

    // 在 DOM 中找到这条消息的显示元素
    const messageWrapper = document.querySelector(`.message-wrapper[data-timestamp="${timestamp}"]`);
    if (!messageWrapper) {
        alert('找不到消息位置');
        return;
    }

    // 找到气泡和内容区域
    const bubble = messageWrapper.querySelector('.message-bubble.is-naiimag');
    if (!bubble) {
        alert('找不到图片显示区域');
        return;
    }

    // 【关键】先保存现有的头像 HTML，以便后续恢复（需要在 try-catch 外定义，这样 catch 块也能用）
    const avatarImg = bubble.querySelector('.avatar');
    const avatarHtml = avatarImg ? `<img src="${avatarImg.src}" class="avatar">` : '';

    try {
        // 显示"正在重新生成"状态
        const loadingHtml = `<div style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #f5f5f5; border-radius: 8px; color: #333; border: 1px solid #d0d0d0;">
            <div style="text-align: center;">
                <div style="font-size: 14px;">📸 重新生成中</div>
            </div>
        </div>`;
        bubble.innerHTML = `${avatarHtml}${loadingHtml}`;

        // 获取 NAI 配置和提示词
        const novelaiApiKey = localStorage.getItem('novelai-api-key');
        const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
        const novelaiSettings = getNovelAISettings();
        const naiPrompts = getCharacterNAIPrompts(state.activeChatId);

        if (!novelaiApiKey) {
            throw new Error('NovelAI API Key未配置');
        }

        // 构建提示词
        const finalPositivePrompt = msg.prompt + ', ' + naiPrompts.positive;
        const finalNegativePrompt = naiPrompts.negative;
        const [width, height] = novelaiSettings.resolution.split('x').map(Number);

        // 构建请求体（V4/V3格式区分）
        let requestBody;
        if (novelaiModel.includes('nai-diffusion-4')) {
            requestBody = {
                input: finalPositivePrompt,
                model: novelaiModel,
                action: 'generate',
                parameters: {
                    params_version: 3,
                    width: width,
                    height: height,
                    scale: novelaiSettings.cfg_scale,
                    sampler: novelaiSettings.sampler,
                    steps: novelaiSettings.steps,
                    seed: novelaiSettings.seed === -1 ? Math.floor(Math.random() * 9999999999) : novelaiSettings.seed,
                    n_samples: 1,
                    ucPreset: novelaiSettings.uc_preset,
                    qualityToggle: novelaiSettings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras',
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                    v4_prompt: {
                        caption: {
                            base_caption: finalPositivePrompt,
                            char_captions: []
                        },
                        use_coords: false,
                        use_order: true
                    },
                    v4_negative_prompt: {
                        caption: {
                            base_caption: finalNegativePrompt,
                            char_captions: []
                        },
                        legacy_uc: false
                    },
                    negative_prompt: finalNegativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                }
            };
        } else {
            requestBody = {
                input: finalPositivePrompt,
                model: novelaiModel,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: novelaiSettings.cfg_scale,
                    sampler: novelaiSettings.sampler,
                    steps: novelaiSettings.steps,
                    seed: novelaiSettings.seed === -1 ? Math.floor(Math.random() * 9999999999) : novelaiSettings.seed,
                    n_samples: 1,
                    ucPreset: novelaiSettings.uc_preset,
                    qualityToggle: novelaiSettings.quality_toggle,
                    sm: novelaiSettings.smea,
                    sm_dyn: novelaiSettings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: finalNegativePrompt
                }
            };
        }

        // 调用 NAI API
        let apiUrl = novelaiModel.includes('nai-diffusion-4')
            ? 'https://image.novelai.net/ai/generate-image-stream'
            : 'https://image.novelai.net/ai/generate-image';

        let corsProxy = novelaiSettings.cors_proxy;
        if (corsProxy === 'custom') corsProxy = novelaiSettings.custom_proxy_url || '';
        if (corsProxy && corsProxy !== '') {
            apiUrl = corsProxy + encodeURIComponent(apiUrl);
        }

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + novelaiApiKey
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API错误 (${response.status}): ${errorText}`);
        }

        // 处理响应（SSE或ZIP）
        let imageDataUrl;
        const contentType = response.headers.get('content-type');

        if (contentType && contentType.includes('text/event-stream')) {
            const text = await response.text();
            const lines = text.trim().split('\n');
            let base64Data = null;

            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6);
                    try {
                        const jsonData = JSON.parse(dataContent);
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            break;
                        }
                    } catch (e) {
                        base64Data = dataContent;
                        break;
                    }
                }
            }

            if (!base64Data) throw new Error('无法提取图片数据');

            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');

            if (isPNG) {
                imageDataUrl = `data:image/png;base64,${base64Data}`;
            } else if (isJPEG) {
                imageDataUrl = `data:image/jpeg;base64,${base64Data}`;
            } else {
                imageDataUrl = `data:image/png;base64,${base64Data}`;
            }
        } else {
            const blob = await response.blob();
            const jszip = window.JSZip || JSZip;
            const zip = new jszip();
            await zip.loadAsync(blob);

            let imageFile;
            for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                    imageFile = zip.files[filename];
                    break;
                }
            }
            if (!imageFile) throw new Error('ZIP中未找到图片');
            const imageBlob = await imageFile.async('blob');
            const reader = new FileReader();
            imageDataUrl = await new Promise((resolve, reject) => {
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(imageBlob);
            });
        }

        // 更新消息对象
        msg.imageUrl = imageDataUrl;
        msg.isFailed = false;
        msg.failureReason = undefined;

        // 保存到数据库
        await db.chats.put(chat);

        // 更新 DOM - 使用完整的容器结构,包含重新生成按钮
        const imgHtml = `<div class="naiimag-container" style="position: relative; display: inline-block;">
            <img
                src="${imageDataUrl}"
                alt="NovelAI图片分享"
                title="${msg.fullPrompt || msg.prompt || 'NovelAI生成'}"
                class="naiimag-image"
                data-timestamp="${timestamp}"
                style="max-width: 300px; max-height: 300px; object-fit: contain; cursor: pointer; display: block;"
                onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';"
            >
            <button class="naiimag-retry-btn" data-timestamp="${timestamp}" style="position: absolute; bottom: 8px; right: 8px; width: 36px; height: 36px; border-radius: 50%; background-color: rgba(50, 50, 50, 0.85); border: none; cursor: pointer; display: none; align-items: center; justify-content: center; transition: background-color 0.2s;" title="重新生成图片">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 2.2" />
                </svg>
            </button>
        </div>`;
        bubble.innerHTML = `${avatarHtml}${imgHtml}`;

        // 自动保存到 NAI 画廊
        if (window.naiGallery && window.naiGallery.addImage) {
            const imageName = msg.prompt || msg.fullPrompt || '生成图片';
            window.naiGallery.addImage(imageDataUrl, imageName, state.activeChatId).catch(e => {
                console.error('保存NAI图片到画廊失败:', e);
            });
        }

        console.log('✅ NovelAI图片重新生成成功！');

    } catch (error) {
        console.error('❌ NovelAI图片重新生成失败:', error);

        // 恢复失败状态显示
        const failedHtml = `<div style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #f5f5f5; border-radius: 8px; color: #333; border: 1px solid #d0d0d0;">
            <div style="text-align: center;">
                <div style="font-size: 16px; margin-bottom: 8px;">⚠️ 生成失败</div>
                <div style="font-size: 11px; color: #666; margin-bottom: 10px; word-break: break-word; max-width: 180px; max-height: 60px; overflow: hidden;">${error.message}</div>
                <button class="retry-nai-image-btn" data-timestamp="${timestamp}" style="padding: 6px 12px; background-color: #333; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">重新生成</button>
            </div>
        </div>`;
        bubble.innerHTML = `${avatarHtml}${failedHtml}`;

        // 更新错误信息
        msg.failureReason = error.message;
        await db.chats.put(chat);
    }
}

// ▲▲▲ ========== NovelAI 函数定义结束 ========== ▲▲▲

// ▼▼▼ ========== NovelAI 系统初始化和事件监听 ========== ▼▼▼

// NovelAI 启用/禁用开关
document.getElementById('novelai-switch')?.addEventListener('change', (e) => {
    const detailsDiv = document.getElementById('novelai-details');
    if (detailsDiv) detailsDiv.style.display = e.target.checked ? 'block' : 'none';
    // 【核心】保存启用状态到localStorage
    localStorage.setItem('novelai-enabled', e.target.checked ? 'true' : 'false');
});

// NovelAI API Key 显示/隐藏切换
document.getElementById('novelai-key-toggle')?.addEventListener('click', function() {
    const input = document.getElementById('novelai-api-key');
    if (!input) return;
    if (input.type === 'password') {
        input.type = 'text';
        this.textContent = '🔓';
    } else {
        input.type = 'password';
        this.textContent = '🔑';
    }
});

// 【新增】NovelAI API Key 输入框自动保存
document.getElementById('novelai-api-key')?.addEventListener('blur', function() {
    const newKey = this.value.trim();
    localStorage.setItem('novelai-api-key', newKey);
    console.log('✅ NovelAI API Key已自动保存');
});

// 【新增】NovelAI Model 选择器自动保存
document.getElementById('novelai-model')?.addEventListener('change', function() {
    localStorage.setItem('novelai-model', this.value);
    console.log('✅ NovelAI Model已自动保存');
});

// 打开NovelAI设置弹窗
document.getElementById('novelai-settings-btn')?.addEventListener('click', () => {
    loadNovelAISettings(true); // 传true，只加载弹窗设置，不覆盖主面板的API Key输入框
    const modal = document.getElementById('novelai-settings-modal');
    if (modal) modal.style.display = 'flex';
});

// CORS代理选择器变化事件
document.getElementById('nai-cors-proxy')?.addEventListener('change', (e) => {
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    if (customProxyGroup) {
        customProxyGroup.style.display = e.target.value === 'custom' ? 'block' : 'none';
    }
});

// 关闭NovelAI设置弹窗
document.getElementById('close-novelai-settings')?.addEventListener('click', () => {
    const modal = document.getElementById('novelai-settings-modal');
    if (modal) modal.style.display = 'none';
});

// 保存NovelAI设置
document.getElementById('save-nai-settings-btn')?.addEventListener('click', () => {
    saveNovelAISettings();
    const modal = document.getElementById('novelai-settings-modal');
    if (modal) modal.style.display = 'none';
    alert('NovelAI设置已保存！');
});

// 恢复默认设置
document.getElementById('reset-nai-settings-btn')?.addEventListener('click', () => {
    if (confirm('确定要恢复默认设置吗？')) {
        resetNovelAISettings();
    }
});

// 打开NovelAI测试弹窗
document.getElementById('novelai-test-btn')?.addEventListener('click', () => {
    const apiKey = document.getElementById('novelai-api-key')?.value.trim();
    if (!apiKey) {
        alert('请先填写NovelAI API Key！');
        return;
    }
    const modal = document.getElementById('novelai-test-modal');
    if (modal) {
        modal.style.display = 'flex';
        document.getElementById('nai-test-result').style.display = 'none';
        document.getElementById('nai-test-error').style.display = 'none';
    }
});

// 关闭NovelAI测试弹窗
document.getElementById('close-novelai-test')?.addEventListener('click', () => {
    const modal = document.getElementById('novelai-test-modal');
    if (modal) modal.style.display = 'none';
});

document.getElementById('close-nai-test-btn')?.addEventListener('click', () => {
    const modal = document.getElementById('novelai-test-modal');
    if (modal) modal.style.display = 'none';
});

// NovelAI生成图像按钮
document.getElementById('nai-generate-btn')?.addEventListener('click', async () => {
    await generateNovelAIImage();
});

// NovelAI下载图像按钮
document.getElementById('nai-download-btn')?.addEventListener('click', () => {
    const img = document.getElementById('nai-result-image');
    if (img && img.src) {
        const link = document.createElement('a');
        link.href = img.src;
        link.download = 'novelai-' + Date.now() + '.png';
        link.click();
    }
});

// 打开/关闭单聊NAI提示词输入区域
document.getElementById('character-nai-prompts-btn')?.addEventListener('click', async () => {
    if (!state.activeChatId) {
        alert('请先选择一个聊天');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const container = document.getElementById('character-nai-prompts-container');

    // 切换展开/收起
    if (container.style.display === 'none') {
        // 展开：加载配置【改进：从数据库加载】
        let promptsData = await loadCharacterNAIPrompts(state.activeChatId);

        // 如果数据库没有，降级到旧的 chat.settings.naiSettings
        if (!promptsData.positive && !promptsData.negative) {
            const naiSettings = chat.settings.naiSettings || {
                characterPositivePrompt: '',
                characterNegativePrompt: ''
            };
            promptsData = {
                positive: naiSettings.characterPositivePrompt || '',
                negative: naiSettings.characterNegativePrompt || ''
            };
        }

        document.getElementById('character-nai-positive-input').value = promptsData.positive;
        document.getElementById('character-nai-negative-input').value = promptsData.negative;
        container.style.display = 'block';
    } else {
        // 收起
        container.style.display = 'none';
    }
});

// 保存单聊NAI提示词【改进：同时保存到数据库】
document.getElementById('character-nai-save-btn')?.addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const chatId = state.activeChatId;

    if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {};
    }

    const positivePrompt = document.getElementById('character-nai-positive-input').value.trim();
    const negativePrompt = document.getElementById('character-nai-negative-input').value.trim();

    chat.settings.naiSettings.characterPositivePrompt = positivePrompt;
    chat.settings.naiSettings.characterNegativePrompt = negativePrompt;

    console.log('💾 保存单聊NAI提示词:', chat.settings.naiSettings);
    await db.chats.put(chat);

    // 【新增】同时保存到 characterNaiPrompts 表（确保持久化）
    await db.characterNaiPrompts.put({
        chatId: chatId,
        characterName: chat.name,
        characterPositivePrompt: positivePrompt,
        characterNegativePrompt: negativePrompt,
        updatedAt: new Date().toISOString()
    });

    alert('角色专属NAI提示词已保存！');
});

// 清空单聊NAI提示词
document.getElementById('character-nai-reset-btn')?.addEventListener('click', () => {
    if (confirm('确定要清空当前角色的NAI提示词配置吗？')) {
        document.getElementById('character-nai-positive-input').value = '';
        document.getElementById('character-nai-negative-input').value = '';
    }
});

// 打开/关闭群聊NAI提示词输入区域
document.getElementById('group-character-nai-prompts-btn')?.addEventListener('click', async () => {
    if (!state.activeChatId) {
        alert('请先选择一个聊天');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const container = document.getElementById('group-character-nai-prompts-container');

    // 切换展开/收起
    if (container.style.display === 'none') {
        // 展开：加载配置【改进：从数据库加载】
        let promptsData = await loadCharacterNAIPrompts(state.activeChatId);

        // 如果数据库没有，降级到旧的 chat.settings.naiSettings
        if (!promptsData.positive && !promptsData.negative) {
            const naiSettings = chat.settings.naiSettings || {
                characterPositivePrompt: '',
                characterNegativePrompt: ''
            };
            promptsData = {
                positive: naiSettings.characterPositivePrompt || '',
                negative: naiSettings.characterNegativePrompt || ''
            };
        }

        document.getElementById('group-character-nai-positive-input').value = promptsData.positive;
        document.getElementById('group-character-nai-negative-input').value = promptsData.negative;
        container.style.display = 'block';
    } else {
        // 收起
        container.style.display = 'none';
    }
});

// 保存群聊NAI提示词【改进：同时保存到数据库】
document.getElementById('group-character-nai-save-btn')?.addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const chatId = state.activeChatId;

    if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {};
    }

    const positivePrompt = document.getElementById('group-character-nai-positive-input').value.trim();
    const negativePrompt = document.getElementById('group-character-nai-negative-input').value.trim();

    chat.settings.naiSettings.characterPositivePrompt = positivePrompt;
    chat.settings.naiSettings.characterNegativePrompt = negativePrompt;

    console.log('💾 保存群聊NAI提示词:', chat.settings.naiSettings);
    await db.chats.put(chat);

    // 【新增】同时保存到 characterNaiPrompts 表（确保持久化）
    await db.characterNaiPrompts.put({
        chatId: chatId,
        characterName: chat.name,
        characterPositivePrompt: positivePrompt,
        characterNegativePrompt: negativePrompt,
        updatedAt: new Date().toISOString()
    });

    alert('角色专属NAI提示词已保存！');
});

// 清空群聊NAI提示词
document.getElementById('group-character-nai-reset-btn')?.addEventListener('click', () => {
    if (confirm('确定要清空当前角色的NAI提示词配置吗？')) {
        document.getElementById('group-character-nai-positive-input').value = '';
        document.getElementById('group-character-nai-negative-input').value = '';
    }
});

// ▲▲▲ ========== NovelAI 事件监听结束 ========== ▲▲▲

// ▼▼▼ 【全新】"kk查岗"功能事件监听器 ▼▼▼
document.getElementById('kk-checkin-entry').addEventListener('click', openKkCheckin);

document.getElementById('kk-char-selection-list').addEventListener('click', (e) => {
    const item = e.target.closest('.character-select-item');
    if (item && item.dataset.chatId) {
        openKkHouseView(item.dataset.chatId);
    }
});

document.getElementById('kk-back-from-house-view').addEventListener('click', () => showScreen('kk-char-selection-screen'));
document.getElementById('kk-back-from-area-view').addEventListener('click', () => showScreen('kk-house-view-screen'));
document.getElementById('kk-back-from-monitor').addEventListener('click', () => showScreen('kk-house-view-screen'));
document.getElementById('close-kk-computer-modal').addEventListener('click', () => document.getElementById('kk-computer-modal').classList.remove('visible'));
document.getElementById('close-file-explorer-modal-btn').addEventListener('click', () => document.getElementById('kk-file-explorer-modal').classList.remove('visible'));
document.getElementById('close-kk-file-viewer-btn').addEventListener('click', closeFileViewer);
document.getElementById('close-kk-steam-modal-btn').addEventListener('click', () => document.getElementById('kk-steam-modal').classList.remove('visible'));

document.getElementById('kk-reset-search-btn').addEventListener('click', handleResetKkHouse);
document.getElementById('kk-continue-search-btn').addEventListener('click', handleContinueKkSearch);

// 监控相关事件监听器
document.getElementById('kk-house-view-screen').addEventListener('click', (e) => {
    if (e.target.closest('#kk-surveillance-icon')) {
        openSurveillanceView(activeKkCharId);
    }
});

document.getElementById('kk-refresh-monitor-btn').addEventListener('click', async () => {
    if (!activeKkCharId) return;
    const chat = state.chats[activeKkCharId];
    if (chat && chat.houseData) {
        const newData = await generateSurveillanceUpdate(activeKkCharId);
        if (newData) {
            chat.houseData.surveillanceData = {
                timestamp: Date.now(),
                characterLocation: newData.characterLocation,
                feeds: newData.feeds
            };
            await db.chats.put(chat);
            renderSurveillanceView(chat.houseData.surveillanceData);
        }
    }
});

document.getElementById('kk-monitor-grid').addEventListener('click', (e) => {
    const monitorItem = e.target.closest('.kk-monitor-item');
    if (!monitorItem) return;

    const areaName = monitorItem.dataset.areaName;
    const interactionButton = e.target.closest('.monitor-btn');

    if (interactionButton) {
        e.stopPropagation();
        const action = interactionButton.dataset.action;
        handleMonitorInteraction(areaName, action, monitorItem);
    } else {
        openKkAreaView(areaName);
    }
});

// 电脑桌面图标点击事件委托
document.getElementById('kk-computer-desktop').addEventListener('click', (e) => {
    const icon = e.target.closest('.kk-desktop-icon');
    if (!icon) return;

    const computerData = state.chats[activeKkCharId]?.houseData?.computer;
    if (!computerData) {
        showCustomAlert("错误", "找不到电脑数据。");
        return;
    }

    switch (icon.id) {
        case 'kk-browser-icon':
            const history = computerData.browser_history || [];
            const historyHtml = history.length > 0 ? `<ul style="text-align: left; padding-left: 20px;">${history.map(item => `<li>${item}</li>`).join('')}</ul>` : '<p>浏览器历史记录是空的。</p>';
            showCustomAlert('浏览器历史记录', historyHtml);
            break;
        case 'kk-movies-icon':
            const movies = computerData.movies || [];
            const moviesHtml = movies.length > 0 ? `<ul style="text-align: left; padding-left: 20px;">${movies.map(item => `<li>${item}</li>`).join('')}</ul>` : '<p>没有下载任何电影。</p>';
            showCustomAlert('下载的电影', moviesHtml);
            break;
        case 'kk-files-icon':
            openFileExplorer();
            break;
        case 'kk-secret-folder-icon':
            const secretFolder = computerData.secret_folder;
            if (secretFolder) {
                showCustomConfirm(
                    '加密访问',
                    `你尝试打开文件 "${secretFolder.fileName}"。<br><br>这是一个加密文件夹，是否继续访问？`
                ).then(confirmed => {
                    if (confirmed) {
                        showCustomAlert('已解密', secretFolder.content.replace(/\n/g, '<br>'));
                    }
                });
            } else {
                showCustomAlert('未发现', '没有找到隐秘文件夹。');
            }
            break;
        case 'kk-steam-icon':
            openSteamScreen();
            break;
    }
});

// 文件列表点击事件委托
document.getElementById('kk-file-list').addEventListener('click', (e) => {
    const fileItem = e.target.closest('.kk-file-item');
    if (fileItem) {
        const fileName = fileItem.dataset.fileName;
        const fileContent = fileItem.dataset.fileContent;
        if (fileName && fileContent) {
            openFileViewer(fileName, fileContent);
        }
    }
});

// 文件查看器点击遮罩关闭
document.getElementById('kk-file-viewer-modal').addEventListener('click', (e) => {
    if (e.target.id === 'kk-file-viewer-modal') {
        closeFileViewer();
    }
});

// Steam游戏列表删除按钮
document.getElementById('kk-steam-games-list').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.item-delete-btn');
    if (deleteBtn) {
        const index = parseInt(deleteBtn.dataset.index);
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条游戏记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            const chat = state.chats[activeKkCharId];
            chat.houseData.computer.steam_games.splice(index, 1);
            await db.chats.put(chat);
            renderSteamScreen();
        }
    }
});

// ▲▲▲ "kk查岗"事件监听结束 ▲▲▲

        // init() 函数结束 - 所有初始化代码已完成
        init().then(() => {
            // 【新增】init()完成后，开始预加载所有表情包，完成后隐藏加载动画
            preloadAllStickersInBackground();
        });
    });

// 🖼️ NAI图片三击下载功能（非入侵式）
// ========================================
// 功能：为所有NAI图片（realimag-image、naiimag-image）添加三击下载功能
// 适用场景：群聊、私聊、动态、测试弹窗等所有显示NAI图片的地方
// 实现方式：事件委托，不修改任何现有代码
// 触发方式：在图片上快速点击三次
// ========================================

(function() {
    'use strict';

    // 下载图片的核心函数
    function downloadImage(imageSrc, filename) {
        try {
            // 【最终修复】禁用 VH 更新 + 锁死容器 + 禁用 resize 监听器
            const htmlElement = document.documentElement;
            const bodyElement = document.body;
            const phoneScreen = document.getElementById('phone-screen');

            // 1. 启用 VH 更新禁用开关
            window.isVhUpdateDisabled = true;
            console.log('🔒 [NAI下载] VH更新已禁用');

            // 2. 移除 resize 和 orientationchange 监听器，防止触发重新计算
            if (window.setVhOnResize) {
                window.removeEventListener('resize', window.setVhOnResize);
            }
            if (window.setVhOnOrientationChange) {
                window.removeEventListener('orientationchange', window.setVhOnOrientationChange);
            }

            // 3. 保存原始样式
            const originalHtmlStyle = {
                overflow: htmlElement.style.overflow,
                height: htmlElement.style.height,
                width: htmlElement.style.width,
                position: htmlElement.style.position
            };
            const originalBodyStyle = {
                overflow: bodyElement.style.overflow,
                height: bodyElement.style.height,
                width: bodyElement.style.width,
                position: bodyElement.style.position
            };
            const originalPhoneScreenStyle = phoneScreen ? {
                height: phoneScreen.style.height,
                overflow: phoneScreen.style.overflow,
                position: phoneScreen.style.position
            } : null;

            // 4. 获取当前视口的实际高度（iOS 下载前的高度）
            const viewportHeight = window.innerHeight;

            // 5. 【关键】强制锁死所有容器，使用 !important 确保不被覆盖
            htmlElement.style.cssText = `
                overflow: hidden !important;
                height: ${viewportHeight}px !important;
                width: 100% !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
            `;

            bodyElement.style.cssText = `
                overflow: hidden !important;
                height: ${viewportHeight}px !important;
                width: 100% !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
            `;

            if (phoneScreen) {
                phoneScreen.style.cssText = `
                    height: ${viewportHeight}px !important;
                    overflow: hidden !important;
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100% !important;
                `;
            }

            // 6. 创建一个隐藏的下载链接
            const link = document.createElement('a');
            link.href = imageSrc;
            link.download = filename;
            link.style.display = 'none';

            document.body.appendChild(link);
            link.click();  // 触发下载

            // 短暂延迟后移除链接
            setTimeout(() => {
                document.body.removeChild(link);
            }, 100);

            console.log('✅ [NAI下载] 开始下载图片:', filename);

            // 显示下载提示
            showDownloadToast();

            // 7. 【关键】等待 iOS 下载完成后，恢复原始样式和事件监听
            // 延迟 5 秒后恢复样式，给 iOS 充足的时间稳定视口
            setTimeout(() => {
                // 恢复样式，触发浏览器重新渲染
                htmlElement.style.overflow = originalHtmlStyle.overflow;
                htmlElement.style.height = originalHtmlStyle.height;
                htmlElement.style.width = originalHtmlStyle.width;
                htmlElement.style.position = originalHtmlStyle.position;

                bodyElement.style.overflow = originalBodyStyle.overflow;
                bodyElement.style.height = originalBodyStyle.height;
                bodyElement.style.width = originalBodyStyle.width;
                bodyElement.style.position = originalBodyStyle.position;

                if (phoneScreen && originalPhoneScreenStyle) {
                    phoneScreen.style.height = originalPhoneScreenStyle.height;
                    phoneScreen.style.overflow = originalPhoneScreenStyle.overflow;
                    phoneScreen.style.position = originalPhoneScreenStyle.position;
                }

                // 调用通用的恢复函数，它会进一步延迟 5 秒再重新启用 VH 更新
                disableDownloadProtection();

                // 强制重新渲染，确保布局正确
                window.scrollTo(0, 0);

                console.log('✅ [NAI下载] 样式已恢复，已触发 VH 恢复流程');
            }, 2000);
        } catch (error) {
            console.error('❌ [NAI下载] 下载失败:', error);
            showDownloadToast('下载失败，请重试', 'error');

            // 出错时立即尝试恢复样式
            const htmlElement = document.documentElement;
            const bodyElement = document.body;
            const phoneScreen = document.getElementById('phone-screen');

            htmlElement.style.cssText = '';
            bodyElement.style.cssText = '';
            if (phoneScreen) {
                phoneScreen.style.cssText = '';
            }

            // 重新启用 VH 更新
            window.isVhUpdateDisabled = false;

            // 重新添加监听器
            if (window.setVhOnResize) {
                window.addEventListener('resize', window.setVhOnResize);
            }
            if (window.setVhOnOrientationChange) {
                window.addEventListener('orientationchange', window.setVhOnOrientationChange);
            }
        }
    }

    // 显示下载提示（临时Toast）
    function showDownloadToast(message = '📥图片下载中...', type = 'success') {
        const toast = document.createElement('div');
        toast.textContent = message;
        // 【修改】黑色背景，屏幕顶部居中，留出灵动岛安全距离
        toast.style.cssText = `
            position: fixed;
            top: calc(40px + env(safe-area-inset-top, 0));
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: #1a1a1a;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            z-index: 10000;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s ease;
        `;

        document.body.appendChild(toast);

        // 动画进入
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(-50%) translateY(0)';
        }, 10);

        // 2秒后淡出并移除
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(-50%) translateY(-20px)';
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 2000);
    }

    // 生成智能文件名
    function generateFilename(imgElement) {
        // 尝试从title属性获取prompt（用于文件名）
        const title = imgElement.getAttribute('title') || imgElement.getAttribute('alt') || '';

        // 清理title，提取前30个有效字符
        let cleanTitle = title
            .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')  // 保留中英文字母数字和空格
            .replace(/\s+/g, '_')  // 空格转下划线
            .substring(0, 30);

        if (!cleanTitle) {
            cleanTitle = 'NAI_Image';
        }

        // 添加时间戳（精确到秒）
        const timestamp = new Date().toISOString()
            .replace(/[-:]/g, '')
            .replace('T', '_')
            .split('.')[0];  // 格式：20250124_123045

        // 生成文件名
        return `${cleanTitle}_${timestamp}.png`;
    }

    // 为图片添加双击时的视觉反馈
    function addVisualFeedback(imgElement) {
        const originalTransform = imgElement.style.transform || '';
        const originalTransition = imgElement.style.transition || '';

        // 添加缩放动画
        imgElement.style.transition = 'transform 0.15s ease';
        imgElement.style.transform = 'scale(0.95)';

        setTimeout(() => {
            imgElement.style.transform = originalTransform;
            setTimeout(() => {
                imgElement.style.transition = originalTransition;
            }, 150);
        }, 150);
    }

    // 三击检测相关变量
    let clickCount = 0;
    let clickTimer = null;
    let lastClickedElement = null;

    // 全局事件监听器（事件委托 - 三击触发）
    document.addEventListener('click', function(e) {
        const target = e.target;

        // 检查是否是NAI图片（realimag-image 或 naiimag-image）
        if (target.tagName === 'IMG' &&
            (target.classList.contains('realimag-image') ||
             target.classList.contains('naiimag-image'))) {

            // 如果点击的是同一个元素，增加计数
            if (target === lastClickedElement) {
                clickCount++;
            } else {
                // 点击了不同的元素，重置计数
                clickCount = 1;
                lastClickedElement = target;
            }

            // 清除之前的定时器
            if (clickTimer) {
                clearTimeout(clickTimer);
            }

            // 如果达到三击
            if (clickCount === 3) {
                // 重置计数
                clickCount = 0;
                lastClickedElement = null;

                // 阻止默认行为和事件冒泡
                e.preventDefault();
                e.stopPropagation();

                console.log('🖼️ [NAI下载] 检测到三击NAI图片');

                // 添加视觉反馈
                addVisualFeedback(target);

                // 获取图片源（可能是base64或URL）
                const imageSrc = target.src;

                if (!imageSrc || imageSrc === 'about:blank') {
                    console.warn('⚠️ [NAI下载] 图片源为空，无法下载');
                    showDownloadToast('图片加载中，请稍后重试', 'error');
                    return;
                }

                // 生成文件名
                const filename = generateFilename(target);

                // 触发下载
                downloadImage(imageSrc, filename);
            } else {
                // 设置定时器，500ms后重置计数（如果用户停止点击）
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                    lastClickedElement = null;
                }, 500);
            }
        }
    }, true);  // 使用捕获阶段，确保优先处理

    console.log('✅ [NAI下载] 三击下载功能已初始化');
    console.log('💡 [NAI下载] 提示：三击任意NAI图片即可下载');
})();
// ▲▲▲ NAI图片三击下载功能结束 ▲▲▲

// ▼▼▼ NAI Gallery 面板功能 ▼▼▼
(() => {
    const naiGalleryPanel = document.getElementById('nai-gallery-panel');
    const naiGalleryGrid = document.getElementById('nai-gallery-grid');
    const naiGalleryActionBar = document.getElementById('nai-gallery-action-bar');
    const closeBtn = document.getElementById('close-nai-gallery-btn');
    const manageBtn = document.getElementById('manage-nai-gallery-btn');
    const selectAllCheckbox = document.getElementById('select-all-nai-gallery-checkbox');
    const downloadBtn = document.getElementById('download-selected-nai-gallery-btn');
    const deleteBtn = document.getElementById('delete-selected-nai-gallery-btn');
    const openPlusBtns = document.querySelectorAll('#nai-gallery-plus-btn, #nai-gallery-plus-btn-group');

    let isManagementMode = false;
    let selectedItems = new Set();
    let naiImages = []; // 存储当前角色的nai图片
    let currentChatId = null; // 存储当前打开的角色ID
    let migrationDone = false; // 标记数据迁移是否已完成

    // 【新增】从localStorage迁移旧数据到IndexedDB
    async function migrateOldData() {
        if (migrationDone) return;
        migrationDone = true;

        try {
            // 扫描localStorage中所有nai-gallery-images开头的key
            const keysToMigrate = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('nai-gallery-images-')) {
                    keysToMigrate.push(key);
                }
            }

            if (keysToMigrate.length === 0) {
                console.log('✅ 没有旧数据需要迁移');
                return;
            }

            console.log(`🔄 开始迁移 ${keysToMigrate.length} 个角色的NAI图片数据...`);

            for (const key of keysToMigrate) {
                try {
                    const data = localStorage.getItem(key);
                    const images = JSON.parse(data);
                    const chatId = key.replace('nai-gallery-images-', '');

                    if (!Array.isArray(images) || images.length === 0) continue;

                    // 检查IndexedDB中是否已有这个角色的数据
                    const existing = await window.db.naiGalleryImages.where('chatId').equals(chatId).count();
                    if (existing > 0) {
                        console.log(`⏭️ 角色 ${chatId} 的数据已存在，跳过迁移`);
                        continue;
                    }

                    // 迁移数据
                    const migrationImages = images.map(img => ({
                        id: img.id || 'nai_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        chatId: chatId,
                        url: img.url,
                        name: img.name || '图片',
                        timestamp: typeof img.timestamp === 'number' ? img.timestamp : new Date(img.timestamp).getTime()
                    }));

                    await window.db.naiGalleryImages.bulkAdd(migrationImages);
                    console.log(`✅ 角色 ${chatId} 的 ${migrationImages.length} 张图片已迁移`);
                } catch (e) {
                    console.error(`❌ 迁移 ${key} 失败:`, e);
                }
            }

            console.log('✅ 数据迁移完成！');
        } catch (e) {
            console.error('❌ 数据迁移过程出错:', e);
        }
    }

    // 在初始化时执行迁移
    migrateOldData().catch(e => console.error('迁移失败:', e));

    // 从IndexedDB加载指定角色的nai图片
    async function loadNaiImages(chatId) {
        currentChatId = chatId;
        try {
            const images = await window.db.naiGalleryImages.where('chatId').equals(chatId).toArray();
            // 【修改】按timestamp正序排列，最新的在最后
            naiImages = images.sort((a, b) => a.timestamp - b.timestamp);
        } catch (e) {
            console.error('加载NAI图片失败:', e);
            naiImages = [];
        }
    }

    // 保存指定角色的nai图片到IndexedDB
    async function saveNaiImages(chatId = currentChatId) {
        if (!chatId) {
            console.error('无法保存NAI图片：chatId未设置');
            return;
        }
        // 这个函数现在只用于删除操作后更新，addImage已经直接插入数据库
    }

    // 渲染画廊网格
    function renderGallery() {
        naiGalleryGrid.innerHTML = '';
        if (naiImages.length === 0) {
            naiGalleryGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 40px 20px;">还没有NAI图片</div>';
            return;
        }

        naiImages.forEach((img, index) => {
            const item = document.createElement('div');
            item.className = 'nai-gallery-item';
            item.dataset.index = index;

            const container = document.createElement('div');
            container.className = 'nai-image-container';
            container.style.backgroundImage = `url("${img.url}")`;

            // const controls = document.createElement('div');
            // controls.className = 'nai-gallery-controls';

            // 垃圾桶按钮已删除，现在controls为空
            // container.appendChild(controls); // 【修复】注释掉空的controls元素

            // const name = document.createElement('div');
            // name.className = 'nai-gallery-name';
            // name.textContent = img.name || `图片${index + 1}`;

            item.appendChild(container);
            // item.appendChild(name); // 【修复】注释掉，避免iOS上产生空白间距

            item.addEventListener('click', () => {
                if (isManagementMode) {
                    item.classList.toggle('selected');
                    if (item.classList.contains('selected')) {
                        selectedItems.add(index);
                    } else {
                        selectedItems.delete(index);
                    }
                    updateSelectAllState();
                    updateActionBar();
                } else {
                    // 查看图片
                    showImagePreview(img);
                }
            });

            naiGalleryGrid.appendChild(item);
        });
    }

    // 显示图片预览
    function showImagePreview(img) {
        const modal = document.createElement('div');
        modal.className = 'nai-image-preview-modal';
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; align-items: center; justify-content: center;';

        const imgElement = document.createElement('img');
        imgElement.src = img.url;
        imgElement.style.cssText = 'max-width: 90%; max-height: 90%; border-radius: 8px; cursor: pointer;';

        modal.appendChild(imgElement);

        // 【修复2】点击modal时只关闭图片预览，不关闭画廊面板
        modal.addEventListener('click', (e) => {
            e.stopPropagation(); // 阻止事件冒泡到document
            modal.remove();
        });

        document.body.appendChild(modal);
    }

    // 更新全选复选框状态
    function updateSelectAllState() {
        selectAllCheckbox.checked = selectedItems.size > 0 && selectedItems.size === naiImages.length;
    }

    // 更新操作栏
    function updateActionBar() {
        downloadBtn.title = `下载 (${selectedItems.size})`;
        deleteBtn.title = `删除 (${selectedItems.size})`;
    }

    // 打开画廊面板
    async function openGallery() {
        // 【修复1】先关闭plus面板再打开画廊
        const singlePanel = document.getElementById('chat-plus-panel-single');
        const groupPanel = document.getElementById('chat-plus-panel-group');
        const chatInterface = document.getElementById('chat-interface-screen');

        if (singlePanel && singlePanel.classList.contains('visible')) {
            singlePanel.classList.remove('visible');
        }
        if (groupPanel && groupPanel.classList.contains('visible')) {
            groupPanel.classList.remove('visible');
        }
        if (chatInterface && chatInterface.classList.contains('panel-expanded')) {
            chatInterface.classList.remove('panel-expanded');
        }

        const chatId = chatInterface?.dataset.chatId;
        if (!chatId) {
            console.warn('无法打开NAI画廊：当前未选中任何角色');
            return;
        }
        await loadNaiImages(chatId);
        renderGallery();
        naiGalleryPanel.classList.add('visible');
    }

    // 关闭画廊面板
    function closeGallery() {
        naiGalleryPanel.classList.remove('visible');
        exitManagementMode();
    }

    // 进入管理模式
    function enterManagementMode() {
        isManagementMode = true;
        selectedItems.clear();
        naiGalleryGrid.classList.add('management-mode');
        naiGalleryActionBar.classList.add('visible');
        manageBtn.title = '完成';
        updateSelectAllState();
        updateActionBar();
    }

    // 退出管理模式
    function exitManagementMode() {
        isManagementMode = false;
        selectedItems.clear();
        naiGalleryGrid.classList.remove('management-mode');
        naiGalleryActionBar.classList.remove('visible');
        manageBtn.title = '管理';
        selectAllCheckbox.checked = false;
        // 【修复】不需要重新渲染，只需移除选中样式即可
        document.querySelectorAll('.nai-gallery-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
    }

    // 事件监听
    openPlusBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            openGallery();
        });
    });

    closeBtn.addEventListener('click', closeGallery);

    manageBtn.addEventListener('click', () => {
        if (isManagementMode) {
            exitManagementMode();
        } else {
            enterManagementMode();
        }
    });

    selectAllCheckbox.addEventListener('change', () => {
        if (selectAllCheckbox.checked) {
            selectedItems.clear();
            naiImages.forEach((_, i) => selectedItems.add(i));
        } else {
            selectedItems.clear();
        }
        renderGallery();
        updateActionBar();
    });

    downloadBtn.addEventListener('click', async () => {
        if (selectedItems.size === 0) return alert('请先选择要下载的图片');

        for (const index of selectedItems) {
            const img = naiImages[index];
            const a = document.createElement('a');
            a.href = img.url;
            a.download = img.name || `nai-${index}.png`;
            a.click();
        }
    });

    deleteBtn.addEventListener('click', async () => {
        if (selectedItems.size === 0) return alert('请先选择要删除的图片');

        const confirmed = confirm(`确定删除选中的 ${selectedItems.size} 张图片吗？`);
        if (confirmed) {
            const indices = Array.from(selectedItems).sort((a, b) => b - a);
            // 从IndexedDB中删除
            for (const i of indices) {
                const img = naiImages[i];
                if (img?.id) {
                    await window.db.naiGalleryImages.delete(img.id);
                }
            }
            // 从内存中删除
            indices.forEach(i => naiImages.splice(i, 1));
            exitManagementMode();
            renderGallery();
        }
    });

    // 点击面板外关闭
    document.addEventListener('click', (e) => {
        // 【修复2】排除预览modal的点击事件
        if (e.target.closest('.nai-image-preview-modal')) {
            return;
        }

        if (naiGalleryPanel.classList.contains('visible') &&
            !naiGalleryPanel.contains(e.target) &&
            !e.target.closest('#nai-gallery-plus-btn') &&
            !e.target.closest('#nai-gallery-plus-btn-group')) {
            closeGallery();
        }
    });

    // 暴露到全局，方便其他地方调用
    window.naiGallery = {
        addImage: async function(imageUrl, name = '图片', chatId) {
            if (!chatId) {
                console.warn('无法保存NAI图片：chatId未传入');
                return null;
            }

            try {
                // 【新增】检查该角色是否已有相同URL的图片（去重）
                const existing = await window.db.naiGalleryImages
                    .where('chatId').equals(chatId)
                    .filter(img => img.url === imageUrl)
                    .count();

                if (existing > 0) {
                    console.log('⏭️ 该图片已存在于画廊，跳过重复添加');
                    return null;
                }

                const img = {
                    id: 'nai_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    chatId: chatId,
                    url: imageUrl,
                    name: name,
                    timestamp: Date.now()
                };

                // 直接插入到IndexedDB
                await window.db.naiGalleryImages.add(img);
                console.log('✅ NAI图片已保存到画廊');
                return img;
            } catch (e) {
                console.error('保存NAI图片失败:', e);
                return null;
            }
        },
        openGallery: openGallery,
        closeGallery: closeGallery
    };

    console.log('✅ [NAI Gallery] 画廊功能已初始化');
})();
// ▲▲▲ NAI Gallery 面板功能结束 ▲▲▲

// ▼▼▼ 【新增】系统级通知功能 ▼▼▼
(function() {
    // 检查浏览器是否支持Notification API
    function isNotificationSupported() {
        return 'Notification' in window;
    }

    // 更新通知状态显示
    function updateNotificationStatus() {
        const statusElement = document.getElementById('notification-status');
        if (!isNotificationSupported()) {
            statusElement.textContent = '状态: 此浏览器不支持系统通知';
            statusElement.style.color = '#999';
            return;
        }

        const permission = Notification.permission;
        if (permission === 'granted') {
            statusElement.textContent = '状态: ✅ 已授权';
            statusElement.style.color = '#1e1e1e';
        } else if (permission === 'denied') {
            statusElement.textContent = '状态: ❌ 已被拒绝（需手动在浏览器设置中允许）';
            statusElement.style.color = '#1e1e1e';
        } else if (permission === 'default') {
            statusElement.textContent = '状态: ⚠️ 未授权（点击授权按钮）';
            statusElement.style.color = '#1e1e1e';
        }
    }

    // 请求通知权限
    async function requestNotificationPermission() {
        if (!isNotificationSupported()) {
            alert('此浏览器不支持系统通知功能');
            return;
        }

        try {
            const permission = await Notification.requestPermission();
            console.log('通知权限结果:', permission);

            if (permission === 'granted') {
                alert('✅ 通知权限已授予！');
            } else if (permission === 'denied') {
                alert('❌ 通知权限被拒绝。您可以在浏览器设置中手动允许通知。');
            }

            updateNotificationStatus();
        } catch (error) {
            console.error('请求通知权限时出错:', error);
            alert('请求权限时出错: ' + error.message);
        }
    }

    // 发送测试通知
    function sendTestNotification() {
        if (!isNotificationSupported()) {
            alert('此浏览器不支持系统通知功能');
            return;
        }

        if (Notification.permission !== 'granted') {
            alert('请先点击授权按钮获取通知权限');
            return;
        }

        try {
            const testNotification = new Notification('EPhone 系统通知', {
                icon: 'https://files.catbox.moe/g2x30e.png',
                badge: 'https://files.catbox.moe/g2x30e.png',
                tag: 'test-notification',
                requireInteraction: false,
                body: '这是一条测试通知消息。如果您看到这条消息，说明系统通知功能已正常工作！'
            });

            // 点击通知时的处理
            testNotification.addEventListener('click', () => {
                window.focus();
                testNotification.close();
            });

            // 通知关闭时的处理
            testNotification.addEventListener('close', () => {
                console.log('测试通知已关闭');
            });

            console.log('✅ 测试通知已发送');
        } catch (error) {
            console.error('发送测试通知时出错:', error);
            alert('发送通知时出错: ' + error.message);
        }
    }

    // 绑定按钮事件
    document.addEventListener('DOMContentLoaded', () => {
        const enableBtn = document.getElementById('enable-system-notifications-btn');
        const testBtn = document.getElementById('test-system-notify-btn');

        if (enableBtn) {
            enableBtn.addEventListener('click', requestNotificationPermission);
        }

        if (testBtn) {
            testBtn.addEventListener('click', sendTestNotification);
        }

        // 页面加载时更新状态
        updateNotificationStatus();
    });

    // 如果页面已加载，直接执行
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            updateNotificationStatus();
        });
    } else {
        updateNotificationStatus();
    }

    // 暴露到全局作用域
    window.EPhoneNotification = {
        requestPermission: requestNotificationPermission,
        sendTest: sendTestNotification,
        updateStatus: updateNotificationStatus
    };

    console.log('✅ [系统通知] 功能已初始化');
})();
// ▲▲▲ 系统级通知功能结束 ▲▲▲

</script>
<input type="file" id="character-card-input" accept="image/png, image/jpeg, application/vnd.openxmlformats-officedocument.wordprocessingml.document, .docx, text/plain" style="display: none;">
<div id="card-diagnostic-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>角色卡诊断工具</span>
        </div>
        <div class="modal-body">
            <p style="font-size: 14px; color: #666;">请上传您的PNG角色卡，下方将显示所有读取到的文本数据块。</p>
            <input type="file" id="diagnostic-card-input" accept="image/png" style="margin-top: 10px;">
            <hr style="margin: 20px 0; opacity: 0.2;">
            <pre id="diagnostic-output" style="white-space: pre-wrap; word-wrap: break-word; background-color: #f0f0f0; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; color: #333;"></pre>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-diagnostic-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<input type="file" id="world-book-import-input" accept=".json,.txt,.docx" style="display: none;">
<div id="import-wb-category-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>选择导入方式</span>
        </div>
        <div class="modal-body">
            <p style="font-size: 14px; color: var(--text-secondary); text-align: center; margin-bottom: 20px;">
                要为这些世界书条目创建一个新的分类吗？
            </p>
            <div class="form-group">
                <label for="import-new-category-name">新分类名称</label>
                <input type="text" id="import-new-category-name" placeholder="例如：角色名 或 故事名">
            </div>
            <div class="form-group" style="margin-top: 15px;">
                <label for="import-existing-category">或选择现存分类</label>
                <select id="import-existing-category" style="width: 100%; padding: 8px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: #fff;">
                    <option value="">-- 选择分类 --</option>
                </select>
            </div>
        </div>
        <div class="modal-footer" style="flex-direction: column; gap: 10px; padding: 15px;">
            <button class="save" id="confirm-import-new-category" style="width: 100%;">创建新分类并导入</button>
            <button class="save" id="confirm-import-existing-category" style="width: 100%; background-color: #4CAF50;">导入到选中分类</button>
            <button class="cancel" id="import-uncategorized" style="width: 100%;">导入到"未分类"</button>
            <button class="cancel" id="cancel-wb-import" style="width: 100%; margin-top: 5px; background-color: #f0f0f0;">取消导入</button>
        </div>
    </div>
</div>

<!-- 【记忆功能】记忆管理弹窗 -->
<div id="memory-summary-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header" style="flex-shrink: 0;">
            <span>核心记忆管理</span>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
            <div id="memory-stats" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 10px; padding: 8px; background-color: #f5f5f5; border-radius: 6px; flex-shrink: 0;">
                <div style="margin-bottom: 5px; display: flex;">
                    <span style="width: 50%;">已总结消息：<span id="summarized-count">0</span></span>
                    <span style="width: 50%;">待总结消息：<span id="pending-count">0</span></span>
                </div>
                <div style="display: flex;">
                    <span style="width: 50%;">总消息数：<span id="total-count">0</span></span>
                    <span style="width: 50%;">上下文Token：<span id="context-token-count">0</span></span>
                </div>
            </div>
            <textarea id="memory-summary-textarea" style="width: 100%; flex-grow: 1; min-height: 0; resize: none; border-radius: 8px; border: 1px solid var(--border-color); padding: 10px; font-size: 14px; box-sizing: border-box; overflow-y: auto;"></textarea>
        </div>
<div class="modal-footer" style="justify-content: space-between; flex-shrink: 0; gap: 8px; margin-top: -30px; border-top: none;">
                <button class="form-button form-button-secondary" id="force-summarize-btn" style="flex: 1; font-size: 12px; padding: 0 12px; height: 36px; border-radius: 25px; white-space: nowrap; display: flex; align-items: center; justify-content: center;">总结</button>
            <button class="form-button form-button-secondary" id="rollback-summary-btn" style="flex: 0.8; background-color: #FF8C00; color: white; border-color: #FF8C00; font-size: 12px; padding: 0 12px; height: 36px; border-radius: 25px; white-space: nowrap; display: flex; align-items: center; justify-content: center;">回滚</button>
            <button class="form-button form-button-secondary" id="delete-summary-btn" style="flex: 1; background-color: #AB4D3F; color: white; border-color: #AB4D3F; font-size: 12px; padding: 0 12px; height: 36px; border-radius: 25px; white-space: nowrap; display: flex; align-items: center; justify-content: center;">删除记忆</button>
            <button class="form-button form-button-secondary" id="save-summary-btn" style="flex: 1; font-size: 12px; padding: 0 12px; height: 36px; border-radius: 25px; white-space: nowrap; display: flex; align-items: center; justify-content: center;">保存</button>
        </div>
    </div>
</div>

<!-- 模式选择面板 -->
<div id="mode-selection-panel" class="modal" style="display: none; z-index: 10001;">
    <div class="modal-content" style="width: 300px; height: auto; padding: 20px;">
        <div class="modal-header" style="text-align: center; border: none; padding-bottom: 15px;">
            <span style="font-size: 16px; font-weight: 500;">选择模式</span>
        </div>
        <div class="modal-body" style="padding: 0;" id="mode-selection-options">
            <!-- 动态生成的模式选项将插入到这里 -->
        </div>
    </div>
</div>

<!-- ▼▼▼ 音乐搜索功能 - 搜索源选择器 ▼▼▼ -->
<div id="music-source-selector-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>选择搜索源</span>
        </div>
        <div class="modal-body" style="text-align: left; padding: 20px;">
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="all" checked> 全部来源 (网易云 + QQ音乐)
            </label>
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="netease"> 仅网易云音乐
            </label>
            <label style="display: block; cursor: pointer;">
                <input type="radio" name="search-source" value="tencent"> 仅QQ音乐
            </label>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-source-select-btn">取消</button>
            <button class="save" id="confirm-source-select-btn">开始搜索</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 搜索源选择器结束 ▲▲▲ -->

<!-- ▼▼▼ 音乐搜索功能 - 搜索结果弹窗 ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索结果</span>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索结果将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-music-search-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 搜索结果弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】"kk查岗"功能的所有HTML界面 ▼▼▼ -->

<!-- 1. 查岗 - 角色选择屏幕 -->
<div id="kk-char-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>要查谁的岗？</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="kk-char-selection-list" class="list-container">
        <!-- 角色列表将由JS动态生成 -->
    </div>
</div>

<!-- 2. 查岗 - 房屋总览屏幕 -->
<div id="kk-house-view-screen" class="screen">
    <div id="kk-house-background"></div>
    <div class="header" style="background: linear-gradient(to bottom, rgba(0,0,0,0.75), rgba(0,0,0,0.3)); border-bottom: none; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">
        <span class="back-btn" id="kk-back-from-house-view" style="color: white;">‹</span>
        <span id="kk-house-owner-name" style="color: white;"></span>
        <div class="header-actions">
            <span class="action-btn" id="kk-surveillance-icon" title="查看监控" style="color: white;">
                <svg viewBox="0 0 1024 1024" width="22" height="22">
                    <path d="M554.666667 768v85.333333h170.666666v42.666667H341.333333v-42.666667h170.666667v-85.333333c-166.4-12.8-298.666667-149.333333-298.666667-320S345.6 140.8 512 128h42.666667c166.4 12.8 298.666667 149.333333 298.666666 320s-132.266667 307.2-298.666666 320z m-21.333334-42.666667c153.6 0 277.333333-123.733333 277.333334-277.333333S686.933333 170.666667 533.333333 170.666667 256 294.4 256 448 379.733333 725.333333 533.333333 725.333333z m0-213.333333c-34.133333 0-64-29.866667-64-64S499.2 384 533.333333 384s64 29.866667 64 64-29.866667 64-64 64z" fill="white"></path>
                </svg>
            </span>
            <span class="action-btn" id="kk-continue-search-btn" title="继续翻找" style="color: white;">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </span>
            <span class="action-btn" id="kk-reset-search-btn" title="重新翻找" style="color: white;">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </span>
        </div>
    </div>
    <div id="kk-house-info-panel">
        <h2 id="kk-house-location"></h2>
        <p id="kk-house-description"></p>
        <div id="kk-house-areas">
            <!-- 房屋区域按钮将由JS动态生成 -->
        </div>
    </div>
</div>

<!-- 3. 查岗 - 区域探索屏幕 -->
<div id="kk-area-view-screen" class="screen">
    <div id="kk-area-background"></div>
    <div class="header" style="background: linear-gradient(to bottom, rgba(0,0,0,0.75), rgba(0,0,0,0.3)); border-bottom: none; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">
        <span class="back-btn" id="kk-back-from-area-view" style="color: white;">‹</span>
        <span id="kk-area-name" style="color: white;"></span>
        <span style="width: 30px;"></span>
    </div>
    <div class="kk-item-list-container">
        <h3 id="kk-area-description"></h3>
        <p class="kk-instruction-text">点击下方物品进行翻找：</p>
        <div id="kk-area-items-grid">
            <!-- 可翻找物品将由JS动态生成 -->
        </div>
    </div>
</div>

<!-- 4. 查岗 - 监控屏幕 -->
<div id="kk-monitor-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="kk-back-from-monitor">‹</span>
        <span id="kk-monitor-title">监控中心</span>
        <div class="header-actions">
            <span class="action-btn" id="kk-refresh-monitor-btn" title="刷新监控画面">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </span>
        </div>
    </div>
    <div id="kk-monitor-grid" class="list-container">
        <!-- 监控画面将由JS动态生成在这里 -->
    </div>
</div>

<!-- 5. 查岗 - 电脑屏幕 (模态框) -->
<div id="kk-computer-modal" class="modal">
    <div class="modal-content" style="width: 95%; height: 90%; max-width: 500px; background-color: #e0e0e0;">
        <div class="modal-header" id="kk-computer-header" style="position: relative;">
            <span>的电脑</span>
            <span id="close-kk-computer-modal" style="position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 28px; line-height: 1; color: #333;">×</span>
        </div>
        <div class="modal-body" id="kk-computer-desktop">
            <!-- 电脑桌面图标将由JS动态生成 -->
        </div>
    </div>
</div>

<!-- 6. 查岗 - 文件浏览器模态框 -->
<div id="kk-file-explorer-modal" class="modal" style="z-index: 1003;">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>私人文件</span>
        </div>
        <div class="modal-body" id="kk-file-list">
            <!-- 文件列表将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="close-file-explorer-modal-btn">关闭</button>
        </div>
    </div>
</div>

<!-- 7. 查岗 - 文件查看器模态框 -->
<div id="kk-file-viewer-modal" class="modal" style="z-index: 1004;">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header" style="position: relative;">
            <span id="kk-file-viewer-title"></span>
            <span id="close-kk-file-viewer-btn" style="position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 28px; line-height: 1; color: #333;">&times;</span>
        </div>
        <div class="modal-body">
            <pre id="kk-file-viewer-content" style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; line-height: 1.6;"></pre>
        </div>
    </div>
</div>

<!-- 8. 查岗 - Steam游戏库模态框 -->
<div id="kk-steam-modal" class="modal" style="z-index: 1003;">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>Steam 游戏库</span>
            <span class="action-btn" id="kk-generate-more-games-btn" title="生成更多游戏">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </span>
        </div>
        <div class="modal-body" id="kk-steam-games-list" style="padding: 0; padding-bottom: calc(0px + env(safe-area-inset-bottom));">
            <!-- Steam游戏列表将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="close-kk-steam-modal-btn">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ "kk查岗"功能HTML结束 ▲▲▲ -->

<!-- 加载提示弹窗 -->
<div id="generation-overlay" class="modal" style="background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div style="text-align: center; color: white;">
        <div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <p id="generation-text">正在同步Ta的手机数据...</p>
        <p style="font-size: 12px; opacity: 0.7;">（这可能需要一些时间，并会消耗API额度）</p>
    </div>
</div>

</body>
</html>
